[{"content":"0. Introduction  해당 내용은 운영체제와 정보기술의 원리 -반효경 지음- 와 kocw 이화여자대학교 운영체제 - 반효경 교수 -를 보고 정리한 내용이다. 정확하지 않은 내용이 있다면 말씀해주시면 감사하겠습니다.   이번 chapter 내용인 메모리 관리는 물리적인 메모리 관리로, 주요 내용은 address binding이다. address binding에서의 OS의 역할은 없고, 다 HW가 해야한다. address binding을 할 때마다 OS에게 CPU 제어권을 양도해도, 결국 물리적 메모리에 instruction을 실행하는 건 CPU다. 그래서 HW가 해야한다.   4. 페이징 기법  프로세스의 주소 공간을 동일한 크기의 페이지 단위로 나누어, 물리적 메모리의 서로 다른 위치에 불연속적으로 페이지들을 저장하는 방식\n   각 프로세스의 주소 공간 전체를 물리적 메모리에 한꺼번에 올릴 필요 없이, 스와핑을 사용하여 일부만 메모리에 올릴 수 있다.\n  또한, 이 메모리는 페이지와 동일한 크기의 프레임(frame) 으로 미리 나누어둔다.\n 그래서 빈 프레임이 있으면 메모리의 어떤 위치이든 사용될 수 있다. 이 특징으로 연속할당에서의 동적 메모리 할당 문제와 외부조각 문제가 발생하지 않는다. 그러나, 프로그램의 크기가 항상 페이지 크기의 배수라는 보장이 없기 때문에 내부조각이 발생할 가능성은 있다.    Problem\n 물리적 메모리의 불연속적인 위치에 각 페이지를 올리기 때문에, 논리적 주소에서 물리적 주소로 변환하는 작업이 복잡하다.    Solution\n 위 문제에 대한 해결책으로 페이지 테이블(page table) 을 가진다. page table이 사용하는 주소 변환기법에 대해 알아보자.    4.1 주소 변환(address translation) 기법   page table에는 각 page마다 frame 주소가 mapping되어 있다.\n  logical address에서 physical address로 변환하는 구체적인 과정은 다음과 같다.\n   p = 페이지 번호: page table 접근 시 인덱스(index)로 사용 d = 페이지 offset\n-\u0026gt; 각 index의 항목(entry)에는 그 페이지의 물리적 메모리상의 기준 주소(base address)인 시작위치가 저장되어 있다.\n-\u0026gt; page table에서 위에서 p 번째를 찾으면 frame 번호(f)가 나온다.\n-\u0026gt; 이렇게 해서 logical address에서 physical address로 바뀐다.  4.2 페이지 테이블의 구현   page table이란? paging 기법에서 주소 변환을 하기 위한 자료 구조로, 물리적 메모리에 위치한다. page table에 접근하기 위해 2개의 레지스터를 사용한다.     page table에 접근하기 위한 2개의 레지스터는 다음과 같다.\n 페이지 테이블 기준 레지스터(page-table base register, PTBR): 물리적 메모리 내에서의 페이지 테이블의 시작 위치 페이지 테이블 길이 레지스터(page-table length register, PTLR): 페이지 테이블의 크기를 보관    Problem\n 페이징 기법에서 메모리 접근 연산은 총 두 번 이뤄진다.  첫 번째: 주소 변환을 위해 메모리에 있는 페이지 테이블에 접근하기 두 번째: 변환된 주소로 실제 데이터에 접근하기   즉, 두 번 접근해야 하는 오버헤드가 뒤따른다.      Solution: TLB\n TLB란?  Translation Look-aside Buffer 의 약어로, 테이블 접근 오버헤드를 줄이고, 메모리 접근 속도를 높이기 위한, 고속 주소 변환용 하드웨어 캐시 page table에서 빈번히 찾는 일부 entry를 저장하고 있다.   TLB mechanism  CPU가 논리적인 주소를 주면 page table보다 먼저 TLB를 검색한다. TLB 저장된 정보를 통해서 주소 변환이 가능한지 확인한다.  TLB에 저장되어 있다면 TLB를 통해서 바로 주소 변환을 한다. 이 경우, 메모리에 한 번만 접근한다. 저장되어 있지 않다면 page table을 통해서 일반적인 주소 변환을 실행한다.        TLB의 문제점\n page table의 경우  page 번호만큼 떨어진 항목에 곧바로 접근해 대응되는 프레임 번호를 얻는다.   하지만, TLB의 경우  모든 페이지에 대한 주소 변환 정보 X -\u0026gt; 페이지 번호와 이에 대응하는 프레임 번호가 쌍으로 저장되야 한다. 해당 페이지에 대한 주소 변환 정보가 TLB에 있는지 확인하기 위해 TLB의 모든 항목을 다 찾아봐야 하는 오버헤드가 발생한다.      Associative register\n 위의 언급한 오버헤드를 줄이기 위해 병렬 탐색(parallel search)이 가능한 연관 레지스터(associative register)를 사용한다.  Parallel search: TLB 내의 모든 항목을 동시에 탐색할 수 있는 기능      page table은 각 process마다 논리적인 주소 체계가 달라서, 각 프로세스마다 존재한다.\n 그래서, TLB도 각 process마다 다르게 존재한다.    4.3 계층적 페이징  2개 이상의 page table을 통해서 물리적 메모리에 접근하는 기법으로, 각 페이지를 다시 페이지화시키는 기법\n 4.3.1 Twp-level page table이란???  2단계 페이징 기법(Two-level page table)은 outer-page table과 inner-page table을 통해서 Physical memory에 접근한다.  4.3.2 Two-level page table을 사용하는 이유   현대의 컴퓨터는 address space가 매우 큰 프로그램을 지원한다.\n  컴퓨터 시스템에서의 K, M, G\n K = 2^(10) = Kilo M = 2^(20) = Mega G = 2^(30) = Giga    32 bit address 사용 시: 2^(32) byte (= 4G byte)의 주소 공간\n  페이지의 크기가 4KB일 때, 4GB / 4KB = 1M 개의 page table entry(항목)이 필요\n  페이지의 항목이 4 byte 라면 한 프로세스 당 페이지 테이블을 위해 1M x 4byte = 4MB 크기의 메모리 공간이 필요하다.\n    이런 상황에서 왜 2단계 페이징 기법을 사용하는가??\n page table이 2개라서 공간 낭비일 것 같지만, 다음과 같은 이유로 효과가 더 크기 때문에 사용한다. 프로그램의 대부분은 방어용 코드로 주로 사용하는 페이지 수는 적다. 그래서, 사용되지 않는 주소 공간에 대해서는 outer page table의 항목을 NULL로 설정하며, 여기에 대응하는 inner page table을 생성하지 않는다. 그 결과, page table의 공간을 줄일 수 있기 때문에, 속도가 느려도 사용한다. 사용하지 않는 주소 공간에 대해서 outer page table에 생성하는 이유는 page table의 자료구조 특성상 index로 작용하기 때문이다.    4.3.3 Two-level page table의 구성과 갯수, 크기 계산   logical address의 구성\n two level 이므로, 두 종류의 페이지 번호(P1,P2) 페이지 오프셋(d) P1: outer page table의 index P2: inner page table의 index    outer page table의 entry 하나 당 inner page table이 하나 만들어진다.\n  inner page table 하나의 크기가 page 크기와 동일하다.\n  page table entry 하나의 크기가 4 byte 라고 했는데, 그러면 entry 갯수는 1K 개다.\n  page 크기가 4KB 이고, 32bit 주소체계라고할 때, page number와 page offset의 크기는 다음과 같다.\n page 크기가 4K = 2^(12) 이므로, 한 페이지를 구분하기 위해서는 page offset은 12bit 가 필요하다. page table entry가 4byte이므로, 내부 페이지 테이블은 1KB = 2^(10) 개의 항목을 가진다. 2^(10)개를 구분하기 위해서는 P2는 10bit 가 필요하다. 그러면 총 32bit 주소체계에서 22bit를 사용했으므로, P1에는 10bit 가 할당된다.    P1 P2 Page offset     10bit 10bit 12bit        다음과 같은 순서로 찾는다.\n 첫 번째  outer page table로부터 P1만큼 떨어진 위치에서 inner page table의 주소 를 얻는다. inner page table은 여러개가 있다. outer page table의 한 entry당 하나의 inner page table이 만들어진다.   두 번째  innter page table로부터 P2만큼 떨어진 위치에서 요청된 페이지가 존재하는 프레임의 위치 를 얻는다.   세 번째  해당 프레임으로부터 d 만큼 떨어진 곳에서 원하는 정보에 접근한다.      4.3.4 multi-level page의 문제점과 해결책   Problem\n  process의 address space가 커질수록 page table의 크기도 커지므로, 주소 변환을 위한 메모리 공간 낭비 점점 심각해지기 때문에, 다단계 페이지 테이블이 필요.\n  이에 따라 공간은 절약할 수 있지만 메모리 접근시간이 크게 늘어나는 문제가 발생.\n    Solution: TLB\n TLB 와 함께 사용하여 메모리 접근 시간을 줄일 수 있고, 다단계 page table을 사용하여 메모리 공간의 효율적 사용 효과는 매우 크다.    4.4 메모리 보호(Memory Protection)  메모리 보호를 위해 page table의 각 entry마다 보호 비트(protection bit)와 유효-무효 비트(valid-invalid bit)를 둔다.\n   보호 비트(Protection bit): 각 page에 대한 연산 접근 권한을 설정하는데 사용\n read / write / read-only    유효-무효 비트(Valid-Invalid bit): 해당 페이지의 내용에 접근을 허용하는지 결정\n valid 로 세팅: 해당 메모리 프레임에 그 페이지가 존재 -\u0026gt; 접근 허용 invalid 로 세팅 -\u0026gt; 유효한 접근 권한 X  첫 번재 경우, 프로세스가 그 주소 부분을 사용 X 두 번째 경우, 해당 페이지가 물리적 메모리에 올라있지 않고, 백킹스토어에 존재      4.5 역페이지 테이블(Inverted page table)   page table이 매우 큰 이유\n 모든 process 별로 그 logical address에 대응하는 모든 page에 대해 page table entry를 다 구성해야 하기 때문이다. 대응하는 page가 메모리에 존재하든 안하든 page table에는 entry로 존재    Inverted page table\n   logical address에 대해 page table을 만드는 것이 아닌, physical address에 대해 page table을 만드는 것\n   시스템 전체에(system-wide) page table을 하나만 두는 방법\n physical address는 1개이기 때문에, physical address에 대해 page table을 만든다는 건 하나만 만드는 걸 의미한다. 각 프로세스마다 page table을 두는 게 아니다.    page table entry 수 = Physical memory의 page frame 수\n Physical memory의 page frame 하나당 page table에 하나의 entry를 둔 것 page table entry 수 =! process의 page 갯수    각 page table entry는 각각의 물리적 메모리의 page frame이 담고 있는 내용 표시\n process의 id(pid), logical address(p) 어떤 process의 p번째 페이지인지를 확인하기 위해 pid를 저장해야 한다.    단점: 테이블 전체를 탐색해야 한다.\n 역페이지 테이블에 주소 변환 요청이 들어오면, 그 주소를 담은 페이지가 물리적 메모리에 존재하는지 여부를 판단하기 위해, 페이지 테이블 전체를 다 탐색해야한다.      physical address를 보고 logical address로 바꾸는 것이기 때문에, 목적에 맞지 않다.\n  그러면 이 table을 통해서 어떻게 전환할 것인가??\n 논리주소에 해당되는 P가 물리적 메모리 어디에 올라가는지를 찾을라면 이 entry를 다 찾아서 해당되는 P가 F 번째에 나오면, f번째에 있는 물리적 프레임에 있다는 걸로 파악한다. table의 장점인 index를 통해서 찾을 수 있는 장점이 없다.    그래서 시간이 아닌 단지 공간을 줄이기 위해서 사용되는 것이다.\n  해결책: associative register 사용한다.\n 연관 레지스터를 사용하여 병렬탐색을 하여 시간적 효율성을 높인다. 단, 비용이 비싸다.    4.6 공유 페이지(Shared page)  shared code(공유 코드)를 담고 있는 페이지\n   shared code란??\n 메모리 공간의 효율적인 사용을 위해, 여러 프로세스에서 공통으로 사용되도록 작성된 코드 재진입 가능코드 (re-entrant code) 또는 순수 코드(pure code)라 한다. read-only 특성을 가진다. -shared memory 기법에서는 read - write다.    프로세스 간 공유 페이지이므로 물리적 메모리에 하나만 적재하여 효율적으로 사용한다.\n  하지만, 이 특성으로 모든 프로세스의 logical address space 의 동일한 위치에 존재해야하는 제약점이 있다.\n 왜냐하면 logical address에서 실행 시작하여 physical address에 올라갈 때, logical address에 연결되기 때문이다. Address binding 내용에서 이미지를 참고하자.    private page(사유 페이지)\n 공유 페이지와 대비되는 개념으로, 프로세스끼리 공유하지 않고 독자적으로 사용하는 페이지 사유 페이지는 해당 프로세스의 논리적 주소 공간 중 어더한 위치에 있어도 무방하다.     5. 세그먼테이션  프로세스 가상 메모리를 의미 단위인 segment로 나눠서 물리적 메모리에 올리는 기법\n   프로세스의 주소 공간을 크기 단위가 아닌 의미 단위(logical unit)로 나눈 것이기 때문에, 크기가 균일하지 않다.\n main (), function, global variables, stack\u0026hellip;    그래서 부가적인 관리 오버헤드가 뒤따른다.\n  segment 크기 기준\n 프로그램은 의미 단위인 여러 개의 segment로 구성한다. 작게는 프로그램을 구성하는 함수 하나 하나를 segment로 정의한다. 크게는 프로그램 전체를 하나의 세그먼트로 정의한다. 일반적으로는 code, data, stack 부분이 하나씩의 segment로 정의된다.    5.1 Segmentation Architecture 5.1.1 Logical address  두 가지 [s: segment-number, d: offset]로 구성\n 5.1.2 Segment table  Segmentation에서 주소 변환을 위해 사용하는 table\n   이 table은 기준점(base) 와 한계점(limit) 을 가진다.\n 기준점:  물리적 메모리에서 각 세그먼트의 시작위치를 의미.   한계점:  각 세그먼트의 길이를 의미. 페이징 기법과는 달리 각 segment의 길이가 균일하지 않기 때문이다.      segment의 갯수에 따라 table entry 수가 결정된다.\n    CPU 안에 주소 변환을 위한 2개의 레지스터\n  Segment Table Base Register(STBR) : 물리적 메모리에서의 segment table의 시작위치\n  Segment Table Length Register(STLR) : 프로세스의 segment의 길이와 갯수\n    Logical address를 physical address로 변환하기 위한 두 가지 사항\n 첫 번째: segment number(s)가 STLR에 저장된 값보다 작은 값인지 확인  아니라면 trap 발생시키기   두 번째: 논리적 주소의 오프셋 값(d)이 세그먼트의 길이보다 작은 값인지 확인  세그먼트 테이블의 한계점과 요청된 논리적 주소의 오프셋값을 비교해 확인한다. d가 더 크다면 trap 발생시키기      균일하지 않은 segment로 인한 paging과의 차이점들\n 첫 번째 차이  paging 기법에서는 크기가 균일하기 때문에, offset의 크기가 page 크기에 의해서 결정된다. segment 기법에서는 offset 크기가 segment 크기를 제한하는 요소다.   두 번째 차이  paging 기법에서는 크기가 균일하기 때문에, 시작 주소가 frame 번호다. segment 기법에서는 크기가 다르기 때문에, 이 segment가 어디서 시작되는지 정확한 byte 단위 주소로 알려줘야 한다.      장점: paging과 달리 의미 단위라서 segment의 갯수가 상대적으로 많이 적다.\n 그래서 table로 인한 메모리 낭비를 비교하자면 일반적인 시스템에서는 적다.    5.2 세그먼테이션에서의 보호비트와 유효비트  보호 비트(protection bit): 각 세그먼트 별로 가지고 있어서 각각에 대해 읽기/쓰기/실행 등의 권한이 있는지 나타낸다. 유효 비트(valid bit): 각 세그먼트의 주소 변환 정보가 유효한지, 즉 해당 세그먼트가 현재 물리적 메모리에 적재되어 있는지 나타낸다.  valid bit = 0 : illegal segment    5.3 공유 세그먼트(shared segment)   공유 세그먼트(shared segment)\n 여러 프로세스가 특정 세그먼트를 공유해 사용한다. 이 세그먼트를 공유하는 모든 프로세스의 주소 공간에서 동일한 논리적 주소에 위치 해야 한다.    장점: 공유(sharing)와 보안(protection) 측면에서 세그먼테이션\n 의미 단위로 나눠져 있어서 페이징 기법보다 훨씬 효과적이다. -\u0026gt; 5.2 와 연결하기 왜냐하면 크기 단위로 나누다 보면 공유 코드와 사유 데이터 영역이 동일 페이지에 공존하는 경우가 발생할 수 있기 때문이다. 그래서 어떤 권한을 줘야할지 결정하기가 어렵다.    5.4 세그먼트 할당 방식  세그먼트를 가용 공간에 할당하는 방식  세그먼트 크기가 균일하지 않기 때문에, 외부 조각 같은 문제점이 발생한다.  내부 조각은 없다는 장점 paging은 fragmentation이 발생하지 않는다.   그래서 동적 메모리 할당 문제가 존재한다. 이 문제에 대해서는 first-fit 방식과 best-fit 방식을 사용한다.     6. 페이지드 세그먼테이션  segmentation을 기반으로, 각 segmentation을 크기가 동일한 page로 구성\n 6.1 pure segmentaton과의 차이점  segment-table entry 가 segment의 base address 를 가지고 있는 것이 아닌, segment를 구성하는 page table 의 base address 를 가지고 있다.  6.2 Paged segmentation의 logical address  두 가지 [s: segment-number, d: offset]로 구성  6.3 Paged segmentation의 특징과 장점   물리적 메모리에 적재하는 단위: page\n  address binding을 위해 외부의 segment table과 내부의 page table을 이용한다.\n  장점: segmentation에서의 외부조각 문제와 paging 기법의 접근 권한 보호 문제를 해결\n  6.4 address binding 과정 설명   첫 번째\n 논리적 주소의 상위 비트인 segment number(s)로 segment table의 해당 항목에 접근    두 번째\n 이 segment table entry = segment 길이 + segment의 page table 시작 주소    세 번째\n  세그먼트 길이를 넘어서는 메모리 접근 시도인지 여부를 체크하기 위해, segment length와 logical address의 하위 비트 offset(d) 값과 비교.\n  If segment lenth \u0026lt; offset: 유효 X -\u0026gt; trap 발생.\n  If segment lenth \u0026gt; offset: offset 값을 다시 상위 하위 비트로 나눔.\n 나눠진 상위비트(p): 그 segment 내에서 page number를 의미. 나눠진 하위비트(d'): page 내에서의 변위를 의미.        네 번째\n segment table entry에 있는 segment의 page-table base를 기준으로, p만큼 떨어진 page table entry로부터 물리적 메모리의 page frame 위치(f)를 얻음.    다섯 번째\n 이 얻어진 위치에서 d\u0026rsquo;만큼 떨어진 곳 = 물리적 메모리 주소.    page table for segment s 의 entry 갯수는 segment table의 segment 길이를 보면 알 수 있다.\n   Reference  운영체제와 정보기술의 원리 kocw 이화여자대학교 운영체제 - 반효경 교수 -  ","permalink":"http://jeha00.github.io/post/os/os_chapter_07_%EB%A9%94%EB%AA%A8%EB%A6%AC%EA%B4%80%EB%A6%AC_2/","summary":"불연속 할당 방법인 pagin 기법, segmentation 기법, paged segmentation 기법에 대해 알아본다.","title":"[TIL] OS Chapter 07: 메모리 관리 2"},{"content":"0. Introduction  해당 내용은 운영체제와 정보기술의 원리 -반효경 지음- 와 kocw 이화여자대학교 운영체제 - 반효경 교수 -를 보고 정리한 내용이다. 정확하지 않은 내용이 있다면 말씀해주시면 감사하겠습니다.   이번 chapter 내용인 메모리 관리는 물리적인 메모리 관리로, 주요 내용은 address binding이다. address binding에서의 OS의 역할은 없고, 다 HW가 해야한다. address binding을 할 때마다 OS에게 CPU 제어권을 양도해도, 결국 물리적 메모리에 instruction을 실행하는 건 CPU다. 그래서 HW가 해야한다.   1. 주소(address) 바인딩 1.1 주소란??   서로 다른 위치를 구분하기 위해 사용하는 일련의 숫자 크게 논리적 주소와 물리적 주소로 나뉠 수 있다.    Memory는 주소를 통해 접근하는 저장장치다. 컴퓨터 시스템은 32bit 혹은 64bit의 주소체계를 사용하는데,  32bit는 2^(32) 가지, 64bit는 2^(64) 가지의 서로 다른 메모리 위치를 구분할 수 있다.   byte 단위로 메모리 주소를 부여한다.  1.2 논리적 주소, 물리적 주소   논리적 주소(logical address, virtual address)란?\n 프로세스마다 독립적으로 가지는 주소 공간 각 프로세스마다 0번지부터 시작 CPU가 보는 주소는 logical address  Why? 물리적 메모리에 올라오는 위치는 달라도 코드 상의 내용은 compile 시 내용.      물리적 주소(physical address)란?\n 메모리에 실제로 올라가는 위치 물리적 주소의 낮은 주소 영역에는 kernel이 올라간다. 물리적 주소의 높은 주소 영역에는 user process들이 올라간다.    프로세스가 실행되기 위해서\n 해당 프로그램이 물리적 메모리에 올라가 있어야 한다. 해당 논리적 주소가 물리적 메모리의 어느 위치에 매핑되는지 확인해야 한다.    1.3 주소 바인딩(address binding)  logical address를 physical address로 연결시켜서, physical address를 결정하는 작업\n  Symbolic address \u0026ndash;(compile)\u0026ndash;\u0026gt; Logical address \u0026ndash;(address binding)\u0026ndash;\u0026gt; Physical address    주소 바인딩 방식 3가지: 물리적 메모리 주소가 결정되는 시기에 따라 분류된다.\n 컴파일 타임 바인딩(compile time binding) 로드 타임 바인딩(load time binding) 실행시간 바인딩(execution time binding or run time binding)    방식 이름 compile time binding load time binding run time binding     시기 컴파일 시 프로그램 실행이 시작 시 (변경 가능 X) 프로그램 실행이 시작 시, (변경 가능 O)   swapping 효과 좋지 않음 좋지 않음 좋음        Compile time binding\n 컴파일 시, 논리적인 주소와 물리적인 주소 다 생성된다. compiler는 절대 코드 를 생성한다.  그래서 program이 올라가 있는 물리적 메모리의 시작위치를 변경할려면 컴파일을 다시 해야 한다.   물리적 주소의 0번지부터 시작한다. 현대의 시분할 컴퓨터 환경에서는 잘 사용하지 않는 기법    Load time binding\n 컴파일 시에는 논리적인 주소만 결정된다. 이를 실행하고 나서, 메모리가 비어있는 곳부터 올린다. 로더(loader)의 책임 하에 물리적 메모리 주소 부여  Loader: user program을 memory에 적재시키는 프로그램   compiler가 재배치 가능 코드 를 생성한 경우 가능    Run time binding\n Load time binding 처럼 실행 시, physical address가 생성된다. 실행을 시작한 후에도 물리적 메모리상의 위치(물리적 주소)를 옮길 수 있는 방식 CPU가 주소 참조 시, address mapping table을 이용해 원하는 데이터가 물리적 메모리의 어느 위치에 존재하는지 확인한다. MMU(Memory Management Unit) 라는 하드웨어적 지원이 필요    1.4 MMU 기법(MMU scheme)  기준 레지스터를 사용하여 logical에서 physical address로 mapping해주는 HW device\n   가정\n 프로그램의 주소 공간이 메모리의 한 장소에 연속적으로 적재되는 걸 가정한다.    MMU scheme\n 사용자 프로세스가 CPU에서 수행되여 생성해내는 모든 논리적 주소값에 대해 base register(= relocation register) 의 값을 더하여 물리적 주소값을 얻어낸다. base register = CPU가 사용하려는 프로세스의 물리적 메모리 시작 주소      user program\n logical address 만을 다룬다. 실제 physical address 를 볼 수 없으며, 알 필요가 없다.    예시\n CPU가 논리적 주소: 123번지 정보를 요청 기준 레지스터(=재배치 레지스터): 23000 물리적 주소 = 123 + 23000 = 23123 물리적 주소 23123번지에서 CPU가 요청한 정보를 찾는다. 논리적 주소란 기준 레지스터로부터 얼마나 떨어져 있는지를 나타내는 것    동일한 논리적 주소\n 프로세스는 각 자신만의 고유한 주소 공간을 가진다. 그래서 동일한 논리적 주소라고 할 지라도, 서로 다른 내용을 담는다. MMU 기법에서 프로세스가 바뀔 때마다 기준 레지스터의 값을 바뀌는 프로세스에 해당되는 값으로 재설정한다.    메모리 보안\n Problem  가상 메모리에 기준 레지스터를 더했을 때, 해당 프로세스의 주소 공간을 벗어나는 경우, 다른 프로세스 영역에 침범하거나, kernel 영역을 변경해 치명적인 결과를 초래할 수 있다.   Solution  한계 레지스터(limit register) 를 사용하여, 프로세스 자신의 주소 공간을 넘어서는 메모리 참조를 하는지 확인한다.  한계 레지스터(limit register): 논리적 주소의 범위   벗어날 경우, trap을 발생시켜 해당 프로세스를 강제종료시킨다.       2. 메모리 관리와 관련된 용어 2.1 동적 로딩(Dynamic loading)   다중 프로그래밍 환경에서 메모리를 효율적으로 사용하기 위한 기법 프로세스의 주소 공간 전체를 메모리에 다 올려놓는 게 아닌, 해당 부분이 불릴 때에마다 메모리에 적재하는 방식    loading: 물리적 메모리로 올리는 것 부분적으로만 올리는 이유  실제 프로그램의 코드 중 상당 부분 = 가끔씩 사용하는 방어용 코드 -\u0026gt; 주소 공간 전체 loading -\u0026gt; 메모리 낭비 초래   동적 로딩 -\u0026gt; 더 많은 프로그램 로딩 가능 -\u0026gt; 메모리 이용 효율성 향상 운영체제 지원 없이 개발자가 코드로 구현 가능하고, OS는 라이브러리를 통해 지원 가능  2.2 중첩(overlays)  메모리보다 큰 프로세스를 실행하기 위해서, 프로세스의 주소 공간을 분할해 실제 필요한 부분만을 메모리에 적재하는 기법\n  중첩과 동적 로딩의 차이점: 목적  동적 로딩의 목적: 메모리에 multi-process를 실행하기 위한 용도 중첩의 목적: single-process를 실행하기 위한 환경에서 메모리 용량보다 큰 프로세스를 실행하기 위한 용도 운영체제의 지원 없이 프로그래머가 직접 구현해야 한다.    2.3 스와핑(Swapping)  프로세스의 주소 공간 전체를 메모리에서 backing store로 쫓아내는 것\n   스왑 영역(Swap area)란??\n 다른 말로 백킹 스토어(backing store) 라고 한다. 디스크 내의 파일 시스템과는 별도로 존재하는 일정 영역으로,  파일 시스템 은 전원이 나가도 유지되어야 하는 비휘발성 저장공간이지만, 스왑 영역 은 프로세스가 수행 중인 동안에만 디스크에 일시적으로 저장하는 휘발성 영역이다. 프로세스 실행이 종료되면 메모리에서 디스크로 내려놓는다. (swap out)   그리고, 다음과 같은 특징을 가져야 한다.  다수의 사용자 프로세스를 담을 수 있을 만큼 충분히 큰 저장 공간이다. 어느 정도의 접근 속도가 보장되야 한다.      Swap in \u0026amp; out\n Swap in: disk -\u0026gt; memory 올리는 작업 Swap out: memory -\u0026gt; disk 내리는 작업    스와핑이 일어나는 과정\n  첫 번째: Swapper라 불리는 중기 스케쥴러 에 의해 swap out할 process를 선정.\n 선정 기준: priority  priority가 낮은 프로세스를 swap out priority가 높은 프로세스를 swap in      두 번째: 선정된 process를 메모리에 올라간 주소 공간 전체 내용을 disk swap area로 아웃시켜서 메모리의 프로세스 수를 조절한다.\n  즉, Swapper로 멀티 프로그래밍 정도(degree of multi-programming)를 조절한다.\n  메모리에 많은 프로그램이 올라오면 할당되는 메모리 양이 지나치게 적어져, 시스템 전체 성능이 감소되기 때문이다.\n    Swap time\n Swap time: swapping에 소요되는 시간 Transfer time: 데이터를 읽고 쓰는 전송 시간 Swap time은 디스크를 탐색하는 것보다 disk sector에서 transfer time이 대부분을 차지한다. 즉, transfer time 은 swap 되는 양에 비례      address binding에 따른 swapping\n compile time binding \u0026amp; load time binding: 다시 swap in 시, 원래 존재하던 메모리 위치로 다시 올라가야 해서 swapping의 효과가 좋지 않다. runtime binding은 추후 빈 메모리 영역 아무 곳에나 프로세스를 올리기 때문에, swapping으로 인한 효과가 좋다.    2.4 동적 연결(Dynamic linking))   연결(linking)이란??\n 목적 파일(object file)과 이미 컴파일된 라이브러리 파일을 묶어서 하나의 실행파일을 생성하는 과정  Object file: 프로그래머가 작성한 source code를 컴파일하여 생성된 파일      정적 연결(static linking)과 동적 연결(dynamic linking)의 차이: 첫 번째\n  정적 연결: 프로그래머가 작성한 코드와 라이브러리가 모두 합쳐진 상태에서 실행파일이 생성되는 방식으로, 연결된 상태에서 실행파일을 생성하는 방식\n 라이브러리가 프로그램의 실행 파일 코드에 포함되어, 실행파일의 크기가 상대적으로 크다.    동적 연결 : 라이브러리를 포함하지 않는 생성된 실행 파일이 라이브버리 호출 시 , 연결이 이뤄지는 방식\n 그래서 라이브러리의 위치를 찾기 위해 라이브러리 호출 부분에 stub 이라는 작은 코드를 둔다. 이 stub을 통해 해당 라이브러리 루틴이 메모리에 이미 존재하는지 먼저 살펴본다.  메모리에 이미 존재 -\u0026gt; 그 메모리 위치에서 직접 참조 메모리에 없음 -\u0026gt; 디스크에서 읽어옴        정적 연결(static linking)과 동적 연결(dynamic linking)의 차이: 두 번째\n  정적 연결: 첫 번째 차이점으로 인해 동일한 라이브러리를 각 프로세스가 개별적으로 메모리에 적재해야 하므로, 물리적 메모리가 낭비된다.\n 동일한 라이브러리 코드여도 각 프로세스의 주소 공간에 독자적으로 존재하는 코드이므로 별도의 적재가 필요하다. 그 결과, 메모리 낭비가 심하다.    동적 연결: 라이브러리를 호출하면 되므로 메모리에 한 번만 적재하여 낭비 X\n 공용으로 쓰는 라이브러리를 shared library 라 한다.      Summary\n   특징 정적 연결 동적 연결     연결 시기 실행 파일 생성 전 실행 파일 생성 후, 호출   적재 횟수 각 프로세스 개별적으로 메모리에 한 번만   실행 파일에 라이브러리 포함 유무 O X   메모리 낭비 발생 O X       3. 물리적 메모리의 할당 방식  물리적 메모리 할당 방식과 사용자 영역 관리 방식은 다음과 같다.  3.1 연속할당(Contiguous allocation) 방식  프로세스를 메모리에 올릴 때, 주소 공간을 여러 개로 분할하지 않고, 메모리의 한 곳에 연속적으로 적재하는 방식\n  고정분할 방식 과 가변분할 방식 으로 나눠진다. 연속적으로 할당하기 때문에 물리적 메모리 주소로 mapping 하는 게 쉽다. 연속 할당 기법에서는 프로세스의 주소 공간 전체를 담을 수 있는 가용공간을 찾아야 한다.  가용 공간(hole) : 사용되지 않은 메모리 공간으로, 메모리 내의 여러 곳에서 산발적으로 존재할 수 있다.   이 가용공간(hole)은 물리적 메모리 내부에 산발적으로 존재하기 때문에, 효율적으로 관리하기 위해서 운영체제는 사용 중인 공간과 가용 공간에 대한 정보를 각각 유지한다.  3.1.1 고정분할(Fixed partition) 방식  물리적 메모리를 영구적인 분할(partition)로 미리 나누어두고, 각 분할에 오직 하나의 프로세스만을 적재해 실행하는 방식\n   이에 따라 다음과 같은 특징을 가진다.\n 미리 나누는 분할의 크기는 다 동일할 수도 있고, 다르게 할 수도 있다. 동시에 메모리에 올릴 수 있는 프로그램의 수가 고정되었다. 수행 가능한 프로그램의 최대 크기 또한 제한된다. 외부 조각(external fragmentation)과 내부 조각(internal fragmentation)이 발생한다.    외부 조각과 내부 조각에 대해 알아보자.\n   조각 종류 외부 조각 내부 조각     When 프로그램 크기 \u0026gt; 분할 크기 프로그램 크기 \u0026lt; 분할 크기   할당 유무 할당하지 않은 조각 할당된 조각     외부 조각:  프로그램의 크기가 분할 크기보다 커서 프로그램을 적재하지 못하여 발생하는 메모리 공간 하지만, 분할 크기보다 작은 프로그램이 도착하면 이 외부조각에 적재할 수 있다.   내부 조각:  하나의 분할에 프로그램을 적재한 후, 남아서 사용되지 않는 메모리 공간 남은 공간에 충분히 적재할 수 있는 프로그램이 있을지라도, 이미 할당된 조각이므로 다른 프로그램에 할당할 수 없다.      3.1.2 가변분할(Variable partition) 방식   미리 분할시키는 것이 아닌 프로그램이 실행될 때마다 메모리에 순서대로 차곡차곡 쌓는 방식 그래서, 분할의 크기, 개수가 동적으로 변한다. 현대의 컴퓨터가 사용하는 방식     분할의 크기를 프로그램 크기보다 일부러 크게 할당하지 않기 때문에, 내부조각이 발생하지 않는다.\n  Problem 1:외부조각\n 메모리에 존재하는 프로그램이 종료될 경우, 중간에 빈 공간이 발생하는데, 이 공간이 새로 시작하는 프로그램보다 작을 경우 외부조각이 발생할 가능성이 있다.    Solution 1: Compaction\n 외부조각 같은 hole을 해결하는 방법으로 **컴팩션(compaction)**을 사용한다.  Compaction이란???  물리적 메모리 중에서 프로세스에 의해 사용 중인 메모리 영역을 한 쪽으로 몰고, 가용 공간들을 다른 한쪽으로 모아서 하나의 큰 가용공간을 만드는 방법     메모리 위치를 상당 부분 이동해야 해서 비용이 매우 많이 들기 때문에, 최소한의 메모리 이동으로 얻을려고 한다. 또한, 수행 중인 프로세스의 물리적 메모리 위치를 옮겨야 하므로, 실행 도중 프로세스 주소를 동적으로 바꿀 수 있는 run time binding 방식을 지원하는 환경에서만 수행할 수 있다.    Problem 2: 동적 메모리 할당 문제(Dynamic storage-allocation problem)\n size가 n인 프로세스를 메모리 내 가용 공간 중 어떤 위치에 올릴 지 결정하는 문제    Solution 2: 3가지\n 아래 3가지 방법들 중 첫 번째와 두 번째가 속도와 공간 이용률 측면에서 효과적이다. 최초적합(first-fit) 방법  size가 n 이상인 것 중 가장 먼저 찾아지는 hole에 프로세스를 할당하는 방법으로, 시간적인 측면에서 효율적이다.   최적적합(best-fit) 방법  size가 n 이상인 가장 작은 hole을 찾아 새로운 프로그램을 할당하는 방법으로, 모든 hole의 리스트를 탐색하므로 시간적 오버헤드가 발생하지만, 공간적인 측면에서는 효율적이다.   최악적합(Worst-fit) 방법  가장 크기가 큰 hole을 찾아 새로운 프로그램을 할당하는 방법으로, 시간적 오버헤드가 발생하고, 가용 공간을 빨리 소진한다.      3.2 불연속할당(Noncontiguous allocation) 기법  물리적 메모리의 여러 위치에 분산되어 올라가는 메모리 할당 기법\n   프로그램을 분할하는 기준에 따라 여러 방법으로 나눠진다.\n 페이징(paging) 기법: 동일한 크기로 나누어 메모리에 올리는 기법 세그먼테이션(segmentation) 기법: 크기는 일정하지 않지만, 의미 단위로 나누어 메모리에 올리는 기법 페이지드 세그먼테이션(paged segmentation) 기법: segmentation을 기본으로 한 후, paging 기법으로 나누어 메모리에 올리는 기법    그러면 다음 챕터에서 위 3가지 기법들에 대해 알아보자.\n   Reference  운영체제와 정보기술의 원리 kocw 이화여자대학교 운영체제 - 반효경 교수 -  ","permalink":"http://jeha00.github.io/post/os/os_chapter_07_%EB%A9%94%EB%AA%A8%EB%A6%AC%EA%B4%80%EB%A6%AC_1/","summary":"logical address와 physical address를 어떻게 mapping하는지, 메모리 관리와 관련된 용어 4가지에 대해 알아보고, 물리적 메모리의 할당 방식 연속할당과 불연속할당 방식 중 연속할당에 대해 알아본다.","title":"[TIL] OS Chapter 07: 메모리 관리 1"},{"content":"0. Introduction  해당 내용은 운영체제와 정보기술의 원리 -반효경 지음- 와 kocw 이화여자대학교 운영체제 - 반효경 교수 -를 보고 정리한 내용입니다. 정확하지 않은 내용이 있다면 말씀해주시면 감사하겠습니다.   1. Bound process 1.1 CPU란??  CPU(Central Processing Unit): PC(Program Counter)가 가리키는 주소의 기계어 명령을 실제로 수행하는 컴퓨터 내의 중앙처리장치  PC: Program Counter로, 레지스터의 한 종류로서 현재 CPU에서 수행할 프로세스의 코드의 메모리 주소값을 가지고 있다.    1.2 기계어 명령의 종류   CPU에서 수행하는 기계어 명령어의 종류를 알아보자.\n  1. CPU 내에서 수행되는 명령어\n Add 명령어: CPU 내의 레지스터에 있는 두 값을 더해 레지스터에 저장하는 명령어 CPU 내에서만 수행되므로 명령의 수행 속도가 매우 빠르다.    2. 메모리 접근을 필요로 하는 명령어\n Load 명령어: 메모리에 있는 데이터를 CPU로 읽어들이는 명령어 Store 명령어: CPU에서 계산된 결과값을 메모리에 저장하는 명령어 1번보다 느리지만, 비교적 짧은 시간에 수행 가능하다.    3. 입출력 동반 명령어\n 입출력 작업(I/O 작업)이 필요한 경우, 사용하는 명령어  ex) 키보드로부터 입력을 받기, 화면에 출력하기   입출력 수반 명령은 1번과 2번에 비해 대단히 오랜 시간이 걸린다. 입출력 작업은 특권 명령으로 규정해서 user program이 직접 수행할 수 없고, OS를 통해서 서비스를 대행하도록 한다.    각 명령어 수행 속도 비교: 3번 \u0026gt; 2번 \u0026gt; 1번\n  특권 명령과 일반 명령으로 분류\n 특권 명령: 3번 일반 명령: 1번과 2번    1.3 CPU burst와 I/O burst   user program이 실행되는 과정은 CPU 작업 과 I/O 작업의 반복이다.\n  즉, CPU burst 와 I/O burst가 번갈아 실행된다.\n CPU burst(버스트): user program이 CPU만 연속적으로 사용하여 instruction만 실행하는 일련의 단계 -\u0026gt; user mode I/O burst(버스트): I/O 요청이 발생해 kernel에 의해 입출력 작업을 진행하는 비교적 느린 단계 -\u0026gt; kernel mode    위 2가지를 I/O 작업을 기준으로 분류해보자.\n  CPU burst: program이 I/O를 한 번 완료한 후, 다음 번 I/O를 수행하기까지 직접 CPU를 가지고 명령을 수행하는 일련의 작업\n  I/O burst: I/O 작업이 요청된 후, 다시 CPU burst로 돌아가기까지 일어나는 일련의 작업\n    1.4 Bound process: CPU \u0026amp; I/O   각 program마다 CPU burst와 I/O burst의 비율이 균일하지 않다.\n  그래서 CPU bound process와 I/O bound process로 나눠볼 수 있다.\n  CPU bound process: 계산 위주의 jb\n few very long CPU bursts 입출력 작업 없이 CPU 작업에 소모하는 계산 위주의 프로그램이 해당된다.    I/O bound process: CPU를 잡고 계산하는 시간보다 I/O에 많은 시간이 필요한 job\n Many short CPU bursts 대화형 프로그램(interactive prgram)에 해당 즉, 사용자에게 입력을 받아 CPU 연산을 수행하여 그 결과를 다시 출력하는 작업에 해당      1.5 CPU sheduling이 필요한 이유   여러 종류의 process(=job)이 동일한 시스템 내부에서 섞여 있기 때문에, CPU scheduling이 필요하다.\n  I/O는 interactive job으로서 적절한 response 필요하다.\n  CPU와 I/O 장치 등 시스템 자원을 골고루 효율적으로 사용\n    특히, 이 CPU는 한 시스템 내에 하나 밖에 없으므로, 시분할 시스템에서 매우 효율적으로 관리해야 한다.\n  대부분의 짧은 CPU burst + 극히 일부분의 긴 CPU burst\n= 대부분 CPU를 오래 사용하기보다는 잠깐 사용하고, I/O 작업을 수행하는 process들이 많다.\n= CPU busrt가 짧은 process는 대부분 대화형 작업이다. = CPU 스케쥴링을 할 때, CPU burst가 짧은 process에게 우선적으로 CPU를 사용할 수 있도록 하는 스케쥴링이 필요\n  그래서, I/O bound process의 우선순위를 높이는 것이 바람직한다.\n I/O bound process에게 늦게 주면 사용자는 답답함을 느낀다.     2. CPU 스케쥴러   CPU 스케쥴러란?? ready state에 있는 procese 중에서 이번에 CPU를 줄 프로세스를 결정하는 OS의 code\n HW가 아닌, os의 code 중 이 기능을 하는 부분을 CPU 스케쥴러라 부르는 것이다.    CPU 스케쥴링이 필요한 경우\n I/O 요청 system call에 의해 running에서 blocked로 바뀐 경우 Timer interrupt에 의해 running에서 ready로 바뀐 경우 I/O 작업 요청으로 blocked 상태였던 process가 I/O 작업 완료에 의해 devce controller가 interrupt 발생하여 ready 상태로 바뀐 경우 running 상태에 있는 프로세스가 종료(terminate)되는 경우    CPU 스케쥴링 방식 2가지: 비선점형(non-preemptive) 과 선점형(preemptive)\n 비선점형(preemptive): process가 작업완료 후, 자발적으로 CPU를 반납하는 방식 -\u0026gt; 1번과 4번 선점형(preemptive): CPU를 계속 사용하기 원해도, 강제로 빼앗는 방법 -\u0026gt; 2번과 3번  ex) timer interrupt       3. Dispatcher   Dispatcher란?? CPU scheduler에 의해 새롭게 선택된 프로세스가 CPU를 할당받아 작업을 수행하도록 환경설정을 하는 OS의 code\n HW가 아닌, os의 code 중 이 기능을 하는 부분을 CPU 스케쥴러라 부르는 것이다.    Dispatcher 과정\n 현재 수행 중이던 process context를 이 process의 PCB에 저장한다.\n-\u0026gt; 새로운 process의 PCB를 복원\n-\u0026gt; user mode로 전환하여 CPU를 넘긴다.\n-\u0026gt; 복원된 context의 program counter로 현재 수행할 주소를 찾는다.    Dispatch latency (디스패치 지연시간): 디스패치가 하나의 프로세스를 정지시키고 다른 프로세스에게 CPU를 전달하기까지 걸리는 시간\n Dispatcher 과정에서 1번부터 3번까지 걸린 시간 context switching의 overhead에 해당     4. 스케쥴링의 성능 척도   스케쥴링의 성능을 평가하기 위해 여러 지표들이 사용된다.\n 시스템 관점의 지표: CPU 이용률, 처리량(throughput) 사용자 관점의 지표: 소요시간, 대기시간, 응답시간    시스템 관점의 지표\n  CPU 이용률(CPU utilization): 전체 시간 중 CPU가 일을 한 시간\n 휴면 상태(idle)에 머무르는 시간을 최대한 줄이는 것이 CPU 스케쥴링의 중요한 목표    처리량(throughput): 주어진 시간 동안 ready queue에서 CPU burst를 완료한 프로세스의 개수\n CPU burst가 짧은 process에게 할당할수록 증가한다.      사용자 관점의 지표\n  소요시간(turnaround time): process가 CPU를 요청한 시점부터 자신이 원하는 만큼 CPU를 다 쓰고, CPU burst가 끝날 때까지 걸린 시간\n 대기시간(waiting time) + 실제로 CPU를 이용한 시간의 합    대기시간(waiting time): CPU burst 기간 중 process가 ready queue에서 CPU를 얻기 위해 기다린 시간의 합\n CPU burst 동안, CPU를 얻기 잃는 걸 반복한다.    응답시간(response time): process가 ready queue에 들어온 후, 첫 번째 CPU를 획득하기까지 기다린 시간\n 사용자 응답하는 대화형 시스템에서 적합한 성능 척도 사용자 관점 지표에서 가장 중요 timer interrupt가 빈번할수록 응답시간 감소      생활 속의 비유: 중국집\n 이용률과 처리량 -\u0026gt; 중국집 입장에서의 척도  이용률: 전체 시간 중 주방장이 일한 시간의 비율 처리량: 주방장이 주어진 시간 동안 몇 명의 손님에게 요리를 만들어주었는지 중국집 입장에서는 주방장을 고용해서 가능한 많은 일을 시키는 것이 좋으므로, 이용률이 높은 것을 선호한다.   소요시간, 대기시간, 응답시간 -\u0026gt; 손님 입장에서의 척도  소요시간: 손님이 중국집에 들어와서 주문한 음식을 다 먹고 나가기까지 소요된 총 시간 대기시간: 각각의 음식이 나오기까지 기다린 시간을 합한 것 응답시간: 최초의 음식이 나오기까지 기다린 시간       5. 스케쥴링 알고리즘 5.1 선입선출 스케쥴링(FCFS: First-Come First-Served)   process가 ready queue에 도착한 순서대로 CPU를 할당하는 방식. 비선점형이다.     FCFS 스케쥴링은 먼저 도착한 프로세스의 성격에 따라 평균 대기시간이 크게 달라진다.\n CPU burst가 긴 프로세스가 먼저 도착할 경우: 평균 대기시간이 길어진다. (Conboy effect) CPU burst가 짧은 프로세스가 먼저 도착할 경우: 평균 대기시간이 짧아진다.    단점\n 콘보이 현상(Convoy effect): CPU burst가 긴 process가 짧은 process보다 먼저 도착하여 오랜 시간을 기다려야하는 현상으로, 평균 대기시간이 길어진다.  FCFS의 대표적인 단점      예시\n   프로세스 CPU burst 시간     P1 24   P2 3   P3 3      들어온 순서가 P1,P2,P3 일 때\n 대기시간: P1 = 0, P2 = 24, P3 = 27 평균 대기시간: (0 + 24 + 27 ) / 3 = 17    들어온 순서가 P2, P3, P1 일 때\n 대기시간: P1 = 6, P2 = 0, P3 = 3 평균 대기시간: (6+0+3)/3 = 3      5.2 최단작업 우선 스케쥴링(Shortest-Job First: SJF)   CPU burst가 가장 짧은 process에게 제일 먼저 CPU를 할당하는 방식 평균 대기시간을 가장 짧게 하는 최적 알고리즘(optimal algorithum)이지만 최고의 알고리즘은 아니다.     SJF algorithum의 방식: 비선점형(non-preemptive) 과 선점형(preemptive)\n  효율적이지만, 형평성을 간과한 스케쥴링\n 비선점형(preemptive): 프로세스가 CPU를 자진 반납하기 전까지는 CPU를 빼앗지 않는 방식 선점형(preemptive): ready queue에서 CPU burst가 가장 짧은 process에게 CPU를 할당했어도, 더 짧은 process가 도착할 경우, CPU를 빼앗아 더 짧은 process에게 부여하는 방식  SRTF(Shortest Remaining Time First)라고도 한다. process들이 ready queue에 도착시간이 불규칙한 환경에서는 선점형이 평균 대기시간을 최소화하는 최적의 알고리즘이 된다.      SJF의 선점형 첫 번째 문제점: 기아 현상(starvation)\n 기아 현상(starvation): CPU burst가 짧은 process가 계속 도착할 경우, 한 process는 영원히 CPU를 할당받지 못하는 현상    SJF의 두 번째 문제점: 현실적으로 미리 알 수 없는 CPU burst 시간\n 하지만 과거의 data를 통해서 예측할 수 있다.    예시\n  비선점형\n  선점형\n    5.3 우선순위 스케쥴링(Priority scheduling)   ready queue에서 기다리는 process 중 우선선위가 가장 높은 process에게 제일 먼저 CPU를 할당하는 방식 우선순위는 우선순위값(priority number)을 통해 표시하며, 작을수록 높은 우선순위를 가지는 것으로 가정한다.     우선순위 스케쥴링도 비선점형 방식과 선점형 방식으로 각각 구현할 수 있다.\n  SJF도 우선순위 스케쥴링의 한 종류다.\n 왜냐하면, CPU burst 시간을 우선순위값으로 정의하며 우선순위 스케쥴링은 SJF 알고리즘과 동일하다.    Problem: 우선순위 스케쥴링도 기아 현상(starvation) 문제점이 있다.\n  Solution: 노화 기법(aging) 을 사용한다.\n 기다리는 시간이 비례하여 우선순위를 높이는 것을 말한다.\nex) 버스나 지하철에서 나이 드신 분께 자리를 양보하는 것과 동일.    5.4 라운드 로빈 스케쥴링(Round Robin Scheduling)   시분할 시스템의 성질을 가장 잘 활용한 스케쥴링 방식 각 프로세스가 연속적으로 CPU를 사용할 수 있는 시간이 제한되며, 이 시간이 경과하면 CPU를 회수해 ready queue에 줄 슨다.     현대 CPU 스케쥴링의 기반 + CPU 설명의 기반 스케쥴링: 라운드 로빈 스케쥴링\n  각 프로세스가 연속적으로 CPU를 사용할 수 있는 시간: 할당 시간(time quantum)\n 규모: 수십 밀리초 정도의 규모 할당시간이 지나면 timer interrupt가 발생 CPU 사용 시간이 할당 시간보다 짧으면 스스로 반납한다. 할당 시간이 너무 짧으면 문맥교환의 오버헤드가 증가하여, 전체 시스템 성능이 저하된다.    대화형 프로세스의 빠른 응답 시간(response time)을 보장할 수 있다.\n  라운드 로빈 스케쥴링의 기본적인 목적: 공정성\n CPU burst 시간이 짧은 프로세스가 빨리 CPU를 얻고, 동시에 CPU burst 시간이 긴 프로세스가 불이익 X CPU를 사용하고자 하는 양에 비례하여 소요시간이 증가하므로 공정하다.    Round robine과 다른 scheduling 비교\n  SJF와의 비교: SJF보다 평균 turnaround time이 길지만, response time은 더 짧다는 것이 중요한 장점이다.\n  FCFS와의 비교: 할당시간을 크게 하면 FCFS와 동일\n  CPU 버스트 시간이 동일한 프로세스들일 경우,\n FCFS: CPU를 먼저 쓰고 나가는 프로세스의 소요시간 및 대기시간이 짧아진다. Round robine: CPU를 조금씩 같이 쓰고, 거의 동시에 끝나게 되어 소요시간 및 대기시간이 가장 오래 기다린 프로세스에 맞춰진다. 따라서 Round robine 스케쥴링은 FCFS의 평균 대기시간 및 평균 소요시간이 FCFS보다 거의 두 배로 더 길어진다.    하지만, CPU burst 시간이 균일하지 않은 경우가 대부분이기 때문에, Round robine은 FCFS보다 합리적\n      5.5 멀티레벨 큐(Multi-level queue)   ready queue를 여러 개로 분할해 관리하는 스케쥴링 기법 공정하지 않은 알고리즘이지만, 우선순위가 높은 프로세스가 더 빨리 CPU를 얻어야 하기 때문이다.     이 기법의 경우, 다음과 같은 문제점이 발생한다.\n 이 기법의 경우, 어떤 줄에 서 있는 프로세스를 우선적으로 스케쥴링할 것인가?? 프로세스가 도착했을 때, 어느 줄에 세워야할지 결정하는 메커니즘 필요    첫 번째 문제에 대한 해결책: 프로세스의 성격에 맞는 스케쥴링을 사용한다.\n 전위 큐(foreground queue): 대화형 작업(interactive job)을 담기 위한 전위 -\u0026gt; 응답시간을 짧게 하기 위해 Round robin scheduling 사용 후위 큐(background queue): 계산 위주의 작업을 담기 위한 후위 -\u0026gt; 응답 시간이 큰 의미를 가지지 않기 때문에, 그리고 context switching overhead를 줄이기 위해 FCFS 사용    두 번째 문제에 대한 해결책: 고정 우선순위 방식(fixed priority scheduling)\n Fixed priority scheduling(고정 우선순위 방식)  Queue에 고정적인 우선순위를 부여하는 방식  우선순위가 높은 큐를 먼저 서비스 -\u0026gt; 낮은 큐는 우선순위가 높은 큐가 비어있을 때만 서비스 실행.   즉, 전위 큐에 있는 프로세스에게 우선적으로 CPU를 부여하고, 전위 큐가 비어 있는 경우에만 후위 큐에 있는 프로세스에게 CPU를 할당한다. 하지만, starvation 이 발생할 수 있다.      두 번재 문제에 대한 또 다른 해결책: time slice\n 각 queue에 CPU 시간을 적절한 비율로 할당  ex) RR인 전위 큐: 80% , FCFS인 후위 큐: 20%      5.6 멀티레벨 피드백 큐(Multi-level Feedback Queue)  멀티레벨 큐와 거의 다 동일하나, 차이점은 process가 하나의 queue에서 다른 큐로 이동이 가능하다.\n즉, 프로세스의 우선순위가 바뀔 수 있다.\n   우선순위 스케쥴링의 aging 기법을 멀티레벨 피드백 큐 방식으로 구현하면,\n 기다렸으면 우선순위가 낮은 큐에서 높은 큐로 승격시키는 방식이다. 차근 차근 시간을 늘려 때문에, CPU 사용 시간을 예측할 필요가 없다.    멀티레벨 피드백 큐를 정의하는 요소들\n 큐의 수 각 큐의 스케쥴링 알고리즘  프로세스를 상위 큐로 승격시키는 기준 프로세스를 하위 큐로 강등시키는 기준 프로세스가 도착했을 때, 들어갈 큐를 결정하는 기준 등등      멀티레벨 피드백 큐의 동작 예\n 프로세스가 준비 큐에 도착하면 우선순위가 가장 높은 큐(Round robine, 할당시간 8)에 줄을 선다.\n-\u0026gt; CPU 사용시간이 짧은 대화형 프로세스라면 빨리 서비스 박고 작업완료할 수 있다.\n-\u0026gt; CPU burst가 긴 process라면 하위 큐(Round robine, 할당시간 16)로 강등시킨다. -\u0026gt; 그럼에도 완료하지 못하면 계산위주의 프로세스로 간주하여 최하위 큐인 FCFS scheduling을 적용    5.7 다중처리기 스케쥴링(Multi-processor system)  multi-processor 상황에서의 scheduling 기법\n   은행창구에서 번호표를 뽑아 기다리는 것처럼 CPU가 알아서 다음 프로세스를 꺼내가도록 할 수 있다.\n  하지만, 반드시 특정 CPU가 실행해야 한다든가 ex) 미용실에서 특정 미용사로 예약한 경우\n  Load sharing\n 각 CPU 별 부하가 적절히 분산되도록 하는 매커니즘이 필요하다.    다중처리기 스케쥴링의 방식\n 대칭형 다중처리(SMP, Symetric Multi-Processing): 모든 CPU가 대등해서 각자 알아서 스케줄링을 결정하는 방식 비대칭형 다중처리(asymmetric multiprogramming): 하나의 CPU가 다른 모든 CPU의 스케줄링 및 데이터 접근을 책임지고, CPU는 거기에 따라 움직이는 방식    5.8 실시간 스케쥴링(real-time system)  정해진 시간(dead line) 이내에 처리해야만 하는 스케줄링\n  경성 실시간 시스템(Hard real-time system)과 연성 실시간 시스템(soft real-time system)으로 나눠진다.  전자는 원자로 제어, 미사일 발사 등 시간을 정확히 지켜야하는 시스템 후자는 데드라인이 존재하지만, 지키지 못했다고 하여 위험한 상황이 발생하지 않는다.    5.9 Thread scheduling  Thread를 구현하는 방식 2가지  Local Scheduling (by user process)  User level thread의 경우, process가 thread를 직접 관리하고 OS는 thread의 존재를 모른다. 그래서 OS는 이 thread에게 CPU를 줄지 결정한다. 그리고, process 내부에서 어떤 thread에게 줄지를 결정한다.   Global Scheduling (by OS)  Kernel level thread의 경우, 일반 프로세스와 마찬가지로 커널의 단기 스케쥴러가 어떤 thread를 스케줄할지 결정 즉, OS가 thread의 존재를 인지한다.       6. 스케쥴링 알고리즘의 평가  스케쥴링 알고리즘의 성능을 평가하는 방법에는 큐잉모델(Queuing model), 구현 및 실측(Implementation \u0026amp; measrrement), 시뮬레이션(Simulation)가 있다.  Queueing model: 이론가들이 수행하는 방식  수학적 계산을 통해 performance index(CPU 처리량, Process 평균 대기시간 등)를 구한다. 밑에 방식이 훨씬 많이 사용된다.   Implementation \u0026amp; measurement: 이론가가 아닌 구현가들이 수행하는 방식  동일한 program을 원래 kernel과 CPU scheduler code를 수정한 kernel에서 수행한 후, 실행시간을 측정하여 알고리즘을 평가한다. 이 방법이 어려우면 밑에 방법을 사용한다.   Simulation: 가상으로 CPU scheduling program을 작성하는 방식  가상으로 CPU scheduling program을 작성한 후, 프로그램의 CPU 요청을 입력값으로 넣어 어떠한 결과가 나오는지 확인하는 방법 그래서 가상으로 생성된 값과 실제 system에서 추출한 입력값(이를 trace라 한다.)을 비교한다.       Reference  운영체제와 정보기술의 원리 kocw 이화여자대학교 운영체제 - 반효경 교수 -  ","permalink":"http://jeha00.github.io/post/os/os_chapter_06_cpu_scheduling/","summary":"Bound process를 중심으로 CPU 스케쥴러가 왜 필요한지, 스케쥴링의 성능 척도는 무엇인지, CPU sheduling 알고리즘의 종류에는 무엇이 있고, 이 알고리즘 평가는 어떻게 이뤄지는지 알아보자.","title":"[TIL] OS Chapter 06: CPU scheduling"},{"content":"0. Introduction  해당 내용은 운영체제와 정보기술의 원리 -반효경 지음- 와 kocw 이화여자대학교 운영체제 - 반효경 교수 -를 보고 정리한 내용입니다. 정확하지 않은 내용이 있다면 말씀해주시면 감사하겠습니다.   1. 프로세스의 개념 1.1 Process (프로세스)  is a prgram in execution  프로세스 = 실행 중인 프로그램 디스크에 실행파일 형태로 존재하는 상태(프로그램) → 메모리에 올라감 → 실행 이 실행 중일 때를 process라 한다.    1.2 Process context (프로세스 문맥 )   process의 수행 상태를 정확히 아는데 필요한 모든 요소\n  process conetxt를 알아야 하는 이유???\n CPU는 시분할 시스템으로, timer interrupt에 의해서 여러 process가 돌아가면서 CPU를 사용한다. 이런 상황에서, 한 process가 CPU를 다른 process에게 이양했다가 다시 획득했을 때, 직전 수행 시점의 정확한 상태 를 재현하기 위해서 필요하다.    Process context의 분류\n  Hardware context\n Program counter 각종 register  이 register에 저장된 값들      Process의 address space\n code, data, stack  process만의 독자적인 주소 공간      process 관련 kernel 상의 문맥\n PCB (Process Control Block) Kernel stack  OS가 process를 관리하기 위해 유지하는 자료구조들: PCB, kernel stack       2. 프로세스의 상태 2.1 Process의 상태도   Process는 다음 상태 중 어느 한 상태에 머무르며, 시간의 흐름에 따라 변한다.\n  Process의 상태를 나누는 이유는 컴퓨터의 자원을 효율적으로 관리하기 위함\n  Process의 상태도\n Running:  CPU를 잡고 instruction을 수행 중인 상태   Ready:  다른 조건은 다 만족하고, 메모리에는 올라와 CPU만 기다리는 상태   Blocked( wait, sleep ):  CPU를 할당받아도 당장 instruction을 수행할 수 없는 상태 process 자신이 요청한 even가 즉시 만족되지 않아 이를 기다리는 상태  ex) disk에서 file을 읽어와야 하는 경우 (I/O 작업)     New:  process가 시작되어 자료구조는 생성되었지만, 메모리 획득을 승인받지 못한 상태   Terminated:  execution(실행)이 끝났지만, 자료 구조 정리는 완료하지 못한 상태      Dispatch:\n CPU를 할당받을 process를 선택한 후, 실제로 CPU의 제어권을 넘겨받는 과정    2.2 Process 상태 변화 예시  입출력을 요청한 프로세스의 상태 변화 Running state  A process가 CPU를 할당 받아 기계어 명령을 하나씩 수행\n→ I/O 요청 파일의 내용을 disk에서 읽어와야 명령이 진행될 수 있으므로, 입출력 요청을 한다.\n→ Blocked state 입출력 요청이 완료될 때까지 CPU를 반환한 다음, disk 입출력 서비스를 기다리며 봉쇄 상태로 바뀐다. 그리고, 해당 process는 device I/O queue 뒤에 줄슨다.\n→ Ready state의 process 중 선정 CPU를 할당받을 process를 선택하기 위해, ready 상태의 process 들 중에서 CPU scheduler가 적절한 process를 하나 선정하여 CPU를 할당한다.\n→ Running state B process가 CPU를 받아 자신의 code를 실행한다.\n→ device controller 가 interrupt 발생 I/O 작업을 하던 controller가 interrupt를 발생하여 CPU에게 I/O 작업 완료를 알림\n→ B process를 user mode에서 kernel mode 진입 interrupt의 발생 원인이 B process와 상관없어도, CPU가 현재 사용하고 있던 process가 kernel mode로 진입했다고 판단.\n→ Ready state HW interrupt에 의해서 A process를 blocked state에서 ready state로 바꾼 후, CPU의 ready queue에 줄을 세운다. 그리고, device의 local buffer에 있는 내용을 memory로 이동한다.     3. 프로세스 제어블록 3.1 PCB란 ??  운영체제가 각 process를 관리하기 위해, process 마다 유지하는 정보들을 담는, 커널 내의 자료구조  3.2 PCB의 구성 요소  1) OS가 관리를 위해 사용하는 정보  Process state, process ID  process state: CPU를 할당해도 되는지 여부를 결정하기 위해 process ID: 효율적인 관리를 위해 process 마다 매긴 고유 번호   scheduling information, priority   2) CPU 수행 관련 HW 값  program counter: 다음에 수행할 명령의 위치를 가리킨다. registers   3) 메모리 관련  code, data, stack   4) 파일 관련  open file descriptors: 입출력 관련 상태 정보     4. 문맥교환 (Context switch) Context switch란??   CPU를 한 프로세스에서 다른 프로세스로 넘겨주는 과정\n  문맥 교환 중, OS가 실행하는 것들\n  CPU를 내어주는 process의 state를 이 process의 PCB에 저장\n  CPU를 새롭에 얻는 process의 state를 PCB에서 읽어온다.\n    context switch가 일어나는 경우와 그렇지 않은 경우\n  System call이나 interrupt 발생 시, 반드시 문맥교환이 일어나는 게 아니다.\n 첫 번째 경우, 단지 같은 process의 mode가 바뀌는 경우 두 번째 경우가 context switch다. 첫 번째 경우도 CPU 수행 정보 등 context의 일부를 PCB에 저장해야 하지만, context switch를 하는 경우, 오버헤드가 훨씬 크다. (eg. cache memory flush)  A process의 address space의 code를 실행하다가, kernel address space의 code를 실행하는 것이기 때문에, PCB에 저장해야 한다.        문맥교환에 소요되는 시간은 일종의 오버헤드다.\n 그래서, timer로 CPU 할당시간을 아주 작게 세팅하면 문맥교환이 빈번히 발생하기 때문에, 오버헤드가 상당히 커진다. 하지만, CPU 할당 시간을 너무 크게 설정하면 시분할 시스템의 의미가 퇴색된다. 그러므로, 적절한 CPU 할당시간을 정해야 한다.     5. 프로세스를 스케쥴링 하기 위한 큐 5.1 kernel의 process 상태 관리  process 상태 관리는 kernel의 주소 공간의 data 영역 에 다양한 queue를 두어 수행한다. process들은 각 queue들을 오가며 수행한다.  5.2 다양한 queue 종류  Job queue  현재 시스템 내에 있는 모든 프로세스를 관리하기 위한 큐 모든 process가 속한다. ready queue와 device queue가 다 포함된다. ready 큐에 포함하면 device 큐에는 포함되지 않는다.   Ready queue  현재 메모리 내에 있으면서 CPU를 잡아서 실행되기를 기다리는 프로세스의 집합   Device queues (장치 큐) = HW queue  각 I/O device의 service를 기다리는 process의 집합 각 deivce마다 있기 때문에, 다양하다. 예)  device controller가 줄 서 있는 순서대로 I/O 작업 수행 → 작업 완료하면 controller가 interrupt 발생 → interrupt service routine에 의해서 입출력 작업이 완료된 process는 I/O queue에서 나와 CPU대기 queue 슨다.     resource queue = SW resource  SW queue가 필요한 이유??  SW resource인 공유 데이터에 여러 process가 접근할 경우, 데이터의 일관성 훼손 이 발생할 수 있다. 그래서, 공유 데이터에는 매 시점 하나의 프로세스만이 접근하도록 한다.  SW resource에 접근 중인 process가 다 사용하고 반납할 때까지, 다른 process가 CPU를 할당받았어도 접근하지 말고 공유 데이터 queue에서 기다려야 한다.        5.3 Process scheduling queue의 모습  위 image는 OS가 queue를 어떻게 자료구조로 구현하는지 보여준다. queue는 각 process의 PCB를 연결 list 형태로 관리하여 순서를 정한다. Queue header  큐의 가장 앞부분 PCB의 pointer 부분이 이어진다.   queue 흐름 설명  process가 CPU 할당받고 수행 중 I/O 요청이 발생하면 해당 device queue에 줄을 슨다. device queue에 속한 process는 blocked state였다가, 해당 장치의 서비스를 받으면, device controller가 인터럽트를 발생시켜 준비 상태로 바껴 ready queue로 이동한다. ready queue에는 PCB 7 다음에, PCV 2가 대기하고 있다. magnetic tape에는 아무것도 대기하지 않는다. disk queue에는 PCB 3 ← PCB 14 ← PCB 6 순서로 대기하고 있다. terminal queue에는 PCB 5 만 대기하고 있다.     6. 스케쥴러 (Scheduler) 6.1 Long-term scheduler (장기 스케쥴러 or job scheduler)  시작 프로세스 중 어떤 것들을 ready queue 로 보낼지 결정 process에 memory (및 각종 자원) 을 주는 문제  메모리를 어느 것에 줄지를 결정 현대의 컴퓨터는 메모리를 기본적으로 바로 준다.   degree of Multiprogramming 제어  multi-programming: 메모리에 여러 프로그램이 동시에 올라가는 것을 의미 이 메모리에 올라가는 수를 제어하는 것 → 컴퓨터 성능에 영향을 줌 현 컴퓨터에는 장기 스케쥴러는 없고, 프로그램이 시작하면 다 ready 상태로 들어간다.   time sharing system에는 보통 장기 scheduler가 없다. (무조건 ready)  6.2 Short-term schduler (단기 scheduler or CPU scheduler)  어떤 프로세스를 다음 번에 running 시킬지 결정 프로세스에 CPU 를주는문제 충분히 빨라야 함 (milli-second 단위)  6.3 Medium-Term Scheduler (중기 스케쥴러 or Swapper)  여유 공간 마련을 위해 프로세스를 통째로 메모리에서 디스크로 쫓아낸다. 프로세스에게서 memory 를 뺏는 문제  메모리에 프로그램이 너무 많이 올라가면, 쫓아내어 전체적인 컴퓨터 성능을 개선. 시스템 입장에서는 장기 스케쥴러보다 중기 스케쥴러를 주는 게 더 이득   degree of multiprogramming 을 제어  현재 multi-programming을 제어하는 scheduler 이 중기 스케쥴러가 들어가 있기 때문에, 프로세스의 상태 3가지에 추가된 게 suspended다.    6.4 추가된 프로세스 상태도  중기 스케쥴러에 의해 suspended state가 추가되었다. Running  CPU를 잡고 instruction을 수행 중인 상태   Ready  CPU를 기다리는 상태( 메모리 등 다른 조건을 모두 만족하고)   Blocked (wait, sleep)  I/O 등의 event를 스스로 기다리는 상태 예) 디스크에서 file을 읽어와야 하는 경우   Suspended (stopped)  외부적인 이유로 강제로 프로세스의 수행이 정지된 상태  중기 스케쥴러에 의해 강제로 뺏긴 상태   이 상태의 프로세스는 통째로 디스크에 swap out 된다. 예) 사용자가 프로그램을 일시 정지시킨 경우 (break key). 이 경우에는 사람이 재개시켜야 위의 상태가 된다.  시스템이 여러 이유로 프로세스를 잠시 중단시킴 → 중기 스케쥴러 (메모리에 너무 많은 프로세스가 올라와 있을 때)     blocked와 suspended 구분하기  Blocekd: 자신이 요청한 event가 만족되면(자신이 요청한 작업이 완료되면) Ready Suspended: 외부에서 정지된 상태이기 대문에, 외부에서 resume 해 주어야 Active     7. 프로세스의 생성 7.1 Process creation (프로세스 생성) : COW(Copy-On-Write)  OS가 process를 전부 생성하는 게 아닌, 부팅 후 최초의 process는 운영체제가 직접 생성한다. 그 다음부터는 이미 존재하는 process가 다른 process를 복제 생성한다. process를 생성하는 process를 부모 프로세스라 하고, 생성된 process를 자식 프로세스라 한다.  부모 프로세스 1개가 자식 프로세스 최소 1개를 복제 생성 한다. 또한, 자식 프로세스가 또 process를 생성할 수 있다. 프로세스의 트리(계층 구조) 형성   작업 수행을 위한 자원  부모 프로세스는 OS로부터 받는다. 자식 프로세스는 부모 프로세스와 공유 한다.  부모와 자식 프로세스가 서로 모든 자원을 공유 하는 모델 일부를 공유 하는 모델 전혀 공유하지 않는 모델     주소 공간 (Address space)  process 생성의 첫 번째: 부모 공간을 복사 → 두 번째: 복사한 공간에 새로운 프로그램의 주소 공간을 덮어씌운다.   Process 와 관련한 system call (특권 명령 )  fork() : create a child (copy) exec() : overlay new image = 새로운 프로그램으로서 덮어씌운다. wait() : sleep until child is done exit() : frees all the resources, notify parent   UNIX의 예  os에게 fork() system call 요청하여, 새로운 process를 생성  부모를 그대로 복사하고, 주고 공간을 할당 복사할 때, 부모 프로세스의 process ID는 제외한다.   fork () 다음에 이어지는 exec () system cal을 통해 새로운 프로그램을 메모리에 올린다. fork () 와 exec () 둘 다 system call을 통해서 실행되므로, 운영체제가 생성한다.    7.2 Process Termination (프로세스 종료)  프로세스가 마지막 명령을 수행한 후, 운영체제에게 이를 알려준다. (’exit’ system call)  자식이 부모에게 output data를 보낸다. (via ‘wait’ system call) 프로세스의 각종 자원들이 운영체제에게 반납된다. 자식 프로세스가 먼저 종료 후 부모 프로세스가 종료되야 한다.   부모 프로세스에게 자식의 수행을 종료시킨다. (abort)  자식이 할당 자원의 한계치를 넘어설 때 자식에게 할당된 task가 더 이상 필요하지 않을 때 (자식 프로세스를 만든 이유가 일을 시키기 위함이기 때문) 부모가 종료(exit)할 때  운영체제는 부모프로세스가 종료하는 경우, 자식이 더 수행되도록 두지 않는다. 단계적인 종료( 손자 → 자식 → 부모 )가 지켜져야 한다.      7.3 fork () system call  creats a new address space that is a duplicate of the caller 자식 process를 만들 때, 부모 process의 program counter까지 복사된다.  부모 process와 자식 process의 차이는 식별자 다.   그래서, program counter는 fork () 실행 후, 다음 코드를 가리키기 때문에, 자식 process는 fork ()한 이후부터 코드를 실행한다.  자식 process라 부르지만, 복제인간이라 생각하는 게 정확한다. 또한, 복제된 process는 자신을 원본이라 생각한다.   복제된 process인지 아닌지 구분하는 방법  fork 함수의 결과값으로 자식 process 는 0을, 부모 process에게는 양수를 준다.    7.4 exec () system call  fork () 한 후, exec () system call을 통해서 자식 프로세스를 새로운 program으로 대체한다. (overwrite) 한 번 만들어지면 다시 되돌아갈 수 없다.  7.5 wait () system call  wait () system call은 자식 process가 종료될 때까지 process A를 blocked state로 만든다. 자식 프로세스가 종료되면 kernel은 프로세스 A를 준비 상태로 변경하여 준비 큐에 진입.  7.6 exit() system call  process의 종료  자발적 종료  마지막 statement 수행 후, OS에게 exit () system call로 자신이 종료됨을 알린다. 명시적으로 exit ()을 호출하지 않아도, main () 함수가 반환되는 위치에 compiler가 자동으로 삽입해 프로세스 종료 직전에 항상 호출한다.   비자발적 종료 (자식 프로세스 밖에서 종료시키는 경우)  부모 프로세스가 자식 프로세스를 강제 종료시킨다. When??  자식 프로세스가 한계치를 넘어서는 할당 자원 요청을 할 때 자식에게 할당된 task가 더 이상 필요하지 않을 때   프로그램 종료 버튼을 누르는 경우나, 키보드로 kill, break 등을 친 경우 부모가 종료하는 경우  부모 프로세스가 종료하기 전에 자식들이 먼저 종료된다.       프로그램을 강제 종료시킨 후, 계속 수행시켜야하는 경우에는 종료되지 않는 다른 자식 프로세스로 이양시켜서, 기존 부모 프로세스가 종료된 후에도 다른 프로세스 아래에서 계속 수행한다.  부모가 죽기 전에 자식이 먼저 죽는다는 원칙은 여전히 지켜진다.     8. 프로세스 간의 협력 8.1 Process 간 협력하는 이유  독립적 프로세스 (Independent process)  프로세스는 각자의 주소 공간을 가지고 수행되므로, 원칙적으로 하나의 프로세스는 다른 프로세스의 수행에 영향을 미치지 못한다.   하지만, process 간 협력한다면 왜 하고 어떻게 하는 것일까?? 협력 프로세스( Cooperating process)  Why?  업무의 효율성 증대: 부분적인 처리 결과, 정보를 공유할 수 있고, 처리 속도가 향상.   How? - IPC(Inter-Process Communication): process 간 통신과 동기화를 이루기 위한 mechanism     8.2 IPC의 대표적인 방법: 2가지   Message passing: 메시지 전달 방식\n  Message passing의 특징\n 프로세스 사이에 공유 변수(shared variable)을 일체 사용하지 않고 통신하는 시스템. 중간에 kernel을 통해서 하는데, 명시적으로 process의 이름을 표시하냐 안하냐의 차이. kernel에 의해 send(message)와 receive(message)라는 두 가지 연산을 제공받는다.  즉, 이 두 가지 연산은 특권명령이다.      Message passing 방식 2가지\n 직접 통신 (direct communication) 간접 통신 (Indirect communication)      Shared memory: 공유 메모리 방식\n  8.3 Message passing 방식: 2가지  Message passing 방식에는 직접통신(direct communication)과 간접통신(indirect communication) 으로 나뉜다. Direct communication  - 통신하려는 프로세스의 이름을 명시적으로 표시한다. - Send (Q, message): process Q에게 메시지를 전송하는 것을 의미 - Receive (P, message): process P로부터 메시지를 전달받는 것을 의미 - link는 자동적으로 생성되며, 하나의 link는 정확히 한 쌍의 process에게 할당된다. - 각 쌍의 process에게는 오직 하나의 link만이 존재한다.   Indirect communication  - 통신하려는 프로세스의 이름을 명시적으로 표시하지 않는다. - mailbox ( or port)를 통해 메시지를 간접 전달한다. - mailbox에는 고유의 ID가 있다. - 이 mailbox를 공유하는 process 들끼리만 서로 통신할 수 있다. - Send(M, message): M이라는 mailbox에 message를 전달하는 것 - Receive(M, message): M이라는 mailbox로부터 메시지를 전달받는 것 - mailbox를 3개 이상의 process가 공유할 경우, 각각의 프로세스에게 링크를 따로 생성가능.  8.4 Shared memory  서로 다른 process 간에도 일부 주소 공간을 공유하게 하는 mechanism 두 process가 서로 신뢰할 수 있는 process여야 한다. kernel에게 system call 후, memory가 공유된다. 물리적인 공간에 mapping 할 때, 공유된 상태로 진행한다. 이 방법에서 동기화 문제는 kernel 책임지지 않고, 공유되는 process 들이 책임져야 한다.   9. Thread 9.1 Thread란??   A Thread (or lightweight process) is a basic unit of CPU utilization\n CPU의 기본 실행 단위를 Thread 라 한다.    Thread의 구성\n Program counter register set stack space  stack space에서 여러 thread로 나눠진다.      process 내부에서 thread가 동료 thread와 공유하는 부분 = task\n code section data section OS resources    heavyweight process 는 하나의 thread를 가지고 있는 task 다.\n CPU가 명령을 수행하기 위해서는 코드의 실행될 부분을 가리키는 program counter가 있어야 한다. 또한, memory에 register 값 을 세팅해야 한다. 그리고, OS는 process를 관리하기 위해 process마다 1개의 PCB를 둔다. 이 PCB를 보면 여러 thread로 구성된 걸 확인할 수 있다.    9.2 Thread의 장점  Responsiveness: 응답성  eg) multi-thread: 하나의 서버 thread가 blocked state 인 동안에도, 동일한 task 내의 다른 thread가 계속 실행되어 빠른 처리를 할 수 있다.   Resource sharing: 자원의 효율적인 관리  여러 thread가 process의 code, data, resource를 공유하기 때문에, 자원 관리가 효율적.   Economy: 경제성  process를 새로 생성하는 것보다 thread를 새로 생성하는 게 오버헤드가 훨씬 적다. process 간의 switching보다, thread 간의 switching이 오버헤드가 훨씬 적다.   Utilization of MP Architectures  병렬로 thread가 실행될 수 있다. 다중 thread가 협력하여 높은 처리율과 성능 향상을 얻는다.    9.3 Implementation of threads  Some are supported by kernel ⇒ Kernel threads  thread가 여러 개인 것을 운영체제가 알고 있음 예)  Windows 95, 98 / NT Solaris Digital UNIX, Mach     Others are supported by library ⇒ User Threads  운영체제가 프로세스 안에 thread가 여러개인 걸 모른다. 즉, User program이 thread를 관리한다. 예)  POSIX Pthreads MAch C-threads Solaris threads     Some are real time threads  real time을 지원하는 thread     Reference  운영체제와 정보기술의 원리 kocw 이화여자대학교 운영체제 - 반효경 교수 -  ","permalink":"http://jeha00.github.io/post/os/os_chapter_05_%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4_%EA%B4%80%EB%A6%AC/","summary":"프로세스란 무엇인지, 프로세스의 상태는 어떻게 흘러가는지, 문맥 교환이란 무엇인지, 프로세스가 어떻게 생성되고 종료되는지, 프로세스끼리 협력은 어떻게 하는지, thread는 무엇인지 알아보겠다.","title":"[TIL] OS Chapter 05: 프로세스 관리"},{"content":"0. Introduction  해당 내용은 운영체제와 정보기술의 원리 -반효경 지음- 와 kocw 이화여자대학교 운영체제 - 반효경 교수 -를 보고 정리한 내용입니다. 정확하지 않은 내용이 있다면 말씀해주시면 감사하겠습니다.   1. 프로그램의 구조와 인터럽트  프로그램이 CPU에서 명령을 수행하기 위해서는 명령을 담은 프로그램의 주소 영역이 메모리에 올라가 있어야 한다. 왜냐하면 CPU는 메모리에 있는 instruction만을 보고 실행하기 때문이다.  1.1 프로그램의 주소 영역  프로그램의 주소영역 = Code + Data + Stack 영역 Code 영역  작성한 함수의 코드가 CPU에서 수행하는 기계어 형태로 변환되어 저장 되는 공간   Data 영역  전역 변수(global variable) 등 프로그램이 사용하는 데이터를 저장 하는 공간   Stack 영역  함수 호출 시의 복귀 주소 및 데이터를 저장 하는 공간 예)  X 함수 수행 → Y 함수 호출 → 이 때 X 함수에서 Y 함수를 호출하는 지점을 stack 영역에 저장 → Y 함수가 호출되어 실행할 명령의 메모리 위치가 바뀜 → Y 함수 수행 완료 → stack에 저장된 X 함수의 주소 위치로 돌아와 코드를 계속 수행      1.2 PCB: 프로그램 수행의 복귀 위치  인터럽트가 발생할 경우 복귀 위치: PCB(Process Control block)에 저장한다. interrupt가 발생한 시점에서 프로그램의 어느 부분까지 수행했는지를 PCB에 저장 과정  A 프로그램이 CPU를 할당받아 명령을 수행 → interrupt 발생 → 현재 수행 중인 명령 위치를 PCB에 저장 → CPU 제어권을 OS에게 양도 → 인터럽트 처리 완료 후, PCB에 저장된 작업 지점으로 돌아와 계속 수행     2. 컴퓨터 시스템의 작동 개요  컴퓨터 시스템의 작동  CPU에서 명령을 수행하는 부분 + 컴퓨터 외부장치와 입출력이 이루어지는 부분    2.1 프로그램 카운터(Program Counter(PC))  PC = Program Counter = CPU가 수행해야할 메모리 주소를 담고 있는 레지스터  CPU는  빠른 속도의 연산 능력은 가지고 있지만, 결정 능력을 가지고 있지 않다. 단지 매번 프로그램 카운터가 가리키는 메모리 위치의 명령을 처리한다.   통상 프로그램 카운터가 다음 명령어를 가리키어 CPU 명령은 순차적으로 수행된다.  반복문이나 함수 호출 등으로 바로 다음 주소가 아닌 명령을 수행할 수도 있다.     Program Counter 가  OS가 존재하는 메모리 위치 를 가리키면 CPU가 \u0026lsquo;kernel mode\u0026rsquo; 에서 수행 중 사용자 프로그램의 메모리 위치 를 가리키면 CPU가 \u0026lsquo;user mode\u0026rsquo; 에서 수행 중    2.2 일반 명령과 특권 명령  일반 명령  메모리에서 자료를 읽어와 CPU에서 연산을 하고, 그 결과를 메모리에 쓰는 명령 모든 프로그램이 수행 가능 mode bit가 1일 때   특권 명령  보안이 필요한 명령 각종 장치에 접근하는 명령 운영체제만이 수행 mode bite가 0일 때   운영체제를 향한 사용자 프로그램의 대행 요청: system call  사용자 프로그램이 특권 명령을 사용하고자 할 때, 사용자 프로그램이 특권 명령을 수행할 수 없으므로 운영체제에게 대행 요청 system call 을 한다. 그러면 CPU의 제어권이 운영체제에게 넘어가서 특권 명령을 수행한다.    2.3 인터럽트 라인을 세팅하는 이유  Problem  CPU는 프로그램 카운터가 가리키는 메모리 위치의 명령만 계속 수행하여, 주변장치의 상태를 지속적으로 파악할 수 없다.   Solution  주변 장치들이 CPU의 도움이 필요할 때 인터럽트 라인(interrupt line)을 세팅한다.  CPU는 매번 명령을 수행한 후, 인터럽트 라인을 체크하여 요청 유무를 확인한다. 또한, 인터럽트의 원인이 다양하기 때문에, 인터럽트 라인을 다르게 해서 구분한다.       3. 프로그램의 실행  “프로그램이 실행(program execution)되고 있다”  = disk에 존재하던 실행 파일이 메모리에 적재된다 = program이 CPU를 할당받고 instruction을 수행하고 있는 상태   “프로그램이 동시에 실행된다”  = 여러 프로그램이 짧은 시간 단위로 CPU를 나누어 사용한다. = 프로그램이 메모리에 동시에 적재되어 있을 수 있으므로    3.1 가상 메모리(Virtual Memory)   프로그램은 실행 파일 형태로 하드 디스크에 저장한다.\n  파일 실행 → 가상 메모리(Virtual Memory) 생성 → Address transition → 물리적 메모리(Physical Memory) 에 올라감\n 가상 메모리(address space, logical memory) : 프로그램마다 가지는 독자적인 주소 영역 물리적 메모리(Physical Memory) : 0번지부터 시작 Address transition : 가상 메모리 주소를 물리적 메모리 주소로 변환하는 것으로, 하드웨어 장치가 수행     Virtual memory = 주소 영역 = Address space = code + data + stack\n  OS의 주소 영역\n kernel의 code  자원 관리를 위한 부분 사용자에게 편리한 인터페이스를 제공하기 위한 부분 system call 및 interrup를 처리하기 위한 부분   kernel의 data  하드웨어와 소프트웨어(ex: 사용자 프로그램)를 포함하는 시스템 내의 모든 자원을 관리하기 위한 자료구조를 유지 ex) PCB   kernel의 stack  현재 수행 중인 프로세스마다 별도의 스택을 두어 관리.  Reason 1: system call로 특권 명령 대행을 요청한 후, 운영체제가 system call 내부의 다른 함수를 호출할 경우 복귀 주소는 커널 내의 주소가 되기 때문에 Reason 2: kernel은 일종의 공유 코드로서, 모든 프로세스가 system call을 통해 kernel 함수를 접근할 수 있으므로, 각 프로세스마다 커널 내에 별도의 스택을 둔다.        함수 호출 복귀 시 저장 장소\n '____' 코드 수행 중 이루어지는 함수 호출로 인한 복귀 주소 유지는 '____' 을 사용  process → 자신의 address space 내의 stack kernel → kernel stack   CPU 수행 주체가 OS로 바뀔 때 직전 수행 프로그램의 복귀 정보는 stack이 아닌 PCB에 저장    3.2 Swap area  Problem  프로그램이 프로세스가 되었을 때 생성되는 address space를 물리적 메모리에 다 올리지 않는다. Why?? 다 올리면 메모리 낭비가 심하기 때문   Solution  바로 필요한 코드 부분만 memory에 올린다. 그 외 부분은 보조기억장치에 놔두는데, 이 영역을 swap area라 한다. swap area는 메모리 용량 한계로 메모리 연장 용도로 사용한다. 하지만, 프로그램이 파일 형태로 저장되는 보조기억장치의 disk 영역은 비휘발성 용도로 저장한다.     4. 사용자 프로그램이 사용하는 함수  프로그램이 사용하는 함수의 종류  사용자 정의 함수: 프로그래머 본인이 직접 작성한 함수 라이브러리 함수: 자신의 프로그램에서 정의하지 않고 가져다 쓴 함수로, 자신의 프로그램의 실행 파일에 포함되어 있다. 커널 함수: kernel의 코드에 정의된 함수 = system call 함수 + interrupt 처리 함수  system call 함수: 사용자 프로그램이 운영체제의 서비스를 요청하기 위해 호출함수 interrupt 처리 함수: 각종 HW 및 SW가 CPU의 서비스를 요청하기 위한 함수  kernel의 address space에 code가 정의되기 때문에, system call로 kernel mode로 바꿔야 실행 가능하다.       사용자 정의 함수와 라이브러리 함수 는  프로그램의 코드 영역에 기계어 명령 형태로 존재 → 프로그램 실행 시, 해당 프로세스의 address space에 포함 함수 호출 시에도, 프로세스의 address process에 있는 stack 영역을 사용 프로세스의 address space의 code 영역 안에서 메모리 상의 점프를 한다. user mode에서 실행된다.     5. 인터럽트 5.1 Interrupt 작동 순서 복습  CPU는 프로그램 카운터가 가리키는 명령만 쉬지 않고 수행하기 때문에, 다른 명령을 수행하기 위해서는 interrupt를 걸어야 한다. CPU는 program counter가 가리키는 명령을 하나씩 수행한 후, interrupt line이 세팅되었는지 확인한다. interrupt line setting을 통해 interrupt가 발생했으면 현재 수행하던 process를 멈추고, 운영체제의 인터럽트 처리 루틴으로 이동하여, 인터럽트 처리를 수행한다. 인터럽트 처리를 마치면 인터럽트 발생 직전의 프로세스에게 CPU 제어권이 넘어간다.  5.2 Interrupt의 서로 다른 중요도  인터럽트 처리 중, 또 다른 인터럽트가 발생한 경우에는 어떻게 처리되는가???  중요도를 비교한다. 현재 처리 중인 인터럽트의 중요도가 상대적으로 낮으면, 처리 중인 인터럽트 코드의 수행 지점을 저장한다. 그 다음, 중요도가 더 높은 인터럽트를 처리한다. 인터럽트 처리가 끝나면 저장 주소로 복귀해 이전에 수행하던 인터럽트 처리 코드를 마저 수행한다.     6. 시스템 콜   system call 사용의 예\n process가 CPU에서 명령을 수행하던 중 I/O 작업이 필요한 경우, sw interrupt인 system call을 통해 kernel 함수를 호출한다.\n→ kernel 함수는 사용자 프로그램이 수행할 수 없으므로, CPU 제어권을 OS에게 넘겨야 하는데,\n→ OS에게 넘기기 위해서 인터럽트 라인을 세팅하는 명령을 실행하여, CPU에게 interrupt가 발생했다는 걸 알린다.\n→ CPU는 program counter가 가리키는 명령을 하나씩 실행한 후, interrupt line을 체크하여 interrupt 발생을 확인한다.\n→ interrupt를 확인한 CPU는 현재 실행 중인 process를 멈춘 후, process의 실행 상태를 PCB에 저장한다.\n→ OS는 interrupt line을 통해서 어느 종류의 interrupt인지 확인한 후, interrupt vector가 가리키는 interrut service routine을 찾아 실행하여, 요청한 I/O에 해당하는 device controller에게 I/O 명령을 한다.\n→ I/O 요청이 수행되는 동안, 해당 process는 데이터가 없어서 다음 명령을 수행할 수 없으므로, CPU를 다른 process에게 이양한다.\n→ 다른 process의 작업을 CPU가 작업하는 도중에, I/O 작업이 완료되면 device controller가 CPU에게 interrupt를 발생시켜 I/O 작업 완료를 알린다. 이 때 발생한 interrupt는 HW interrupt다.\n→ iterrupt 처리 내용으로 device controller가 device로부터 읽어와서 local buffer에 저장한 내용을 메모리로 복사해온다.\n→ 복사 후, I/O 작업을 요청했던 process에게 다시 CPU를 얻을 수 있는 권한을 준다.\n→ 그러면 I/O 작업을 이제 완료한 process는 CPU를 기다리는 큐에 삽입되고, CPU의 제어권은 iterrupt를 당한 process에게 넘어가서 하던 작업을 계속 수행한다.    process가 CPU를 빼앗기는 경우: 2가지\n Timer의 CPU 할당 시간이 만료된 경우, interrupt가 발생  time sharing system의 필수적인 요소 한 process가 CPU를 독점하는 걸 방지   process가 I/O 작업 같은 kernel code 수행이 필요한 경우 sw interrupt인 system call 하는 경우  시간이 오래 걸리는 I/O 작업이 수행하는 동안, CPU를 다른 process에게 할당한다.  그 이유는???  입출력 작업을 요청한 process에게 CPU를 할당해도 파일 데이터가 있어야 당장 다음 명령을 수행할 수 있는데, I/O 연산 속도는 CPU 연산 속도보다 매우 느리기 때문에, 긴 기다리는 시간 동안 CPU가 일을 할 수 없어 비효율적이기 때문이다.           7. 프로세스의 두 가지 실행 상태  프로세스의 실행 상태 두 가지: user mode running(사용자 모드에서의 실행 상태) 와 kernel mode running(커널 모드에서의 실행 상태) 프로그램 자신의 주소 공간에서 정의된 코드를 실행 ↔ user mode running  ex) 사용자 정의 함수 와 라이브러리 함수를 호출   kernel의 system call 함수 (kernel 주소 공간에 정의된 함수) 를 실행 ↔ kernel mode running  system call 실행이 끝나면 다시 user mode로 복귀 또한, 프로그램 실행이 끝날 때에는 kernel mode로 진입해 프로그램을 종료한다.   process 가 kernel mode에서 실행 중이란 의미는???  process A가 system call 을 통해 OS에게 대행 요청을 하여 kernel code를 실행 중이다 = process A가 kernel mode에서 실행 중 os가 kernel code를 수행하고 있을 지라도, os는 process A를 대신하여 수행 중이기 때문에, process A가 실행 상태인 걸로 간주한다.     Reference  운영체제와 정보기술의 원리 kocw 이화여자대학교 운영체제 - 반효경 교수 -  ","permalink":"http://jeha00.github.io/post/os/os_chapter_04_%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%A8%EC%9D%98%EA%B5%AC%EC%A1%B0%EC%99%80%EC%8B%A4%ED%96%89/","summary":"프로그램의 구조와 실행에 대해 설명한다. 예를 들어 프로그램의 주소영역, PCB, Program counter, 일반 명령과 특권 명령, Virtual memory, kernel mode와 user mode 등등을 알아본다.","title":"[TIL] OS Chapter 04: 프로그램의 구조와 실행"},{"content":"0. Introduction  해당 내용은 운영체제와 정보기술의 원리 -반효경 지음- 와 kocw 이화여자대학교 운영체제 - 반효경 교수 -를 보고 정리한 내용입니다. 정확하지 않은 내용이 있다면 말씀해주시면 감사하겠습니다.   5. 입출력 구조  CPU의 명령 수행 속도는 빠르지만, 입출력 연산은 상대적으로 느리다. 이 입출력 방식에는 동기식 입출력 과 비동기식 입출력 이 있다.  5.1 동기식 입출력(Synchronous I/O)   일반적으로 사용하는 방식\n  어떤 프로그램이 입출력했을 때, 입출력 작업이 완료된 후에야 그 프로그램이 후속 작업을 수행할 수 있는 방식이다.\n 예) 프로그램이 CPU를 점유한 상태에서 디스크에 정보를 읽어오라는 요청을 했다. 디스크 입출력이 완료되기까지 어느 정도의 시간이 소요된다. 이 때 동기식은 입출력 작업이 완료될 때까지 다음 명령을 수행하지 않고 기다린다. 그러다가 입출력이 완료되면 인터럽트를 통해 이 사실을 대기하고 있던 CPU에게 전달하고, CPU의 제어권이 프로그램에게 넘어가서 다음 명령을 수행할 수 있다.    동기식 입출력 과정\nA process가 code 실행 중에 I/O 요청이 필요한 명령을 만나서 I/O 요청을 한다\n→ A는 CPU에게 system call이라는 SW interrupt를 발생\n→ CPU는 프로그램 A의 코드를 실행하던 일을 멈추고, 현재 상태를 프로그램의 PCB에 저장한다\n→ CPU의 제어권이 운영체제에게 넘어간다\n→ A가 입출력 연산을 요청했으므로, 운영체제가 프로세스 A를 봉쇄상태로 표시 그리고, 운영체제는 인터럽트 처리루틴 수행\n→ CPU는 컨트롤러에게 입출력 연산을 요청\n→ 컨트롤러는 A가 요청한 데이터를 디스크로부터 자신의 로컬 버퍼로 읽어온다\n→ 컨트롤러가 읽어오는 동안 CPU를 다른 프로그램 B에 할당해 계속 CPU가 일을 할 수 있도록 한다\n→ 원하는 정보가 로컬버퍼로 다 들어오면 컨트롤러는 CPU에게 입출력이 완료되었다는 사실을 인터럽트를 발생시켜 알린다. 이 때 발생시킨 인터럽트는 하드웨어 인터럽트다\n→ 프로그램 B를 수행 중이던 CPU는 수행하던 지점 및 상태를 process B의 PCB에 저장하고, 인터럽트를 처리\n→ 인터럽트 처리 루틴은 로컬 버퍼에 있는 A가 요청한 데이터를 A의 메모리 영역으로 읽어오고 A의 봉쇄 상태를 해제시켜 A에게 CPU를 할당\n→ A는 CPU를 기다리는 줄에 다시 선다\n→ 다시 B로 돌아와 업무를 계속 진행\n→ A는 CPU를 큐에서 기다리다가 자신의 차례가 되면 CPU를 할당받고 입출력 연산 이후의 작업을 수행\n  5. 1.1 입출력 연산 동안 CPU를 다른 process에게 할당하는 이유 : CPU 낭비 방지   기본 지식 1: 입출력 연산 속도는 CPU 연산 속도보다 매우 느리다.\n  기본 지식 2: 매 시점 시스템 내에서는 하나의 입출력만 수행할 수 있다.\n 하지만, 동기화는 자동적으로 이뤄진다.    입출력 연산 속도는 매우 느려서 이를 수행하고 있는 프로그램이 CPU를 계속 점유하면, 프로그램의 입출력 연산이 끝날 때까지 CPU는 언터럽트를 기다리며 아무런 일을 하지 못한다.\n  그래서 일반적으로 프로그램이 입출력을 수행 중인 경우, CPU를 다른 프로그램에게 이양해 CPU가 쉬지 않고 일하도록 관리한다.\n  예시\n프로세스 A가 CPU를 할당받고, 명령을 수행하다가 입출력 요청을 한다. → 그러면 CPU를 다른 프로세스 B에게 할당한다.\n→ 프로세스 B가 CPU를 할당받아 명령을 수행하고, 프로세스 A는 입출력 작업을 수행한다.\n→ 프로세스 A가 입출력 작업을 완료할 때까지 CPU를 프로세스 A에게 할당 안한다.\n→ 또한, CPU를 프로세스 A에게 할당해도 명령을 수행하지 못하도록 봉쇄한다.\n→ 프로세스 A가 입출력 작업을 완료 후, 연산 완료의 통보로서 인터럽트를 보내야 CPU가 프로세스 A가 할당.\n  입출력 작업을 수행 중인 프로세스에게 CPU를 할당해도 명령을 수행하지 못하는 이유\n 입출력 중인 프로그램의 상태를 봉쇄 상태(Bblocked state) 로 전환하기 때문 봉쇄 상태의 프로그램에게는 CPU를 할당하지 않고, CPU 할당 시 곧바로 명령을 수행할 수 있는 프로그램에만 CPU를 할당한다. 인터럽트를 보내면 프로그램의 상태를 봉쇄 상태로부터 해제시킨다.    5.1.2 봉쇄 해제 후, ready 상태로 큐에서 기다리는 이유: 동기성 보장=동기화  입출력 수행 중일 때 다른 프로그램에게 CPU를 양도하면, 다수의 입출력 연산이 동시에 요청되거나 처리되어 동기화에 문제가 발생할 수 있다. 그래서 입출력 요청의 동기화를 위해 장치별로 큐(queue)를 두어 요청한 순서대로 처리할 수 있도록 한다. 예시  프로그램 A가 먼저 요청했으면 이를 먼저 큐에 넣고, 그 후에 발생한 B의 요청을 A 요청 뒤에 삽입한다. 디스크 차원에서는 큐에 있는 순서대로 처리하여 동기화 문제를 해결할 수 있다.    5.1.3 Summary  동기식 입출력을 요청한 프로그램은 입출력이 완료될 때까지 다음 명령을 수행할 수 없어 CPU가 낭비된다. 그러나, CPU의 효율적인 사용을 위해 입출력이 수행하는 동안 다른 프로그램에게 CPU를 양도하면 동시에 다수의 입출력 연산이 일어날 수 있다. 그래서 다수의 프로그램이 동시에 입출력 연산을 요청하는 경우 동기성(synchronization)을 보장하기 위해 장치마다 큐를 두어 요청된 순서대로 처리할 수 있도록 한다.  5.2 비동기식 입출력(Asynchronous I/O)  I/O가 시작된 후, 입출력 작업이 끝나기를 기다리지 않고 즉시 제어가 사용자 프로그램에 넘어간다. 그래서 입출력 연산과 무관한 처리 가능한 작업부터 처리한다.   6. DMA  DMA( Direct Memory Access) 란??  CPU의 중재 없이 device controller가 device의 buffer stroage의 내용을 메모리에 block 단위로 직접 복사한 후, CPU에 interrupt를 발생시키는 장치   왜 DMA가 필요한가???  Interrupt가 발생하면 CPU가 controller의 local buffer와 memory 사이에서 데이터를 옮기는 일을 수행. 만약 사용자 프로그램이 CPU를 사용하는 중에 I/O 장치가 interrupt를 많이 걸면, CPU가 많은 방해를 받아 CPU 효율이 많이 떨어진다. 그래서 DMA가 CPU를 대신하여 local buffer에서 메모리로 읽어오는 작업을 수행한다. 또한, CPU는 바이트(byte) 단위로 읽어오는데 byte가 아닌 block이라는 큰 단위로 정보를 메모리로 읽어온 후에 CPU에게 인터럽트를 발생시켜 해당 작업의 완료를 알리기 때문에, 인터럽트의 빈도를 줄인다. 이에 대한 궁극적인 효과로 CPU를 효율적으로 관리하고, 입출력 연산을 빠르게 수행할 수 있다.   그래서 CPU와 DMA만 memory에 접근할 수 있다.   7. 저장장치의 구조  저장장치 = 주기억장치 + 보조기억장치 주기억장치 = 메모리 = RAM with 휘발성(volatile) 보조기억장치 = 마그네틱 디스크 with 비휘발성(non-volatile)  ex) 마그네틱 디스크(하드디스크), 플래시 메모리, CD, 마그네틱 테이프 보조기억장치의 용도 = file system용 + swap area용  file system용:  비휘발성 성질을 이용하여 전원이 나가도 유지해야할 정보를 파일형태로 저장하는 용도   swap area용:  메모리 한계로 메모리 연장 용도로 사용. 프로그램 수행에 필요한 부분만 메모리에 올려놓고(process), 그렇지 않은 부분은 swap area에 내려놓는다. swap area에 내려놓는 일을 swap out(스왑 아웃) 이라 한다. 비휘발성으로 사용되는 file system용과 구분       하드디스크의 물리적 구조  여러 개의 마그네틱 원판들이 회전축에 붙어있고, 원판의 표면은 track으로 나눠지고, 각 track은 sector로 나눠지며, 이 sector에 최소한의 단위 정보가 저장된다. Arm assembly에 연결된 arm이 움직이면서 head가 저장된 데이터를 읽고 쓴다.     8. 저장장치의 계층 구조  컴퓨터 시스템의 저장장치 계층 구조는 다음과 같다.  위로 올라갈수록 속도는 빨라지고, 가격은 비싸지고, 용량은 적어진다.     저장장치 = Primary(주기억장치) + Secondary(보조기억장치) Primary  적은 용량, 빠른 속도, 비싼 가격  CPU는 한 clock 당 한 instruction이 걸리지만, Main memory는 10 clock 당 한 instruction이 걸린다. 그래서 그 중간의 완충으로 cache memory를 둔다.   당장 필요한 정보 구성: 휘발성 저장장치로 구성되어, 전원이 나가면 그 내용이 사라진다.  최상위 CPU 내부에 존재하는 register부터 cache memory, main memory 등     Secondary  많은 용량, 느린 속도, 저렴한 가격 당장 필요하지 않은 정보 구성: 비휘발성 저장장치로 구성되어, 전원이 나가도 지워지지 않는다.   Caching: copying information into faster storage system  상대적으로 용량이 적은 빠른 저장장치를 이용해 느린 저장장치의 성능을 향상시키는 총체적인 기법 상대적으로 ‘느린 저장장치’ 에 있는 내용 중 당장 필요한 것만 ‘빠른 저장장치’ 에 선별적으로 저장 하여 두 저장장치의 속도를 완충시킨다. 프로그램을 구성하는 모든 부분이 균일하게 사용되는 게 아니라, 일부분만 집중적으로 사용되기 때문에 적은 용량으로도 효과를 거둔다.    9. 하드웨어의 보안  하드웨어의 보안이 필요한 이유??  OS는 multi-programming 환경에서 동작하기 때문에, 프로그램 간에 충돌이나, 다른 프로그램의 실행을 방해할 수 있기 때문.   Solution: 보조 장치 Mode bit 사용  Mode bit 을 통해 하드웨어적으로 두 가지 모드의 operation 지원 Mode bit == 0: kernel mode  운영체제가 CPU를 수행하는 mode 모든 종류의 명령 실행 가능 보안을 해칠 수 있는 중요 명령어는 특권명령 으로 규정 모든 I/O 명령은 특권명령이므로, kernel mode에서 실행 interrupt가 들어오면 mode bit는 0으로 setting   Mode bit == 1: user mode  사용자 프로그램이 CPU를 수행하는 mode 자신의 메모리 영역 주소만 보고 수행하여, 모든 기계어 실행을 막는다. 사용자가 무한 루프로 CPU를 사용할 경우에도 timer가 있기 때문에 CPU 독점 사용 방지가능 운영체제가 CPU 제어권을 사용자 프로그램에게 넘길 때 mode bit를 1로 세팅하여 넘긴다.     전환 mechanism  CPU는 보안 관련 명령을 수행하기 전에는 항상 mode bit가 0인지 확인한다. 입출력 명령도 보안 관련 명령이므로, 사용자 프로그램이 입출력을 직접 할 수 없고, 운영체제가 한다. 그래서, 사용자 프로그램이 입출력을 하고 싶으면 sw interrupt인 system call을 CPU에 걸어서 운영체제가 CPU를 할당 받고, interrupt vector가 가리키는 위치를 통해 interrupt service routine으로 이동한다. sw interrupt를 거는 순간 mode bit 는 1에서 0으로 세팅되어 입출력 명령을 수행할 수 있다.     10. 메모리 보안  메모리 보안이 필요한 이유??  메모리에 여러 프로그램들이 동시에 올라와 실행되기 때문에, 한 사용자 프로그램이 다른 사용자 프로그램이나 운영체제가 위치한 메모리 영역을 침범할 수 있기 때문이다. 그래서 프로세스가 합법적인 메모리 범위에 있는지 체크하는 방법을 사용한다.   Solution: 기준 레지스터(base register) + 한계 레지스터(limit register)  기준 레지스터(base register)  어떤 프로그램이 수행하는 동안 그 프로그램이 합법적으로 접근할 수 있는 메모리 상의 가장 작은 주소를 보관한다.   한계 레지스터(limit register)  프로그램이 기준 레지스터값부터 접근할 수 있는 메모리의 범위를 보관     이 Solution을 어떻게 사용하는가???  사용자 프로그램이 base register + limit register 값을 벗어나는 주소에 접근하면 불법적인 메모리 접근이므로, SW interrupt인 exception을 발생시킨다. 그래서 CPU의 제어권을 해당 프로그램으로부터 운영체제로 이양시키고, 예외상황을 발생시킨 프로그램을 강제로 종료시킨다.   메모리 보안에서 특권명령  기준 레지스터와 한계 레지스터의 값을 세팅하는 연산은 특권명령으로 규정. 메모리 접근 연산은 사용자 프로그램이 CPU를 가지고 있는 동안 수행되므로 특권명령이 아니다.   kernel mode와 user mode의 메모리 접근 차이  kernel mode: 메모리에 무제한 접근 가능 user mode: base register와 limit register를 사용해서 메모리를 보호     11. CPU 보호  CPU의 독점 사용을 방지하기 위해 Timer(타이머) 라는 하드웨어를 사용한다.  사용자 프로그램이 CPU를 보유하고 있다가 정해진 시간이 흐른 뒤, 운영체제에게 제어권이 넘어가도록 interrupt를 발생시키는 하드웨어 매 clock tick 때마다 1씩 감소하다가, 0이 되면 interrupt가 발생한다.   timer의 값을 setting하는 명령을 load timer 라 하며, 특권 명령 이다. timer는 시분할 시스템을 구현하기 위해서도 사용된다.   12. 시스템 콜을 이용한 입출력 수행  모든 입출력(I/O) 명령은 특권 명령(kernel 영역)에 해당한다. 그러면 사용자 프로그램은 어떻게 I/O를 하는가??  system call이라는 SW interrupt를 사용하여 운영체제에게 I/O 서비스 대행 요청을 한다. 그러면 제어권이 사용자 프로그램에서 운영체제로 넘어간다. 그리고, 운영체제는 인터럽트 처리 루틴을 실행한다. 입출력 완료 시, 제어권을 사용자 프로그램에게 넘긴다.     Reference  운영체제와 정보기술의 원리 kocw 이화여자대학교 운영체제 - 반효경 교수 -  ","permalink":"http://jeha00.github.io/post/os/os_chapter_03_%EC%BB%B4%ED%93%A8%ED%84%B0%EC%8B%9C%EC%8A%A4%ED%85%9C%EC%9D%98%EB%8F%99%EC%9E%91%EC%9B%90%EB%A6%AC_2/","summary":"입출력 구조, DMA, 저장장치의 구조 그리고 계층구조에 대해 알아본다. 또한, 하드웨어, 메모리, CPU의 각 보안 방법에 대해 알아본다.","title":"[TIL] OS Chapter 03: 컴퓨터 시스템의 동작원리 2"},{"content":"0. Introduction  해당 내용은 운영체제와 정보기술의 원리 -반효경 지음- 와 kocw 이화여자대학교 운영체제 - 반효경 교수 -를 보고 정리한 내용입니다. 정확하지 않은 내용이 있다면 말씀해주시면 감사하겠습니다.   1. 컴퓨터 시스템의 구조 1.1 컴퓨터의 구조: 내부장치와 외부장치  컴퓨터 시스템의 구조 = 컴퓨터 내부장치 + 컴퓨터 외부장치  컴퓨터 내부장치 : CPU, Memory가 존재 컴퓨터 외부장치 : Disk, keyboard, mouse, monitor, network device 등    1.2 컴퓨터의 업무 처리 방식  컴퓨터 외부장치에서 내부장치로 데이터를 읽어와 각종 연산을 수행한 후, 연산 결과를 외부장치로 다시 내보내는 방식으로 업무를 처리한다. 이때, 업무의 각 부분을 다음과 같이 정의한다.  입력(input): 컴퓨터 내부로 데이터가 들어오는 것 출력(output): 컴퓨터 외부장치로 데이터가 나가는 것  입출력(Input-output: I/O): 컴퓨터 시스템이 컴퓨터 외부 입출력 장치들과 데이터를 주고 받는 것   예시)  키보드로부터 입력을 받아 컴퓨터가 연산을 한 후, 그 결과를 모니터에 출력 컴퓨터 외부장치인 디스크에서 내용을 읽어 컴퓨터 내부에 연산을 한 후, 디스크에 데이터를 저장.      1.3 Controller: 각 하드웨어 장치의 작은 CPU  컴퓨터 전체에 CPU(Cetnral Processing Unit)라는 중앙처리장치가 있듯이, 컴퓨터의 각 하드웨어 장치에는 이들을 제어하는 일종의 작은 CPU인 컨트롤러 가 있다. 예)  메모리를 제어하는 컨트롤러는 메모리 컨트롤러 디스크를 제어하는 컨트롤러는 디스크 컨트롤러     2. CPU 연산과 I/O 연산 2.1 연산 = CPU가 무언가를 한다  컴퓨터에서 연산을 한다 = CPU가 무언가 일을 한다 컴퓨터의 구성장치 관점에서 연산을 나눠 보자면 다음과 같이 담당한다.  입출력 장치들의 I/O 연산 → 입출력 컨트롤러가 담당 컴퓨터 내에서 수행되는 연산 → main CPU 이 때 입출력 장치와 main CPU는 일이 다른 곳에서 발생하므로 동시 수행이 가능하다.    2.2 Local Buffer(로컬 버퍼)  각 장치 컨트롤러는 장치로부터 오고 나가는 데이터를 임시 저장 하기 위한 작은 메모리인 로컬 버퍼(local buffer) 가 존재한다. 입력 장치로부터 데이터를 읽어오는 경우, 각 입력장치의 컨트롤러가 장치에서 로컬버퍼로 데이터를 읽어와서 저장 후, 컴퓨터 내부의 메모리에 전달한다.  2.3 CPU와 I/O 장치의 연산과정   프로그램에서 데이터를 읽어오라는 명령을 내린다 →\n  각 장치의 컨트롤러가 장치로부터 내용을 읽어 로컬버퍼에 저장한다 →\n  데이터를 읽는 작업을 완료했기 때문에, 메인 CPU에서 다음 일을 수행이 가능하다. HW 또는 SW는 CPU 옆에 인터룹트 라인(interrup line) 을 세팅하는 명령을 실행하여, 컨트롤러가 인터룹트(interrupt) 를 발생시켜 메인 CPU에 완료를 알린다 →\n  CPU는 명령 하나를 수행할 때마다 인터룹트가 발생했는지 확인한다. →\n  인터럽트가 발생하면 자신이 하던 일을 멈추고, 인터럽트 처리를 먼저 한 후 명령을 다시 수행.\n   3. 인터럽트의 일반적 기능 3.1 Interrupt(인터럽트)란??   인터럽트(Interrupt)란 CPU의 제어권을 양도하라는 신호\n  사용자 프로그램에게 CPU 제어권이 있어서, CPU를 사용하고 있다가 interrupt를 발생시키면 운영체제 코드 부분으로 CPU가 이양된다.\n  오늘날 운영체제가 CPU를 점유하는 건 인터럽트에 의하지 않고는 발생하지 않는다.\n 운영체제는 단지 인터럽트가 발생할 때에만 CPU의 제어권을 획득할 수 있는데, 인터럽트가 발생하지 않으면 사용자 프로그램이 계속 CPU를 점유한다.    3.2 인터럽트 처리루틴이란???  인터럽트 당한 시점의 레지스터와 program counter를 저장한 후, CPU 제어를 인터럽트 처리 루틴에 넘긴다. 인터럽트 처리루틴(Interrupt Service Routine) 이란?  해당 인터럽트를 처리하는 커널 함수 인터럽트 핸들러(interrupt handler) 라고도 한다. 다양한 controller가 있는 만큼 interrupt의 종류도 다양하다. 그러므로 인터럽트 처리루틴의 종류도 다양하다.   인터럽트 벡터(interrupt vector)  해당 인터럽트의 처리 루틴 주소를 가리킨다.   인터럽트 처리루틴까지의 과정  컨트롤러가 인터럽트를 발생시키면 CPU는 인터럽트 라인을 통해 인터럽트 발생을 확인하고, 자신이 하던 일을 멈춘다.\n-\u0026gt; 프로그램의 실행 상태를 PCB에 저장한 후, CPU의 제어권은 프로세스에서 운영체제로 넘어간다.\n-\u0026gt; 그리고, 운영체제는 interrupt vector가 가리키는 곳으로 가서 인터럽트 처리루틴을 찾는다.\n-\u0026gt; 인터럽트 처리루틴을 통해 해당하는 인터럽트 처리를 완료하고 나면, CPU는 PCB로부터 CPU 상에 복원하여 인터럽트 당하기 직전의 위치부터 계속 수행.    3.3 Iterrupt line  특정 프로그램이 CPU를 독점하는 걸 방지하기 위해서 timer라는 hw를 사용하여, timer의 시간이 다 되면 interrupt line 을 통해 interrupt를 건다. 또한, controller가 I/O 작업을 완료하면 interrupt line을 통해 interrupt를 건다.  3.4 인터럽트의 종류: HW interrupt 와 SW interrupt  Interrupt = HW interrupt + SW interrupt HW interrupt  HW가 발생시킨 인터럽트 hw 일꾼들이 CPU와 정보 교신을 위해서 거는 것 하드웨어 장치가 CPU의 interrupt line을 세팅한다. 통상적으로 불리는 interrupt의 의미가 HW interrupt다.   SW interrupt (트랩(trap))  사용자 프로그램이 운영체제에게 대행해달라고 요청하는 것 소프트웨어가 CPU의 interrupt line을 세팅한다. Trap의 종류: 예외 상황(exception) 과 시스템 콜(system call)   HW interrupt와 SW interrupt의 공통점  CPU 옆에 있는 인터럽트 라인에 신호를 보내 인터럽트 발생유무를 알리는 방식은 동일.    3.5 Trap: exception 과 system call  예외 상황(exception)  비정상적인 작업 또는, 권한이 없는 작업을 시도할 때, 이에 대한 처리를 위해 발생시키는 인터럽트  비정상적인 작업의 예: 사용자 프로그램이 0으로 나누는 연산을 실행 권한이 없는 작업의 예: 사용자 프로그램이 자신의 메모리 영역 바깥에 접근하려는 시도     시스템 콜(system call)  사용자 프로그램이 운영체제 내부에 정의된 코드를 실행할 때, 운영체제에 서비스를 요청하는 방법 사용자 프로그램 자신의 코드는 사용자 프로그램이 CPU에 대한 제어권을 가지고 실행한다. 하지만, 커널 내부에 있는 코드를 사용자 프로그램이 실행하고자 할 때는 사용자 프로그램이 직접 접근할 수 있는 게 아니라, system call을 통해서 대행 요청 을 한다. system call 요청을 interrupt line 을 통해 CPU 제어권을 운영체제로 넘겨 커널 내부 코드를 실행한다.     4. 인터럽트 핸들링(Interrupt handling) 4.1 Interrupt handling 이란??  Interrupt handling: 인터럽트가 발생한 경우에 처리해야할 일의 절차 프로그램 A가 실행되고 있을 때, 인터럽트가 발생하면 프로그램 A의 현재 상태를 먼저 저장 한다.  현재 상태란 현재 CPU에서 실행 중인 명령의 메모리 주소를 포함해 몇 가지 부가적인 정보들을 의미한다.   현재 상태를 먼저 저장하는 이유는??  CPU에서 명령이 실행될 때 CPU 내부에 있는 임시 기억장치인 레지스터(register)에 데이터를 읽거나 쓰면서 작업을 한다. 그런데, 인터럽트가 발생해 새로운 명령을 실행하면 기존의 레지스터 값들이 지워지므로 , CPU 내의 이러한 상태를 저장해둬야 한다.    4.2 PCB(Process Control Block)이란??  OS가 현재 시스템 내에서 실행되는 프로그램들을 관리하기 위해 둔 자료구조를 PCB(Process Control Block, 프로세스 제어 블록) 라 한다. PCB 는  각각의 프로그램마다 하나씩 존재 한다. 해당 프로그램의 어느 부분이 실행 중이었는지를 저장 한다. ex) 코드의 메모리 주소, 레지스터값, 하드웨어 상태 등   PCB 사용절차  Interrupt 발생 → CPU의 제어권을 넘기기 전에 프로그램의 실행 상태를 PCB에 저장 → CPU의 제어권이 OS로 넘어간다 → 운영체제는 인터럽트 벡터가 가리키는 곳으로 가서 인터럽트 처리루틴에 따라 인터럽트 처리를 수행→ 인터럽트 처리 완료 → 저장된 상태를 PCB로부터 CPU 상에 복원 → 인터럽트 당하기 직전 위치부터 재실행     Reference  운영체제와 정보기술의 원리 kocw 이화여자대학교 운영체제 - 반효경 교수 -  ","permalink":"http://jeha00.github.io/post/os/os_chapter_03_%EC%BB%B4%ED%93%A8%ED%84%B0%EC%8B%9C%EC%8A%A4%ED%85%9C%EC%9D%98%EB%8F%99%EC%9E%91%EC%9B%90%EB%A6%AC_1/","summary":"I/O 연산이 무엇이고, controller와 local buffer가 무엇이고, 입출력 연산이 Interrupt를 중심으로 어떻게 진행되는지를 알아본다.","title":"[TIL] OS Chapter 03: 컴퓨터 시스템의 동작원리 1"},{"content":"1. Context Manager란?  원하는 타이밍에 정확하게 resource를 할당 및 제공하며, 반환하는 역할을 한다.\n그래서, special method .__enter__ 와 .__exit__을 가지고 있는 객체를 말한다.\n 1.1 Context Manager가 필요한 이유???  외부와 connection될 때, 한정된 H/W resource를 사용하기 때문에, resource가 제 때 반환되지 않으면 system이 느려지거나 특정 상황에서 error가 발생할 수 있다. 즉, 문을 열고 들어갔으면 문을 닫아야 하고, 도서관에서 책을 빌리면 책을 반납해야 하듯이 memory resource 또한 사용되면 반환되야 한다. 그래서 원하는 시점에 resource 할당 및 회수를 위해서 context manager가 중요하다. 이러한 특징으로 외부 resource를 처리하는 작업을 할 때, 안전하게 할 수 있는 기능을 만들 수 있다.  1.2 Context Manager의 magic method   What is a \u0026ldquo;runtime context?\u0026quot; stackoverflow 내용을 덧붙인다.\n with statement 아래의 code block에 들어가기 위해서 .__enter__ special method가 호출된다. with statement 아래의 code block에서 나가기 위해서 .__exit__ special method가 호출된다.    Python docs: Context Manager Types의 내용을 추가한다.\n  context manager는 context manager 자체를 반환하는데 이것의 example 중 하나는 file object다.\n  file obejct는 open() function이 with statement 에서 사용되기 위해 __enter__ 로부터 file object 자신들을 반환한다.\n  .__enter__() magic method에 의해 반환된 값은 with statement의 as 절의 식별자(identifier)에 연결된다.\n  .__exit__(exc_type, exc_val, exc_tb) 은 runtime context를 빠져나오고, 발생한 exception을 무시해야하는지를 가리키는 boolean flag를 반환한다.\n with 문의 body를 실행하는 동안 예외가 발생하면 예외 타입, 값, 추적정보가 포함된다. 이 method에서 True를 반환하면, with문이 예외를 막고 계속해서 실행한다.        Context manager의 대표적인 구문인 with를 이해해야한다.\n with문에 관한 내용은 [TIL] Python basic 20: with open as 와 [TIL] Python basic 21: csv.read, write을 참고한다.     2. Context manager: no use \u0026lsquo;with\u0026rsquo; \u0026gt; file = open(\u0026#39;./testfile1.txt\u0026#39;, \u0026#39;w\u0026#39;) # 파일을 열고 \u0026gt; try: \u0026gt; file.write(\u0026#39;Context Manager Test1.\\nContextlib Test1.\u0026#39;) # 파일을 닫는다. \u0026gt; finally: \u0026gt; file.close()  python이 업데이트 되어 나온게 with문이다.   3. Context manager: use \u0026lsquo;with\u0026rsquo;  위에 no use \u0026lsquo;with\u0026rsquo; 에서의 코드가 with를 사용해서 다음 code로 바뀐다. close를 입력하지 않아도, 자동으로 반환한다. 그래서 이 with문으로 Internet connection을 맺고 끊는 것으로 사용할 수 있다.  \u0026gt; with open(\u0026#39;testfile1.txt\u0026#39;, \u0026#39;w\u0026#39;) as f: \u0026gt; f.write(\u0026#39;Context Manager Test1.\\nContextlib Test1.\u0026#39;)  위 코드의 결과로 testfile2.txt 가 생성되고, 그 안에는 Context Manager Test2. \\nContextlib Test2. 가 작성되어 있다.   4. Context manager: use \u0026lsquo;class\u0026rsquo;  magic method를 사용하여 class로 customizing 한 후, with문을 실행해보자. with문을 실행하면 magic method는 이와 같은 순서로 실행된다.  __init__ -\u0026gt; __enter__가 실행된다. 실행된 결과로 어느 값이 반환되고, 이 반환 값으로 write 작업을 실행한다. write 작업이 완료 후, 빠져나갈 때 error가 발생되면 __exit__의 print에서 처리되고, close()가 실행된다.    \u0026gt; class FileWriter(): \u0026gt; def __init__(self, file_name, method): \u0026gt; print(\u0026#39;FileWriter started : __init__\u0026#39;) \u0026gt; self.file_obj = open(file_name, method) \u0026gt; def __enter__(self): \u0026gt; print(\u0026#39;MyfilerWriter started : __enter__\u0026#39;) \u0026gt; return self.file_obj \u0026gt; def __exit__(self, exc_type, value, trace_back): \u0026gt; print(\u0026#39;FileWriter started : __exit__\u0026#39;) \u0026gt; if exc_type: \u0026gt; print(\u0026#39;Logging exception {}\u0026#39;.format(exc_type, value, trace_back)) \u0026gt; self.file_obj.close() \u0026gt; with FileWriter(\u0026#39;testfile1.txt\u0026#39;, \u0026#39;w\u0026#39;) as f: \u0026gt; f.write(\u0026#39;Context Manager Text1.\\nContextlib Test1\u0026#39;) FileWriter started : __init__ FileWriter started : __enter__ FileWriter started : __exit__ # 그리고 testfile3.txt가 생성된다.  5. Context manager: Measure execution  Github에서 많이들 제작하는 timer다. 이 timer로 with문이 걸린 시간을 알 수 있다.  \u0026gt; class Timer(object): \u0026gt; def __init__(self,msg): \u0026gt; delf._msg = msg \u0026gt; def __enter__(self): # 시간을 숫자형태로 가져와서, self의 start 변수에 저장한다. \u0026gt; self._start = time.monotonic() \u0026gt; return self._start \u0026gt; def __exit__(self, exc_type, exc_value, exc_traceback): \u0026gt; if exc_type: \u0026gt; print(\u0026#34;Logging exception {}\u0026#34;.format(exc_type, exc_value, exc_traceback)) \u0026gt; else: \u0026gt; print(\u0026#39;{} : {}s\u0026#39;.format(self._msg, time.monotonic() - self._start)) # with문을 잘 빠져나왔다는 의미 \u0026gt; return True \u0026gt; with Timer(\u0026#34;Start!\u0026#34;) as j: \u0026gt; print(\u0026#39;Received start monotonic1 : {}\u0026#39;.format(v)) # self._start가 v에 연결된 걸 확인했다. Received start monotonic1 : 590914.968 # else문이 실행된 결과 Start! job: 0.35999999998603016 s  6. Context manager: use \u0026lsquo;decorator\u0026rsquo;  contextlibary를 annotation을 사용하여 class 형태가 아닌 함수 형태로 구현해본다. 코드의 line을 줄일 수 있고, 직관적으로 코드를 작성할 수 있다. class로 context manager를 구현하는 것보다 확실히 간결하다. 하지만, \u0026lsquo;예외 처리\u0026rsquo;를 꼼꼼히 정석대로 할려면 class로 구현하는 게 낫다.  \u0026gt; import contextlib \u0026gt; import time # annotation \u0026gt; @contextlib.contextmanger \u0026gt; def writer(file_name, method): \u0026gt; f = open(file_name, method) # __enter__ \u0026gt; yield f # __exit__ \u0026gt; f.close() # yield된 f가 with문의 alias f와 연결된다. \u0026gt; with writer(\u0026#39;testfile1.txt\u0026#39;, \u0026#39;w\u0026#39;) as f: \u0026gt; f.write(\u0026#39;Context manager Test4.\\nContextlib test4\u0026#39;)  마지막 예제로 decorator를 사용하여 timer를 만들어보자.  \u0026gt; @contextlib.contextmanager \u0026gt; def Timer(msg): \u0026gt; start = time.monotonic() # __enter__ \u0026gt; try: \u0026gt; yield start \u0026gt; except BaseException as e: \u0026gt; print(\u0026#39;Logging exception {} : {}\u0026#39;.format(msg, e)) \u0026gt; raise # __exit__ \u0026gt; else: \u0026gt; print(\u0026#39;{} : {} s\u0026#39;.format(msg, time.monotonic() - start)) \u0026gt; with Timer(\u0026#34;Start!\u0026#34;) as v: \u0026gt; print(\u0026#39;Received start monotonic2 : {}\u0026#39;.format(v)) Received start monotonic2 : 594934.0 Start! : 0.42099999997299165 s  Reference  모두를 위한 파이썬 : 필수 문법 배우기 Feat. 오픈소스 패키지 배포 (Inflearn Original) [TIL] Python basic 20: with open as [TIL] Python basic 21: csv.read, write What is a \u0026ldquo;runtime context?\u0026quot; Python docs: Context Manager Types  ","permalink":"http://jeha00.github.io/post/python_basic/python_basic_42_contextmanager/","summary":"context manager가 무엇이고, 이를 with, class, decorator를 사용하여 여러 방법으로 구현해본다.","title":"[TIL] Python basic 42: Context manager"},{"content":"Intro  [TIL] Python basic 29: Data Model에서 간단히 다뤘던 shallow copy와 deep copy에 대해 깊이 알아보자.   shallow copy와 deep copy는 모든 분야에 통틀어 알고 있어야 하는 지식이다. Python은 모든 걸 객체취급하는데, 이 객체의 복사를 수행하는 명령어가 copy 명령어다.  어느 수준까지 복사가 되는 지에 따라 copy, shallow 그리고 deep copy로 나눠진다. 각 copy에 대해 정확히 이해한 후, 프로그램 개발에 사용해야 문제가 발생하지 않고, 디버깅의 방해 요소가 되지 않는다. 또한, 구현하려는 목적에 맞게 이 3가지 copy 방식을 구분해서 사용해야 한다.     1. Copy # mutable data type \u0026gt; a_list = [1, 2, 3, [4, 5, 6], [7, 8, 9]] # call by reference \u0026gt; b_list = a_list # 동일한 id가 출력된다. \u0026gt; print(id(a_list), id(b_list)) 2230595359488 2230595359488 \u0026gt; print(id(a_list) == id(b_list)) True # b_list를 수정해보자. \u0026gt; b_list[2] = 100 # b_list만 수정했지만, 어째서인지 a_list까지 수정되었다. \u0026gt; print(a_list) [1, 2, 100, [4, 5, 6], [7, 8, 9]] \u0026gt; print(b_list) [1, 2, 100, [4, 5, 6], [7, 8, 9]] # b_list를 다시 수정해보자. \u0026gt; b_list[3][2] = 100 \u0026gt; print(a_list, b_list) [1, 2, 100, [4, 5, 100], [7, 8, 9]] \u0026gt; print(a_list, b_list) [1, 2, 100, [4, 5, 100], [7, 8, 9]]  일반적인 copy 방식으로 call by reference 방식이다. 동일한 reference를 참조하기 때문에, b_list의 성분만을 수정했지만 a_list 까지 수정되었다.   2. Shallow Copy  중첩 data는 수정된다.\n   shallow copy는 위에 일반 copy와 달리 copy module을 import 해야 한다.\n\u0026gt; c_list = [1, 2, 3, [4, 5, 6], [7, 8, 9]] \u0026gt; d_list = copy.copy(c_list) # 위에 call by reference로 복사한 것과 달리 id 값이 다른 걸 확인할 수 있다. \u0026gt; print(id(c_list), id(d_list)) 1892474493824 1892474493568 # d_list 수정 \u0026gt; d_list[1] = 100 # c_list는 수정되지 않았다. \u0026gt; print(\u0026#39;c_list \u0026gt; \u0026#39;, c_list) c_list \u0026gt; [1, 2, 3, [4, 5, 6], [7, 8, 9]] # d_list만 수정되었다. \u0026gt; print(\u0026#39;d_list \u0026gt; \u0026#39;, d_list) d_list \u0026gt; [1, 100, 3, [4, 5, 6], [7, 8, 9]]   여기까지만 보면 왜 shallow copy인지 이해가 안갈 것이다.\n  왜냐하면 d_list를 수정해도 c_list가 수정되지 않기 때문이다.\n  그러면 list 안에 list 성분을 수정해보자.\n\u0026gt; d_list[3].append(1000) \u0026gt; d_list[4][1] = 10000 # d_list만 시도했지만, c_list까지 중첩 data가 수정되었다. \u0026gt; print(\u0026#39;c_list \u0026gt; \u0026#39;, c_list) [1, 2, 3, [4, 5, 6, 1000], [7, 10000, 9]] \u0026gt; print(\u0026#39;d_list \u0026gt; \u0026#39;, d_list) [1, 100, 3, [4, 5, 6, 1000], [7, 10000, 9]]   mutable 안에 중첩 data는 동일한 reference를 참조한다는 걸 알 수 있다.\n  이를 id function으로 확인해보자.\n\u0026gt; print(\u0026#39;nested data - \u0026#39;,id(c_list[3]), id(d_list[3])) nested data - 2343545032000 2343545032000 \u0026gt; print(\u0026#39;c_list \u0026gt; \u0026#39;, id(c_list)) c_list \u0026gt; 2636124593152 \u0026gt; print(\u0026#39;d_list \u0026gt; \u0026#39;, id(d_list)) d_list \u0026gt; 2636124592896   중첩된 data 까지는 독립된 reference를 가지지 않는 걸 확인했다.\n   3. Deep Copy  중첩된 data까지 독립된 id를 가진다.\n   Deep copy도 copy module을 import 하는 것부터 시작한다.\n  shallow copy는 중첩 성분을 포함하는 객체만 복사하는 방식이면, deep copy는 중첩 성분까지 복사한다.\n  그래서 deep copy를 깊은 복사 말고, 전체 복사라고도 한다.\n\u0026gt; c_list = [1, 2, 3, [4, 5, 6], [7, 8, 9]] \u0026gt; d_list = copy.deepcopy(c_list) # 다른 id 값을 확인할 수 있다. \u0026gt; print(\u0026#39;Ex3 \u0026gt; \u0026#39;, id(c_list)) Ex3 \u0026gt; 2636124592960 \u0026gt; print(\u0026#39;Ex3 \u0026gt; \u0026#39;, id(d_list)) Ex3 \u0026gt; 2636124593408 # 내장된 data도 독립된 id값을 가진 걸 확인할 수 있다. \u0026gt; print(\u0026#39;nested data \u0026gt; \u0026#39;, id(c_list[3])) nested data \u0026gt; 1329303493056 \u0026gt; print(\u0026#39;nested data \u0026gt; \u0026#39;, id(d_list[3])) nested data \u0026gt; 1329303494272    4. Summary   다음 image로 shallow copy와 deep copy 복사 정도를 비교하면 쉽게 알 수 있다.\n  같은 색상의 block이 동일한 id를 가지고 있다.\n  shallow copy는 객체만을 복사하고, 객체의 성분은 복사하지 않는다.\n 객체는 call by value, 객체의 성분은 call by reference    하지만, deep copy는 객체와 객체의 성분까지 복사한다.\n 객체와 객체의 성분도 call by value    shallow copy   deep copy\n   Reference  모두를 위한 파이썬 : 필수 문법 배우기 Feat. 오픈소스 패키지 배포 (Inflearn Original) [TIL] Python basic 29: Data Model  ","permalink":"http://jeha00.github.io/post/python_basic/python_basic_41_shallowdeepcopy/","summary":"Shallow copy 와 Deep copy가 각각 무엇이고, 무슨 차이인지 알아본다.","title":"[TIL] Python basic 41: Shallow copy \u0026 Deep copy"},{"content":"Intro  python의 변수를 만드는 원리와 호출 방식에 대해 알아보자.   1. Object reference  파이썬의 변수들은 객체에 대한 참조들이다.\n   컴퓨터 프로그램에서 사용되는 한 물리적인 메모리 위치를 나타내는 상징적으로 나타내는 이름이 변수 다.\n 이 변수에는 여러 가지 data type들이 담겨질 수 있으니, container 로 생각하자. program이 실행되는 동안, 이 변수에 접근할 수 있고, 변경할 수도 있다.    하지만, 변수를 만드는 원리가 C,C++, JAVA 와 Python에는 차이가 있다.\n  C,C++, JAVA 의 예\n 먼저 변수 이름을 아래와 같이 선언한다.    \u0026gt; int x \u0026gt; int y   위 코드를 그림으로 표현하면 다음과 같다.\n   그리고 나서 변수들에 값을 할당한다. 할당하는 건 =을 사용한다.  \u0026gt; x = 42 \u0026gt; y = 78   위 코드를 그림으로 표현하면 다음과 같다.\n  변수를 할당할 때는 처음에 int로 정했기 때문에, integer type만 할당할 수 있다.\n   다음으로 Python에서의 variable을 알아보자.  파이썬에서는 선언하는 게 필요 없고, 바로 변수의 이름과 이 변수에 할당할 data type과 value만 정하면 된다.     파이썬의 변수들은 객체들을 가리키고, 객체들은 임의의 data type을 가질 수 있다. 실제 데이터는 객체들 안에 포함되어 있다.\n \u0026gt; x = 42   아래 이미지는 파이썬에서 x = 42를 그림으로 구현할 것이다.\n  \u0026gt; y = x   아래 이미지는 파이썬에서 y = x를 그림으로 구현할 것이다.\n   2. Call by object reference   python은 공식문서에 따르면 call by object reference 방식으로 호출한다.\n  call by value 와 call by reference 의 중간 방식인데, 인수의 data type에 따라 달라진다.\n 값에 의한 호출(call by value): immutable object 참조에 의한 호출(call by reference): mutable object    각 방식에 대해 code로 구현해보자.\n  data type에 따라 id 값이 변하는 것과 변하지 않는 것에 대한 설명은 [TIL] Python basic 29: Data Model를 참조한다.\n  2.1 Call by value  실제 인수의 값을 매개변수에 복사하는 방식이다. 값에 의한 호출 이라 한다. 변수에 할당된 값만을 복사해서 함수의 인자로 넘긴다. 파이썬은 immutable object일 때 이 방식을 사용한다.  \u0026gt; def foo(s): \u0026gt; print(id(s), s) \u0026gt; s += \u0026#34; is Best\u0026#34; \u0026gt; print(id(s),s) \u0026gt; return s \u0026gt; msg = \u0026#34;Python\u0026#34; \u0026gt; print(\u0026#39;msg = \u0026#39;, msg, id(msg)) msg = Python 2072884335536 \u0026gt; foo(msg) 2072884335536 Python 2072889254896 Python is Best \u0026gt; print(\u0026#39;msg = \u0026#39;, msg, id(msg)) msg = Python 2072884335536  msg에 할당된 값만을 복사해서 foo의 매개변수로 넘어간다. foo에서 처음 print가 실행되어 확인한 id 값은 동일하다. 하지만, value가 수정됨에 따라 참조 객체가 달라진다.  2.2 Call by reference  실제 인수의 참조를 매개변수에 복사하여, 매개변수가 실제 인수와 같아지는 방식이다. 참조에 의한 호출 이라 한다. 함수의 인자로 넘어간 값이 함수 내부에서 변경되면, 실제로 값이 변경된다. 파이썬은 mutable object일 때 이 방식을 사용한다. mutable object가 넘어갈 때, object reference가 넘어가기 때문에 값을 바꿀 수 있다.  \u0026gt; def foo(s): \u0026gt; print(s, id(s)) \u0026gt; s.append(10) \u0026gt; print(s, id(s)) \u0026gt; msg = [s for s in range(1,6)] \u0026gt; print(\u0026#39;msg = \u0026#39;, msg, id(msg)) msg = [1, 2, 3, 4, 5] 2211845893440 \u0026gt; foo(msg) [1, 2, 3, 4, 5] 1764496575680 [1, 2, 3, 4, 5, 10] 1764496575680 \u0026gt; print(\u0026#39;msg = \u0026#39;, msg, id(msg)) msg = [1, 2, 3, 4, 5, 10] 2211845893440  foo function에서 수정했지만, 그것이 global scope에서 출력 시에도 영향을 준다. 즉, 참조값이 수정된 걸 의미한다.   Reference  모두를 위한 파이썬 : 필수 문법 배우기 Feat. 오픈소스 패키지 배포 (Inflearn Original) [TIL] Python basic 29: Data Model Python tutorials Data type call-by-value, call-by-reference  ","permalink":"http://jeha00.github.io/post/python_basic/python_basic_40_callbyobjectreference/","summary":"python의 변수를 만드는 원리인 object reference에 대해 알아보고, 파이썬의 호출 방식인 call by object reference에 대해 알아본다.","title":"[TIL] Python basic 40: Call by object reference"},{"content":"Intro  [TIL] Python basic 31: First-class에서 학습한 고위 함수(High-Order Function)의 대표적인 예인 map, filter, reduce function에 대해 집중적으로 학습하기 위해 작성한다. 그래서 고위 함수(High-Order Function)란 무엇인지 간단히 알아보고, 각 fuction에 대해 기존에 했던 예제에 추가하여 더 알아보자.    High - Order Function (고위 함수)란??\n 함수들 중 인수로 전달 가능하고, 결과값으로서 반환 가능한 함수 일급 함수(first - class)의 특징이기도 한다.    이번 예에서 lambda function을 사용할 것이다.\n [TIL] Python basic 12: Method 에서 학습했으므로, 이를 참조한다.     1. Map   map(func, iterable)\n iterable에 있는 모든 요소에 지정한 function을 적용하여 결과를 iterator로 반환한다. return 된 객체는 map oject 다.    map의 인자로 넘어가는 function은 3가지 방식으로 구현해본다.\n lambda (Ex1-1) def (Ex1-2) closure (Ex1-3)    \u0026gt; digist1 = [x * 10 for x in range(1, 6)] \u0026gt; print(\u0026#39;Ex1 \u0026gt; \u0026#39;, digist1) Ex1 \u0026gt; [10, 20, 30, 40, 50] \u0026gt; result = map(lambda x: x ** 2, digist1) \u0026gt; print(\u0026#39;Ex1-1 lambda \u0026gt; \u0026#39;result) Ex1-1 lambda \u0026gt; \u0026lt;map object at 0x000002786FE62D90\u0026gt; # map object로 뜨기 때문에 type conversion을 한 후, result에 할당한다. # lambda를 사용했기 때문에, 메모리에 저장되지 않고 garbage collector에 의해서 제거된다. \u0026gt; result = list(map(lambda x: x ** 2, digist1)) \u0026gt; print(\u0026#39;Ex1-1 lambda \u0026gt; \u0026#39;result) Ex1-1 lambda \u0026gt; [100, 400, 900, 1600, 2500] # lambda로 구현한 함수를 선언형으로 해보자. \u0026gt; def ex2_func(x): \u0026gt; return x ** 2 \u0026gt; result = list(map(ex2_func, digist1)) \u0026gt; print(\u0026#39;Ex1-2 function \u0026gt; \u0026#39;, result) Ex1-2 function \u0026gt; [100, 400, 900, 1600, 2500] # closure를 통해서 선언해보자. \u0026gt; def also_square(nums): \u0026gt; def double(x): \u0026gt; return x * 2 \u0026gt; return map(double, nums) \u0026gt; print(\u0026#39;Ex1-3 Closure\u0026#39;, list(also_square(digist1))) Ex1-3 Closure \u0026gt; [20, 40, 60, 80, 100]  2. Filter   filter(func, iterable)\n iterable 중에서 function 조건에 True인 요소만 뽑아 새로운 시퀀스형으로 만드는 함수 return된 객체는 filter object 다.    filter의 인자로 넘어가는 function은 2가지 방식으로 구현해본다.\n lambda (Ex1-1) closure (Ex1-3)    # list comprehension으로 iterator를 만든다. \u0026gt; digist2 = [x for x in range(1, 6)] # 홀수만 출력한다. # lambda 사용 \u0026gt; result = list(filter(lambda x: x % 2, digist2)) \u0026gt; print(\u0026#39;Ex2-1 lambda \u0026gt; \u0026#39;, result) Ex2-1 lambda \u0026gt; [1, 3, 5] # closure 사용 \u0026gt; def odd(nums): \u0026gt; def is_oven(x): \u0026gt; return x % 2 \u0026gt; return filter(is_oven, nums) \u0026gt; print(\u0026#39;Ex2-2 closure\u0026#39;, odd(digist2)) Ex2-2 closure \u0026gt; [1, 3, 5]  3. Reduce   reduce(func, iterable)\n iterable의 요소를 왼쪽부터 오른쪽 방향으로 함수를 적용하여 하나의 값으로 합친다.    reduce는 built-in fuction이 아니기 때문에, 별도로 import를 해야 한다.\n from functools import reduce    reduce의 인자로 넘어가는 function은 2가지 방식으로 구현해본다.\n lambda (Ex1-1) closure (Ex1-3)    \u0026gt; from functools import reduce \u0026gt; digit3 = [x for x in range(1, 101)] # lambda 사용 \u0026gt; reduce = reduce(lambda x,y: x + y, digit3) \u0026gt; print(\u0026#39;Ex3 lambda \u0026gt; \u0026#39;, reduce) 5050 # closure 사용 \u0026gt; def also_add(nums): \u0026gt; def add_plus(x,y): \u0026gt; return x + y \u0026gt; return reduce(add_plus, nums) \u0026gt; print(\u0026#39;Ex3 Closure \u0026gt; \u0026#39;, also_add(digit3)) 5050  Reference  모두를 위한 파이썬 : 필수 문법 배우기 Feat. 오픈소스 패키지 배포 (Inflearn Original) [TIL] Python basic 31: First-class  ","permalink":"http://jeha00.github.io/post/python_basic/python_basic_39_mapfilterreduce/","summary":"High-order function의 대표적인 예인 map, filter, reduce에 대해 lambda, def, closure로 구현해본다.","title":"[TIL] Python basic 39: Map, Filter, Reduce"},{"content":"Intro  이번 내용은 파이썬 고급 과정 고수가 되는 파이썬 : 동시성과 병렬성 문법 배우기 Feat. 멀티스레딩 vs 멀티프로세싱 (Inflearn Original) 에서 자세히 배운다고 하여 깊이 있게 들어가진 않았다. 이런 게 있구나 정도로만 파악하자.   1. Synchronous VS Asynchronous   소제목에 있는 두 영단어는 접두어와 어원으로 분석하여 접근하면 쉽다.\n  syn는 \u0026lsquo;together\u0026rsquo;를, chrono는 \u0026lsquo;time\u0026rsquo;을 의미한다.\n  하지만 Asynchronous 는 접두어로 \u0026lsquo;a\u0026rsquo;가 붙었는데, 이는 부정의 의미를 가진다.\n  시간을 함께 맞추는 것 vs 시간을 함께 맞추지 않는 것의 의미로 해석할 수 있다.\n  Synchronous는 단어적 의미를 기반으로 바라보면 2가지 이상의 대상이 서로 시간을 맞춰 해동하는 걸 의미한다.\n A 작업이 끝난 후에야 B 작업이 시작되는 걸 말한다. 끝나고 나서 시작되는 것처럼 시간을 맞춘다.    Asynchronous는 서로 시간을 맞추지 않는 걸 의미한다.\n A에 작업을 조금 걸어넣고, B에도 조금 시작하여 동시성이 실행되는 걸 의미한다.     2. Blocking vs Non-Blocking   Blocking이란 직접 제어할 수 없는 대상의 작업이 끝날 때까지 제어권을 넘겨주지 않는 걸 말한다.\n 예) 호출 함수가 I/O 을 요청했을 때, 이 요청이 완료될까지 아무 일도 하지 못한 채 기다리는 걸 말한다.    Non-blocking이란 non이 붙여졌듯이 blocking의 반대 의미다.\n  요청이 완료될 때까지 기다릴 필요 없이 바로 자신의 작업을 할 수 있는 상태를 말한다.\n  blocking 현상으로 CPU 및 resource 낭비를 하고 있을 때, 동시성 활용 작업으로 낭비를 방지한다.\n  파이썬은 단일 쓰레드로 해도 충분히 빠르다.\n  특히, 비동기 작업과 적합한 프로그램일 경우, 압도적으로 성능이 향상된다.\n   3. GIL(Global Interface Lock)   GIL은 Python에만 존재하는 것으로, Global Interface Lock in CPython을 의미한다.\n  GIL은 두 개 이상의 thread가 동시에 실행될 때(context switching 상황) 하나의 자원에 액세스하는 경우, 문제점을 방지하기 위해 GIL을 실행하여 resource 전체에 lock을 건다.\n  그래서 multi-thread할 때, GIL 때문에 single-thread보다 느린 경우가 많다.\n  GIL을 우회하기 위해서는 반드시 multi-processing을 사용하거나 CPython을 사용하면 GIL이 걸리지 않는다.\n  하지만 이 때는 동기화를 직접해야 한다.\n   4. Concurrent.futures 4.1 Thread Pool이란??   server 요청 model에 Thread per request model 이다.\n 즉, 요청마다 새로운 thread를 할당하여 처리한다면, 요청이 들어올 때마다 thread를 생성하고 요청이 완료되면 thread를 삭제해야 한다.    이 방식의 문제는 요청마다 스레드 생성에 소요되는 시간 때문에, 요청 처리가 더 오래 걸린다.\n  만약 처리 속도 \u0026lt; 요청 속도이면??\n thread가 계속 생성되어, thread 수는 증가한다. 이에 따라 context switching이 더 자주 발생한다. CPU overhead 증가로 CPU time이 낭비된다. 결국, 어느 순간 서버 전체가 응답 불가능 한 상태에 빠진다. 또한, 메모리가 점점 고갈 된다.    그래서 미리 최대 몇 개의 thread 묶음을 만들어놓는다. 이를 thread pool이라 한다.\n API 요청이 들어오면 thread pool 안에 일이 없는 thread를 할당한다. 요청이 완료되면 thread는 삭제하지 않고, 이 pool에 다시 들어온다. 미리 thread를 여러 개 만들어 놓고 재사용하여 thread 생성 시간을 절약한다. 또한, 제한된 개수의 thread를 응용 하기 때문에, 무제한으로 생성되는 걸 방지한다.    Thread pool 사례: 여러 작업을 동시 처리해야할 때\n task를 subtask로 나뉘어서 동시에 처리할 때 순서 상관없이 동시실행이 가능한 task 처리할 때    Thread pool 사용 시, Tip\n thread pool에 몇 개의 thread를 만들어 두는 게 적절한가???  CPU의 core 개수와 task의 성향에 따라 다르다. CPU-bound task라면 코어 개수 만큼 혹은 그보다 몇 개 더 많은 정도 I/O-bound task라면 경험적으로 찾아야 한다.   thread pool에서 실행될 task 개수에 제한이 없다면, thread pool의 큐가 사이즈 제한이 있는지 반드시 확인할 것   큐에 요청이 무한정 쌓인다면??? 잠재적으로 메모리를 고갈시킬 수 있는 원인이 된다. 그래서 큐에 제한이 없다면 제한을 걸어야 한다.    process pool 또한, process를 미리 만들어두는 방식을 말한다.\n  python에서는 GIL 때문에 CPU-bound task를 실행할려면, 동시에 CPU에서 여러 프로세스가 실행될 수 없으므로 thread pool을 사용해야 한다.\n  4.2 concurrent.futures package   concurrent.futures package\n 비동기 실행을 위한 API를 고수준으로 작성하고, \u0026lsquo;사용하기 쉽도록 개선\u0026rsquo;하여 나온 것  전에는 \u0026lsquo;import processing\u0026rsquo;, \u0026lsquo;import thread\u0026rsquo; 으로 따로 호출해서 사용했었지만, 지금은 multi-threading / multi-processing API가 통일되어 매우 사용하기 쉽다. 또한, low level로 하지 않아도 가능하다.   실행 중인 작업 취소, 완료 여부 체크, 타임아웃 옵션, 콜백 추가, 동기화 코드를 매우 쉽게 작성할 수 있다.    concurrent.futures.ProcessPoolExecutor 는 multiprocessing.Process와 동일한 역할을 한다.\n  하지만, concurrent.futures.ProcessPoolExecutor는 max_workers를 지정하여 fork할 process의 최대 갯수를 지정하는 게 가능하다.\n  process pool을 사용하여 호출을 비동기적으로 실행하는 method\n  ThreadPoolExecutor는 process pool이 아닌, thread pool을 사용한다.\n thread pool이란 미리 만들어 놓은 thread 집단을 말한다.     5. Exercise - PoolExecutor  concurrent.futures 사용법  ThreadPoolExecutor의 max_work 기본 값은 min(32, os.cpu_count() + 4)다.  이 기본값은 I/O 병목 작업을 위해 최소 5개의 작업자를 유지한다.   ProcessPoolExecutor의 max_work 기본 값은 기계의 프로세서 수를 기본값으로 사용한다. 아래 코드의 pattern을 외우자. map은 작업 순서를 유지하고, 즉시 실행한다.  4개를 동시에 시작해서 그 결과값을 받아온다. 그런데 4개 중 한 작업이 1시간이 걸린다면 이 한 시간을 계속 기다린다.      \u0026gt; import os \u0026gt; import time # threading, multi-processing이 저수준으로 만들어져 있는 걸 사용한다. \u0026gt; from concurrent import futures # 1부터 각 성분값까지 합을 계산할 것이기 때문에, 4가지 작업을 동시에 실행한다. # 실무에서는 각 값에 자신이 만든 함수를 넣어 사용해도 된다. \u0026gt; WORK_LIST = [100000, 1000000, 10000000, 100000000] # 인자 n에 위 WORK_LIST의 성분 값들이 하나씩 넘어와서 합이 계산된다. # 그래서 총 동시에 4개가 실행된다. # 누적 합계 함수(generator) \u0026gt; def sum_generator(n): \u0026gt; return sum(n for n in range(1, n+1)) # worker의 수는 두 인수 중 작은 수로 한다. # worker를 몇 개 할지 모르면 운영체제한테 맡긴다. \u0026gt; def main1(): \u0026gt; worker= min(10, len(WORK_LIST)) ## 시작시간 # time.time은 현재 시간을 나타낸다. \u0026gt; start_tm = time.time() ## 결과 건수 # with문으로 해야 열고 닫는 게 자동적으로 이뤄진다. # def main1 과의 차이점 (ThreadPoolExecutor) \u0026gt; with futures.ThreadPoolExecutor() as excutor: \u0026gt; result = excutor.map(sum_generator, WORK_LIST) ## 종료시간 # 현재 시간을 나타낸 거에, 시작 시간을 빼서 총 걸린 시간을 나타낸다. \u0026gt; end_tm = time.time() - start_tm ## 출력 포맷 # float 형 데이터 출력에 소수점 둘째짜리까지 출력한다. \u0026gt; msg = \u0026#39;\\n Result -\u0026gt; {} Time : {:.2f}s\u0026#39; \u0026gt; print(msg.format(list(result), end_tm)) \u0026gt; def main2(): \u0026gt; worker= min(10, len(WORK_LIST)) \u0026gt; start_tm = time.time() # def main2 와의 차이점 (ProcessPoolExcutor) \u0026gt; with futures.ProcessPoolExecutor() as excutor: \u0026gt; result = excutor.map(sum_generator, WORK_LIST) \u0026gt; end_tm = time.time() - start_tm \u0026gt; msg = \u0026#39;\\n Result -\u0026gt; {} Time : {:.2f}s\u0026#39; \u0026gt; print(msg.format(list(result), end_tm)) ## 실행 # 진입점을 알려줘야, multi-processing이 실행될 때 작업을 할 수 있다. \u0026gt; if __name__ == \u0026#39;__main__\u0026#39;: \u0026gt; main1() \u0026gt; main2() Result -\u0026gt; [5000050000, 500000500000, 50000005000000, 5000000050000000] Time : 7.61s Result -\u0026gt; [5000050000, 500000500000, 50000005000000, 5000000050000000] Time : 7.14s  ProcessPool로 실행했을 때의 결과가 더 빠르다는 걸 확인했다.   그러면 동기적으로 진행했을 때의 시간을 측정해보자.  \u0026gt; WORK_LIST = [100000, 1000000, 10000000, 100000000] # 시작 시간 \u0026gt; stm = time.time() \u0026gt; for i in WORK_LIST: \u0026gt; sum(n for n in range(1, i+1)) # 종료 시간 \u0026gt; etm = time.time() - stm \u0026gt; print(\u0026#39;total time - {:0.2f}s\u0026#39;.format(etm)) 8.43s  thread pool과 process pool을 사용하는 방법이 더 빠르다는 걸 알 수 있다.   6. Exercise - wait, as_completed  Exercise - PoolExecutor에서 한 예제는 총 4가지에 대한 합계를 구하는 동시성을 구현해보는 예제였다. 그러면 동시적으로 수행되는 각 작업이 성공했는지, 확인할 수도 있어야 하지 않을까?? 이를 확인하기 위해, wait과 as_completed module에 대해 먼저 알아보자.  6.1 wait  작업의 양이 작아서 금방 끝나서, 한 번에 다 끝난 다음에 작업을 하기 원할 때 wait을 사용한다.\n  각 작업이 정해진 시간(timeout)을 벗어나면 실패로 간주하고 중단시킨다. 완료된 작업들만 추출하고 싶으면 .done method를 사용한다. 완료되지 않은 작업들, 실패한 작업들을만 추출하고 싶으면 .not_done method를 사용한다. 결과값을 원할 때는 .result를 사용한다.  6.2 as_completed  하나라도 끝난 다음에 바로 일을 시작할려고 할 때, 즉 real time 작업을 하려고 할 때, as_completed를 사용한다.\n  먼저 끝나는 대로 순서를 반환한다. (yield) 결과값만 추출하기 원하면 .result를 사용한다. 완료된 작업들만 추출하고 싶으면 .done method를 사용한다. 완료되지 않은 작업들, 실패한 작업들을만 추출하고 싶으면 .cancelled method를 사용한다.   그러면 예시 코드로 적용해보자.  \u0026gt; import os \u0026gt; import time # 이번에는 쓸만큼만 호출한다. \u0026gt; from concurrent.futures import ThreadPoolExecutor, ProcessPoolExecutor, wait, as_completed \u0026gt; WORK_LIST = [100000, 1000000, 10000000, 100000000] \u0026gt; def sum_generator(n): \u0026gt; return sum(n for n in range(1, n+1)) \u0026gt; def main(): \u0026gt; worker= min(10, len(WORK_LIST)) ## 시작시간 \u0026gt; start_tm = time.time() \u0026gt; future_list = [] ## 결과 건수 # ThreadPoolExecutor로도 해보자. \u0026gt; with ProcessPoolExecutor() as excutor: \u0026gt; for work in WORK_LIST: \u0026gt; furture = excutor.submit(sum_generator, work) \u0026gt; futures_list.append(future) \u0026gt; print(\u0026#39;Scheduled for {} : {}\u0026#39;.format(work, future)) \u0026gt; print() ## wait 결과 출력 # 스케쥴된 list를 인자로 받는다. # timeout으로 정한 시간만큼 list를 기다린다. # 이 정해진 시간 안에 일을 못 끝내면 실패로 간주하고 중단시킨다. # sum_generator로 인한 연산 작업으로 future_list에 append될 때까지 7초를 넘으면 실패로 간주한다. \u0026gt; result = wait(futures_list, timeout = 7) ## 성공한 것들 \u0026gt; print(\u0026#39;Completed Tasks : \u0026#39; + str(result.done)) \u0026gt; print() ## 실패한 것들 \u0026gt; print(\u0026#39;Pending ones after waiting for 7seconds : \u0026#39; + str(result.not_done)) \u0026gt; print() ## 결과 값 출력 \u0026gt; print([future.result() for future in result.done]) \u0026gt; print() ## as_completed 결과 출력 \u0026gt; for future in as_completed(futures_list): \u0026gt; result = future.result() \u0026gt; done = future.done() \u0026gt; cancelled = future.cancelled ## future 결과 확인 \u0026gt; print(\u0026#39;Future Result : {}, Done: {}\u0026#39;.format(result, done)) \u0026gt; print(\u0026#39;Future Cancelled : {}\u0026#39;.format(cancelled)) ## 종료시간 \u0026gt; end_tm = time.time() - start_tm ## 출력 포맷 \u0026gt; msg = \u0026#39;\\n Time : {:.2f}s\u0026#39; \u0026gt; print(msg.format(end_tm)) ## 실행 \u0026gt; if __name__ == \u0026#39;__main__\u0026#39;: \u0026gt; main() ## 결과 건수에서 예약된 작업들 Scheduled for 100000 : \u0026lt;Future at 0x204190e5490 state=running\u0026gt; Scheduled for 1000000 : \u0026lt;Future at 0x20419161130 state=pending\u0026gt; Scheduled for 10000000 : \u0026lt;Future at 0x20419161370 state=pending\u0026gt; Scheduled for 100000000 : \u0026lt;Future at 0x204191610d0 state=pending\u0026gt; ## 성공한 것들 Completed Tasks : {\u0026lt;Future at 0x204190e5490 state=finished returned int\u0026gt;, \u0026lt;Future at 0x20419161130 state=finished returned int\u0026gt;, \u0026lt;Future at 0x20419161370 state=finished returned int\u0026gt;} ## 실패한 것들 Pending ones after waiting for 7seconds : {\u0026lt;Future at 0x204191610d0 state=running\u0026gt;} ## 결과값 출력 [5000050000, 500000500000, 50000005000000] ## 종료시간 Time : 8.47s   submit(func, *args)는 func에 *args 를 넘겨주어 그 결과값을 return하는 함수다.\n  Futures chapter는 더 공부를 해야할 필요를 다른 단원보다 많이 느낀다.\n  파이썬에 대해 더 공부한 후, 파이썬 과정 level 4인 고수가 되는 파이썬 : 동시성과 병렬성 문법 배우기 Feat. 멀티스레딩 vs 멀티프로세싱 (Inflearn Original) 을 공부하면서 깊이 있게 학습해야겠다.\n   Reference  인프런 파이썬 중급 Sync VS Async, Blocking VS Non-Blocking thread pool  ","permalink":"http://jeha00.github.io/post/python_basic/python_basic_38.futures/","summary":"인프런 파이썬 level 4 과정의 기반으로 대략적으로 학습하는 내용이다. 구체적으로 Synchro와 Asynchro가 각각 무엇을 의미하는지, threadpool이란 무엇인지, concurrent.futures package에서 wait과 as_completed module에 대해 학습해본다.","title":"[TIL] Python basic 38: Futures"},{"content":"0. Introduction  해당 내용은 운영체제와 정보기술의 원리을 보고 혼자 정리한 내용입니다. 정확하지 않은 내용이 있다면 말씀해주시면 감사하겠습니다.  1. 운영체제의 정의  운영체제란?   운영체제(operating system) 란??\n컴퓨터 하드웨어의 바로 윗단에 설치되는 소프트웨어로, 사용자 및 다른 소프트웨어와 하드웨어를 연결하는 소프트웨어 계층이다.\n  왜 system이라 하는가??? system은 흔히들 하드웨어를 지칭할 때 주로 사용되는 단어인데, 이 system을 사용한 이유는 운영체제 없이 하드웨어만 있다면 컴퓨터 역할을 할 수 없고, OS와 하드웨어가 같이 있어야 진정한 컴퓨터이기 때문이다.\nkernel이란?? 소프트웨어가 실행되기 위해서는 메모리에 그 프로그램이 올라가야 한다. 운영체제도 하나의 SW이기 때문에, 컴퓨터 하드웨어의 전원이 켜지는 동시에, 메모리에 올라간다. 이 운영체제 SW는 규모가 큰 프로그램이기 때문에, 운영체제 전부를 메모리에 올린다면 메모리 공간 낭비가 심해진다.\n그래서 운영체제 중 항상 필요한 부분만 을 전원이 켜짐과 동시에 메모리에 올려놓고, 그렇지 않은 부분은 메모리로 올려서 사용한다. 메모리에 항상 상주하는 운영체제 부분 을 커널(kernel) 이라 한다. 이 커널을 좁은 의미의 운영체제 라고도 불리며, 넓은 의미의 운영체제 는 utility들(ex: copy)을 광범위하게 포함하는 개념이다.\n2. 운영체제의 기능  하드웨어 그리고 사용자를 위한 운영체제의 역할 운영체제는 사용자 및 다른 소프트웨어와 하드웨어를 연결하는 소프트웨어 계층이라는 관점에서 운영체제의 기능을 생각해보면, 하드웨어를 위한 역할 과 사용자를 위한 역할 로 나눠진다.\n전자 는 사용자를 대신하여 운영체제가 하드웨어인 컴퓨터 시스템 내의 resource를 효율적으로 관리하는 역할 을 말한다.\n후자 는 사용자가 컴퓨터 시스템을 편리하게 사용하도록, 사용자에게 편리한 인터페이스를 제공하는 역할 을 말한다. 하드웨어를 직접 다루는 부분은 운영체제가 대행하여, 사용자 및 프로그램이 이에 대한 내용은 알지 못 해도 프로그램을 실행해주는 기능을 말한다.\n❗운영체제의 핵심 역할: 효율적, 균형있게, 안전하게 자원 관리하기 운영체제의 기능은 전자와 후자 중 중요한 핵심기능은 바로 전자 다.\n그래서 운영체제를 자원 관리자(resource manager) 라고도 부른다. 여기서 자원이란 하드웨어 자원(ex: CPU, memory, HDD) 과 소프트웨어 자원을 모두 총칭하는 말이다. 운영체제는 이 자원들을 효율적으로 관리 하여 가장 좋은 성능 을 내도록 만든다.\n하지만, 전체적인 성능을 향상시켜려다보면 일부 프로그램 또는 사용자가 불이익을 당할 수 있다. 그래서 운영체제는 사용자 및 프로그램들 간에 자원이 형평성 있게 분배 되도록 하는 균형자 역할도 함께 수행해야 한다.\n또한, 더 중요한게 사용자와 운영체제 자신을 보호하는 보안 역할을 담당한다. 악의성 프로그램으로 다른 사용자 프로그램에 접근하지 않도록 보안 및 보호 기능을 수행해야 한다.\n3. 운영체제의 분류  운영체제의 분류 중 하나는 multi-processing system 과 single-processing system 이다. CPU가 2개 이상 설치되면 전자, 1개만 설치되면 후자를 말한다. 여기서 분류는 후자를 가정으로 진행된다.\n운영체제의 분류에는 동시 작업을 지원하는지, 다중 사용자를 지원하는지, 실시간(real time)을 지원하는지에 따라 분류된다. 앞에서부터 차근 차근 알아보자.\n첫 번째 분류: 동시 작업의 지원 유무 동시 작업을 지원하는지의 여부에 따라 단일작업(single tasking)용 운영체제와 다중작업(multi tasking)용 운영체제로 나누어볼 수 있다. 각 설명은 다음 표와 같다.\n   운영체제 분류 동시 작업 지원 유무 예시     single tasking X (한 번에 하나) 초창기 운영체제, DOS   multi-tasking O (동시에 창 여러개) MS window, Unix    Multi-tasking: 시분할, 다중 프로그래밍, 대화형 system 다중 작업 시에는 여러 프로그램이 CPU와 memory를 공유한다.\nCPU의 경우, 처리 속도가 워낙 빨라서 여러 프로그램이 CPU의 작업시간을 조금씩 나누어 번갈아 쓰지만, 사용자 입장에서는 동시 실행처럼 보인다. 이를 시분할 시스템(time sharing system) 이라 한다.\n또한, 메모리의 경우 메모리 공간을 분할해 여러 프로그램들을 동시에 메모리에 올려놓고 처리하는 시스템을 사용한다. 이를 다중 프로그래밍 시스템(multi-programming system) 이라 한다.\n다중 작업의 경우, 여러 프로그램을 같이 실행하지만, 사용자 개개인의 관점에서는 각 프로그램에 대한 입력 결과를 곧바로 화면에 보여준다. 이를 대화형 시스템(interactive system) 이라 한다. 여러 사용자가 동시 접속 하는 서버의 경우에도, 각 사용자 입장에서는 혼자 사용하는 것처럼 느끼게 해주므로 대화형 시스템에 해당된다.\n두 번째 분류: 다중 사용자 동시지원 유무    운영체제 분류 다중 사용자 지원 추가 설명 예시     단일 사용자용 X 한 번에 한 사용자만 DOS, MS window   다중 사용자용 O 여러 사용자 동시 접속 가능 server(서버)    세 번째 분류: 작업 처리 방식(일괄처리 와 시분할 방식)    작업 처리 방식 의미 추가 설명 예     일괄 처리 (batch processing) 일정량씩 모아 한꺼번에 처리하는 방식 응답 시간이 길다. 초창기 컴퓨터에 사용하는 punch card   시분할 방식 (time sharing system) 여러 작업을 수행 시, 일정 시간 단위로 분할해 CPU를 사용하는 방식 짧은 응답시간을 갖는다. 유닉스 운영체제 하의 서버 컴퓨터    다섯 번째 분류: 실시간(real time) 운영체제 real time system은 정해진 시간 안에 처리를 보장하는 시스템에서 사용된다.\n   분류 설명 예     Hard realtime system 주어진 시간을 지키지 못할 경우, 매우 위험한 결과를 초래할 가능성 O 원자로, 공장 제어 시스템, 미사일 제어 시스템   Soft realtime system 데이터가 정해진 시간 단위로 되어야 올바른 기능을 수행할 수 있는 시스템. 위험한 결과 X 멀티 미디어 스트링    4. 운영체제의 예  MS Window와 Unix의 예를 통해 간단히 살펴보자.\nMS Window는 마이크로소프트에서 이전에 개발한 MS-DOS와 WINDOW 3.1을 발전시킨, 개인용 컴퓨터를 위한 운영체제다.\n마이크로소프트가 기존에 발표한 MS-DOS는 초보자가 사용하기 어려운 명령어 입력 방식을 지녔기 때문에, 좀 더 쉬운 사용을 위해 윈도우를 개발했다.\n그리고, WINDOW 3.1은 grapic interface와 mouse 기능을 지원하는 점에서 사용자에게 편리한 환경을 제공했지만, 독자적인 운영체제가 되지 못하고 MS-DOS 위에 수행된다는 점에서 여러 한계점을 가지고 있었다. 예를 들어 컴퓨터 시스템을 완전히 제어할 수 없는 것, 불안정하다는 것 그리고, WINDOW를 사용하면서도 DOS를 함께 사용해야 하는 부가적인 어려움이 있었다.\n그 이후 온전한 운영체제가 된 것이 윈도우 95다. 윈도우 XP부터는 인터페이스측면에서 그래픽 환경과 아이콘 방식을 기본적으로 채택하면서, 다양한 방식으로 지원해 자신에게 편한 방법으로 다룰 수 있게 했다.\nMS Window의 또 다른 큰 특징은 plug and play다. 시스템에 새로운 하드웨어를 장착하면 OS가 자동으로 감지하여, 새로운 하드웨어에 맞게 설정된다는 점이다.\n그러면 MS Window와 Unix를 비교해보겠다.\n이식성(protability) 이란?\n해당 소프트웨어를 다른 기종의 기계로 옮기는 것이 얼마나 용이한가를 나타내는 지표\n    MS Window Unix     대상 누구든지 손쉽게 사용(개인용 컴퓨터) 프로그램 개발 환경을 위해 설계된 OS, 오랜 전통, 대형 컴퓨터,전문적인 목적   특징 1 편리한 인터페이스 이식성(protability)이 좋음   특징 2 안정성 낮음 안정성이 좋음   특징 3  kernel의 크기가 작음   특징 4  souce code 공개됨 → 실제 연구에 이바지   특징 5  스스로 꾸밀 수 있음   특징 6  후에 GUI 제공됨    5. 운영체제의 자원 관리 기능  자원이란 하드웨어 자원과 소프트웨어 자원을 포함한다고 했다. 이번 소단원에서는 하드웨어 자원을 어떻게 관리하는지 알아보자.\n하드웨어 자원에는 CPU, 메모리, 그리고 입출력 장치들로 구성된다.\nCPU 관리 기법: 3가지 CPU 란 Central Processing Unit의 약자로, 명령어를 실행하는 연산 장치를 말한다. 이 CPU 는 통상적으로 컴퓨터 한 대에 하나가 장착되기 때문에, 여러 프로세스들이 CPU를 효율적으로 나누어 사용할 수 있도록 관리되어야 한다. 이 CPU의 대표적인 관리 방법 에는 선입선출(First Come First Served: FCFS), 라운드 로빈(Round Robin), 우선순위(Priority) 기법이 있다.\nCPU 관리 기법 첫 번째: 선입선출(FCFS) CPU를 사용하기 위해 먼저 온 process를 먼저 처리하는 방식이 선입선출 이다. 일상생활에서 줄을 서서 기다리는 것과 동일하다. 이 방법의 단점은 CPU를 필요로 하는 process가 여러 개 있을 때, CPU를 먼저 얻은 process가 원하는 작업을 완료할 때까지 다른 프로세스들은 CPU를 사용하지 못한다는 점이다. CPU 자체의 효율적인 측면에서는 문제 없지만, 전체 시스템의 관점에서는 비효율적인 결과를 초래할 수 있다. 장시간 이용해야 하는 프로세스가 먼저 오고, 그 뒤에 단시간 이용해야하는 프로세스가 올 경우 단시간 이용하면 되지만, 먼저 온 프로세스로 인해 계속 대기해야하는 상황이 발생된다.\nCPU 관리 기법 두 번째: 라운드 로빈(Round Robin) 위 선입선출의 단점을 보완하여 나온 방법이 라운드 로빈(Round Robin) 이다. 이 방법은 CPU를 한 번 할당 받아 사용할 수 있는 시간을 일정하게 고정된 시간으로 제한 한다. 각 프로세스는 이 정해진 시간 동안에만 CPU를 할당받는다. 작업이 완료되지 않았어도, 시간이 끝나면 CPU를 내려놓고, CPU 대기열의 제일 뒤에 가서 줄을 서야 한다. 먼저 온 프로세스의 작업 완료 시간이 길어도, 계속해서 기다릴 문제가 발생되지 않는다. 각 process마다 이 정해진 시간만큼 보장받을 수 있다.\nCPU 관리 기법 세 번째: 우선순위(Priority) 대기 중인 프로세스들에게 우선순위를 부여하고, 우선순위가 높은 process들에게 먼저 CPU를 할당 한다. 먼저 와서 CPU를 기다릴지라도, 우선순위에 따라 융통성 있게 process들에게 CPU를 할당할 수 있다. 또한, 지나치게 오래 기다리는 프로세스가 발생하지 않도록, 기다리는 시간에 비례하여 우선순위를 점차 높여주는 방안도 활용된다.\nMemory란?? 또 다른 중요 관리 대상으로 Memory가 있다. 메모리 역시 CPU처럼 한정된 용량만 존재하기 때문에, 서로 다른 다수의 프로세스들이 나누어 쓸 수 있도록 해야 한다. 메모리는 CPU가 직접 접근할 수 있는 컴퓨터 내부 기억장치다. 프로그램이 CPU에서 실행될라면 해당 부분이 메모리에 올라가 있어야 한다. 메모리는 한정된 용량을 가지고 있기 때문에, 효율적인 관리를 위해 운영체제는 메모리의 어느 부분이 어떤 프로그램에 의해 사용되고 있는지를 주소(address) 를 통해 관리된다.\n운영체제가 Memory 관리가 필요한 이유 프로세스와 메모리의 관계는 다음과 같다. 추가적으로 할당하여 프로세스가 빨리 수행될 수 있지만, 메모리 자원을 낭비하는 경우도 발생한다. 운영체제는 프로그램에 메모리가 필요할 때 할당하고, 필요하지 않으면 메모리를 회수한다. 따라서 운영체제는 전체 메모리 공간이 효율적으로 사용될 수 있도록 잘 판단해야 한다. 또한, 각 프로세스가 자신의 메모리 영역에만 접근할 수 있도록 보안 관리를 잘 해야 한다.\nMemory 관리 방식 3가지 memory 관리 방식에는 고정 분할(fixed partition) 방식, 가변 분할(variable partition) 방식, 가상 메모리(virtual memory) 방식이 있다. 각 방식에 대해 알아보자.\nMemory 관리 방식 첫 번째: 고정 분할 방식 고정 분할 방식은 명칭 그대로 물리적 메모리를 미리 고정된 크기로 나누어 관리한다. 이로 인해 몇 가지 단점이 있다.\n첫 번째, 프로그램 크기에 맞게 융통성 있게 할당할 수가 없다는 문제점이 있다.\n두 번째, 고정된 크기이기 때문에 최대 할당할 수 있는 프로그램의 수가 정해져 있다.\n세 번째, 나눠진 메모리 크기보다 큰 프로그램은 적재가 불가능하다.\n네 번째, 나눠진 크기보다 작은 프로그램에 할당하면 분할 내에 남는 영역 이 발생한다. 이 영역을 내부 조각(internal fragmentation) 이라 한다. 이 영역은 올라온 프로그램에 의해서도 사용될 수 없고, 다른 프로그램에 할당할 수 없어서 비효율적으로 낭비되는 공간 이다.\nMemory 관리 방식 두 번째: 가변 분할 방식 가변 분할 방식은 매 시점 프로그램의 크기에 맞게 메모리를 분할해서 사용하는 방식을 말한다. 이 방식 또한 전체 물리적 메모리 크기보다 큰 프로그램에는 여전히 할당할 수 없다. 그리고, 고정 분할 방식의 내부 조각은 발생되지 않지만, 외부 조각(external fragmentation) 이 발생할 수 있다. 외부조각이란 프로그램에 할당되지는 않았지만, 그 크기가 작아 프로그램을 올리지 못하는 메모리 영역을 말한다. 그래서 비효율적으로 낭비되는 공간이다.\nMemory 관리 방식 세 번째: 가상 메모리(Virtual Memory) 기법 현대 컴퓨터 환경에서 가장 널리 사용되는 메모리 관리 기법이다. 이 기법에서 실행될 수 있는 프로그램의 크기는 물리적 메모리가 아닌 가상 메모리 크기에 의해 결정된다. 그래서 물리적 메모리보다 큰 프로그램도 지원할 수 있다.\n모든 프로그램은 물리적 메모리와 독립적으로 가상 메모리를 가지고 있다. 운영체제는 이 가상 메모리의 주소를 물리적 메모리의 주소로 mapping (전환, 연결)하는 기술을 사용하여 전환 후, 물리적 메모리에 올린다.\n예를 드어보자.\n가상 메모리 기법을 사용하여 현재 물리적 메모리보다 더 큰 메모리를 요구하는 프로그램을 실행한다고 하자. 각 프로그램은 전체가 동시에 사용되는 게 아니다. 그러므로 사용되고 있는 부분만 물리적 메모리에 올리고, 나머지는 보조기억장치에 저장해두었다가 필요할 때 적재하는 방식으로 큰 프로그램을 사용할 수 있다. 이 때, 사용되는 보조기억장치의 영역을 스왑 영역(swap area) 라고 부른다. 프로그램을 구성하는 가상 메모리 공간은 페이징(paging) 기법을 사용하여 저장된다.\n입출력 장치 관리 기법 이 CPU와 메모리는 전원이 꺼지면 처리 중이던 정보가 모두 지워지기 때문에, 보조기억장치 에 파일 형태로 저장한다. 이 보조기억장치의 예로는 하드디스크가 있으며, 그 외에는 키보드, 마우스, 모니터 등이 입출력 장치 로 OS 관리 대상에 포함된다. 입출력 장치 관리는 인터룹트(interrupt) 를 통해 이뤄진다.\nInterrupt mechanism CPU는 CPU schedulling에 따라 주어진 작업을 수행하다가, 주변 입출력 장치로의 controller가 CPU에게 인터룹트를 발생시키면 CPU는 자신이 하던 작업을 중단한다. 그리고 현재 자신이 하던 작업 상태를 저장한다. 왜냐하면 다시 중단된 작업을 이어서 해야하기 때문이다. 이 인터룹트가 발생된 순간, CPU의 사용권은 프로그램에서 운영체제로 넘어온다. 그러면, 운영체제는 kernel에 발생된 인터룹트의 종류에 맞는 인터룹트 처리루틴을 찾아서 처리루틴에 기록된 코드에 따라 일을 처리한다. 그 후, 다시 중단되 업무에 CPU는 복귀한다. controller란 입출력 장치가 가지고 있는 sub CPU라 생각하자.\n Reference  운영체제와 정보기술의 원리  ","permalink":"http://jeha00.github.io/post/os/os_chapter_02_%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C_%EA%B0%9C%EC%9A%94/","summary":"운영체제란 무엇이고, 무슨 역할을 하는지, 어떻게 분류되는지, 그리고 CPU, 메모리, 입출력 장치의 대략적인 관리 mechanism에 대해 알아본다.","title":"[TIL] OS Chapter 02: Introduction to Operating System"},{"content":"Intro   Thread, Multi-thread 그리고 Coroutine이 무엇인지를 통해 코루틴의 중요성을 이해한다.\n  Coroutine을 구현해보면서 Generator와의 차이를 통해 Coroutine을 이해한다.\n  코루틴이 왜 필요한지 이해하기 위해서 먼저 Thread, Multi-thread 를 이해해보자.\n  그리고, 이들을 이해하기 위해서는 process가 뭔지 알아야 한다.\n  그러면 이 개념들에 대해 알아보자.    1. Thread, Multi - thread란?? Process 와 Thread란??  process는 코드로 구현된 파일인 program이 실행된 것을 의미한다. Thread(쓰레드)는 \u0026lsquo;한\u0026rsquo; process 내에서 나뉘어진 하나 이상의 실행 단위를 말한다.  Single thread(단일 스레드) 와 Multi-thread란??  thread가 프로세스 내에 하나만 존재하면 단일 스레드 상태로 실행 단위는 프로세스 자체가 된다. 하지만, 한 프로세스 내에서 분리하여 여러 thread로 나뉘어 실행 단위가 나눠지고 많아지면 이를 Multi-thread라 한다. 한 process 내부의 각 thread가 한 applicaiton이 여러 가지 일을 처리해야하는 상황에서 각 작업들을 담당하는 거다.  multi-thread 장점  한 process 내에 thread끼리는 긴밀히 연결되어 있다. 한 process 내에 있으므로, 공유된 자원으로 통신 비용을 절감할 수 있다. 공유된 자원으로 메모리가 효율적이다. multi-process보다 Context switching 비용이 적다.  multi-thread 단점   하나의 thread에 문제가 생기면 다른 여러 thread에도 영향을 준다.\n  Single thread(단일 thread)를 하다가 속도를 높이기 위해 multi-thread를 사용하기 시작하면, thread 끼리 공유되는 자원 때문에 교착 상태(Dead Lock)가 발생할 수 있다.\n  single thread에 비해 \u0026lsquo;context switching\u0026rsquo; cost가 크다.\n  자원 소비 가능성이 증가한다.\n  이런 이유로 Single thread가 더 빠른 이유가 switching cost 때문이다.\n   2. 코루틴(Coroutine)이란??   Cooperative routine의 약어로, 서로 협력하는 routine을 의미한다. Generator의 특별한 형태로, yield와 send를 통해서 main routine과 sub routine의 데이터 상호 교환 방식     코루틴은 위의 의미를 가지고 있지만, thread의 관점에서 보자면\n single thread환경에서 yieldkeyword를 통해 stack 기반으로 동작하는 비동기 작업    함수에서 single thread에서도 동시성이 가능하도록 언어가 발전하고 있는데,바로 코루틴이 이런 발전의 한 예이다.\n  coroutine은 routine 실행 중지 후, 다시 이어서 실행 가능한 동시성 프로그래밍 방법.\n 그래서 coroutine은 thread에 비해서 overhead가 감소된다.  overhead: 어떤 처리를 하기 위해 들어가는 간접적인 처리 시간 · 메모리      흐름 제어: 메인 루틴에서 서브 루틴을 호출하면 서브루틴에서 수행한다.\n    이어지는 예제들을 통해서 아래 3가지를 유심히 보자.\n Coroutine을 어떻게 제어하는지 상태 저장 양방향 전송     3. 코루틴 기본예제 1: 코루틴 이해하기   앞으로 def를 보면 단지 function이라 생각하지 말자.\n def로 function, generator, coroutine을 구현할 수 있기 때문이다.    for문에서는 예외가 잡히기 때문에, StopIterator가 발생되지 않는다.\n  ## Generator ## sub routine \u0026gt; def corountine1(): \u0026gt; print(\u0026#39;\u0026gt;\u0026gt;\u0026gt; coroutine started\u0026#39;) # yield는 외부 main routine에서 주는 값을 받아오고, 이 yield가 i로 할당된다. \u0026gt; i = yield \u0026gt; print(\u0026#39;\u0026gt;\u0026gt;\u0026gt; coroutine received: {}\u0026#39;.format(i)) ## main routine: 함수를 호출하기 때문에 \u0026gt; cr1 = coroutine1() \u0026gt; print(cr1, type(cr1)) \u0026lt;generator object coroutine1 at 0x00000158B4A1EB30\u0026gt; \u0026lt;class \u0026#39;generator\u0026#39;\u0026gt; \u0026gt; next(cr1) \u0026gt;\u0026gt;\u0026gt; coroutine started. \u0026gt; next(cr1) \u0026gt;\u0026gt;\u0026gt; coroutine received : None StopIteration   위 코드에서는 sub routine이 main routine에 주는 것 밖에 하지 못 했다.\n  그러면 어떻게 main과 sub가 상호작용 할 수 있을까??\n  send를 통해서 main routine과 sub routine이 상호작용할 수 있다.\n  send를 사용해야 yield keyword가 값을 받을 수 있다.\n  이것이 바로 coroutine이다.\n Generator의 특별한 형태로, yield와 send를 통해서 main routine과 sub routine의 데이터를 상호 교환할 수 있다.\n   \u0026gt; cr1 = coroutine1() # yield 지점까지 sub routine 실행 \u0026gt; next(cr1) \u0026gt;\u0026gt;\u0026gt; coroutine started. ## 값 전송 \u0026gt; cr1.send(100) \u0026gt;\u0026gt;\u0026gt; coroutine received : 100 StopIteration  send와 next 비교  위 code를 통해서 send도 next 기능이 포함된 걸 알 수 있다. 하지만, next는 값을 sub routine에 보낼 수 없고, send만 보낼 수 있다.   send() 에 100을 입력하니, \u0026lsquo;coroutine received: 100\u0026rsquo;이 출력되었다. main routine에서 보낸 100이 sub routine인 coroutine1의 yield가 받았고, 이를 i에 할당한 걸 알 수 있다.   그러면 send를 잘못 사용한 경우를 알아보자.  \u0026gt; cr1 = coroutine1() # next(cr1)을 생략하고, 바로 send한다. # 시작되지 않고 보내는 상황이다. ## 값 전송 \u0026gt; cr1.send(100) TypeError: can\u0026#39;t send non-None value to a just-started generator  Error를 통해 알 수 있는 건 sub-routine의 yield 지점에서 context가 멈춰야, send로 보냈을 때 받을 수 있다는 걸 알 수 있다. 즉, next를 먼저 실행하여, coroutine을 실행한 후 yield keyword를 실행해야 한다.   4. 코루틴 기본예제 2: 상태값 확인하기   GEN_CREATED: 처음 대기 상태를 의미 GEN_RUNNING: 실행 상태를 의미 GEN_SUSPENDED: yield 대기 상태를 의미 GEN_CLOSED: 실행 완료 상태를 의미   # 이번에는 매개변수가 존재 \u0026gt; def coroutine2(x): \u0026gt; print(\u0026#39;coroutine started : {}\u0026#39;.format(x)) # main과 sub routine의 양방향 통신 -\u0026gt; 동시성 개발 # 좌변 = 우변 # 좌변은 main routine에서 sub routine으로 입력을 받는 것 # 우변은 sub routine에서 나한테 준 것 \u0026gt; y = yield x \u0026gt; print(\u0026#39;coroutine y received : {}\u0026#39;.format(y)) \u0026gt; z = yield x + y \u0026gt; print(\u0026#39;coroutine z received : {}\u0026#39;.format(z)) \u0026gt; cr3 = coroutine2(10) \u0026gt; print(next(cr3)) coroutine started : 10 10 \u0026gt; print(cr3.send(100)) coroutine y received : 100 110 \u0026gt; print(cr3.send(100)) coroutine z received : 100 Stop Iteration  상태값 확인을 해보겠다. 상태값 확인은 getgeneratestate를 import하는 것부터 시작한다.  \u0026gt; from inspect import getgeneratorstate \u0026gt; cr3 = coroutine2(10) \u0026gt; print(getgeneratorstate(cr3)) GEN_CREATED \u0026gt; next(cr3) coroutine started : 10 \u0026gt; print(getgeneratorstate(cr3)) GEN_SUSPENDED \u0026gt; cr3.send(100) coroutine y received : 100 \u0026gt; print(getgeneratorstate(cr3)) GEN_SUSPENDED \u0026gt; cr3.send(20) coroutine z received : 20 StopIteration  5. 코루틴 기본예제 3: 중첩 코루틴 처리 \u0026gt; def generator1(): \u0026gt; for x in \u0026#39;AB\u0026#39;: \u0026gt; yield x \u0026gt; for y in range(1,4): \u0026gt; yield y \u0026gt; t1 = generator1() \u0026gt; print(next(t1)) A \u0026gt; print(next(t1)) B # 이어서 출력되는 걸 알 수 있다. \u0026gt; print(next(t1)) 1 \u0026gt; print(next(t1)) 2 \u0026gt; print(next(t1)) 3 \u0026gt; print(next(t1)) StopIteration \u0026gt; t2 = generator1() \u0026gt; print(list(t2)) [\u0026#39;A\u0026#39;, \u0026#39;B\u0026#39;, 1, 2, 3]  yield from을 사용해서 위 code를 구현해보자. 그냥 yield보다 더 직관적으로 이해가 가능하다.  \u0026gt; def generator2(): # from 뒤에 iterator가 다 소진될 때까지 반환하겠다. \u0026gt; yield from \u0026#39;AB\u0026#39; \u0026gt; yield from range(1,4) \u0026gt; t3 = generator2() \u0026gt; print(next(t3)) A \u0026gt; print(next(t3)) B \u0026gt; print(next(t3)) 1 \u0026gt; print(next(t3)) 2 \u0026gt; print(next(t3)) 3  6. Summary   coroutine은 generator에서 시작되며, 동시성이 무엇인지 이해했다.\n  coroutine은 함수가 종료되지 않은 상태에서 main routine의 code를 실행한 뒤, 다시 돌아와서 coroutine의 code를 실행한다.\n  coroutine이 종료되지 않았으므로, coroutine의 내용도 계속 유지된다.\n  즉, 일반함수는 호출하면 코드를 한 번만 실행할 수 있지만, coroutine은 여러 번 실행이 가능하다\n  coroutie이 generator에서 시작되었다면, 둘의 구체적인 차이는 무엇일까???\n generator는 yield로 값을 발생시켰지만, coroutine은 yield로 값을 받아올 수 있다. 호출하는 과점에서 보면 제네레이터는 next 함수(__next__ method)를 반복 호출하여 값을 얻어내는 방식 코루틴은 next 함수(__next__ method)를 한 번만 호출한 뒤, send method를 사용하여 값을 주고, 받는 방식     Reference  인프런 파이썬 중급 코다의 Process vs. Thread 파이썬 강의 UNIT 41.1 코루틴에 값 보내기  ","permalink":"http://jeha00.github.io/post/python_basic/python_basic_37_coroutine/","summary":"첫 번째, Thread, Multi-thread 그리고 Coroutine이 무엇인지 알아보면서, coroutine이 왜 중요한지를 이해한다. 두 번째, Coroutine을 구현해보면서 Generator와의 차이를 통해 Coroutine을 이해한다.","title":"[TIL] Python basic 37: Coroutine"},{"content":"Intro  병행성을 위한 방법으로 generator와 coroutine을 알아보고자 한다. 이번 포스팅에서는 generator를 알아본다. 그리고, 병행성과 병렬성이 개념적으로 무엇인지 학습한다. 두 번째로, Generator를 본격적으로 알아본다.   1. 병행성과 병렬성이란??   병행성(Concurrency):  한 컴퓨터가 여러 일을 동시에 수행하는 것 -\u0026gt; 단일 프로그램 안에서 여러 일을 쉽게 해결 목적   병렬성(parallelism):  여러 컴퓨터가 여러 작업을 동시에 수행하는 것 -\u0026gt; 속도 향상 목적      병행성 : thread는 하나지만, 마치 동시에 일을 하고 있는 것처럼 수행한다.  예) 공부 중에 강의 멈춰놓고, 밥 먹고 와서 강의를 중단한 부분부터 다시 시작하는 것   파이썬에서는 병행성 과 병렬성 을 모두 지원한다. 그리고, 파이썬 실력을 결정하는 중요한 내용이다.   2 Generator란?   모든 값을 메모리에 올려두고 이용하는 게 아닌, 필요할 때마다 한 번에 한 개의 항목을 생성해서 메모리에 올려두고 반환하는 객체. 그래서 메모리를 유지하지 않기 때문에, 효율적으로 사용할 수 있다.     Generator는 iterator의 한 종류로, 위와 같은 이유로 매우 강력한 iterator다.\n  연산을 필요한 순간까지 미루는 걸 Lazy evaluation이라 한다.\n  iterator이므로 출력하기 위해 next() 를 사용한다.\n  Generator function이 일반 function과의 차이는 yield statement다.\n  Generator = iterator + yield\n  공통점:\n yield 또한 return 처럼 값을 반환한다.    차이점:\n return을 사용할 경우 지역 변수가 사라지지만, yield는 local을 나가도 사라지지 않는다. 그리고, yield는 제네레이터를 반환한다.    Generator의 장점\n list comprehension, dictionary comprehension 등 데이터 양이 증가하면 메모리 사용량이 증가하는데, 이 때 제네레이터를 사용하여 메모리 사용량을 줄이고, 수행시간도 절약해준다. 단위 실행 가능한 코루틴(Coroutine) 구현과 연동이 가능하다. 작은 메모리 조각으로 사용 가능하다.    Generator 주의사항\n generator는 실행 시, 함수의 몸체를 실행하는 게 아니라, generator 함수가 가진 객체를 반환하는 일을 한다. 한 번 생성해서 반환한 객체를 보관하지 않기 때문에, 이전 코드를 실행한 후, 추가 코드를 실행하면 아무런 객체도 출력되지 않는다.     3. Generator 예제 3.1 예제 1 # Generator Ex1 \u0026gt; def generator_ex1(): \u0026gt; print(\u0026#39;Start\u0026#39;) # yield 뒤에 값을 return하고 멈춘다. \u0026gt; yield \u0026#39;A Point.\u0026#39; \u0026gt; print(\u0026#39;continue\u0026#39;) # 멈춘 후, 다음 yield value를 return할 때까지 진행된다. \u0026gt; yield \u0026#39;B Point.\u0026#39; \u0026gt; print(\u0026#39;End\u0026#39;) \u0026gt; temp = iter(generator_ex1()) \u0026gt; print(temp) \u0026lt;generator object generator_ex1 at 0x000001E8B2549510\u0026gt; \u0026gt; print(next(temp)) Start A Point. \u0026gt; print(next(temp)) Continue B point. \u0026gt; print(next(temp)) End StopIteration  yield 까지 출력한 후, 다음 출력은 다음 yield까지 한다. 이처럼 위의 next처럼 위치 인자를 계속해서 유지하는 게 병행성의 핵심이다. 위치 인자를 계속해서 기억하는 것 즉, 다음 할 일을 계속해서 기억하는 걸 의미한다.  3.2 예제 2  이 예제가 단순히 동일한 일을 하는 것처럼 보이지만, 생성된 값을 미리 메모리에 만들어 두는 게 아닌, for 문에서 필요한 때마다 generator로부터 받아온다. 즉, 메모리에서 보관하지 않는다. list comprehension 과 유사해보이지만, 소괄호()를 사용하여 generator expression을 만들 수 있다.  # list comprehension \u0026gt; temp2 = [x * 3 for x in generator_ex1()] # Generator \u0026gt; temp3 = (x * 3 for x in generator_ex1()) \u0026gt; print(type(temp2)) \u0026lt;class \u0026#39;list\u0026#39;\u0026gt; \u0026gt; print(type(temp3)) \u0026lt;class \u0026#39;generator\u0026#39;\u0026gt; # yield로 반환되는 값만 list로 만들어진 걸 확인했다. \u0026gt; print(\u0026#39;temp2 - \u0026#39;, temp2) temp2 - [\u0026#39;A Point.A Point.A Point.\u0026#39;, \u0026#39;B Point.B Point.B Point.\u0026#39;] # 아래와 같이 출력되기 때문에, for문에서 출력하자. \u0026gt; print(\u0026#39;temp3 - \u0026#39;,temp3) temp3 - \u0026lt;generator object \u0026lt;genexpr\u0026gt; at 0x000002895A5AE9E0\u0026gt; # list comprehension \u0026gt; for i in temp2: \u0026gt; print(i) A Point.A Point.A Point. B Point.B Point.B Point. # Generator # Generator이기 때문에, 사용하는 순간에만 함수를 실행했다. # 그래서 Start, continue, End 까지 출력되었다. \u0026gt; for i in temp3: \u0026gt; print(i) Start A Point.A Point.A Point. continue B Point.B Point.B Point. End  그러면 list comprehension과 generator를 더 자세히 비교해보자.  \u0026gt; import time \u0026gt; l = [1, 2, 3, 4] \u0026gt; def print_iter(iter): \u0026gt; for element in iter: \u0026gt; print(element) \u0026gt; def lazy_return(num): \u0026gt; print(\u0026#34;sleep 1s\u0026#34;) \u0026gt; time.sleep(1) \u0026gt; return num \u0026gt; print(\u0026#39;comprehension_list = \u0026#39;) \u0026gt; comprehension_list = [lazy_return(i) for i in L] \u0026gt; print_iter(comprehension_list) \u0026gt; print(\u0026#39;generator_exp = \u0026#39;) \u0026gt; generator_exp = [lazy_return(i) for i in L] \u0026gt; print_iter(generator_exp) sleep 1s sleep 1s sleep 1s 1 2 3 generator_exp= sleep 1s 1 sleep 1s 2 sleep 1s 3   위 code review\n list comprehension은 함수를 미리 다 실행시켜서 \u0026lsquo;sleep 1s\u0026rsquo; 문자열이 먼저 출력되었다. 하지만, generator는 실제로 값을 출력하기 전까지 실행하지 않았다. 값을 사용하는 순간에만 함수를 실행하고 있다.    이 내용을 더 자세히 확인해보자.\n  print_iter를 아래와 같이 수정한 후, 실행하자.\n  \u0026gt; def print_iter(iter): \u0026gt; for element in iter: # element가 1일 떄 코드 실행은 중단된다. \u0026gt; if element == 1: \u0026gt; break \u0026gt; print(element) \u0026gt; print_iter(comprehension_list) comprehension_list= sleep 1s sleep 1s sleep 1s \u0026gt; print_iter(generator_exp) generator_exp= sleep 1s   위 code review\n list comprehension:  lazy_return 함수를 모두 실행한 후, print_iter 함수를 실행할 때 멈췄다.   generator expression:  print_iter 함수가 실행 시, lazy_return 함수를 실행한 걸 확인할 수 있다.      이번에는 속도를 비교해보자.\n  \u0026gt; start_time = time.time() \u0026gt; comprehension_list=[lazy_return(i) for i in L] \u0026gt; print_iter(comprehension_list) \u0026gt; print(time.time()-start_time) sleep 1s sleep 1s sleep 1s 3.0265092849731445 \u0026gt; start_time = time.time() \u0026gt; generator_exp = (lazy_return(i) for i in L) \u0026gt; print_iter(generator_exp) \u0026gt; print(time.time()-start_time) sleep 1s 1.0092661380767822   위 code review\n 제네레이터를 사용했을 때 시간이 단축되었다.    이번에는 메모리를 비교해보자.\n  \u0026gt; import sys # 크기를 늘렸다. \u0026gt; L = [1,2,3,4,5,6,7,8,9,10] \u0026gt; comprehension_list=[lazy_return(i) for i in L] \u0026gt; print(sys.getsizeof(comprehension_list)) \u0026gt; generator_exp = (lazy_return(i) for i in L) \u0026gt; print(sys.getsizeof(generator_exp)) 184 #list comprehension 112 # generator  데이터의 크기가 커질수록 제네레이터의 효율성이 더 두드러지게 나타난다!! 이렇게 어떤 값이 실제로 쓰일 때까지 그 값의 연산을 뒤로 미루는 방식을 Lazy Evaluation이라 한다.  4. Generator 관련 중요 함수들  Generator 관련 함수들은 itertools를 import하는 것부터 시작한다. 계속 복습을 하면서 활용해보도록 하자.  4.1 itertools.count(시작값, 증가값)  첫 번째는 itertools.count(시작값, 증가값) 이다. 시작값에서 증가하여, 증가값만큼 커져서 무한히 출력된다.  \u0026gt; import itertools # 숫자 무한대로 만들기 \u0026gt; gen1 = itertools.count(1, 2.5) \u0026gt; print(next(gen1)) 1 \u0026gt; print(next(gen1)) 3.5 \u0026gt; print(next(gen1)) 6.0 \u0026gt; print(next(gen1)) 8.5 4.2 itertools.takewhile(predicate, iter)  두 번째는 itertools.takewhile(predicate, iter) 다. iter의 원소들 중 predicate의 조건에 참인 값들을 반환한다. predicate는 영어 단어 자체의 의미로는 영어 문법의 서술부를 의미한다.  # gen1 에 람다함수로 조건을 추가한다. # 아래 조건은 range(1,1000, 2.5) 와 동일하다. \u0026gt; gen2 = itertools.takewhile(lambda n : n \u0026lt; 1000, itertools.count(1, 2.5)) # 이렇게 for문과 같이 쓰인다. \u0026gt; for v in gen2: \u0026gt; print(v) 1 3.5 ... 998.5 4.3 itertools.filterfalse(predicate, iter)  세 번째는 itertools.filterfalse(predicate, iter) 이다. 두 번째인 itertools.takewhile과 반대 의미를 가진 함수다. iter 원소들 중에서 predicate의 조건에 부정인 값들을 반환한다.  # 필터 반대 \u0026gt; gen3 = itertools.filterfalse(lambda n : n \u0026lt; 3, [1,2,3,4,5]) \u0026gt; for v in gen3: \u0026gt; print(v) 3 4 5 4.4 itertools.accumulate(iterable, func=operator.add)  네 번째는 itertools.accumulate(iterable, func=operator.add) 이다. iterable의 누적 합계나, 다른 이항함수 func의 누적 결과를 반환하는 iterator를 만든다. 총 원소 수가 n개라고 할 때,  iterable[0], iterable[0] + iterable[1], \u0026hellip;, iterable[0]+ ~ + iterable[n-1]    # 누적 합계 \u0026gt; gen4 = itertools.accumulate([x for x in range(1, 101)]) \u0026gt; for v in gen4: \u0026gt; print(v) 1 3 6 ... 5050 4.5 itertools.chanin(*itertables)  다섯 번째는 itertools.chanin(*itertables)이다. 첫 번째 iterable에서 소진될 때까지 원소들을 반환한 후, 다음 이터러블로 넘어간다. 이런 식으로 iterables의 모든 iterable이 소진될 때까지 진행하는 iterator를 만든다.  # 연결1 \u0026gt; gen5 = itertools.chain(\u0026#39;ABCDE\u0026#39;, range(1,11,2)) \u0026gt; print(list(gen5)) [\u0026#39;A\u0026#39;, \u0026#39;B\u0026#39;, \u0026#39;C\u0026#39;, \u0026#39;D\u0026#39;, \u0026#39;E\u0026#39;, 1, 3, 5, 7, 9] # 연결2 # enumerate를 통해서 index와 value를 mapping 했다. \u0026gt; gen6 = itertools.chain(enumerate(\u0026#39;ABCDE\u0026#39;)) \u0026gt; print(list(gen6)) [(0, \u0026#39;A\u0026#39;), (1, \u0026#39;B\u0026#39;), (2, \u0026#39;C\u0026#39;), (3, \u0026#39;D\u0026#39;), (4, \u0026#39;E\u0026#39;)] 4.6 itertools.product(*iterables, repeat=)  여섯 번째는 itertools.product(*iterables, repeat=1) 다. 입력 이터러블들(iterables)의 데카르트 곱을 반환한다. 대략 제너레이터 표현식에서의 중첩된 for-루프와 동일하다. 예를 들어 product(A, B)는 ((x,y) for x in A for y in B)와 같은 것을 반환한다.  # 개별 \u0026gt; gen7 = itertools.product(\u0026#39;ABCDE\u0026#39;) \u0026gt; print(list(gen7)) gen7 - [(\u0026#39;A\u0026#39;,), (\u0026#39;B\u0026#39;,), (\u0026#39;C\u0026#39;,), (\u0026#39;D\u0026#39;,), (\u0026#39;E\u0026#39;,)] # 연산(경우의 수) # repeat = 2는 .product(\u0026#39;ABCDE\u0026#39;, \u0026#39;ABCDE\u0026#39;) 와 동일하다. \u0026gt; gen8 = itertools.product(\u0026#39;ABCDE\u0026#39;, repeat=2) \u0026gt; print(list(gen8)) [(\u0026#39;A\u0026#39;, \u0026#39;A\u0026#39;), (\u0026#39;A\u0026#39;, \u0026#39;B\u0026#39;), (\u0026#39;A\u0026#39;, \u0026#39;C\u0026#39;), (\u0026#39;A\u0026#39;, \u0026#39;D\u0026#39;), (\u0026#39;A\u0026#39;, \u0026#39;E\u0026#39;), (\u0026#39;B\u0026#39;, \u0026#39;A\u0026#39;), (\u0026#39;B\u0026#39;, \u0026#39;B\u0026#39;), (\u0026#39;B\u0026#39;, \u0026#39;C\u0026#39;), (\u0026#39;B\u0026#39;, \u0026#39;D\u0026#39;), (\u0026#39;B\u0026#39;, \u0026#39;E\u0026#39;), (\u0026#39;C\u0026#39;, \u0026#39;A\u0026#39;), (\u0026#39;C\u0026#39;, \u0026#39;B\u0026#39;), (\u0026#39;C\u0026#39;, \u0026#39;C\u0026#39;), (\u0026#39;C\u0026#39;, \u0026#39;D\u0026#39;), (\u0026#39;C\u0026#39;, \u0026#39;E\u0026#39;), (\u0026#39;D\u0026#39;, \u0026#39;A\u0026#39;), (\u0026#39;D\u0026#39;, \u0026#39;B\u0026#39;), (\u0026#39;D\u0026#39;, \u0026#39;C\u0026#39;), (\u0026#39;D\u0026#39;, \u0026#39;D\u0026#39;), (\u0026#39;D\u0026#39;, \u0026#39;E\u0026#39;), (\u0026#39;E\u0026#39;, \u0026#39;A\u0026#39;), (\u0026#39;E\u0026#39;, \u0026#39;B\u0026#39;), (\u0026#39;E\u0026#39;, \u0026#39;C\u0026#39;), (\u0026#39;E\u0026#39;, \u0026#39;D\u0026#39;), (\u0026#39;E\u0026#39;, \u0026#39;E\u0026#39;)] 4.7 itertools.groupby(iterable, key = none)  일곱 번쨰는 itertools.groupby(iterable, key = none) 이다. (분류기준, 분류기준으로 묶인 데이터) 순서인 tuple로 값을 반환한다.  # 그룹화 \u0026gt; gen9 = itertools.groupby(\u0026#39;AAABBCCCCDDEEE\u0026#39;) \u0026gt; for chr, group in gen9: \u0026gt; print(chr, \u0026#39; : \u0026#39;, list(group)) A : [\u0026#39;A\u0026#39;, \u0026#39;A\u0026#39;, \u0026#39;A\u0026#39;] B : [\u0026#39;B\u0026#39;, \u0026#39;B\u0026#39;] C : [\u0026#39;C\u0026#39;, \u0026#39;C\u0026#39;, \u0026#39;C\u0026#39;, \u0026#39;C\u0026#39;] D : [\u0026#39;D\u0026#39;, \u0026#39;D\u0026#39;] E : [\u0026#39;E\u0026#39;, \u0026#39;E\u0026#39;, \u0026#39;E\u0026#39;]  Reference  인프런 파이썬 중급 itertools — Function to create an etherator for efficient looping Python - generator  ","permalink":"http://jeha00.github.io/post/python_basic/python_basic_36_generator_2/","summary":"Generator 1에 이어서 본격적으로 Generator에 대해 알아본다. 그리고, Generator와 관련된 중요 함수들도 알아본다.","title":"[TIL] Python basic 36: Generator 2"},{"content":"Dev-contents를 만든 목적과 이유는???  개발 관련 좋은 컨텐츠를 보관하고 섭취하기\n   컨텐츠의 종류는 한정되어 있지 않습니다.\n 유익한 개발 관련 컨텐츠를, 주제별로 나눠서 각 주제별로 앞으로 볼 것, 다 본 것들, 현재 보고 있는 것으로 나누고 어느 부분을 중점적으로 공부했는지 직관적으로 알 수 있기 때문입니다.    지난 주에 구매했던 업무와 일상을 정리하는 새로운 방법 Notion을 보고 notion으로 정리 후, 블로그에 업데이트했습니다.\n  정리수단으로 notion을 결정한 이유는 다음과 같습니다.\n block을 이동하기가 쉽습니다. 여러 단락으로 나눠서 사용할 수 있습니다. toggle button이 있어 훨씬 깔끔합니다. 이미지 첨부나, table 등등 만들기가 용이합니다. 나중에 협업 도구로 notion을 사용해볼 생각이라, 미리 익히고 싶었습니다. 디자인이 제 취향에 맞았습니다.    notion에 정리한 후, Github blog에 주기적으로 업로드할 예정입니다.\n 업데이트 날짜 또한 표시합니다.    📚은 서적을, 💻은 인터넷 강의를, 🖊️ 은 블로그 포스팅 글을 말합니다.\n  Doing과 Done의 경우, 위에 있을 수록 최신의 것을 말합니다.\n   OS   Will\n  Doing\n 📚 운영체제와 정보기술의 원리 - 반효경 지음 - 💻 KOCW 운영체제 이화여자대학교 - 반효경 -    Done\n   Network   Will\n 💻 KOCW 컴퓨터 네트워크 한양대학교 - 이석복 -    Doing\n  Done\n 💻 모든 개발자를 위한 HTTP 웹 기본 지식     Algorithum   Will\n 📚 알고리즘 문제해결전략 1,2 세트    Doing\n 📚 자료구조와 함께 배우는 알고리즘 입문 파이썬편    Done\n   Cloud   Will\n 📚 따라하며 배우는 AWS 네트워크 입문    Doing\n  Done\n   Docker  Will Doing Done   Linux   Will\n  Doing\n 📚 실습과 그림으로 배우는 리눅스 구조 -    Done\n   Python   Will\n 💻 level 4 고수가 되는 파이썬: 동시성과 병렬성 문법 배우기 Feat. 멀티스레딩 vs 멀티프로세싱 (Inflearn Original)    Doing\n 💻 level 3 모두를 위한 파이썬 : 필수 문법 배우기 Feat. 오픈소스 패키지 배포 (Inflearn Original)    Done\n 💻 level 2 우리를 위한 프로그래밍 : 파이썬 중급 (Inflearn Original) 💻 level 1 프로그래밍 시작하기 : 파이썬 입문 (Inflearn Original) 📚 Do it! 첫 코딩 with 파이썬     Django   Will\n  Doing\n 💻 파이썬/장고 웹서비스 개발 완벽 가이드 with 리액트    Done\n   생산성 도구   Will\n  Doing\n 📚 Pro Git 2 edition    Done\n 📚 업무와 일상을 정리하는 새로운 방법 Notion     개발 문화 \u0026amp; 개발 life \u0026amp; 공부법   Will\n 🖊️ 개발자가 공부로 살아남는 방법 🖊️ 나는 어떻게 공부했는가? 🖊️ 개발자의 평생공부 🖊️ 프로그래머로서의 성장을 도왔던 태도들 🖊️ 프레임 공부를 멈춰라 🖊️ 회사 밖에서 성장하기 🖊️ 어려운 것을 쉽게 배우는 방법: 슈퍼 파워 장착을 위한 3단계 학습법 🖊️ 개발자는 어떻게 성장해야 할까 🖊️ 어려운 것을 쉽게 배우는 방법 🖊️ 내게 실용적이었던 프로그래밍 공부 방법들 🖊️ 더 나은 개발자가 되는 8가지 방법 🖊️ 개발 배우기가 정말 어려운 이유 🖊️ 개발자의 성장에 대한 이야기 (주니어, 기술, 팀, 이직, 자기 PR) 🖊️ 초보 웹 개발자를 위한 학습 안내서 🖊️ 개발자를 꿈꾸는 취업 준비생에게    Doing\n  Done\n 🖊️ 프로그래밍 학습 방법 🖊️ 학습에 실패한 이야기 🖊️ 개발자가 실력을 향상시킬 방법은 OO뿐이에요. 반복     기술 면접  Will Doing Done   비전공자 \u0026amp; 신입   Will\n 🖊️ 주니어 개발자를 위한 취업 정보 모음 🖊️ Technical Interview Guidelines for beginners 🖊️ 개발자 블로그 모음 🖊️ 개발자 회고 모음 🖊️ iOS 개발에 대한 질문과 답변 모음    Doing\n  Done\n 🖊️ 3 번째 직장에 오기까지 시리즈 🖊️ 체대 출신 개발자의 연말 회고 시리즈 🖊️ 문돌이가 개발자가 되기까지 시리즈 🖊️ 문과생의 카카오 개발자 이직기 시리즈 🖊️ 늦은 나이, 개발자로 시작해도 좋을까요 - 30대 초반 비전공자의 고민 🖊️ 문과생 비전공자가 웹 개발자가 되기까지.. 🖊️ 32살에 개발에 입문한 비전공자가 인프런 창업한 이야기 (슬라이드) 🖊️ 야 너두 할 수 있어. 비전공자, COBOL 개발자를 거쳐 네이버에서 FE 개발하게 된 이야기 (영상) 🖊️ 비전공자로 개발자 커리어를 시작하는 사람들에게 (영상) 🖊️ 비전공자가 개발자가 되기까지(feat. Wecode) 💻 비전공자를 위한 개발자 취업 올인원 가이드 [통합편] 📚 비전공자를 위한 이해할 수 있는 IT 지식 📚 코딩 진로: IT 진로를 고민하는 이들을 위한 지침서     ","permalink":"http://jeha00.github.io/post/dev-contents/","summary":"Updated on March 31   /  개발 관련 좋은 컨텐츠를 보관하고 섭취하기","title":"Dev-Contents"},{"content":"Intro  병행성을 위한 방법으로 generator와 coroutine을 알아보고자 한다. 이번 포스팅에서는 __iter__와 __next__ 을, 다음 포스팅에서는 generator를 알아본다. 그러면 첫 번째로 병행성이 무엇을 의미하는 건지, 이와 유사한 개념으로 병렬성은 무엇인지 학습한다. 두 번째로, Generator를 이해하기 위해서 __iter__와 __next__ 을 먼저 학습한다.   1. 병행성과 병렬성이란??   병행성(Concurrency): 한 컴퓨터가 여러 일을 동시에 수행하는 것 -\u0026gt; 동시 수행 병렬성(parallelism): 여러 컴퓨터가 여러 작업을 동시에 수행하는 것 -\u0026gt; 속도 향상    병행성 은 단일 프로그램 안에서 여러 일을 쉽게 해결하기 위해 사용된다.  thread는 하나지만, 마치 동시에 일을 하고 있는 것처럼 수행한다. 예) 공부하다가 강의 멈춰놓고, 밥 먹고 와서 강의를 중단한 부분부터 다시 시작하기   파이썬에서는 병행성 과 병렬성 을 모두 지원한다. 그리고, 파이썬 실력을 결정하는 중요한 내용이다.   2. __iter__와 __next__ 2.1 __iter__와 __next__ 용어 정리   __iter__  __iter__: iter() built-in function이 호출하는 메소드 iter(): 호출된 __iter__의 return 값을 반환한다. 즉, iterator는 __iter__ method가 만든다.   __next__  __next__: next() built-in function이 호출하는 메소드      iter 가 있는 용어들에 대해 정리하면서 알아보자.    iteration 이란??\n  The process of looping through the objects or items in a collection\n  그러면 파이썬에서 iteration 상황은 무엇이 있을까??\n  Definite iteration 상황: 미리 반복 횟수를 명백하게 정한 상황. ex) for 문\n  Indefinite iteration 상황: 몇 가지 조건이 만족될 때까지 code block을 실행하는 상황. ex) while 문\n      iterable의 의미는 2가지로 사용된다.\n An object(or the adjective used to describe an object) that can be iterated over __iter__을 가지고 있는 객체    이 iterable한 객체 또는 iterable을 iter()에 인자로서 전달하여 반환되는 것을 interator라 불린다.\n  그리고, iter()는 __iter__ method의 return 값(iterator)을 반환하는 함수다.\n The built-in function used to obtain an iterator from an iterable    즉, iterator의 의미는\n The object that produces successive items or values from its associated iterable  iterable object로부터 연속적인 값을 낳는(yield) 값 생성기   iter()로 만들어지는 객체 next() function의 기준으로 보자면, __next__을 가지고 있는 객체    2.2 Iterator 관련 data type  iterator를 반환하는 data type들:  for, collections, string, list, dict, set, tuple, unpacking, *args    # string \u0026gt; iter(\u0026#39;foobar\u0026#39;) \u0026lt;str_iterator object at 0x036E2750\u0026gt; # list \u0026gt; iter([\u0026#39;foo\u0026#39;, \u0026#39;bar\u0026#39;, \u0026#39;baz\u0026#39;]) \u0026lt;list_iterator object at 0x036E27D0\u0026gt; # tuple \u0026gt; iter((\u0026#39;foo\u0026#39;, \u0026#39;bar\u0026#39;, \u0026#39;baz\u0026#39;)) \u0026lt;tuple_iterator object at 0x036E27F0\u0026gt; # set \u0026gt; iter({\u0026#39;foo\u0026#39;, \u0026#39;bar\u0026#39;, \u0026#39;baz\u0026#39;}) \u0026lt;set_iterator object at 0x036DEA08\u0026gt; # dict \u0026gt; iter({\u0026#39;foo\u0026#39;: 1, \u0026#39;bar\u0026#39;: 2, \u0026#39;baz\u0026#39;: 3}) \u0026lt;dict_keyiterator object at 0x036DD990\u0026gt;  iterator를 반환하지 않는 data type들  Integer, foat, built-in functions    # Integer \u0026gt;\u0026gt; iter(42) Traceback (most recent call last): File \u0026#34;\u0026lt;pyshell#26\u0026gt;\u0026#34;, line 1, in \u0026lt;module\u0026gt; iter(42) TypeError: \u0026#39;int\u0026#39; object is not iterable # Float \u0026gt;\u0026gt;\u0026gt; iter(3.1) Traceback (most recent call last): File \u0026#34;\u0026lt;pyshell#27\u0026gt;\u0026#34;, line 1, in \u0026lt;module\u0026gt; iter(3.1) TypeError: \u0026#39;float\u0026#39; object is not iterable # Built-in functions \u0026gt;\u0026gt;\u0026gt; iter(len) Traceback (most recent call last): File \u0026#34;\u0026lt;pyshell#28\u0026gt;\u0026#34;, line 1, in \u0026lt;module\u0026gt; iter(len) TypeError: \u0026#39;builtin_function_or_method\u0026#39; object is not iterable 2.3 iter() 과 next() 예제  내장함수 next()는 값 생성기 iterator으로부터 다음 값을 얻기 위해 사용된다.  # a는 iterable list다. \u0026gt; a = [\u0026#39;foo\u0026#39;, \u0026#39;bar\u0026#39;, \u0026#39;baz\u0026#39;] # iter을 통해서 a의 iterator를 만든다. \u0026gt; itr = iter(a) \u0026gt; itr \u0026lt;list_iterator object at 0x031EFD10\u0026gt; # nest()를 통해서 itr 안의 다음 값을 얻는다. \u0026gt; next(itr) \u0026#39;foo\u0026#39; \u0026gt; next(itr) \u0026#39;bar\u0026#39; \u0026gt; next(itr) \u0026#39;baz\u0026#39; # 값이 다 소진되면 다음과 같은 Error를 띄운다. \u0026gt; next(itr) StopIteration  만약 iterator로 전환하지 않고, 그냥 사용한다면??? iterator가 아니므로 next()를 사용할 수 없다. 즉 __iter__을 호출하여 전환해야 사용이 가능하다.  \u0026gt; w = [1,2,3,4,5] # iter()로 iterator로 전환하지 않았기 때문에 __next__가 없다. \u0026gt; print(dir(w)) [\u0026#39;__add__\u0026#39;, \u0026#39;__class__\u0026#39;, \u0026#39;__iter__\u0026#39;, ..... \u0026#39;sort\u0026#39;] \u0026gt; print(next(w)) TypeError: \u0026#39;list\u0026#39; object is not an iterator 2.4 iter() 과 next() 토대로 for문 이해하기  그러면 __iter__ 과 __next__를 토대로 for 문을 이해해보자.  \u0026gt; t = \u0026#39;ABCDEF\u0026#39; \u0026gt; for c in t: \u0026gt; print(c) A B C D E F  어떻게 해서 하나씩 출력되는 것일까??? for문의 구조를 다시 확인해보자  \u0026gt; for \u0026lt;var\u0026gt; in \u0026lt;iterable\u0026gt;: \u0026gt; \u0026lt;statement(s)\u0026gt;   in 다음에는 iterable이 온다. 그러면 어떻게 하나씩 반환될까??\n __iter__ 과 __next__ 와 연결시켜보자. iteralbe을 입력하면 for문에서 iter()을 호출하여 iterable객체를 iterator로 바꾼 후, __next__ method를 통해 하나씩 출력된는 원리라는 걸 이해할 수 있다.    위에 for문을 while문으로 만들어서 구체적으로 이해해보자.\n  \u0026gt; t = \u0026#39;ABCDEF\u0026#39; \u0026gt; while True: \u0026gt; try: \u0026gt; print(next(t)) # iterator의 내부 성분이 다 출력되면 Error가 발생되고, 중단된다. \u0026gt; except Stopiteration \u0026gt; break 2.5 __iter__ 확인하는 방법 \u0026gt; t = \u0026#39;ABCDEF\u0026#39; # 첫 번째 방법 # 이 방법은 눈으로 찾아봐야하기 때문에, 추천하지 않는다. \u0026gt; print(dir(t)) [\u0026#39;__add__\u0026#39;, \u0026#39;__iter__\u0026#39;, \u0026#39;__le__\u0026#39;, ....\u0026#39;] # 두 번째 방법 # hasattr = has attribution # t가 __iter__를 가지고 있는가?? \u0026gt; print(hasattr(t, \u0026#39;__iter_\u0026#39;)) True # 세 번째 방법 \u0026gt; print(isinstance(t, abc.Iterable)) True 2.6 class로 __next__ 구현하기 \u0026gt; class WordSplitter: \u0026gt; def __init__(self, text): \u0026gt; self._idx = 0 \u0026gt; self._text = text.split(\u0026#39;\u0026#39;) \u0026gt; def __next__(self): \u0026gt; print(\u0026#39;Called __next__\u0026#39;) \u0026gt; try: \u0026gt; word = self._text[self._idx] \u0026gt; except IndexError: \u0026gt; raise StopIteration(\u0026#39;Stopped Iteration\u0026#39;) \u0026gt; self._idx += 1 \u0026gt; return word \u0026gt; def __repr__(self): \u0026gt; return \u0026#39;WordSplit(%s)\u0026#39; % (self._text) \u0026gt; wi = WordSplitter(\u0026#39;Do today what you could do tomorrow\u0026#39;) \u0026gt; print(wi) WordSplit([\u0026#39;Do\u0026#39;, \u0026#39;today\u0026#39;, \u0026#39;what\u0026#39;, \u0026#39;you\u0026#39;, \u0026#39;could\u0026#39;, \u0026#39;do\u0026#39;, \u0026#39;tomorrow\u0026#39;]) \u0026gt; print(next(wi)) Do \u0026gt; print(next(wi)) today \u0026gt; print(next(wi)) what \u0026gt; print(next(wi)) you \u0026gt; print(next(wi)) could \u0026gt; print(next(wi)) do \u0026gt; print(next(wi)) tomorrow  구현했지만, 코드량이 많아진다. 그러면 제네레이터를 사용해서 구현해보자.  \u0026gt; class WordSplitter: \u0026gt; def __init__(self, text): # 인덱스를 기억하지 않아도 된다. \u0026gt; self._text = text.split(\u0026#39;\u0026#39;) \u0026gt; def __next__(self): \u0026gt; for word in self._text: # 이것이 제네레이터이며, 이 제네레이터가 위치 정보를 기억한다. # 따로 예외처리를 하지 않아도 된다. \u0026gt; yield word \u0026gt; return \u0026gt; def __repr__(self): \u0026gt; return \u0026#39;WordSplit(%s)\u0026#39; % (self._text) \u0026gt; wi = WordSplitter(\u0026#39;Do today what you could do tomorrow\u0026#39;) \u0026gt; wt = iter(wg) # 출력 코드는 동일.  Reference  인프런 파이썬 중급 04-3 제너레이터와 yield(feat. return 문) (널널한 교수의 고급 파이썬) ft. 파이썬 코딩  ","permalink":"http://jeha00.github.io/post/python_basic/python_basic_35_generator_1/","summary":"첫 번째, 병행성과 병렬성이란 무엇인지 각 개념에 대해 알아본다.  두 번째, Generator를 이해하기 위해 __iter__와 __next__에 대해 알아본다.","title":"[TIL] Python basic 35: Generator 1"},{"content":"Intro  Closure에 이어서 decorator(데코레이터)에 대해 알아보자.   1. Decorator가 중요한 이유   데코레이터를 사용하기는 쉽지만, 작성하기는 어렵다고 한다.\n  왜냐하면 여러가지 개념들이 합쳐져 있기 때문이다.\n  파이썬의 전반적인 과정을 이해해야 가능하다.\n Closure(클로저) -\u0026gt; [TIL] Python basic 33: Closure firt-class(일급 함수) -\u0026gt; [TIL] Python basic 31: First-class 가변 인자(*args, **args) -\u0026gt;[TIL] Python basic 12: Method 인자 풀기(unpacking) -\u0026gt;[TIL] Python basic 12: Method 파이썬이 소스 코드를 불러오는 자세한 과정   from 파이썬 데코레이터를 작성하는 법을 배워야 하는 5가지 이유      그렇다면 왜 데코레이터를 배워야하는가???\n 장점    중복 제거, 코드 간결, 공통 함수 작성\n 프로그래밍 언어의 패러다임이 이런 방식으로 진행된다.    로깅, 프레임워크, 유효성 체크\n 이러한 기능들을 가지는 함수를 만들어서 공통 기능으로 사용 가능하다. 파이썬 기반 프레임 워크의 많은 비중이 데코레이터로 설계되어 있다.    조합해서 사용 용이\n    단점\n 가독성 감소 특정 기능에 한정된 함수는 단일 함수로 작성하는 것이 유리 디버깅 불편    from 인프런 파이썬 중급\n   2. Closure의 기본 패턴  데코레이터는 클로저와 형태가 유사하다. 그래서, 특히 클로저를 이해하지 못하면 데코레이터를 만들 수 없다. 자바에서는 어노테이션이라 한다.  ## closure의 기본 패턴 # outer function \u0026gt; def perf_clock(func): # inner function(nested function) # closure \u0026gt; def perf_clocked(*args): \u0026gt; # inner function의 결과 반환 \u0026gt; return result \u0026gt; # inner function 반환 \u0026gt; return perf_clocked  3. Decorator 실습 예제  decorator를 직접 구현해보자. 모든 함수가 실행될 때마다 performance를 체크하는 함수를 만들 것이다. perf_counter: time module에 있는 method로, 코드 실행 시간을 측정한다.  3.1 Decorator로 사용할 function 만들기 \u0026gt; import time \u0026gt; def perf_clock(func): \u0026gt; def perf_clocked(*args): \u0026gt; # st = start time \u0026gt; st = time.perf_counter() \u0026gt; # outer function의 argument인 func이 inner function 안에서 실행된다. \u0026gt; # 그래서 자유 변수가 된다. \u0026gt; result = func(*args) \u0026gt; # et = end time \u0026gt; et = time.perf_counter() - st \u0026gt; # func의 이름 \u0026gt; name = func.__name__ \u0026gt; # arg로 구성된 문자열이 arg_str에 할당된다. \u0026gt; arg_str = \u0026#39;, \u0026#39;.join(repr(arg) for arg in args) \u0026gt; print(\u0026#39;[%0.5fs] %s(%s) -\u0026gt; %r\u0026#39; % (et, name, arg_str, result)) \u0026gt; return result \u0026gt; return perf_clocked 3.2 Decorator 없이 사용하기  그러면 데코레이터를 사용하지 않고, 위 function을 사용해보자.  \u0026gt; def time_func(seconds): \u0026gt; time.sleep(seconds) \u0026gt; def sum_func(*numbers): \u0026gt; return sum(numbers) \u0026gt; none_deco1 = perf_clock(time_func) \u0026gt; none_deco2 = perf_clock(sum_func) \u0026gt; print(none_deco1, none_deco1.__code__co_freevars) \u0026lt;function perf_clock.\u0026lt;locals\u0026gt;.perf_clocked at 0x0000021629F6FCA0\u0026gt; (\u0026#39;func\u0026#39;,) \u0026gt; print(none_decow, none_deco2.__code__co_freevars) \u0026lt;function perf_clock.\u0026lt;locals\u0026gt;.perf_clocked at 0x0000021629F6FD30\u0026gt; (\u0026#39;func\u0026#39;,) \u0026gt; print(\u0026#39;-\u0026#39; * 40, \u0026#39;Called None Decorator -\u0026gt; time_func\u0026#39;) ---------------------------------------- Called None Decorator -\u0026gt; time_func \u0026gt; none_deco1(1.5) [1.51397s] time_func(1.5) -\u0026gt; None \u0026gt; print(\u0026#39;-\u0026#39; * 40, \u0026#39;Called None Decorator -\u0026gt; sum_func\u0026#39;) ---------------------------------------- Called None Decorator -\u0026gt; sum_func \u0026gt; none_deco2(100, 150, 250, 300, 350) [0.00001s] sum_func(100, 150, 250, 300, 350) -\u0026gt; 1150   위 코드의 매커니즘에 대해 알아보자.\n  첫 번째, perf_clock(func) 의 func 인자에 time_func을 할당했다.\n  두 번째, perf_clock(time_func)의 return 값인 perf_clocked fuction을 none_deco1에 할당했다.\n  세 번째,\n  inner fuction인 perf_clocked(**args) function의 자유변수인 func에 time_func가 할당된 상태로, none_deco1에 할당된다.\n  그러면 인자 func 그리고 **args 중에서 할당되지 않은 인자는 **args다.\n    다섯 번째,\n  none_deco1(1.5)를 선언하면서 **args에 1.5가 할당된다.\n  none_deco2(100, 150, 250, 300, 350)은 **args에 100, 150, 200, 300, 350이 할당.\n      이처럼 지난 firt-class에서 알아본 partial처럼 하나씩 고정인수를 만들어간다.\n  이 방식이 가능한 이유는 closure의 개념을 이용했기 때문이다.\n  3.3 Decorator로 사용하기  이번에는 데코레이터를 사용해본다. decorator를 사용하니 코드가 훨씬 간결해진 걸 확인해보자.  \u0026gt; @perf_clock \u0026gt; def time_func(seconds): \u0026gt; time.sleep(seconds) \u0026gt;@perf_clock \u0026gt; def sum_func(*numbers): \u0026gt; return sum(numbers) \u0026gt; print(\u0026#39;*\u0026#39; * 40, \u0026#39;Called Decorator -\u0026gt; time_func\u0026#39;) **************************************** Called Decorator -\u0026gt; time_func \u0026gt; time_func(1.5) [1.49993s] time_func(1.5) -\u0026gt; None \u0026gt; print(\u0026#39;*\u0026#39; * 40, \u0026#39;Called Decorator -\u0026gt; sum_func\u0026#39;) **************************************** Called Decorator -\u0026gt; sum_func \u0026gt; sum_func(100, 150, 250, 300, 350) [0.00001s] sum_func(100, 150, 250, 300, 350) -\u0026gt; 1150   Decorator를 사용하면 별도의 변수에 함수를 할당할 필요가 없다.\n  @perf_clock을 time_func와 sum_func 위에 각각 입력하여 time_func와 sum_func의 decorator로 사용한다.\n  위에 각각 입력하는 의미는 perf_clock의 func 인자에 time_func와 sum_func을 할당하여 고정시킨다.\n  이 다음으로 time_func(1.5) 와 time_func(100, 150, 250, 300, 350)처럼 **args 가변인자를 사용하여 할당한다.\n   이처럼 decorator는 closure, firt-class, 가변인자, packing \u0026amp; unpacking 개념을 사용한다.   Reference  인프런 파이썬 중급 파이썬 데코레이터를 작성하는 법을 배워야 하는 5가지 이유  ","permalink":"http://jeha00.github.io/post/python_basic/python_basic_34_decorator/","summary":"Decorator(데코레이터)가 왜 중요한지, 왜 사용해야 하는지 그리고 작성하기 어려운 지에 대해 알아본다.","title":"[TIL] Python basic 34: Decorator"},{"content":"Intro  Closure가 필요한 이유 그리고, 잘못 사용된 사례에 대해 알아보자.   1. UnboundLocalError  전역 변수와 지역 변수에 대해 간단히 복습해보자.  # global (전역) 변수 \u0026gt; c = 30 \u0026gt; def func_v3(a): \u0026gt; print(a) \u0026gt; # local (지역) 변수 \u0026gt; print(c) \u0026gt; c = 40 \u0026gt; func_v3(10) UnboundLocalError: local variable \u0026#39;c\u0026#39; referenced before assignmnet   func_v3를 정의하기 전에 c에 값을 할당했다.\n  그래서 func_v3 안에 값은 이름의 c 와 이어질거라 생각했지만, Error가 떴다.\n  Error의 의미:\n c 라는 변수에 값이 할당되지 않았는데, print(c)로 참조되었다. 함수 블럭에서 할당하는 건 지역 변수다. 하지만, name이 같아도 함수 밖에서 할당했기 때문에 전역 변수로 인식하여 다르다.    해결책\n function block 안에 global 선언을 하든가, nonlocal 선언을 한다. local scope에서 전역으로 쓸 수 있는 방법이다.    \u0026gt; c = 30 \u0026gt; def func_v3(a): \u0026gt; global c \u0026gt; print(a) \u0026gt; print(c) \u0026gt; c = 40 # 함수 실행 전 이므로 30이 출력된다. \u0026gt; print(\u0026#39;\u0026gt;\u0026gt;\u0026#39;,c) 30 \u0026gt; func_v3(10) 10 30 # 함수 실행 후에는 40이 출력된다. \u0026gt; print(\u0026#39;\u0026gt;\u0026gt;\u0026gt;\u0026#39;,c) 40   해결책의 문제점\n 함수 내에 global 또는 nonlocal을 쓰는 건 좋은 방법이 아니다. 왜냐하면 함수 내에 전역 변수와 연결되는 게 있다면 디버깅 할 때 쉽지 않다. 그래서 위의 statement로 local에서 수정하는 건 권하지 않는다.    그래서 또 다른 방법이 바로 closure(클로저) 다.\n  이 클로저에 대해 알아보자.\n   2. Closure 2.1 What is closure ??  [Reference에 따른 closure 정의]\n 외부에서 호출된 함수의 변수값, 상태(레퍼런스)를 복사 후 저장한다. 그 후에 접근(액세스)이 가능하도록 하는 도구     scope을 기준으로 설명하자면\n  Closure란 enclosing scope에 있는 자유변수(free variable)를 이 scope의 실행이 종료되도 보유하고 있는 내부 함수 또는 중첩함수를 말한다.\n  자유변수(free variable)란??\n 정의되지 않은 code block에 사용되는 변수 여러 번 호출이 일어나도 상태 정보를 보유하기 위해 closure가 사용하는 원리      closure는 outer function을 호출해서 innter function을 return 했지만, outer function의 enclosing scope 에 있던 자유변수(free variable)를 계속해서 기억한다.\n  그래서, 함수실행이 끝나도 그 시점의 변수를 이어서 작업할 수 있다.\n  2.2 Why does we need closure ??   함수 안에 선언된 것들이 함수의 실행이 끝나서 소멸되면 변수 값도 사라지지만, closure를 사용하면 기억된다.\n  서버 프로그래밍의 관점에서 closure를 바라보면\n 서버 프로그래밍에서 어려운 것이 동시성(Concurrency) 제어다. 한정된 메모리 공간에서 여러 자원이 접근하면 교착상태(Dead lock)에 부딪힌다. 이를 해결하는 게 동시성(Concurrency) 제어다. closure는 불변자료 (immutable, Read Only) 구조 및 atom, STM 이므로 multi-thread 프로그래밍에 강점을 가진다. multi-thread가 아닌 단일 thread인데도 동시성을 갖도록 하는 기반이 되는 게 바로 이 closure다.    또한, 이 클로저는 함수형 프로그래밍에도 연결된다.\n  위 관점에 대해서는 그렇구나 정도만 알고 넘어가자. 나중에 차차 알아보자.\n  그러면 class를 사용하여 closure가 무엇인지 구현해보자.\n  # global scope \u0026gt; class Avenager(): # enclosing scope \u0026gt; def __init__(self): \u0026gt; self._series = [] # local scope # special method __call__은 class를 function처럼 호출해서 사용하도록 한다. \u0026gt; def __call__(self, v): \u0026gt; self._series.append(v) \u0026gt; print(\u0026#39;inner \u0026gt;\u0026gt;\u0026gt; {} / {}\u0026#39;.format(self._series, len(self, series))) \u0026gt; return sum(self._series) / len(self._series) # local scope # 인스턴스 생성 \u0026gt; averager_cls = Averager() # 누적 # instance를 생성했는데, function처럼 사용하고 있다. # Avenger()를 사용하면 __call_ method의 return 값이 출력된다. \u0026gt; print(averager_cls(15)) \u0026gt; print(averager_cls(35)) \u0026gt; print(averager_cls(40)) inner \u0026gt;\u0026gt;\u0026gt; [15] / 1 15.0 inner \u0026gt;\u0026gt;\u0026gt; [15, 35] / 2 25.0 inner \u0026gt;\u0026gt;\u0026gt; [15, 35, 40] / 3 30.0  위의 예시처럼 class 실행이 끝나서, 변수가 소멸되야 하는데 유지되고 있다. 상태를 기억하고 있기 때문에 계속해서 누적된다. 그래서 중간부터 해도 이어서 할 수 있다.   3. Exercises for closure  closure는 pattern이 정해져 있다.  # global scope \u0026gt; def closure_ex1(): # closure_ex1의 local scope이면서 # averager(v)의 the enclosing scope 또는 자유영역 # 이 영역에 정의된 변수: series \u0026gt; series = [] \u0026gt; def averager(v): # averager의 local scope \u0026gt; series.append(v) \u0026gt; print(\u0026#39;inner \u0026gt;\u0026gt;\u0026gt; {} / {}\u0026#39;.format(series, len(series))) \u0026gt; return sum(series) / len(series) # 일급 함수의 특징: 함수를 반환할 수 있다. \u0026gt; return averager # make a instance # 반환값인 averager가 avg_closure1에 할당된다. \u0026gt; avg_closure1 = closure_ex1() \u0026gt; print(avg_closure1) \u0026lt;function closure_ex1.\u0026lt;locals\u0026gt;.averager at 0x000001B59D11FC10\u0026gt; # 인자로 입력된 15는 averager function의 인자 v이다. \u0026gt; print(avg_closure1(15)) inner \u0026gt;\u0026gt;\u0026gt; [15] / 1 15.0 \u0026gt; print(avg_closure1(35)) inner \u0026gt;\u0026gt;\u0026gt; [15, 35] / 2 25.0 \u0026gt; print(avg_closure1(40)) inner \u0026gt;\u0026gt;\u0026gt; [15, 35, 40] / 3 30.0  series가 local scope에 있었다면 위 경우처럼 출력할 때 이전 값이 보존되지 않는다. 왜냐하면 averager가 실행이 끝나면 그 안에 local scope에 있던 변수는 소멸된다. 하지만, enclosing scope에 변수를 정의했기 때문에, 함수를 실행할 때마다 자유변수에 접근해서 값이 보존된다. 그래서 새로 추가해도 실행이 가능하다.   그러면 파이썬에서 이 closure를 어떻게 취급하는지 확인해보자.  # function inspection # __closure__ 로 취급된다. # __call__이 있으므로, 호출할 수 있다. \u0026gt; print(dir(avg_closure1)) [\u0026#39;__annotations__\u0026#39;, \u0026#39;__call__\u0026#39;, \u0026#39;__class__\u0026#39;, \u0026#39;__closure__\u0026#39;, \u0026#39;__dict__\u0026#39;, \u0026#39;__dir__\u0026#39;, \u0026#39;__doc__\u0026#39;, \u0026#39;__init__\u0026#39;, \u0026#39;__init_subclass__\u0026#39;, \u0026#39;__kwdefaults__\u0026#39;, \u0026#39;__le__\u0026#39;, \u0026#39;__lt__\u0026#39;, \u0026#39;__module__\u0026#39;, \u0026#39;__name__\u0026#39;] # detail한 함수 목록이 나온다. \u0026gt; print(dir(avg_closure1.__code__)) \u0026gt; print(avg_closure1.__code__.co_freevars) (\u0026#39;series\u0026#39;,) # 자유 변수값을 출력할 수 있다. \u0026gt; print(avg_closure1.__closure__[0].cell_contents) [15, 35, 40]  __code__: 함수가 컴파일되서 바이트코드 상태의 정보를 출력해주는 역할   4. Incorrect use of closures  closure의 잘못된 사용법을 예제로 알아보자.  \u0026gt; def closure_ex3(): \u0026gt; # Free variable \u0026gt; cnt = 0 \u0026gt; total = 0 \u0026gt; def averager(v): # cnt와 total을 자유변수로 만든다. \u0026gt; nonlocal cnt, total \u0026gt; cnt += 1 \u0026gt; total += v \u0026gt; return total / cnt \u0026gt; return averager \u0026gt; avg_closure3 = closure_ex3() \u0026gt; print(avg_closure3(15)) 15.0 \u0026gt; print(avg_closure3(35)) 25.0 \u0026gt; print(avg_closure3(40)) 30.0  바로 위의 예시처럼 nonlocal을 사용하는 방법 그리고, UnboundLocalError를 설명할 때 언급한 global 을 사용하는 법이 잘못된 closure 사용법이다. UnboundLocalError 를 설명한 경우와 달리, 변수를 전역이 아닌 자유 변수로 만들었다. 그래서, closure지만 좋은 방법이 아니다. 왜냐하면 함수 내에 전역 변수와 연결되는 게 있다면 디버깅 할 때 쉽지 않다.   Reference  인프런 파이썬 중급 Python Scope \u0026amp; the LEGB Rule: Resolving Names in Your Code  ","permalink":"http://jeha00.github.io/post/python_basic/python_basic_33_closure/","summary":"Closure를 설명하기 위해서 global variable, local variable에 추가하여 free variable에 대해 설명하고, 왜 closure가 필요한지, closure의 잘못된 사용법을 알아본다.","title":"[TIL] Python basic 33: Closure"},{"content":"Intro  coroutin을 공부하면서 global variable과 local variable에 대해서 기본적인 의미만 알았지만, 이것이 Scoping Rule과 연관이 되어있다는 것과,stack과 heap이라는 데이터 임시 저장 자료 구조와 연관된 걸 몰랐다. 그래서 Scoping Rule, Stack 그리고, Heap에 대해 알아보겠다.   1.LEGB rules(Scoping rules)  변수(variable)의 생존 범위(lifetime)에 관련된 규칙\n  Python scope 개념을 알아야 하는 이유:  신뢰성 있고, 유지보수성이 좋은 프로그램을 작성할 수 있다. name 충돌을 방지할 수 있고, 버그를 줄일 수 있다. 이와 관련된 tool인 Closure에 대해 알 수 있다.    1.1 Scope의 일반적인 종류 : 2가지  global scope  이 scope에서 정의한 name은 모든 코드에서 사용할 수 있다.   local scope  이 scope에서 정의한 name은 범위 내의 코드에서만 사용할 수 있거나 볼 수 있다.      name: 변수, 상수, 함수, 클래스 등등의 식별자(identifier)를 참조하는 것으로, 구분하기 위해 존재한다.   1.2 초기 Scope의 부재로 인한 문제  초기 프로그래밍은 global만 있었기 때문에, 변수를 수정해야할 때 모든 코드를 동시에 염두에 둬야했다. 그래서 이런 문제를 피하기 위해 scope을 사용했다. scope을 사용한 후, 프로그램의 어디에서든지 그 scope에 있는 변수들에 함부로 접근할 수 없다. (out of scope) name들의 scope은 이 name들을 정의한 코드의 block scope과 동일하다. (in scope)  1.3 파이썬의 이름(name)과 범위(scope)들  파이썬에서의 변수들에 값이 할당될 때, 즉 파이썬 names을 다음과 같은 방법들로 만들 때 변수들은 존재하게 된다.  변수(variable): 변수에 값을 할당하면, 변수는 만들어진다. function , classes: 예약어 def, classes를 사용하여 정의하면 이용할 수 있다. modules: import하여 사용할 수 있다.    1.4 assignment operations와 reference operations의 차이  reference operations  name을 \u0026lsquo;참조\u0026rsquo; 한다는 건, name에 담겨진 content or value를 \u0026lsquo;단지 가져온다\u0026rsquo;   assignment operations  name을 \u0026lsquo;할당\u0026rsquo; 한다는 건, name을 \u0026lsquo;새롭게\u0026rsquo; 만들거나, \u0026lsquo;수정\u0026rsquo; 한다   할당한다는 건 특정 scope이 결정된다는 걸 말한다.  1.5 Python scope와 namespace의 관계  Namespace : python의 name이 dictionary data type으로 구현된 것\n   dictionary가 Python이 name을 저장하는 구체적인 원리다.\n  Namespace는 또한 __dir__ 명령어에 저장되어 있다.\n  namespace는 각각 다른 수명 시간(life time)을 가지고 있다.\n  왜냐하면 각각 다른 지점에서 만들어지기 때문이다.\n  from Python-course.eu: Namespaces\n    즉, __dir__은 Namespace를 확인할 수 있는 명령어이고, 할당된 name이 가지는 scope을 보여준다.\n  .__dict__.keys() 로 key value로 indexing하여 확인할 수 있다.\n  python은 name의 존재유무를 확인하기 위해서, 여러 scope levels(or namespace)를 찾아본다.\n  찾는 순서는 다음과 같다.\n local namespace -\u0026gt; global namespace -\u0026gt; global or module namespace -\u0026gt; built-in namespace      1.6 Python이 name을 찾는 규칙: LEGB rules   local namespace -\u0026gt; enclosing namespace -\u0026gt; global(or module) namespace-\u0026gt; built-in scope namespace 순서로 주어진 name을 파이썬이 찾는다.\n  Local(or function) scope: Python function의 body 또는 code block 부분이 local scope\n   지역 함수 내에 로직을 해결하는 값을 사용한다.\n   fuction 내에서 정의한 name들만 포함한다.\n  이 function의 코드에서만 local scope에 있는 name을 확인할 수 있다.\n  lifetime of a local namespace: 할당된 function이 종료되면 끝난다.\n  Enclosing(or nonlocal) scope: 중첩함수(nested functions)를 위해서만 존재하는 scope\n enclosing function 안에서 정의된 names만 포함한다. 이 enclosing function의 코드에서만 enclosing scope에 있는 name을 확인할 수 있다.    Global(or module) scope: Python program, script, module 안에서 Top level의 scope\n   이 scope에는 주로 변하지 않는 고정값을 사용한다.\n   프로그램 또는 모듈에서 최고 수준으로(Top level) 정의한 이름들을 포함한다.\n  어느 코드에서든지 Global scope에 있는 name을 확인할 수 있다.\n Top level이란??    lifetime of a module namespace: 일반적으로 script가 끝날 때까지만 지속된다.\n  Built-in scope: script를 run할 때마다 만들어지는 특별한 scope\n Python 안에 내장된 예약어들, functions들 등등의 name을 포함한다. 이 scope 또한 Global scope처럼 어느 코드에서든지 name을 확인한다. Built-in namespace는 interpreter가 시작되면 만들어지고, 절대로 삭제되지 않는다.    1.7 LEGB rules: The Local Scope  그러면 code를 보면 이해해보자.  \u0026gt; def square(base): \u0026gt; result = base ** 2 \u0026gt; print(f\u0026#39;The square of {base} is : {result}\u0026#39;) \u0026gt; square(10) The square of 10 is : 100 \u0026gt; result NameError: name \u0026#39;result\u0026#39; is not defined \u0026gt; base NameError: name \u0026#39;base\u0026#39; is not defined   위 코드에 대해 알아보자.\n square fuction을 호출할 때, 파이썬은 base와 result를 포함하는 local scope을 만든다. square(10)으로 호출할 때, base에는 10을 result에는 100을 취한다. 또 다시 호출할 때는 첫 번째 호출 시 취한 값들은 기억하지 않는다. result와 base는 square() 호출에 의해 만들어진 local scope에만 존재한다. 그래서 square fuction 호출 후, 접근한다면 NameError을 얻는 것이다.    그러면 추가로 local scope에 동일한 변수 이름을 가진 fuction을 정의해보자.\n  \u0026gt; def cube(base): \u0026gt; result = base ** 3 \u0026gt; print(f\u0026#39;The cube of {base} is : {result}\u0026#39;) \u0026gt; cube(30) The cube of 30 is : 27000  local scope에 동일한 변수이름을 사용했지만, 프로그램 충돌이 일어나지 않았다. 왜냐하면 local scope을 사용했기 때문이다. local scope에만 살아있는 변수를 local variable이라 한다. 함수 실행이 끝나면 local scope에서 벗어나기 때문에 local variable의 생명력은 끝난다. 이러한 장점 때문에, 디버깅과 수정이 쉽고 가독성이 좋아진다.  1.8 LEGB rules: The Enclosing Scope (Nested Functions) \u0026gt; def outer_func(): \u0026gt; # 이 block은 외부 함수(outer_func)의 local scope이면서 \u0026gt; # 내부 함수(inner_func)의 enclosing scope이기도 하다. \u0026gt; var = 100 \u0026gt; def inner_func(): \u0026gt; print(f\u0026#39;Printing var from inner_func() : {var}\u0026#39;) \u0026gt; inner_func() \u0026gt; print(f\u0026#39;Printing var from outer_func() : {var}\u0026#39;) \u0026gt; outer_func() Printing var from inner_func(): 100 Printing var from outer_func(): 100 \u0026gt; inner_func() NameError: name \u0026#39;inner_func\u0026#39; is not defined  outer_func()을 호출할 때, outer_func()의 local scope이 만들어진다. 이 scope은 동시에 inner_func()의 enclosing scope이라고도 한다.  global scope과 local scope 둘 다 아니고, 이 사이에 놓여있는 특별한 scope을 의미.   또한, inner_func()은 enclosing function인 outer_func이 실행되는 동안에만 유지되는 일시적인 함수다. 즉, outer_func()의 code에서만 inner_func()을 찾을 수 있다.  1.9 LEGB rules: Modules - The Global Scope    프로그램을 실행한 순간부터 global scope에 있는 것이다.    이 global scope은 module file과 깊은 연관이 있기 때문에, module scope이라 한다.    그리고 현재 실행되는 script 또는 module이 entry point 역할을 한다면, 이 시점부터 scope of __main__이 된다.    namespace를 확인하기 위해서 dir()을 사용할 때, 아무런 인자 없이 사용하면 main global Python scope에서 이용가능한 name list를 얻는다.    프로그램 실행할 때 단 하나의 global Python scope만이 존재한다. 그리고, 프로그램 실행이 끝나야 scope이 종료된다.    local scope에 있는 global 변수를 참조하거나 접근할 수 있다.   하지만, local scope에서 global variable에 값을 할당할려고 하면 Error가 발생된다.    # a global variable \u0026gt; var = 100 \u0026gt; def increment(): \u0026gt; var += 1 # global variable 업데이트 시도하기 \u0026gt; increment() UnboundLocalError: local variable \u0026#39;var\u0026#39; referenced before assignment   global variable을 업데이트하려고 시도했지만, local scope 내에서는 global variable을 선언할 수 없기 때문에, 파이썬에서는 var 이라는 동일한 이름으로 local variable을 새롭게 만들었다.\n  그리고, 이 과정에서 첫 번째 할당 var + 1 전에 local var을 사용하려고 시도한 걸 알았기 때문에 Error가 발생된다.\n  그러면 이렇게 코드를 다시 짜보자.\n  # a gloabl variable \u0026gt; var = 100 \u0026gt; def func(): # the global varaible 참조한다. \u0026gt; print(var) \u0026#39;var\u0026#39; # 동일한 이름으로 새로운 local variable을 정의한다. \u0026gt; var = 200 \u0026gt;\u0026gt; func() UnboundLocalError: local variable \u0026#39;var\u0026#39; referenced before assignment   global variable을 출력한 후에 var을 업데이트 할 수 있다고 생각했겠지만, 다시 동일한 Error가 발생된다.\n  global variable을 업데이트한 것이 아닌 function의 body 부분에 있기 때문에 local variable를 새로 만든 것이다.\n   Python은 global variable과 동일한 이름으로 function body에 선언해도, local variable로 인식한다.\n 1.10 LEGB rules: summary # This area is the global or module scope \u0026gt; number = 100 \u0026gt; def outer_func(): \u0026gt; # This block is the local scope of outer_func() \u0026gt; # It\u0026#39;s also the enclosing scope of inner_func() \u0026gt; def inner_func(): \u0026gt; # This block is the local scope of inner_func() \u0026gt; print(number) \u0026gt; \u0026gt; inner_func() \u0026gt; outer_func() 100  Inside inner_func(): local scope 이지만, number variable는 존재하지 않는다. Inside outer_func(): the enclosing scope 이다. number variable이 정의되지 않았다. In the module scope: the global scope 이다. number variable을 찾을 수 있어서 출력할 수 있다. 만약 number variable이 the global scope에서 정의되지 않는다면, 파이썬은 built-in scope에서 찾을 것이다.  1.11 Local variable 또는 global variable 찾아보기  locals() method를 통해서, globals() method를 통해서 지역 변수만, 또는 전역 변수만 출력할 수 있다. 먼저 locals()에 대해 알아보자.  \u0026gt; def func(var): \u0026gt; x = 10 \u0026gt; def printer(): \u0026gt; print(\u0026#39;Ex \u0026gt; 5\u0026#39;, \u0026#34;Printer Func Inner\u0026#34;) \u0026gt; print(\u0026#39;Func Inner\u0026#39;, locals()) \u0026gt; func(\u0026#39;Hi\u0026#39;) Func Inner {\u0026#39;var\u0026#39;: \u0026#39;Hi\u0026#39;, \u0026#39;x\u0026#39;: 10, \u0026#39;printer\u0026#39;: \u0026lt;function func.\u0026lt;locals\u0026gt;.printer at 0x000001D53343FDC0\u0026gt;}  func() 함수를 호출하기 위해 인자로 넘겼던 \u0026lsquo;Hi\u0026rsquo; 또한 지역변수임을 알 수 있다. enclosing scope에 있는 것 또한 local variable로 확인할 수 있다. outer function의 local scope에 정의했기 때문에 printer 또한 지역 변수로 확인할 수 있다.   그러면 다음으로 globals()에 대해 알아보자. globals는 이 코드를 실행할 때 입력한 모든 전역 변수가 입력되기 때문에, 다음과 같이 하여 알아본다. globals()는 global 영역에 변수를 입력할 때 호출된다.  \u0026gt; print(\u0026#39;Ex \u0026gt;\u0026#39;, globals()) Ex7 \u0026gt; {.....} \u0026gt; globals()[\u0026#39;text_variable\u0026#39;] = 100 \u0026gt; print(\u0026#39;Ex \u0026gt;\u0026#39;, globals()) Ex7 \u0026gt; {\u0026#39;test_variable\u0026#39;: 100}  globals()를 사용한 변수 자동화 생성: 지역 -\u0026gt; 전역 변수로 작성한다.  \u0026gt; for i in range(1, 6): \u0026gt; for k in range(1, 6): \u0026gt; globals()[\u0026#39;plus_{}_{}\u0026#39;.format(i, k)] = i + k \u0026gt; print(globals()) {\u0026#39;plus_1_1\u0026#39;: 2, \u0026#39;plus_1_2\u0026#39;: 3, \u0026#39;plus_1_3\u0026#39;: 4, \u0026#39;plus_1_4\u0026#39;: 5, \u0026#39;plus_1_5\u0026#39;: 6, \u0026#39;plus_2_1\u0026#39;: 3, \u0026#39;plus_2_2\u0026#39;: 4, \u0026#39;plus_2_3\u0026#39;: 5, \u0026#39;plus_2_4\u0026#39;: 6, \u0026#39;plus_2_5\u0026#39;: 7, \u0026#39;plus_3_1\u0026#39;: 4, \u0026#39;plus_3_2\u0026#39;: 5, \u0026#39;plus_3_3\u0026#39;: 6, \u0026#39;plus_3_4\u0026#39;: 7, \u0026#39;plus_3_5\u0026#39;: 8, \u0026#39;plus_4_1\u0026#39;: 5, \u0026#39;plus_4_2\u0026#39;: 6, \u0026#39;plus_4_3\u0026#39;: 7, \u0026#39;plus_4_4\u0026#39;: 8, \u0026#39;plus_4_5\u0026#39;: 9, \u0026#39;plus_5_1\u0026#39;: 6, \u0026#39;plus_5_2\u0026#39;: 7, \u0026#39;plus_5_3\u0026#39;: 8, \u0026#39;plus_5_4\u0026#39;: 9, \u0026#39;plus_5_5\u0026#39;: 10} \u0026gt; rint(plus_3_5) 8 \u0026gt; print(plus_5_5) 10 1.12 LEGB rules: Built-in scope  Built-in scope은 builtins 라 불리는 표준 라이브러리 모듈로서 실행되는 특별한 파이썬 scope이다. 파이썬은 LEGB 에서 마지막으로 built-in을 찾는다. 이 scope에서는 어느 모듈이든지 import할 필요 없이 names을 사용할 수 있다. builtins 안에 있는 name들은 언제나 Python의 global scope에, __builtins__로 담겨진다. 밑에 예제를 보자.  \u0026gt; dir() [\u0026#39;__annotations__\u0026#39;, \u0026#39;__builtins__\u0026#39;,..., \u0026#39;__package__\u0026#39;, \u0026#39;__spec__\u0026#39;] \u0026gt; dir(__builtins__) [\u0026#39;ArithmeticError\u0026#39;, \u0026#39;AssertionError\u0026#39;,..., \u0026#39;tuple\u0026#39;, \u0026#39;type\u0026#39;, \u0026#39;vars\u0026#39;, \u0026#39;zip\u0026#39;]  dir()의 첫 호출에서 __builtins__을 확인할 수 있다. 그리고 __builtins__를 dir로 내부를 들여다보면, 파이썬의 built-in names의 전체 목록을 얻을 수 있다.   또 한 가지 특징은 global scope에서 어떠한 built-in names이든 오버라이드할 수 있다. 하지만 우연히 또는 부주의하게 이렇게 오버라이드가 된다면 위험하며, bugs를 찾기 어렵다. 그래서 이런 종류의 실행은 최대한 피하는 게 낫다.  # a built-in fuction의 표준 사용 \u0026gt; abs(-15) 15 # global scope에서 built-in name을 재정의한다. \u0026gt; abs = 20 \u0026gt; abs(-15) TypeError: \u0026#39;int\u0026#39; object is not callable \u0026gt; del abs \u0026gt; abs(-15) 15 1.13 LEGB rules: final summary  From: Python Scope \u0026amp; the LEGB rule: Resolving Names in Your code   2. Python memory structure 2.1 코드 영역  실행할 프로그램의 코드가 저장되는 영역 (text 영역이라고도 한다)\n  lifetime: 프로그램이 시작하고, 끝날 때까지 메모리에 계속 남아 있는다.  2.2 데이터 영역  프로그램의 global variable과 정적(static) variable가 저장되는 영역\n  프로그램이 시작하고, 끝날 때까지 메모리에 계속 남아 있는다.  2.3 Stack   데이터를 임시 저장할 때 사용하는 자료구조로, 데이터의 입력과 출력 순서는 후입선출(Last In First Out, LIFO) 방식 loca var. 와 parameter var.가 저장된다.    push(푸쉬): stack에 데이터를 넣는 작업 pop(팝):stack에서 데이터를 꺼내는 작업 데이터를 넣고 꺼내는 작업에서 윗 부분을 top, 아랫 부분을 bottom 이라 한다.   stack 영역은 함수의 호출과 함께 생성되고, 함수의 호출이 완료되면 소멸한다. 스택 프레임(stack frame): 스택 영역에 저장되는 함수의 호출 정보 메모리의 높은 주소에서 낮은 주소의 방향으로 할당된다. 한계가 있어서, 한계를 초과하도록 삽입할 수 없다. Stack overflow: 함수는 변수를 저장하기 위해 stack을 만드는데, 만들어진 stack이 메모리 용량을 넘어서면 Stack overflow가 발생한다.  2.2 Heap  사용자가 직접 관리할수 잇는 영역으로, 객체가 생성된다.\n  사용자에 의해 메모리 공간이 동적으로 할당되고, 해제된다. heap 영역은 런타임 시에 크기가 결정된다 (메모리가 할당된다) 메모리의 낮은 주소에서 높은 주소로 할당된다.   Reference  파이썬 프로그래밍 기초 - 지역 변수와 전역 변수 Python-course.eu: Namespaces 스코핑 룰(Scoping rule) 자료구조와 함께 배우는 알고리즘 입문 파이썬편 Python Scope \u0026amp; the LEGB rule: Resolving Names in Your code  ","permalink":"http://jeha00.github.io/post/python_basic/python_basic_32_legb_rules/","summary":"LEGB rules 즉 Local, Enclosing, global(or module), built-in varialbe의 scope에 대해 알아본다. 그리고, Python Memory structure가 어떤지 개괄적으로 알아본다.","title":"[TIL] Python basic 32: LEGB rules and Memory structures"},{"content":"Intro  이번 시간에 배울 내용은 특히 더 중요하다. 이번 시간에는 일급 객체라고도 불리는 일급 함수에 대해 알아보겠다. 그 후, 일급 함수의 예인 lambda, callable, partial에 대해 알아본다.   1. 일급 함수(first-class)란??   일급 함수(일급 객체, first-clss)란??  객체 취급되는 함수   다음 4가지 특징을 가지는 함수를 말한다.    런타임 초기화: 실행 시점에서 초기화한다.    함수를 변수에 할당 가능하다.    함수를 인수로 전달 가능하다. (Higher - order function의 첫 번째 특징)    함수를 결과값으로서 반환 가능하다. (Higher - order function의 첫 번째 특징)         위 일급 함수의 특징들은 파이썬 함수의 특징이라고 할 수 있다.\n  그러면 first-class는 왜 중요한가??\n 일급함수를 알아야 함수형 프로그래밍 을 할 수 있기 때문이다. 함수형 프로그래밍이란?? side effect를 허용하지 않는 순수 함수(pure function)을 지향하여 동시에 여러 thread에서 문제 없이 동작하는 프로그램을 쉽게 작성할 수 있다.    이러한 이유로 일급 함수에 대해 알아보자.\n  일급 함수가 가지는 특징을 모두 예제로 구현해볼 것이다.\n  1.1 객체 취급되는 함수   객체란 무엇인가???\n [TIL] Python basic 14: class에 따르면 소프트웨어로 구현할 대상이라 했다.    하지만 파이썬 내부에서의 객체의 정의와 특징은 무엇일까???\n  파이썬이 data를 추상화(abstraction)한 것을 말하며,\n  id(identity), type(형) 그리고, value(값)을 가지는 걸 말 한다.\n  파이썬의 모든 데이터는 객체나 객체 간의 관계로 표현된다.\n  객체의 id는 메모리 상에서 객체의 주소를 말한다.\n  또한, id는 한 번 만들어진 후에는 변경되지 않는다.\n from 데이터 모델: 객체    attribute란 객체와 결합한 값(value)를 말한다.\n 용어집 - python 3.10.4      함수 객체 : 함수처럼 행동하는 객체\n from 함수 객체의 장점    그럼 코드 상에서 확인해보자.\n  \u0026gt; def factorial(n): \u0026gt; ```Factorial Function -\u0026gt; n : int ``` \u0026gt; if n == 1: \u0026gt; return 1 \u0026gt; # 이렇게 함수 내에서 함수를 호출하는 걸 재귀함수라 한다. \u0026gt; return n * factorial(n-1) \u0026gt; class A: \u0026gt; pass \u0026gt; print(factorial(6)) 720 # 함수 comment 출력 \u0026gt; print(factorial.__doc__) Factorial Function -\u0026gt; n : int \u0026gt; print(type(factorial), type(A)) \u0026lt;class \u0026#39;fuction\u0026#39;\u0026gt;, \u0026lt;class \u0026#39;type\u0026#39;\u0026gt; \u0026gt; print(id(factorial)) id - 2416266045904 # dir은 객체가 가지고 있는 속성(attribute)를 출력하는 함수다. \u0026gt; print(dir(factorial)) [\u0026#39;__annotations__\u0026#39;, \u0026#39;__call__\u0026#39;, \u0026#39;__class__\u0026#39;, \u0026#39;__closure__\u0026#39;, \u0026#39;__code__\u0026#39;, \u0026#39;__defaults__\u0026#39;, \u0026#39;__delattr__\u0026#39;, \u0026#39;__dict__\u0026#39;, \u0026#39;__dir__\u0026#39;, \u0026#39;__doc__\u0026#39;, \u0026#39;__eq__\u0026#39;, \u0026#39;__format__\u0026#39;, \u0026#39;__ge__\u0026#39;, \u0026#39;__get__\u0026#39;, \u0026#39;__getattribute__\u0026#39;, \u0026#39;__globals__\u0026#39;, \u0026#39;__gt__\u0026#39;, \u0026#39;__hash__\u0026#39;, \u0026#39;__init__\u0026#39;, \u0026#39;__init_subclass__\u0026#39;, \u0026#39;__kwdefaults__\u0026#39;, \u0026#39;__le__\u0026#39;, \u0026#39;__lt__\u0026#39;, \u0026#39;__module__\u0026#39;, \u0026#39;__name__\u0026#39;, \u0026#39;__ne__\u0026#39;, \u0026#39;__new__\u0026#39;, \u0026#39;__qualname__\u0026#39;, \u0026#39;__reduce__\u0026#39;, \u0026#39;__reduce_ex__\u0026#39;, \u0026#39;__repr__\u0026#39;, \u0026#39;__setattr__\u0026#39;, \u0026#39;__sizeof__\u0026#39;, \u0026#39;__str__\u0026#39;, \u0026#39;__subclasshook__\u0026#39;] # class와 동일하게 가지는 속성들을 빼서 함수만 가진 속성들을 확인할 수도 있다. \u0026gt; print(set(sorted(dir(factorial))) - set(sorted(dir(A))) {\u0026#39;__call__\u0026#39;, \u0026#39;__defaults__\u0026#39;, \u0026#39;__closure__\u0026#39;, \u0026#39;__kwdefaults__\u0026#39;, \u0026#39;__code__\u0026#39;, \u0026#39;__globals__\u0026#39;, \u0026#39;__name__\u0026#39;, \u0026#39;__get__\u0026#39;, \u0026#39;__annotations__\u0026#39;, \u0026#39;__qualname__\u0026#39;} # 함수의 이름을 알려준다. \u0026gt; print(factorial.__name__) factorial # type과 위치, 코드의 몇 번째 줄인지를 알려준다. \u0026gt; print(factorial.__code__) \u0026lt;code object factorial at 0x00000201685D8D40, file \u0026#34;c:\\Users\\rudtl\\Desktop\\Dev\\Python_lecture\\InflearnOriginal\\Level_2_중급\\p_chapter05_01.py\u0026#34;, line 35\u0026gt; 1.2 변수로 할당되는 함수  함수 또한 객체로 취급되는 걸 확인했다. 다음으로 이 함수가 변수에 할당되는지 확인해보자.  # 1.1 코드와 이어진다. # 변수에 할당 \u0026gt; var_func = factorial \u0026gt; print(var_func) \u0026lt;function factorial at 0x0000023294ADE9D0\u0026gt; \u0026gt; print(var_func(10)) 3628800  변수에 할당되어 여러 함수에 사용될 수 있다는 걸 확인했다.  1.3 고위 함수의 두 가지 특징   Higher - order function (고위함수)의 특징    함수를 인수로 전달 가능하다.    함수를 결과값으로서 반환 가능하다.         고위 함수의 대표적인 예로는 map, filter, reduce, lambda 등이 있다.\n  그러면 코드로 확인해보자.\n  ## range 함수로 iterator를 만들고, iteraotr의 각 성분들이 vap_func의 인자로 넘어간다. # 다음처럼 object로 출력된다면 type conversion을 해야 한다. # map 함수의 인자로 전달 가능하다. \u0026gt; print(map(vap_func, range(1,6))) \u0026lt;map object at 0x000001C1FC0A0DF0\u0026gt; \u0026gt; print(list(map(vap_func, range(1,6)))) [1, 2, 6, 24, 120] # var_func 을 결과값으로 반환 가능하다. \u0026gt; print(list(map(var_func, filter(lambda x: x % 2, range(1,6))))) [1, 6, 120] # 위와 동일한 출력값을 갖는다. 하지만, 가독성이 더 좋다. \u0026gt; print([var_func(i) for i in range(1, 6) if i % 2]) [1, 6, 120]  reduce : 여러 원소를 하나의 원소로 줄이기 위해, 왼쪽에서부터 오른쪽 방향으로 축적하며 함수를 적용해간다.  ## reduce \u0026gt; from functools import reduce \u0026gt; from operator import add \u0026gt; print(list(range(1,11))) [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] # 인수 하나 하나를 줄여나가면서 더해가는 함수 \u0026gt; print(reduce(add, range(1, 11))) # 하지만 reduce는 잘 사용하지 않고, sum을 사용한다. \u0026gt; print(sum(range(1, 11)))  2. 익명 함수(lambda)  이름 없는 함수로, 익명 함수다. 그래서 익명 함수가 복잡할 때, 주석을 사용해야 한다. 하지만, 되도록 함수를 만들어서 사용하자. 일반 함수 형태로 refactoring을 권장한다.\n \u0026gt; print(reduce(lambda x, t : x + t, range(1,11))) 55  3. Callable 설명   callable이란??  호출 연산자로 함수, 클래스 인스턴스, 메서드 등이 호출 가능한지 확인하는 함수 specail method인 __call__ method의 존재 유무를 확인한다. 이 method가 있으면 True다. What is a \u0026lsquo;callable\u0026rsquo;      호출한다는 건 무슨 의미일까???  # 아래 예시처럼 함수를 불러와서 사용할 수 있는 걸 의미한다. \u0026gt; str(3) \u0026gt; var_func(5) # 하지만 다음 같은 경우는 호출할 수 없는 함수다. \u0026gt; 3.14(334)  이를 callable로 확인해보자.  \u0026gt; print(callable(str), callable(list), callable(var_func), callable(3.14)) True True True False  3.14는 호출할 수 없다는 걸 callable을 통해 간단히 확인했다.   4. Partial 사용법   인수를 고정할 때 사용하는 함수로, 콜백 함수에 사용한다. 매우 중요하다.    코드로 알아보자.  \u0026gt; from operator import mul \u0026gt; from functools import partial # mul은 multiply의 약어다. \u0026gt; print(mul(10, 10)) 100 # 그러면 인수 하나를 고정하여, 함수를 변수에 할당하자. \u0026gt; five = partial(mul, 5) \u0026gt; print(five(10)) 50 # 한 번도 고정한다면?? \u0026gt; six = partial(five, 6) \u0026gt; print(six()) 60  5. Signature   signature(callable, *, follow_wrapped=True)  인자로 callable을 취하고, annotation을 반환한다.      signature 함수는 inspect module에서 import한다. inspect module은  모듈은 모듈, 클래스, 메서드, 함수, 트레이스백, 프레임 객체 및 코드 객체와 같은\n라이브 객체에 대한 정보를 얻는 데 도움이 되는 몇 가지 유용한 함수를 제공한다.   예를 들어  클래스의 내용을 검사하거나, 메서드의 소스 코드를 꺼내오거나, 함수의 인자 리스트를 추출하고 포맷하거나, 자세한 트레이스백을 표시하는 데 필요한 모든 정보를 얻는 데 도움이 될 수 있다. from Inspect: 라이브 객체 검사    \u0026gt; from inspect import signature \u0026gt; sg = signature(var_func) \u0026gt; print(sg) (n) \u0026gt; print(sg.parameters) OrderedDict([(\u0026#39;n\u0026#39;, \u0026lt;Parameter \u0026#34;n\u0026#34;\u0026gt;)]) \u0026gt; def foo(a, *, b:int, **kwargs): \u0026gt; pass \u0026gt; sig = signature(foo) \u0026gt; print(str(sig)) (a, *, b:int, **kwargs) \u0026gt; print(str(sig.parameters[\u0026#39;b\u0026#39;])) \u0026#39;b:int\u0026#39; \u0026gt; print(sig.parameters[\u0026#39;b\u0026#39;].annotation) \u0026lt;class \u0026#39;int\u0026#39;\u0026gt;  Reference  인프런 파이썬 중급 데이터 모델: 객체 Inspect: 라이브 객체 검사 용어집 - python 3.10.4 What is a \u0026lsquo;callable\u0026rsquo;  ","permalink":"http://jeha00.github.io/post/python_basic/python_basic_31_firstclass/","summary":"일급 함수(일급 객체, first-class)란 무엇인지 알고, 일급 함수의 예인 lambda function, Callable, Partial에 대해 알아본다.  그리고 추가적으로 Signature에 대해 간단히 알아본다.","title":"[TIL] Python basic 31: First-class"},{"content":"Intro  sort와 sorted는 책 한 권으로 나올만큼 많은 내용이 있지만, 무엇보다 이 두가지의 기본적인 차이를 알아본다. 그리고, [TIL] Python basic 29: Data Model에서 상세 분류에서 언급된 Array data type에 대해 알아본다.   1. Sort vs Sorted   sort : 정렬 후, 객체의 원본을 수정한다. 그리고, 반환값이 없다(return none). sorted : 정렬 후, 객체의 원본을 수정하지 않는다. 그리고 새로운 객체를 반환한다.     list data model에서 자주 사용하는 함수인 sort 와 sorted에 대해 알아보자.\n  실습 예제를 통해 확인하자.\n  \u0026gt; f_list = [\u0026#39;orange\u0026#39;, \u0026#39;apple\u0026#39;, \u0026#39;mango\u0026#39;, \u0026#39;papaya\u0026#39;, \u0026#39;lemon\u0026#39;, \u0026#39;strawberry\u0026#39;, \u0026#39;coconut\u0026#39;] ## sort # 1. 반환값이 없다. \u0026gt; print(\u0026#39;sort - \u0026#39;, f_list.sort()) sort - None # 2. 원본 객체를 수정한다. \u0026gt; print(f_list) [\u0026#39;apple\u0026#39;, \u0026#39;coconut\u0026#39;, \u0026#39;lemon\u0026#39;, \u0026#39;mango\u0026#39;, \u0026#39;orange\u0026#39;, \u0026#39;papaya\u0026#39;, \u0026#39;strawberry\u0026#39;] ## sorted # 1. 반환값이 존재한다. \u0026gt; print(\u0026#39;sort - \u0026#39;, sorted(f_list)) sorted - [\u0026#39;apple\u0026#39;, \u0026#39;coconut\u0026#39;, \u0026#39;lemon\u0026#39;, \u0026#39;mango\u0026#39;, \u0026#39;orange\u0026#39;, \u0026#39;papaya\u0026#39;, \u0026#39;strawberry\u0026#39;] # 2. 원본 객체를 수정하지 않는다. \u0026gt; print(f_list) sorted - [\u0026#39;orange\u0026#39;, \u0026#39;apple\u0026#39;, \u0026#39;mango\u0026#39;, \u0026#39;papaya\u0026#39;, \u0026#39;lemon\u0026#39;, \u0026#39;strawberry\u0026#39;, \u0026#39;coconut\u0026#39;]  다음으로 여러 key 값을 사용하여 sort와 sorted를 활용해보자.  # reverse = True # 순서를 뒤집는다. \u0026gt; print(\u0026#39;sorted - \u0026#39;, sorted(f_list, reverse = True)) sorted - [\u0026#39;strawberry\u0026#39;, \u0026#39;papaya\u0026#39;, \u0026#39;orange\u0026#39;, \u0026#39;mango\u0026#39;, \u0026#39;lemon\u0026#39;, \u0026#39;coconut\u0026#39;, \u0026#39;apple\u0026#39;] \u0026gt; print(\u0026#39;sort - \u0026#39;, f_list.sort(reverse = True), f_list) sort - None [\u0026#39;strawberry\u0026#39;, \u0026#39;papaya\u0026#39;, \u0026#39;orange\u0026#39;, \u0026#39;mango\u0026#39;, \u0026#39;lemon\u0026#39;, \u0026#39;coconut\u0026#39;, \u0026#39;apple\u0026#39;] # key = len # 단어 길이를 기준으로 정렬한다. \u0026gt; print(\u0026#39;sorted - \u0026#39;, sorted(f_list, key = len)) sorted - [\u0026#39;apple\u0026#39;, \u0026#39;mango\u0026#39;, \u0026#39;lemon\u0026#39;, \u0026#39;orange\u0026#39;, \u0026#39;papaya\u0026#39;, \u0026#39;coconut\u0026#39;, \u0026#39;strawberry\u0026#39;] \u0026gt; print(\u0026#39;sort - \u0026#39;, sort(key = len), f_list) sort - None [\u0026#39;apple\u0026#39;, \u0026#39;mango\u0026#39;, \u0026#39;lemon\u0026#39;, \u0026#39;orange\u0026#39;, \u0026#39;papaya\u0026#39;, \u0026#39;coconut\u0026#39;, \u0026#39;strawberry\u0026#39;] # key = lambda x: x[-1] # 마지막 알파벳을 기준으로 정렬한다. \u0026gt; print(\u0026#39;sorted - \u0026#39;, sorted(f_list, key=lambda x: x[-1])) sorted - [\u0026#39;papaya\u0026#39;, \u0026#39;orange\u0026#39;, \u0026#39;apple\u0026#39;, \u0026#39;lemon\u0026#39;, \u0026#39;mango\u0026#39;, \u0026#39;coconut\u0026#39;, \u0026#39;strawberry\u0026#39;] \u0026gt; print(\u0026#39;sort - \u0026#39;, sort(f_list, key=lambda x: x[-1])) sort - None [\u0026#39;papaya\u0026#39;, \u0026#39;orange\u0026#39;, \u0026#39;apple\u0026#39;, \u0026#39;lemon\u0026#39;, \u0026#39;mango\u0026#39;, \u0026#39;coconut\u0026#39;, \u0026#39;strawberry\u0026#39;] # key = lambda x: x[-1], reverse = True # 마지막 알파벳을 기준으로 정렬한 후, 뒤집는다. \u0026gt; print(\u0026#39;sorted - \u0026#39;, sorted(f_list, key=lambda x: x[-1], reverse = True)) sorted - [\u0026#39;strawberry\u0026#39;, \u0026#39;coconut\u0026#39;, \u0026#39;mango\u0026#39;, \u0026#39;lemon\u0026#39;, \u0026#39;orange\u0026#39;, \u0026#39;apple\u0026#39;, \u0026#39;papaya\u0026#39;] \u0026gt; print(\u0026#39;sort - \u0026#39;, sort(f_list, key=lambda x: x[-1], reverse = True)) sorted - None [\u0026#39;strawberry\u0026#39;, \u0026#39;coconut\u0026#39;, \u0026#39;mango\u0026#39;, \u0026#39;lemon\u0026#39;, \u0026#39;orange\u0026#39;, \u0026#39;apple\u0026#39;, \u0026#39;papaya\u0026#39;]  2. Array data model   1.Python data model 상세 분류에서 꺼냈던 Array data model에 대해 알아보자.\n  Array 자료형에 대해 알아보자.\n  Array의 구조는 다음과 같다.\n Array(type code, [array 원소값]) 여기서 type code는 형 코드를 말하는데, 다음 대표 reference를 참조하자. Array in docs.python    # array module을 가져오는 것부터 시작한다. \u0026gt; import array \u0026gt; chars = \u0026#39;+_)(*\u0026amp;^%$#@!~)\u0026#39; # array module의 array method를 사용한다. # ord: Return the Unicode code point for a one-character string \u0026gt; array_g = array.array(\u0026#39;I\u0026#39;, (ord(s) for s in chars)) \u0026gt; print(type(array_g), array_g) \u0026lt;class \u0026#39;array.array\u0026#39;\u0026gt; array(\u0026#39;I\u0026#39;, [43, 95, 41, 40, 42, 38, 94, 37, 36, 35, 64, 33, 126, 41]) # .tolist(): array data type을 list로 바꿔주는 함수 \u0026gt; array_l = array_g.tolist() \u0026gt; print(type(array_l)) \u0026lt;class \u0026#39;list\u0026#39;\u0026gt; \u0026gt; print(array_l) [43, 95, 41, 40, 42, 38, 94, 37, 36, 35, 64, 33, 126, 41] List vs Array 적합한 사용법  List 기반: 다양한 data type을 사용할 수 있기 때문에, 융통성 있게 범용적으로 사용 가능. Array 기반: 한 가지 data type만 사용할 수 있기 때문에, 숫자 기반에 많이 사용한다.   Reference  인프런 파이썬 중급  ","permalink":"http://jeha00.github.io/post/python_basic/python_basic_30_sortvssorted_array/","summary":"sort와 sorted의 차이를 알아보고, Array data type 에 대해 알아본다.","title":"[TIL] Python basic 30: Sort VS Sorted"},{"content":"Intro  파이썬에 존재하는 모든 sequence type 및 data structure에 대해 조금 더 깊이 알아보자.  data structure: 논리적인 관계로 이루어진 데이터 구성   이러한 Data type 들이 있고, 각 각의 특징을 이해하여 코드에 녹여내자. 각 data type에 대해서 여기에 언급된 내용이 전부가 아니니 더 공부하자.   1. Python data type 상세 분류  Python의 data type은 여러 기준으로 분류될 수 있다.    1. 무슨 형태의 자료형 을 담을 수 있는가???\n  Container 형: 서로 다른 자료형을 담을 수 있다.\nex) list, tuple, collections.deque..\n  flat 형: 한 가지 자료형만 담을 수 있다.\nex) string, bytes, byte array, array, memoryview\u0026hellip;\n    # Container의 예: 정수, 실수, 문자열 같이 서로 다른 자료형을 담을 수 있다. \u0026gt; a = [3, 3.0, \u0026#39;a\u0026#39;] # flat 형 \u0026gt; chars = \u0026#39;+_)(*\u0026#39;   2. element가 수정 될 수 있는가?? 없는가??\n  Mutable: 변경할 수 있는 date type ex) list, dictionary, set, bytearray, array, memoryview, deque..\n  Immutable: 변경할 수 없는 data type ex) tuple, str, bytes, int, float\u0026hellip;\n  수정될 수 있으면 element를 교체, 삭제, 추가가 가능하다. ex) del, append 등등 가능\n    3. 순서 가 있는가 없는가???\n  Sequence: 순서가 존재한다. ex) list, tuple, string ..\n  Collections: 순서가 존재하지 않는다. ex) set, dictionary ..\n  순서가 존재하면 slicing, indexing 이 가능하다.\n     2. Mutable 과 Immutable   id() 을 사용하여 mutable과 immutable에 대해 자세히 알아보자.\n  mutable:\n 함수 안에서 매개변수의 값을 변경하면 객체 자체를 업데이트한다. 따라서, 매개변수의 값을 변경하면 호출하는 쪽의 실제 인수는 변경된다.    immutable:\n 함수 안에서 매개변수의 값을 변경하면 다른 객체를 생성하고, 그 객체에 대한 참조로 업데이트된다. 따라서 매개변수의 값을 변경해도 호출하는 쪽의 실제 인수에는 영향을 주지 않는다.    예시를 들어보자.\n  \u0026gt; chars = \u0026#39;+_)(*\u0026#39; # immutable data type인 string을 수정하려 하면 다음과 같은 error 가 뜬다. \u0026gt; chars[2] = \u0026#39;h\u0026#39; TypeError: \u0026#39;str\u0026#39; object does not support item assignment \u0026gt; n = 12 \u0026gt; print(id(n)) 2041592179344 \u0026gt; n = 13 \u0026gt; print(id(n)) 2041592179376 \u0026gt; n += 1 \u0026gt; print(n, id(n)) 14 2041592179408   int형은 분명 immutable인데 어떻게 수정이 가능할까???\n 이는 int형 객체 12의 값 자체를 변경한 것이 아니라, 다른 정수형 객체 13을 참조하도록 업데이트된 것이다.    immutable은 값 자체를 변경할 수 없기 때문에, 다른 객체를 참조한다.\n  그래서 id가 바뀐다.\n  그래서 누적 변수를 출력하면 id가 달라지는 걸 알 수 있다.\n 누적 변수: 변수값에 특정값을 더한 결과값을 다시 대입하여 업데이트한 변수     이번에 mutable 예시를 들어보자.  \u0026gt; k = [1, 2, 3] \u0026gt; print(id(k)) 2249826233536 \u0026gt; k[0] = 0 \u0026gt; print(k, id(k)) [0, 2, 3] 2249826233536  list는 mutable이라 성분값을 수정할 수 있다. 수정 후, id을 확인하면 수정 전과 동일한 걸 알 수 있다.    정리  immutable 은 value가 변경되지 못하기 때문에, id 값을 바꾼다. mutable 은 value를 수정할 수 있기 때문에, id 값을 바꾸지 않는다.      3. List comprehension 3.1 List comprehension의 의미와 구조   list comprehension에 대해 찾아보니 번역이 다양하고, 딱 들어맞는게 없었다.\n  그래서 그대로 사용하는게 좋다고 판단했다.\n  그러면 list comprehension은 뭘까??\n list를 만드는 간결한 문법을 말한다. List comprehensions provide a concise way to create lists.  from list comprehension      그러면 일반적으로 list를 만드는 방법과 비교해보자.\n  # 일반적으로 list를 만드는 방법 \u0026gt; code_list1 = [] \u0026gt; chars = \u0026#39;+_)(*\u0026amp;^\u0026#39; # ord: Return the Unicode code point for a one-character string. # ord: 유니 코드로 전환하는 함수 \u0026gt; for s in chars: \u0026gt; code_list1.append(ord(s)) [43, 95, 41, 40, 42, 38, 94] ## list comprehension을 이용한 방법 \u0026gt; code_list2 = [ord(s) for s in chars] [43, 95, 41, 40, 42, 38, 94] # for문과 if문을 사용한 list comprehension \u0026gt; code_list3 = [ord(s) for s in chars if ord(s) \u0026gt; 40] [43, 95, 41, 40, 42, 38, 94] \u0026gt; vec = [-4, -2, 0, 2, 4] \u0026gt; [x for x in vec if x \u0026gt;= 0] [0, 2, 4]   그러면 위 예시를 통해 list comprehension의 문법에 대해 정리해보자.\n   [\u0026lsquo;변수(B)를 사용하여 list의 성분이 될 값(A)\u0026rsquo; for \u0026lsquo;사용할 변수 이름(B)\u0026rsquo; in \u0026lsquo;iterator\u0026rsquo;]    list comprehension에서 if 조건문은 for문 표현식 뒤에 설정할 수 있다.      지난 번에 알아본 namedtuple을 사용해서 예시를 만들어보자.\n  # list comprehension을 통해 3개의 반을 만들고, 각 반마다 6명의 학생이 있는 list를 만들자. # 예제 2-1 \u0026gt; numbers = [str(n) for n in range(1,6)] \u0026gt; ranks = \u0026#39;A B C\u0026#39;.split( ) \u0026gt; print(numbers) \u0026gt; print(ranks) [\u0026#39;1\u0026#39;, \u0026#39;2\u0026#39;, \u0026#39;3\u0026#39;, \u0026#39;4\u0026#39;, \u0026#39;5\u0026#39;] [\u0026#39;A\u0026#39;, \u0026#39;B\u0026#39;, \u0026#39;C\u0026#39;] # namedtuple 만들기 \u0026gt; Classes = namedtuple(\u0026#39;Classes\u0026#39;, [\u0026#39;rank\u0026#39;, \u0026#39;number\u0026#39;]) # 2개의 for 반복문을 사용하여 list의 성분값으로 만들어질 인수들에 각각 mapping 했다. \u0026gt; students = [Classes(rank, number) for rank in ranks for number in numbers] \u0026gt; print(students) [Classes(rank=\u0026#39;A\u0026#39;, number=\u0026#39;1\u0026#39;), Classes(rank=\u0026#39;A\u0026#39;, number=\u0026#39;2\u0026#39;), Classes(rank=\u0026#39;A\u0026#39;, number=\u0026#39;3\u0026#39;), Classes(rank=\u0026#39;A\u0026#39;, number=\u0026#39;4\u0026#39;), Classes(rank=\u0026#39;A\u0026#39;, number=\u0026#39;5\u0026#39;), Classes(rank=\u0026#39;B\u0026#39;, number=\u0026#39;1\u0026#39;), Classes(rank=\u0026#39;B\u0026#39;, number=\u0026#39;2\u0026#39;), Classes(rank=\u0026#39;B\u0026#39;, number=\u0026#39;3\u0026#39;), Classes(rank=\u0026#39;B\u0026#39;, number=\u0026#39;4\u0026#39;), Classes(rank=\u0026#39;B\u0026#39;, number=\u0026#39;5\u0026#39;), Classes(rank=\u0026#39;C\u0026#39;, number=\u0026#39;1\u0026#39;), Classes(rank=\u0026#39;C\u0026#39;, number=\u0026#39;2\u0026#39;), Classes(rank=\u0026#39;C\u0026#39;, number=\u0026#39;3\u0026#39;), Classes(rank=\u0026#39;C\u0026#39;, number=\u0026#39;4\u0026#39;), Classes(rank=\u0026#39;C\u0026#39;, number=\u0026#39;5\u0026#39;), Classes(rank=\u0026#39;D\u0026#39;, number=\u0026#39;1\u0026#39;), Classes(rank=\u0026#39;D\u0026#39;, number=\u0026#39;2\u0026#39;), Classes(rank=\u0026#39;D\u0026#39;, number=\u0026#39;3\u0026#39;), Classes(rank=\u0026#39;D\u0026#39;, number=\u0026#39;4\u0026#39;), Classes(rank=\u0026#39;D\u0026#39;, number=\u0026#39;5\u0026#39;)] # 예제 2-2 \u0026gt; student = [Classes(rank, number) \u0026gt; for rank in \u0026#39;A B C\u0026#39;.split( ) \u0026gt; for number in [str(n) for n in range(1,6)]]  예제 2-2의 경우, 여러 for문을 사용했다. 한 줄로 표현할 수 있지만, 가독성이 떨어진다. 코드 몇 줄을 줄이기 위해서 가독성이 많이 떨어진다면 재고할 방법이다.  3.2 list comprehension의 주의사항  깊은 복사와 얕은 복사를 주의하라.  # 반복은 하지만 사용하지 않는 변수라면 \u0026#39;_\u0026#39; 로 표현한다. \u0026gt; marks1 = [[\u0026#39;~\u0026#39;] * 3 for _ in range(4)] # 하나의 값이 4개로 복사된 것 \u0026gt; marks2 = [[\u0026#39;~\u0026#39;] * 3] * 4 # 동일한 출력물을 갖는다. \u0026gt; print(marks1) \u0026gt; print(marks2) [[\u0026#39;~\u0026#39;, \u0026#39;~\u0026#39;, \u0026#39;~\u0026#39;], [\u0026#39;~\u0026#39;, \u0026#39;~\u0026#39;, \u0026#39;~\u0026#39;], [\u0026#39;~\u0026#39;, \u0026#39;~\u0026#39;, \u0026#39;~\u0026#39;], [\u0026#39;~\u0026#39;, \u0026#39;~\u0026#39;, \u0026#39;~\u0026#39;]] # 수정하기 \u0026gt; marks1[0][1] = \u0026#39;x\u0026#39; \u0026gt; marks2[0][1] = \u0026#39;x\u0026#39; \u0026gt; print(marks1) [[\u0026#39;~\u0026#39;, \u0026#39;x\u0026#39;, \u0026#39;~\u0026#39;], [\u0026#39;~\u0026#39;, \u0026#39;~\u0026#39;, \u0026#39;~\u0026#39;], [\u0026#39;~\u0026#39;, \u0026#39;~\u0026#39;, \u0026#39;~\u0026#39;], [\u0026#39;~\u0026#39;, \u0026#39;~\u0026#39;, \u0026#39;~\u0026#39;]] \u0026gt; print(marks2) [[\u0026#39;~\u0026#39;, \u0026#39;x\u0026#39;, \u0026#39;~\u0026#39;], [\u0026#39;~\u0026#39;, \u0026#39;x\u0026#39;, \u0026#39;~\u0026#39;], [\u0026#39;~\u0026#39;, \u0026#39;x\u0026#39;, \u0026#39;~\u0026#39;], [\u0026#39;~\u0026#39;, \u0026#39;x\u0026#39;, \u0026#39;~\u0026#39;]]   \u0026lsquo;marks2\u0026rsquo;\n 하나의 값이 4개로 복사되었다는 건 하나의 id값이 복사된 걸 의미한다. 한 객체를 참조하는 게 4개다. 그래서 하나의 객체만 수정해도 이 객체를 참조하는 값들까지 다 수정된다. 이를 얕은 복사(copy)라고 한다.    \u0026lsquo;marks1\u0026rsquo;\n \u0026lsquo;marks2\u0026rsquo; 와 달리 for문을 통해 다 새로 만들어졌다. 그래서 각각 다른 객체를 참조한다. 이를 깊은 복사(deepcopy)라 한다.    이를 id값으로 확인해보자.\n  # marks1은 다 다른 id 값을 가진다. \u0026gt; print([id(i) for i in marks1]) [2922096396544, 2922096396480, 2922096396352, 2922096396288] # marks2는 다 동일한 id 값을 가진다. \u0026gt; print([id(i) for i in marks2]) [2922096395200, 2922096395200, 2922096395200, 2922096395200]  그래서 copy 형식을 사용할 때는 조심히 다뤄야 한다. id값을 확인해보고, 꼼꼼히 개발하자.   4. Advanced tuple with unpacking   tuple에 unpacking을 사용하여 더 깊이 들어가자.\n  오픈 소스들을 보면 아래 방식으로 코딩한 경우가 많다.\n  그러니, 아래 3가지 경우를 눈에 익혀두자.\n  # divmod: Return the tuple (x//y, x%y). # divmode: tuple data type으로 (몫, 나머지)를 반환하는 함수 # 정상적인 입력 \u0026gt; print(divmod(100, 9)) (11, 1) # divmod는 인자를 2개 받아야하는데, 다음과 같이 입력하면 1개만 받은 걸로 인식한다. \u0026gt; print(divmod((100, 9))) TypeError: divmod expected 2 arguments, got 1 # 인자를 1개만 입력하고 싶다면 unpacking을 사용하자. \u0026gt; print(divmond(*(100, 9))) (11, 1) # divmond가 반환하는 걸 unpacking할 수도 있다. \u0026gt; print(*(divmond(100, 9))) 11 1  tuple은 immutable이지만, unpacking으로 풀을 수 있다.  # range: Return an object that produces a sequence of integers from start (inclusive) to stop (exclusive) by step \u0026gt; x, y, rest = range(10) ValueError: too many values to unpack (expected 3) # 그러면 unpacking을 이용해보자. \u0026gt; x, y, *rest = range(10) \u0026gt; print(x, y, rest) 0 1 [2, 3, 4, 5, 6, 7, 8, 9] \u0026gt; x, y, *rest = range(2) \u0026gt; print(x, y, rest) 0 1 []  정리\n 인자를 입력할 때 upacking을 사용할 수 있다. 반환값을 unpacking하여 출력할 수 있다. unpacking으로 여러 값을 담을 수 있다.    5. Advanced dictionary 5.1 hash table이란??  Dictionary는 hash table의 종류다.\n   dictionary에 대해 간단히 정리하면\n  key : value로 구성된 data type을 말한다.\n  dictionary의 key는 중복을 허용하지 않는다.\n ex) 각 사람이 가지고 있는 주민등록번호      그런데, 이러한 key : value로 된 자료형을 hash table이라 한다.\n  또한, 파이썬 언어 자체가 강력한 hash table 엔진으로 만들어졌다.\n  그래서 파이썬에서는 hash table을 별도로 구현할 필요가 없다.\n  python의 dictionary는 key 를 hash 함수를 통해서 hash 주소가 나오는 원리이기 때문에, key를 통해서 value에 접근할 수 있다.\n    hash table이란??  key를 사용하여 적은 리소스로 많은 데이터를 효율적으로 관리하는 데이터 구조 타입 from reference      그러면 직접 이에 대해서 알아보자.  \u0026gt; t1 = (10, 20, (30, 40, 50)) \u0026gt; t2 = (10, 20, [30, 40, 50]) # 출력되는 hash index \u0026gt; print(hash(t1)) 465510690262297113 \u0026gt; print(hash(t2)) TypeError: unhashable type: \u0026#39;list\u0026#39;  hash 값을 확인할 수 있다는 건 고유하다는 의미로, 수정 불가능하다는 걸 말한다. 그래서 list type의 hash number를 확인할려고 했으나, TypeError가 뜬 것이다. list는 mutable이기 때문이다.  5.2 key가 중복되는 dictionary 만들기   setdefault 를 사용하여 만든다. tuple로 dictionary를 만들 때, 권고되는 방법이다.    이런 방식으로 자주 구현하므로 눈에 익혀두자.  # 이중 tuple \u0026gt; source = ((\u0026#39;k1\u0026#39;, \u0026#39;val1\u0026#39;), \u0026gt; (\u0026#39;k1\u0026#39;, \u0026#39;val2\u0026#39;), \u0026gt; (\u0026#39;k2\u0026#39;, \u0026#39;val3\u0026#39;), \u0026gt; (\u0026#39;k2\u0026#39;, \u0026#39;val4\u0026#39;), \u0026gt; (\u0026#39;k2\u0026#39;, \u0026#39;val5\u0026#39;)) \u0026gt; new_dict1 = {} \u0026gt; new_dict2 = {} ## No use setdefault # k에는 k1, k2가, v에는 val가 할당된다. \u0026gt; for k, v in source: # new_dict1 에 k1 이나 k2가 있다면, 이에 대한 value 값으로 v를 끝에 추가한다. \u0026gt; if k in new_dict1: \u0026gt; new_dict1[k].append(v) # new_dict1 에 k1 이나 k2가 없다면 k를 추가하고, 이 k에 대한 value로 v를 추가한다. \u0026gt; else: \u0026gt; new_dict1[k] = [v] \u0026gt; print(new_dict1) {\u0026#39;k1\u0026#39;: [\u0026#39;val1\u0026#39;, \u0026#39;val2\u0026#39;], \u0026#39;k2\u0026#39;: [\u0026#39;val3\u0026#39;, \u0026#39;val4\u0026#39;, \u0026#39;val5\u0026#39;]} ## use setdefault \u0026gt; for k, v in source: # k는 default로 들어가고, 나머지는 list type로 담는다. \u0026gt; new_dict2.setdefault(k []).append(v) \u0026gt; print(new_dict2) {\u0026#39;k1\u0026#39;: [\u0026#39;val1\u0026#39;, \u0026#39;val2\u0026#39;], \u0026#39;k2\u0026#39;: [\u0026#39;val3\u0026#39;, \u0026#39;val4\u0026#39;, \u0026#39;val5\u0026#39;]}  setdefault를 사용하여 훨씬 짧은 코드로 key가 중복된 tuple을 dictionary로 구현했다. setdefault를 사용하여 [] 가 아닌 ()로 했다면 tuple이므로, 만들 수 없다.   만약, dictionary를 만들 때 키가 중복되면 나중 값으로 overwritten된다.  \u0026gt; new_dict3 = {k : v for k , v in source} \u0026gt; print(new_dict3) {\u0026#39;k1\u0026#39;: \u0026#39;val2\u0026#39;, \u0026#39;k2\u0026#39;: \u0026#39;val5\u0026#39;} 5.3 Immutable Dictionary 생성하기   immutable dictionary 즉, \u0026lsquo;읽기 전용\u0026rsquo; dictionary를 만들어보자.\n  왜 읽기 전용을 만들까???\n \u0026lsquo;읽기 전용\u0026rsquo;을 만들지 않고, 파일을 그냥 두어도 된다. 하지만, communication의 문제로 팀원이 이 데이터를 수정할수도 있다. 그래서 수정하면 안되는 file은 \u0026lsquo;읽기 전용\u0026rsquo;으로 만든다.    \u0026lsquo;읽기 전용\u0026rsquo;으로 만들기 위해서\n MappingProxyType 를 사용할 것이다. data 이름에는 _frozen을 작성한다. (외국에서는 이렇게 한다.)    \u0026gt; from types import MappingProxyType \u0026gt; d = {\u0026#39;key1\u0026#39;: \u0026#39;value1\u0026#39;} \u0026gt; d_frozen = MappingProxyType(d) \u0026gt; print(d, id(d)) {\u0026#39;key1\u0026#39;: \u0026#39;value1\u0026#39;} 2586113038272 \u0026gt; print(d_frozen, id(d_frozen)) {\u0026#39;key1\u0026#39;: \u0026#39;value1\u0026#39;} 2586113478608 \u0026gt; print(type(d), type(d_frozen)) \u0026lt;class \u0026#39;dict\u0026#39;\u0026gt; \u0026lt;class \u0026#39;mappingproxy\u0026#39;\u0026gt; \u0026gt; print(d is d_frozen, d == d_frozen) False True  d와 d_frozen이 ==을 통해서 value가 같다는 건 확인했다. 하지만, 서로 다른 객체라는 걸 id를 통해 확인했다. 다른 객체를 참조했기 때문에 is로 확인했을 때, false가 뜬 것이다.   6. Advanced set 6.1 Immutable set  frozenset 사용하여 immutable로 바꾸기\n   set은 mutable로 알고 있으나, immutable로 바꿔보자.\n  set data type을 선언하는 방법은 다음과 같다.\n  # {}만 사용 \u0026gt; s1 = {\u0026#39;Apple\u0026#39;, \u0026#39;Orange\u0026#39;, \u0026#39;Apple\u0026#39;, \u0026#39;Orange\u0026#39;, \u0026#39;Kiwi\u0026#39;} \u0026gt; s3 = {3} # set([]) 사용 \u0026gt; s2 = set([\u0026#39;Apple\u0026#39;, \u0026#39;Orange\u0026#39;, \u0026#39;Apple\u0026#39;, \u0026#39;Orange\u0026#39;, \u0026#39;Kiwi\u0026#39;]) \u0026gt; s4 = set() # Not {}  그러면 frozenset 을 사용하여 선언해보자.  \u0026gt; s5 = frozenset({\u0026#39;Apple\u0026#39;, \u0026#39;Orange\u0026#39;, \u0026#39;Apple\u0026#39;, \u0026#39;Orange\u0026#39;, \u0026#39;Kiwi\u0026#39;})  그러면 s1과 s5에 각각 원소를 추가한 후, 출력한다.  \u0026gt; s1.add(\u0026#39;Melon\u0026#39;) # s5인 경우, immutable로 바꼈기 때문에, 수정할 수 없다는 걸 확인했다. \u0026gt; s5.add(\u0026#39;Melon\u0026#39;) AttributeError: \u0026#39;frozenset\u0026#39; object has no attribute \u0026#39;add\u0026#39; ## s1 ~ s5까지 출력해보자. \u0026gt; print(s1, type(s1)) {\u0026#39;Kiwi\u0026#39;, \u0026#39;Orange\u0026#39;, \u0026#39;Melon\u0026#39;, \u0026#39;Apple\u0026#39;} \u0026lt;class \u0026#39;set\u0026#39;\u0026gt; \u0026gt; print(s2, type(s2)) {\u0026#39;Kiwi\u0026#39;, \u0026#39;Apple\u0026#39;, \u0026#39;Orange\u0026#39;} \u0026lt;class \u0026#39;set\u0026#39;\u0026gt; \u0026gt; print(s3, type(s3)) {3} \u0026lt;class \u0026#39;set\u0026#39;\u0026gt; \u0026gt; print(s4, type(s4)) set() \u0026lt;class \u0026#39;set\u0026#39;\u0026gt; \u0026gt; print(s5, type(s5)) frozenset({\u0026#39;Kiwi\u0026#39;, \u0026#39;Orange\u0026#39;, \u0026#39;Apple\u0026#39;}) \u0026lt;class \u0026#39;frozenset\u0026#39;\u0026gt;  frozenset을 통해서 immutable로 set을 만들 수 있는 걸 알았다.  6.2 선언 최적화  from dis import dis 사용하여, 더 빠른 선언법을 확인하기\n   요즘은 하드웨어의 성능이 매우 좋기 때문에, 소량의 데이터에서는 큰 영향이 없다.\n  하지만, 데이터량이 늘어남에 따라 작은 최적화가 쌓여 큰 성능 개선을 이룰 수 있으므로, 확인해보자.\n  위의 여러 set 선언 방법들 중 어느 것이 제일 빠를까???\n  \u0026gt; print(dis(\u0026#39;{10}\u0026#39;)) 1 0 LOAD_CONST 0 (10) 2 BUILD_SET 1 4 RETURN_VALUE None \u0026gt; print(dis(\u0026#39;set([10])\u0026#39;)) 1 0 LOAD_NAME 0 (set) 2 LOAD_CONST 0 (10) 4 BUILD_LIST 1 6 CALL_FUNCTION 1 8 RETURN_VALUE None  set([10]) 은 5단계, {10}은 3단계로 s1처럼 선언하는 방식이 더 빠르다는 걸 알 수 있다.  6.3 Set comprehension   list comprehension에서 알아봤기 때문에, comprehension의 의미는 생략한다.\n  바로 실습해보자.\n  ## 예제 1 \u0026gt; l = {(m, n) for n in range(2) for m in range(3, 5)} \u0026gt; l = set([(3, 0), (3, 1), (4, 0), (4, 1)]) \u0026gt; print(l) {(3, 1), (4, 0), (4, 1), (3, 0)} ## 예제 2 \u0026gt; sentence = \u0026#34;The cat in the hat had two sidekicks, thing one and thing two.\u0026#34; \u0026gt; words = sentence.lower().replace(\u0026#39;.\u0026#39;, \u0026#39;\u0026#39;).replace(\u0026#39;,\u0026#39;, \u0026#39;\u0026#39;).split() \u0026gt; unique_word = {word for word in words} \u0026gt; print(unique_word) {\u0026#39;in\u0026#39;, \u0026#39;and\u0026#39;, \u0026#39;the\u0026#39;, \u0026#39;had\u0026#39;, \u0026#39;cat\u0026#39;, \u0026#39;two\u0026#39;, \u0026#39;thing\u0026#39;, \u0026#39;one\u0026#39;, \u0026#39;sidekicks\u0026#39;, \u0026#39;hat\u0026#39;} ## 예제 3 # if 조건문을 함께 사용해보자. \u0026gt; unique_words = {word for word in words if len(word) \u0026lt;= 3} \u0026gt; print(unique_word) {\u0026#39;and\u0026#39;, \u0026#39;cat\u0026#39;, \u0026#39;had\u0026#39;, \u0026#39;hat\u0026#39;, \u0026#39;in\u0026#39;, \u0026#39;one\u0026#39;, \u0026#39;the\u0026#39;, \u0026#39;two\u0026#39;}  set 또한 list처럼 comprehension의 방법으로 선언할 수 있다는 걸 확인했다. 간결한 선언법이 장점이지만, 과하면 가독성이 좋지 않다는 걸 기억하자.   Reference  Data Model 인프런 파이썬 중급 python 공식문서: list comprehension [Python] list comprehension에 대한 즐거운 이해 자료구조와 함께 배우는 알고리즘 입문 - 파이썬편  ","permalink":"http://jeha00.github.io/post/python_basic/python_basic_29_datamodel/","summary":"Python data model을 상세히 분류하여 mutable과 immutable의 차이가 무엇인지,  list comprehension이 무엇인지, unpacking을 tuple에 어떻게 구현하는지, immutable dictionary와 set에 대해 조금 더 깊이 알아보자.","title":"[TIL] Python basic 29: Data Model"},{"content":"Intro  파이썬에서 모든 객체는 데이터에 대한 추상화로 표현될 수 있다. 파이썬에서는 namedtuple외에도 많은 Container datatypes가 있다. 이 종류들은 Collections library에서 찾을 수 있다. 객체를 사용하기보다 튜플 활용을 공식 레퍼런스에서 추천하고 있다.   1. Namedtuple이란??  namedtuple(typename: str, field_names: str)\n  tuple의 기본 성질인 immutable 다양한 선언법을 지원한다. Dictionary Key와 같이 사용된다.  key 값을 통해서 access할 수 있다.   일반 class 형태보다 적은 메모리를 사용한다.   2. 실습 예제  3차원 좌표 사이의 거리를 구하는 예제를 통해서 namedtuple에 대해 알아보자.  2.1 namedtuple 없이 구하기  namedtuple 없이 구해보자.  # namedtuple 를 import 해서 시작한다. \u0026gt; from collections import namedtuple # 두 점을 정의한다. \u0026gt; pt1 = (2.0, 4.0, 5,0) \u0026gt; pt2 = (4.0, 10.0, 25.0) # sqrt를 import 한다. root를 의미한다. \u0026gt; from math import sqrt # index를 통해서 직접 value에 접근해야 한다. \u0026gt; leng1 = sqrt((pt2[0] - pt1[0]) ** 2 + (pt2[1] - pt1[1]) ** 2 + (pt2[2] - pt1[2]) ** 2 ) \u0026gt; print(round(leng1)) 21 2.2 namedtuple로 구해보기  namedtuple을 사용하여 거리를 구해보자.  \u0026gt; from collections import namedtuple # namedtuple 선언 \u0026gt; Point = namedtuple(\u0026#39;Point\u0026#39;, \u0026#39;x y z\u0026#39;) # 두 점을 정의한다. \u0026gt; pt1 = (2.0, 4.0, 5.0) \u0026gt; pt2 = (4.0, 10.0, 25.0) # index로도 접근이 가능하지만 # value에 직접 접근하지 않고, key 값을 통해서 접근한다. \u0026gt; leng2 = sqrt((pt4.x - pt3.x) ** 2 + (pt4.y - pt3.y) ** 2 + (pt4.z - pt3.z) ** 2) \u0026gt; print(leng1 == leng2) True  이처럼 namedtuple을 사용하면 dictionary처럼 key 값이 생기기 때문에, index로 직접 접근하지 않아 오류를 낼 가능성이 낮다.  2.3 namedtuple의 다양한 선언법  다음으로 namedtuple의 다양한 선언법에 대해 알아보자.  # list 안에 string 성분으로 입력하는 방법 \u0026gt; Point = namedtuple(\u0026#39;Point\u0026#39;, [\u0026#39;x\u0026#39;, \u0026#39;y\u0026#39;, \u0026#39;z\u0026#39;]) # 하나 하나 string으로 입력하는 방법 \u0026gt; Point = namedtuple(\u0026#39;Point\u0026#39;, \u0026#39;x\u0026#39;, \u0026#39;y\u0026#39;, \u0026#39;z\u0026#39;) # string 묶음으로 입력하는 방법 \u0026gt; Point = namedtuple(\u0026#39;Point\u0026#39;, \u0026#39;x y z\u0026#39;) ## field_name으로 예약어를 사용하고 싶을 때 # 일반적으로 예약어를 name에 사용하면 안된다. 하지만, 사용하고 싶다면?? \u0026gt; Point = namedtuple(\u0026#39;Point\u0026#39;, \u0026#39;x y z class\u0026#39;, rename = True)  rename을 입력하지 않으면 rename = False 가 default다.  2.4 namedtuple의 다양한 객체 생성법  객체 생성 방법도 다양하다. 이에 대해서도 알아보자.  # field name을 직접 입력하여 할당하기 \u0026gt; p1 = Point(x=10, y=35) # 값만 입력 \u0026gt; p2 = Point(20, 40) # field name 부분 입력 \u0026gt; p3 = Point(45, y=20) # 여러 개로도 가능하지만, p4[2] 와 p4[3]에는 지정된 field-name 값이 없으므로 _2 = 30, _3 = 40 으로 저장된다. \u0026gt; p4 = Point(10, 20, 30, 40) ## unpacking을 통해 만들기 \u0026gt; temp_dict = {\u0026#39;x\u0026#39;:75, \u0026#39;y\u0026#39;:55} \u0026gt; p5 = Point(**temp_dict) ## 출력해보기 \u0026gt; print(p1, p2, p3, p4, p5) Point(x=10, y=35) Point(x=20, y=40) Point(x=45, y=20) Point(x=10, y=20, _2=30, _3=40) Point(x=75, y=55) 2.5 namedtuple 메소드   namedtuple에 사용되는 메소드를 몇 가지 알아보자.\n _make(): list를 namedtuple로 만드는 함수 _fields(): field_name 조회 함수 _asdict(): namedtuple을 dictionary로 전환하는 함수    \u0026gt; temp = [52, 38] \u0026gt; p4 = Point._make(temp) Point(x=52, y=38) \u0026gt; print(p1._fields, p2._fields, p3._fields) (\u0026#39;x\u0026#39;, \u0026#39;y\u0026#39;) (\u0026#39;x\u0026#39;, \u0026#39;y\u0026#39;) (\u0026#39;x\u0026#39;, \u0026#39;y\u0026#39;) \u0026gt; print(p1._asdict(), p4._asdict()) {\u0026#39;x\u0026#39;: 10, \u0026#39;y\u0026#39;: 35} {\u0026#39;x\u0026#39;: 52, \u0026#39;y\u0026#39;: 38}  Reference  Data Model 인프런 파이썬 중급 Python- namedtuple 사용 예제 및 소스 코드  ","permalink":"http://jeha00.github.io/post/python_basic/python_basic_28_namedtuple/","summary":"Data Model의 한 종류인 namedtuple에 대해 알아보자.","title":"[TIL] Python basic 28: Namedtuple"},{"content":"Intro  예시코드는 Python basic 24에서 작성한 코드를 이어서 사용한다.  \u0026gt; class Airline(): \u0026gt; \u0026#34;\u0026#34;\u0026#34; \u0026gt; Airline class \u0026gt; Author: Kim \u0026gt; Data: 2022.03.16 \u0026gt; Description: Class, Static, Instance Method \u0026gt; \u0026#34;\u0026#34;\u0026#34; \u0026gt; price_per_raise = 1.0 \u0026gt; def __init__(self, company, details): \u0026gt; self._company = company \u0026gt; self._details = details \u0026gt; def __str__(self): \u0026gt; return \u0026#39;str : {} - {}\u0026#39;.format(self._company, self._details) \u0026gt; def __repr__(self): \u0026gt; return \u0026#39;repr : {} - {}\u0026#39;.format(self._company, self._details) ### 코드 추가 \u0026gt; def __add__(self, x): \u0026gt; print(\u0026#39;Called \u0026gt;\u0026gt; __add__\u0026#39;) \u0026gt; return (self._details.get(\u0026#39;price\u0026#39;) + x._details.get(\u0026#39;price\u0026#39;)) \u0026gt; def __sub__(self, x): \u0026gt; print(\u0026#39;Called \u0026gt;\u0026gt; __sub__\u0026#39;) \u0026gt; return (self._details.get(\u0026#39;price\u0026#39;) - x._details.get(\u0026#39;price\u0026#39;)) \u0026gt; def __le__(self, x): \u0026gt; print(\u0026#39;Called \u0026gt;\u0026gt; __le__\u0026#39;) \u0026gt; if self._details.get(\u0026#39;price\u0026#39;) \u0026lt;= x._details.get(\u0026#39;price\u0026#39;): \u0026gt; return True \u0026gt; else: \u0026gt; return False \u0026gt; def __ge__(self, x): \u0026gt; print(\u0026#39;Called \u0026gt;\u0026gt; __ge__\u0026#39;) \u0026gt; if self._details.get(\u0026#39;price\u0026#39;) \u0026gt;= x._details.get(\u0026#39;price\u0026#39;): \u0026gt; return True \u0026gt; else: \u0026gt; return False ### 코드 추가 끝 ## Instance \u0026gt; Airline1 = Airline(\u0026#39;Koreanair\u0026#39;, {\u0026#39;uniform_color\u0026#39;: \u0026#39;skyblue\u0026#39;, \u0026#39;kind\u0026#39;:\u0026#39;FSC\u0026#39;, \u0026#39;price\u0026#39;: 8000}) \u0026gt; Airline2 = Airline(\u0026#39;Asiana\u0026#39;, {\u0026#39;uniform_color\u0026#39;: \u0026#39;gray\u0026#39;, \u0026#39;kind\u0026#39;:\u0026#39;FSC\u0026#39;, \u0026#39;price\u0026#39;: 6000}) \u0026gt; Airline3 = Airline(\u0026#39;t-way\u0026#39;, {\u0026#39;uniform_color\u0026#39;: \u0026#39;red\u0026#39;, \u0026#39;kind\u0026#39;:\u0026#39;LCC\u0026#39;, \u0026#39;price\u0026#39;: 3000}) Python의 핵심: 4가지   파이썬의 핵심은 4 가지다.\n  시퀀스(Sequence), 반복(Iterator), 함수(Functions), 클래스(Class)\n  Sequence를 알아야 Iterator를 할 수 있다.\n  일급함수 개념을 알아야 Iterator와 함께 Closure와 coroutine을 할 수 있다.\n  special method를 알아야 클래스를 풍부하게 사용할 수 있다.\n  이 4가지는 서로 유기적으로 연결되어 있다.\n    이번 시간에는 이 4가지 중 클래스 안에 정의되는 special method에 대해 알아보자.\n  파이썬 공식문서 Data Model 을 꼭 참고하자.\n   Special method란 ??   class 안에서 정의할 수 있는 특별한 method. double under-bar로 시작한다.    그렇다면 왜 특별할까??    내장(Buit-in)되어 있는 method를 사용자가 오버라이딩하여 사용할 수 있기 때문. 그래서 Special method를 통해서 클래스끼리의 연산도 가능해진다. 그래서 low level에서 효율적인 코딩을 작성할 수 있다.     그래서 Magic method라고도 한다.\n  우리가 사용한 모든 데이터 타입은 클래스다.\n 그래서 많은 연산의 백그라운드에는 이 method가 사용하고 있었던 셈이다.    dir()은 인자로 들어간 클래스 객체에서 사용할 수 있는 Special method를 보여준다.\n    special method는 클래스 안에 정의된 method다. __add__ 는 dir()로 확인할 수 있듯이 \u0026lt;class \u0026lsquo;int\u0026rsquo;\u0026gt; 안에 정의된 method다. 많은 magic method들이 이렇게 클래스 하에 존재한다.   \u0026gt; n = 10 \u0026gt; print(type(n)) \u0026lt;class \u0026#39;int\u0026gt; \u0026gt; print(dir(n)) [\u0026#39;__abs__\u0026#39;, \u0026#39;__add__\u0026#39;, \u0026#39;__and__\u0026#39;, \u0026#39;__bool__\u0026#39;, \u0026#39;__ceil__\u0026#39;, \u0026#39;__class__\u0026#39;, ...] \u0026gt; print(n + 100) 110 # 이는 `__add__` magic method를 사용하는 결과와 동일하다. \u0026gt; print(n.__add__(100)) 110   지난 번에 알아봤던 것처럼 repr() 를 사용하는 건 __repr__를 호출하여 이 method에 의한 결과값을 반환하는 것이라 했다.\n  \u0026lsquo;+\u0026rsquo; 연산자도 __add__ magic method를 호출한다.\n  그래서 위와 같이 결과가 동일하다.\n  또 다른 예를 보자.\n  \u0026gt; print(n.__bool__(), bool(n)) True True  boolean 함수도 그렇다. 파이썬에서는 많은 함수가 magic method를 호출하여 사용된다. 즉, 객체들은 다 클래스다.   Special method 연산 예제 1  magic method를 재정의하지 않고, 클래스끼리 덧셈을 해보자.  \u0026gt; print( Airline1 + Airline2 ) \u0026gt; print(Airline1.__add__(Airline2)) TypeError: unsupported operand type(s) for +: \u0026#39;Airline\u0026#39; and \u0026#39;Airline\u0026#39;  즉, 피연산자의 type이 지원되지 않는 type이라는 의미다. 이처럼 클래스끼리의 연산은 가능하지 않다. 그러면 이를 magic method를 customizing하여 사용해보자.  # 각 Airline의 `price` key에 대한 value끼리 덧셈 연산하기 \u0026gt; def __add__(self, x): # 호출되었는지 확인하기 \u0026gt; print(\u0026#39;Called \u0026gt;\u0026gt; __add__\u0026#39;) \u0026gt; return (self._details.get(\u0026#39;price\u0026#39;) + x._details.get(\u0026#39;price\u0026#39;))  instance 끼리 연산을 한다면 instance의 어느 부분들이 더하는 건지 재정의한다. 그러면 다시 덧셈을 해보자.  \u0026gt; print( Airline1 + Airline2 ) \u0026gt; print(Airline1.__add__(Airline2)) Called \u0026gt;\u0026gt; __add__ 14000  위 코드를 보고 이런 생각이 들 수도 있다. 아래와 같이 코드를 짤 수도 있지 않은가??  \u0026gt; print(Airline1._details.get(\u0026#39;price\u0026#39;) + Airline2._details.get(\u0026#39;price\u0026#39;)) 14000   동일한 결과다.\n  하지만 이렇게 직접 값에 접근하는 건\n 위험하다. 코드 양이 많아지고, 가독성이 좋지않다.    이와 같은 이유로 magic method를 잘 활용하자.\n  다른 magic method도 만들어보자.\n  # 각 Airline의 `price` key에 대한 value끼리 뺄셈 연산하기 \u0026gt; def __sub__(self, x): # 호출되었는지 확인하기 \u0026gt; print(\u0026#39;Called \u0026gt;\u0026gt; __sub__\u0026#39;) \u0026gt; return (self._details.get(\u0026#39;price\u0026#39;) - x._details.get(\u0026#39;price\u0026#39;)) # 각 Airline의 `price` key에 대한 value끼리 비교 연산하기 \u0026gt; def __le__(self, x): # 호출되었는지 확인하기 \u0026gt; print(\u0026#39;Called \u0026gt;\u0026gt; __le__\u0026#39;) \u0026gt; if self._details.get(\u0026#39;price\u0026#39;) \u0026lt;= x._details.get(\u0026#39;price\u0026#39;): \u0026gt; return True \u0026gt; else: \u0026gt; return False # 각 Airline의 `price` key에 대한 value끼리 비교 연산하기 \u0026gt; def __ge__(self, x): # 호출되었는지 확인하기 \u0026gt; print(\u0026#39;Called \u0026gt;\u0026gt; __ge__\u0026#39;) \u0026gt; if self._details.get(\u0026#39;price\u0026#39;) \u0026gt;= x._details.get(\u0026#39;price\u0026#39;): \u0026gt; return True \u0026gt; else: \u0026gt; return False \u0026gt; print(Airline1 \u0026gt;= Airline2) Called \u0026gt;\u0026gt; __ge__ True \u0026gt; print(Airline1 \u0026lt;= Airline2) Called \u0026gt;\u0026gt; __le__ False \u0026gt; print(Airline1 - Airline2) Called \u0026gt;\u0026gt; __sub__ 2000   연산자 약어\nge: greater or equal\nle: less or equal\nlt: little\ngt: greater    Special method 연산 예제 2   이번 예제에서는 packin 과 unpacking을 사용한다.\n  packin 과 unpacking에 대한 기본 내용은 다음을 참고한다.\n [TIL] Python basic 12: Method    일반적인 덧셈 연산으로는 벡터 연산을 하지 못한다.\n  그래서 벡터 연산에 맞게 magic method를 구현한다.\n   other이란??\n정의한 class로 만든 또 다른 instance\n \u0026gt; class Vector(Object): # def __init__(self,x,y) 로 써도 되지만, 팩킹을 사용해보자. # 잘 만든 오픈 소스들을 보면 아래처럼 작성된다. \u0026gt; def __init__(self, *args): \u0026gt; \u0026#39;\u0026#39;\u0026#39; Create a vector, example: v = Vector(5, 10) \u0026#39;\u0026#39;\u0026#39; # 실전에서는, 그리고 잘 만든 소스들에는 주석이 잘 달려있다. \u0026gt; if len(args) == 0: \u0026gt; self._x, self._y = 0, 0 \u0026gt; else: # unpacking \u0026gt; self._x, self._y = args \u0026gt; def __repr__(self): \u0026gt; \u0026#39;\u0026#39;\u0026#39;Returns the vector method informations\u0026#39;\u0026#39;\u0026#39; # raw data로 출력하기 \u0026gt; return \u0026#39;Vector(%r, %r)\u0026#39; % (self._x, self._y) \u0026gt; def __add__(self, other): \u0026gt; \u0026#39;\u0026#39;\u0026#39;Returns the vector addtion of self and other\u0026#39;\u0026#39;\u0026#39; \u0026gt; return Vector(self._x+ other._x) \u0026gt; def __mul__(self, y): \u0026gt; ```Returns the vector addition of self and other``` \u0026gt; return Vector(self._x * y, self._y * y )   Vector에 대한 comment를 보고 싶다면??\n print(Vector.__doc__) 를 사용한다.    그러나 위에 코드에는 Vector에 대한 comment는 없다.\n  Vector에 대한 comment 대신 Vector.__init__에 대한 comment가 있다.\n  이런 경우에는 어떻게 볼 수 있을까???\n print(Vector.__init__.__doc__를 사용한다.    위 코드들로 실습을 해보자.\n  \u0026gt; v1 = Vector(20, 45) \u0026gt; v2 = Vector(2.5, 5) \u0026gt; v3 = Vector() \u0026gt; print(Vector.__init__.__doc__) Create a vector, example : v = Vector(5, 10) \u0026gt; print(Vector.__repr__.__doc__) Returns the vector method infomations \u0026gt; print(Vector.__add__.__doc__) Returns the vector addition of self and other \u0026gt; print(v1, v2, v3) Vector(20, 45) Vector(2.5, 5) Vector(0, 0) \u0026gt; print(v1 + v2) Vector(22.5, 50) \u0026gt; print(v1 * 3) Vector(60, 135) \u0026gt; print(v2 * 10) Vector(25.0, 50)  위 magic method 외에도 매우 많이 있다. 이 문서 A Guide to Python\u0026rsquo;s Magic Methods를 참고하자.   Reference  인프런 파이썬 중급 Data Model stackoverflow : \u0026lsquo;What does \u0026ldquo;other\u0026rdquo; mean in python?'  ","permalink":"http://jeha00.github.io/post/python_basic/python_basic_27_specialmethod/","summary":"지난 번 Python basic 26 Class advanced에 이어서 class 안에 정의되는 built-in method인 special method에 대해 알아보자.","title":"[TIL] Python basic 27: Special Method"},{"content":"Intro  HTTP 학습내용의 기본 출처: 김영한님의 모든 개발자를 위한 HTTP 웹 기본지식 강의를 듣고 정리한 내용과 모르는 부분에 대한 추가 내용을 합쳐 올린다. 이 강의는 HTTP에 대한 웹 기본지식을 설명하는 강의이므로, 내용이 간략할 수 있다.   학습 이유: 프레임워크를 사용하여 웹 개발을 배우기 전에, HTTP에 대해 기본적인 지식을 알고자 HTTP 공부를 시작한다. 이 강의에 대해 공부 후, 네트워크 전반에 대해 공부한다.    이번 chapter에서는 지난 HTTP header [TIL] Network HTTP Header 1에 이어서 관련 header에 대해 집중적으로 알아본다.\n  HTTP header의 용도는 [TIL] Network HTTP basic을 참고한다.\n   1. 캐시 기본 동작 1.1 캐시가 없을 때  클라이언트가 GET 메소드를 사용하여 /star.jpg 를 조회요청을 서버에 보낸다. 서버는 이에 응답하여 HTTP 메세지를 생성하고, HTTP body에 data를 담는다. data의 크기는 다음 같이 가정한다.  HTTP header의 data 크기: 0.1 Megabye HTTP body의 data 크기: 1.0 Megabyte   서버의 응답에 클라이언트는 star.jpg를 받는다.   그러면 캐시가 없는 상황에서 서버에 동일한 요청을 또 보내면 어떻게 될까??   처음과 동일하게, 총 1.1M의 크기를 다운받는다.   캐시가 없기 때문에  데이터가 변경되지 않아도, 계속 네트워크를 통해서 데이터를 다운받아야 한다. 인터넷 네트워크는 비싸고 매우 느리다. 브라우저 로딩 속도가 느리다. 결국, 사용자는 느린 사용 경험을 겪는다.    1.2 캐시를 적용할 때  브라우저에 캐시 저장 공간을 사용한다. 클라이언트의 요청에 서버는 응답 메세지를 생성한다. 그리고, 클라이언트에게 응답 메세지를 보내면서 결과를 캐시에 저장한다.   클라이언트의 두 번째 요청 시, 클라이언트는 서버에 요청을 바로 보내지 않는다. 먼저, 브라우저 캐시에서 캐시 유효 시간을 먼저 검증한다. 유효 시간이 일치하면 캐시에서 조회하여 원하는 데이터를 사용한다.   캐시가 존재하기 때문에  캐시 가능 시간 동안 네트워크를 사용하지 않아도 된다. 비싼 네트워크 사용량을 줄일 수 있다. 브라우저 로딩 속도가 매우 빠르다. 사용자는 빠른 네트워크 경험을 할 수 있다.    1.3 캐시 시간 초과했을 때  캐시 유효 시간을 검증 요청한다.   서버에서 다시 전송한다.    응답 결과를 다시 캐시에 저장한다.\n  캐시 유효 시간이 초과하면, 서버를 통해 데이터를 다시 조회하고, 캐시를 갱신한다.\n  이때 다시 네트워크 다운로드가 발생한다.\n   2. 검증 헤더와 조건부 요청 1  검증 헤더: 캐시 데이터와 서버 데이터가 같은지 검증하는 데이터. ex) Last-Modified header\n조건부 요청 헤더: 검증 헤더로 조건에 따른 분기. ex) if-modified-since: header\n   캐시 유효 시간이 초과해서 서버에 다시 요청하면 다음 두 가지 상황이 나타난다.\n 서버에서 기존 데이터를 변경하거나, 변경하지 않는 상황    캐시 만료 후에도 서버에서 데이터를 변경하지 않은 상황으로 가정하자.\n 데이터를 전송하는 대신에 저장해 두었던 캐시를 재사용할 수 있다. 단, 클라이언트와 서버의 각 데이터가 같다는 사실을 확인할 수 있는 방법이 필요하다.     캐시 시간 초과로 서버에 재요청 시, if-modified-since: header를 메세지에 넣어 보낸다. 이 header가 조건부 요청 header다. 이 header는 캐시가 가지고 있는, 데이터 최종 수정일을 말한다.   서버에서 클라이언트가 보낸 요청과 서버의 해당 data의 데이터 최종 수정일을 비교.   동일할 경우, HTTP body를 전송하지 않고 HTTP header만 전송한다. 데이터가 수정되지 않았기 때문에, 304 Not Modified 상태이며, 검증헤더인 Last-Modified header를 추가한다.    그러면 응답 결과를 재사용하여, header data를 갱신한다.\n  정리\n 캐시 유효 시간이 초과해도, 서버의 데이터가 갱신되지 않으면  304 Not Modified + Header Meta data만 응답하면 된다. 여기서 Header Meta data란 검증헤더를 말한다. 이 때, HTTP Body는 없어도 된다. -\u0026gt; 클라이언트는 서버가 보낸 응답 헤더정보로 캐시의 메타 정보를 갱신한다. -\u0026gt; 클라이언트는 캐시에 저장되어 있는 데이터를 재활용한다. 결과적으로, 네트워크 다운로드가 발생하지만 용량이 적은 헤더 정보만 다운로드.      실제 웹 브라우저에서 다음 경로를 통해서 조건부 요청 헤더를 볼 수 있다.\n 검사(F12) -\u0026gt; Network tab 클릭 -\u0026gt; Status 란에 글씨가 연한 게 Cache에서 불러온 것 다시 이미지 더블클릭 -\u0026gt; 검사 -\u0026gt; Network -\u0026gt; 새로고침(F5) -\u0026gt; 이미지 클릭 -\u0026gt; headers tab -\u0026gt; Request header -\u0026gt; if-modified-since 보기     3. 검증 헤더와 조건부 요청 2  검증 헤더: Last-Modified, ETag\n조건부 요청 헤더: If-Modified-Since:, Last-Modified, If-None-Match:ETag\n   Last-Modified header 의 단점을 해결하는 header에 대해 알아보자.\n  검증 헤더 (Validator)\n Last-Modified, ETag    조건부 요청 헤더\n If-Match, If-None-Match:ETag 값 사용 If-Modified-Since, If-Unmodified-Since: Last-Modified 값 사용 조건이 만족하면 200 OK 조건이 만족하지 않으면 304 Not Modified    예시\n If-Modified-Since: 이후에 데이터가 수정되었다면???  데이터 미변경 예시  캐시: 2020년 11월 10일 10:00:00 vs 서버:2020년 11월 10일 10:00:00 304 Not Modified, 헤더 데이터만 전송(BODY 미포함) 전송 용량 0.1M (헤더 0.1M, 바디 1.0M)   데이터 변경 예시  캐시: 2020년 11월 10일 10:00:00 vs 서버:2020년 11월 10일 11:00:00 200 OK, 모든 데이터 전송(BODY 포함) 전송 용량 1.1M (헤더 0.1M, 바디 1.0M)        3.1 If-Modified-Since:, Last-Modified 단점  1초 미만(0.x초) 단위로 캐시 조정이 불가능하다. 날짜 기반의 로직을 사용한다. 그래서 데이터를 수정해서 날짜가 다르면, 같은 데이터를 수정해서 데이터 결과가 똑같은 경우에도 다시 다운받아야 한다. 위 문제로 서버에서 별도의 캐시 로직을 관리하고 싶은 경우, 다음 Header들을 사용한다.  ex) 스페이스나 주석처럼 크게 영향이 없는 변경에서 캐시를 유지하고 싶은 경우    3.2 해결책: ETag, IF-None-Match  날짜 기반의 date가 기준이 아닌 데이터의 버전 이름이 기준\n  ETag: Entity Tag 캐시용 데이터에 임의의 고유한 버전 이름을 달아둔다.  ex) ETag: v1.0, ETag: a2jiodwjekij3   데이터가 변경되면 이 이름을 바꾸어서 변경한다. (Hash를 다시 생성한다.)  ex) ETag: \u0026lsquo;aaaaa\u0026rsquo;, -\u0026gt; ETag: \u0026lsquo;bbbbbb\u0026rsquo;   진짜 단순하게 ETag만 보내서 같으면 유지, 다르면 다시 받는다.   ETag: aaaaaaaaaa header 로 서버가 응답했다.   그리고 위 Tag 로 응답 결과를 캐시에 저장했다.   두 번째 요청을 했지만, 캐시 시간이 초과된 상황이다.   서버에 재요청을 보낼 때, 캐시가 가지고 있는 ETag의 내용을 If-None-Match: header로, 요청 message의 header에 함께 보낸다.   서버에서 응답하는 ETag의 내용과 If-None-Match:의 내용을 비교한다. 동일하다는 건, 아직 데이터는 수정되지 않았음을 의미한다.   데이터가 수정되지 않았기 때문에, HTTP 헤더만 보낸다.   응답 결과를 재사용하여, 캐쉬 데이터의 헤더 데이터를 갱신한다.   4. 캐시와 조건부 요청 헤더  캐쉬 제어 헤더의 종류에는 3가지가 있다.  Cache-Control: 캐시 제어 Pragma: 캐시 제어(하위 호환) Expires: 캐시 유효 기간(하위 호환)    4.1 Cache-Control  캐시 지시어(directives)\n   Cache-Control: max-age\n 초 단위로, 캐시 유효 시간을 알려준다.    Cache-Control: no-cache\n 데이터는 캐시해도 되지만, 항상 원(origin) 서버에 검증하고 사용해야 한다.  Origin 서버라 하는 이유는 중간에 여러 proxy 서버가 있기 때문이다.      Cache-Contrl: no-store\n 데이터에 민감한 정보가 있으므로 저장하면 안된다. (메모리에서 사용하고 최대한 빨리 삭제)    4.2 Pragma  캐시 제어(하위 호환)\n  Pragma:no-cache HTTP 1.0 의 하위 호환  하위 호환이라 지금은 대부분 사용하지 않는다. 하지만, 구글에서는 여러 국가를 지원하기 때문에 사용하고 있다.    4.3 Expires  캐시 만료일 지정(하위 호환)\nexpires: Mon, 01 Jan 1990 00:00:00 GMT\n  캐시 만료일을 정확한 날짜로 지정한다. HTTP 1.0부터 사용한다. 지금은 더 유연한 방법인 Cache-Control:max-age 를 권장한다. Cache-Control:max-age와 함께 사용하면 Expires는 무시된다.  4.4 검증 헤더와 조건부 요청 헤더   검증 헤더 (Validator)\n ETag: \u0026ldquo;v1.0\u0026rdquo;, ETag: \u0026ldquo;asid93jkrh2l\u0026rdquo; Last-Modified: Thu, 04 Jun 2020 07:19:24 GMT    조건부 요청 헤더\n If-Match, If-None-Match: ETag 값 사용 If-Modified-Since, If-Unmodified-Since: Last-Modified 값 사용     5. 프록시 캐시  Cache-Control\n캐시 지시어(directives) - 기타\n   Cache-Control: public\n 응답이 public 캐시에 저장되어도 된다.    Cache-Control: private\n 응답이 해당 사용자만을 위한 것이다. private 캐시에 저장해야 한다. (기본값)    Cache-Control: s-maxage\n  프록시 캐시에만 적용되는 max-age\n  Age: 60(HTTP 헤더)\n Origin 서버에서 응답 후, proxy 캐시 내에 머문 시간(단위:초) 우리가 데이터를 받아야 알 수 있다.     원 서버와 클라이언트 사이에 중간 서버 없이, Origin (원) 서버에 직접 접근하는 경우 데이터를 가져오는데 비교적 긴 시간이 걸린다.   하지만 이렇게 proxy 캐시 서버를 도입하면 한국에서 보다 빨리 데이터를 받을 수 있다.   6. 캐시 무효화  확실한 캐시 무효화 응답\nCache-Control: no-cache, Cache-Control: no-store, Cache-Control: must-revalidate\nPragma: no-cache : HTTP 1.0 하위호환\n   캐시 무효화가 필요한 이유:\n 캐쉬를 적용하려고 하지 않아도, 웹 브라우저들이 임의로 적용한다. 그래서, 이 페이지는 캐쉬를 넣으면 안된다면, 위 헤더들을 반드시 넣어야 한다.    Cache-Control directives(캐시 지시어) - 확실한 캐시 무효화\n  Cache-Control: no-cache\n 데이터는 캐시해도 되지만, 항상 원 서버에 검증하고 사용해야 한다. Header 이름 혼동 주의!    Cache-Control: no-store\n 데이터에 민감한 정보가 있으므로 저장하면 안된다.\n(메모리에서 사용하고 최대한 빨리 삭제)    Cache-Control: must-revalidate\n 캐시 만료 후, 최초 조회시 원 서버에 검증해야 한다. 원 서버 접근 실패시 반드시 오류가 발생해야한다. 504(Gateway Timeout) =\u0026gt; no-cache와의 차이점 must-revalidate는 캐시 유효 시간이라면 캐시를 사용함    Pragma: no-cache\n HTTP 1.0 하위 호환      no-cache vs must-revalidate  no-cache의 기본 동작 (데이터가 수정되지 않은 상황)   no-cache 상황에서, 프록시 캐시와 원 서버 간 네트워크 단절이 순간 발생한 경우   must=revalidate 상황에서, 프록시 캐시와 원 서버 간 네트워크 단절이 순간 발생한 경우    정리\n  프록시 캐시와 원 서버 간 네트워크 단절이 순간 발생한 경우\n  no-cache\n 원 서버에 접근할 수 없는 경우, 서버 설정에 따라서 프록시 서버에서 응답할 수 있다. 응답한 data가 오류보다 오래된 데이터라도 보여준다. 단, 오류인지는 알려주지 않는다.    must=revalidate\n 원 서버에 접근할 수 없는 경우, 항상 오류가 발생해야 한다. 504 Gateway Timeout 으로 응답한다. 오류인지 알려준다       Reference  모든 개발자를 위한 HTTP 웹 기본지식  ","permalink":"http://jeha00.github.io/post/network/network_http_8/","summary":"검증 헤더와 조건부 요청 헤더의 종류, 그중 캐시 관련 헤더에 대해서 알아본다. 그리고, 프록시 서버와 원(Origin) 서버의 차이와 캐시를 어떻게 무효화하는지 알아본다.","title":"[TIL] Network HTTP Header 2"},{"content":"Intro  HTTP 학습내용의 기본 출처: 김영한님의 모든 개발자를 위한 HTTP 웹 기본지식 강의를 듣고 정리한 내용과 모르는 부분에 대한 추가 내용을 합쳐 올린다. 이 강의는 HTTP에 대한 웹 기본지식을 설명하는 강의이므로, 내용이 간략할 수 있다.   학습 이유: 프레임워크를 사용하여 웹 개발을 배우기 전에, HTTP에 대해 기본적인 지식을 알고자 HTTP 공부를 시작한다. 이 강의에 대해 공부 후, 네트워크 전반에 대해 공부한다.    이번 chapter에서는 HTTP header 여러 종류에서 주로 사용하는 헤더에 대해 알아보겠다.\n  HTTP header의 용도는 [TIL] Network HTTP basic을 참고한다.\n  RFC2616(과거) - HTTP Header 분류  HTTP header 종류에 대해 알아보기 전, 과거 \u0026lsquo;RFC2616\u0026rsquo; 일 때 헤더 분류를 살펴보자.   General 헤더: 메시지 전체에 적용되는 정보, 예) Connection: close Request 헤더: 요청 정보, 예) User-Agent: Mozilla/5.0 (Macintosh; ..) Response 헤더: 응답 정보, 예) Server: Apache Entity 헤더: 엔티티 바디 정보, 예) Content-Type: text/html, Content-Length: 3423  RFC2616(과거) - HTTP body  메세지 본문(message body)은 엔티티 본문(entity body)을 전달하는데 사용 entity body는 요청이나 응답에서 전달할 실제 데이터 entity header는 entity 본문의 데이터를 해석할 수 있는 정보를 제공한다.  데이터 유형(html, json), 데이터 길이, 압축 정보 등등    RFC2616 폐지 그리고, RFC7230~7235 등장  RFC2616이 폐지되고, RFC7230~7235가 등장하면서 Entity 라는 표현이 Representation 으로 바꼈다. 그리고, Representation 이란 representation Metadata와 Representation Data를 합친 걸 의미한다. 엔티티(Entity) -\u0026gt; Representation  Representation = Representation Metadata + Representation Data    RFC7230 - HTTP Body  메시지 본문(message body)을 통해 표현 데이터를 전달한다. 메시지 본문을 다른 말로 페이로드(payload)라 한다. representation은 요청이나 응답에서 전달할 실제 데이터 representation header는 Representation Data를 해석할 수 있는 정보를 제공한다.  데이터 유형(html, json), 데이터 길이, 압축 정보 등등   참고: Representation header는 representation metadata 와 payload message를 구분해야 하지만, 여기서는 생략한다.   그러면 이 representation이 뭔지 알아보자.   1. 표현(representation) 1.0 Representation header 란??  client와 server 간에 주고 받는 resource의 data를 어떻게 표현할지 결정하는 header\n   예) DB에 있는 binary data를 바로 서버에 전송하는 게 아니라, HTML 또는 XML 또는 JSON 형태로 전달한다.\n  Representation header는 전송, 응답 둘 다 사용한다.\n  그래서 representation header 에는 여러 정보들이 담긴다.\n Content-Type: 표현 데이터의 형식 설명 Content-Encoding: 표현 데이터의 압축 방식 Content-Language: 표현 데이터의 자연 언어 Content-Length: 표현 데이터의 길이    1.1 Content-Type  표현 데이터의 형식 설명\n  미디어 타입, 문자 인코딩 예)  text/html; charset =utf-8 application/json image/png    1.2 Content-Encoding  표현 데이터의 압축 방식 설명\n  표현 데이터를 압축하기 위해 사용 데이터를 전달하는 곳에서 압축 후 인코딩 헤더 추가 데이터를 읽는 쪽에서 인코딩 헤더의 정보로 압축 해제 예)  gzip deflate identity    1.3 Content-Language  표현 데이터의 자연어 설명\n  표현 데이터의 자연 언어를 표현 예)  ko en en-US    1.4 Content-Length  표현 데이터의 길이 설명\n  바이트 단위 Transfer-Encoding(전송 코딩)을 사용하면 Content-Length를 사용하면 안된다.   2. 콘텐츠 협상  클라이언트가 선호하는 표현을 서버에게 요청하는 것\n   서버에 요청 사항이 다양하다면, 우선 순위에 맞춰 서버에서 만든다.\n  클라이언트가 요청할 때 작성하기 때문에, 요청 시에만 사용한다.\n  협상 헤더 종류\n Accept: 클라이언트가 선호하는 미디어 타입 전달 Accept-Charset: 클라이언트가 선호하는 문자 인코딩 Accept-Encoding: 클라이언트가 선호하는 압축 인코딩 Accept-Language: 클라이언트가 선호하는 자연 언어    2.1 Accept-Language 적용 전과 후  적용 전   적용 후   복잡한 예시  2.2 협상과 우선순위 (Quality Values(q)) 2.2.1 협상과 우선순위 첫 번째  첫 번째: Quality Values(q)가 높을 수록 우선순위가 높다.\n   Quality Values(q) 값 사용\n 0~1, 클수록 높은 우선순위 생략하면 1    Accept-Language: ko-KR,ko;q=0.9,en-US;q=0.8,en;q=0.7\n   ko-KR;q=1 (q생략)    ko;q=0.9    en-US;q=0.8    en:q=0.7      인터넷 창 -\u0026gt; 검사 -\u0026gt; Network -\u0026gt; Headers -\u0026gt; Request Headers 창에 들어가면 사용하는 도메인의 우선순위를 볼 수 있다.\n  2.2.2 협상과 우선순위 두 번째  두 번째: 구체적인 것이 우선된다. GET /event\nAccept: text/*, text/plain, text/plain;format=ﬂowed, */*\n   Accept: text/_, text/plain, text/plain;format=flowed, _/*\n text/plain;format=flowed text/plain text/* */*    2.2.3 협상과 우선순위 세 번째  세 번째: 구체적인 것을 기준으로 미디어 타입을 맞춘다.\n  Media Type 우선도  Accept: text/*;q=0.3, text/html;q=0.7, text/html;level=1,text/html;level=2;q=0.4, */*;q=0.5     3. 전송 방식  전송 방식에는 4 종류가 있다.  단순 전송(Content-Length) 압축 전송(Content-Encoding) 분할 전송(Transfer-Encoding) 범위 전송(Range, Content-Range)    3.1 단순 전송(Content-Length)  content의 길이를 알 수 있을 때 사용한다. 한 번에 요청하고,한 번에 받는다.  3.2 압축 전송(Content-Encoding)  서버에서 메세지 바디를 압축해서 전달하는 방식 Content-Encoding에 어떻게 압축했는지 알려줘야, 웹 브라우저에서 이에 맞게 풀어서 접근할 수 있다.  3.3 분할 전송(Transfer-Encoding)  용량이 커서 한 번에 보내면 받는데 시간이 걸리기 때문에, 분할하여 보내서 오는 대로 바로 구현한다. 이 때는 content-length를 넣으면 안된다. 전체 길이를 알 수 없기 때문이다. 5 byte 씩 나눠서 보내고, 마지막에는 보낼 게 없어서 0이다.  3.4 범위 전송(Range, Content-Range)  4. 일반 정보 4.1 From  유저 에이전트의 이메일 정보\n  일반적으로 잘 사용되지 않는다. 검색 엔진 같은 곳에서, 주로 사용한다. 요청에서 사용한다.  4.2 Referer  이전 웹 페이지 주소\n  유입 경로 분석을 위해 많이 사용한다. 현재 요청된 페이지의 이전 웹 페이지 주소 A -\u0026gt; B로 이동하는 경우 B를 요청할 때 Referer: A 를 포함해서 요청한다. Referer를 사용해서 유입 경로 분석이 가능하다. 요청에서 사용한다. 참고: referer는 단어 referrer의 오타다. 이미 너무 많은 곳에서 사용해서 그냥 사용한다.  4.3 User-Agent  유저 에이전트 애플리케이션 정보\nuser-agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/86.0.4240.183 Safari/537.36\n  검사(F12) -\u0026gt; Network -\u0026gt; Headers -\u0026gt; User-Agent 확인 클리이언트의 애플리케이션 정보(웹 브라우저 정보, 등등) 통계 정보 어떤 종류의 브라우저에서 장애가 발생하는지 파악 가능 요청에서 사용  4.4 Server  요청을 처리하는 ORIGIN 서버의 소프트웨어 정보\n여러 proxy server를 거치고, 최종적으로 나의 요청을 처리하는 서버를 ORIGIN 서버라 한다.\n  Server: Apache/2.2.22 (Debian) server: nginx 응답에서 사용한다.  4.5 Data  메시지가 생성된 날짜\n  Date: Tue, 15 Nov 1994 08:12:31 GMT 응답에서 사용한다.   5. 특별 정보  Host: 요청한 호스트 정보(도메인) Location: 페이지 리다이렉션 Allow: 허용 가능한 HTTP 메서드 Retry-After: 유저 에이전트가 다음 요청을 하기까지 기다려야 하는 시간  5.1 Host  GET /search?q=hello\u0026amp;hl=ko HTTP/1.1\nHost: www.google.com\n  요청에서 사용 필수 하나의 서버가 여러 도메인을 처리할 때  하나의 IP 주소에 여러 도메인이 적용되어 있을 때     가상 호스트를 통해 여러 도메인을 한 번에 처리할 수 있는 서버에서는 실제 애플리케이션이 여러 개 구동될 수 있다. 이럴 때 HOST가 없이 요청을 하면 어느 도메인으로 들어가야하는지 알 수 없다. 이럴 때, 헤더 정보에 host를 추가하여 어느 도메인으로 들어가야 할지 알 수 있다.  5.2 Location  페이지 리다이렉션\n  웹 브라우저는 3xx 응답의 결과에 Location 헤더가 있으면, Location 위치로 자동 이동 (리다이렉트) 응답코드 3xx에서 설명 201 (Created): Location 값은 요청에 의해 생성된 리소스 URI 3xx (Redirection): Location 값은 요청에 의해 생성된 리소스 URI  5.3 Allow  허용 가능한 HTTP 메서드를 명시한다.\n하지만, 실제로 많이 구현되어 있지 않으므로 이런 게 있다 정도만 알자.\n  405 (Method Not Allowed) 에서 응답에 포함해야 한다. Allow: GET, HEAD, PUT  5.4 Retry-After  유저 에이전트가 다음 요청을 하기까지 기다려야 하는 시간\n하지만, 실제로는 사용하기 어렵다.\n  503 (Service Unavailable): 서비스가 언제까지 불능인지 알려줄 수 있음 Retry-After: Fri, 31 Dec 1999 23:59:59 GMT (날짜 표기) Retry-After: 120 (초단위 표기)   6. 인증 6.1 Authorization  클라이언트 인증 정보를 서버에 전달한다.\n  Authorization: Basic xxxxxxxxxxxxxxxx 인증 관련해서 여러 매커니즘이 있다. 각 매커니즘마다 넣는 헤더가 다르다. 추가적으로 알아보자.  6.2 WWW-Authenticate  리소스 접근시 필요한 인증 방법 정의한다.\n  401 Unauthorized 응답과 함께 사용한다. WWW-Authenticate: Newauth realm=\u0026ldquo;apps\u0026rdquo;, type=1, title=\u0026ldquo;Login to \u0026quot;apps\u0026quot;\u0026rdquo;, Basic realm=\u0026ldquo;simple\u0026rdquo;  인증할려면 : 이후의 내용들을 참고해서 인증 방법을 만들라는 의미다.     7. 쿠키(중요) 7.1 쿠키란??  쿠키: HTTP의 stateless 성질 때문에 필요 하에, 서버가 자동 생성하여 클라이언트에 저장하는 데이터\n캐시: 클라이언트 자체에서 페이지 로드를 효율적으로 하려고 저장하는 데이터\n   매우 많이 사용하고, 많이 중요하다.\n  웹 브라우저는 서버에서 보낸 이 쿠키를 웹 브라우저 내부에 쿠키 저장소에 저장해 놓았다가, 서버의 응답에 클라이언트가 HTTP 메세지를 보낼 때, 이 쿠키 정보를 포함하여 보내는 용도\n  Cookie 를 사용할 때는 2가지 header를 사용한다.\n Set-Cookie: server에서 client로 쿠키를 전달할 때(응답) Cookie: client가 server에서 받은 쿠키를 저장하고, HTTP 요청 시 서버로 전달할 때    그러면 먼저 쿠키를 사용하지 않으면 어떻게 되는지 알아보자.\n   GET으로 /welcome resource를 조회한다. 서버에서는 손님으로 인식한다. 로그인을 해야 서버에서 가입된 유저로 인식한다.   하지만, 로그인후 다시 welcome page에 접근하면 다시 손님으로 인식한다.   HTTP는 stateless 프로토콜이기 때문에, 클라이언트와 서버가 요청과 응답을 주고 받으면 연결이 끊어진다. 그래서 클라이언트가 다시 요청하면 서버는 이전 요청을 기억하지 못하기 때문에, 클라이언트와 서버는 서로 상태를 유지하지 않는다.   이에 대한 대안으로 모든 요청에 사용자 정보가 포함되도록 개발한다면??  현실적으로 매우 힘들다. 그래서 이에 대한 대책으로 만든게 쿠키(cookie)다.     쿠키를 사용하면 어떻게 되는지 알아보자.   웹 브라우저 내부에 쿠키 저장소가 있어서, 서버가 만든 쿠키를 이 저장소에 저장한다.   서버에 요청을 보낼 때마다 쿠키 저장소를 조회하여 Cookie HTTP header를 생성한다.   모든 요청에 쿠키 정보를 자동으로 포함한다.  7.2 쿠키의 사용처와 문제점  ex) set-cookie: sessionId=abcde1234; expires=Sat, 26-Dec-2020 00:00:00 GMT; path=/; domain=.google.com; Secure\n   사용처\n 사용자 로그인 세션 관리 (위 이미지 사례) 광고 정보 tracking  이 웹 브라우저의 사용자는 이런 광고를 주로 클릭한다는 걸 추적한다.      문제점\n 네트워크 트래픽 추가 유발한다. 그래서 최소한의 정보만 사용한다.  (세션 id, 인증토큰)   서버에 전송하지 않고, 웹 브라우저 내부에 데이터를 저장하고 싶으면 웹 스토리지 (localStorage, sessionStroage) 참고    주의사항!\n 보안에 민감한 데이터는 저장하면 안된다.  ex) 주민번호, 신용카드 번호 등등      7.3 쿠키 - 생명주기 header  쿠키가 언제까지 지속되는지 알려주는 header\nExpries, max-age\n   Set-Cookie: expires = Sat, 26-Dec-2020 04:39:21 GMT\n 만료일이 되면 쿠키를 삭제한다.    Set-Cookie: max-age = 3600 (3600초)\n 0이나 음수를 지정하면 쿠키 삭제    세션 쿠키: 만료 날짜를 생략하면 브라우저 종료 시까지만 유지\n  영속 쿠키: 만료 날짜를 입력하면 해당 날짜까지 유지\n  7.4 쿠키 - domain header  ex) domain = example.org\n   쿠키는 도메인을 지정할 수 있다.\n  2가지 방법\n  명시: 명시한 문서 기준 도메인 + 서브 도메인을 포함한다.\n domain = example.org 를 지정해서 쿠키 생성  example.org는 물론이고, dev.example.org도 쿠키 접근한다.      생략: 현재 무선 기준 도메인만 적용한다.\n example.org에서 쿠키를 생성하고 domain 지정을 생략한다.  exmple.org 에서만 쿠키 접근 가능하다. dev.example.org는 쿠키 미접근  하위 도메인은 접근 불가능하다.          7.5 쿠키 - 경로 header  예) path = /home\n  이 경로를 포함한 하위 경로 페이지만 쿠키 접근 가능하다. 일반적으로 path=/ 루트로 지정한다. 예  path =/home 지정  /home -\u0026gt; 가능 /home/level1 -\u0026gt; 가능 /home/level1/level2 -\u0026gt; 가능 /hello -\u0026gt; 불가능      7.6 쿠키 - 보안 header  Secure, HttpOnly, SameSite\n   Secure\n 쿠키는 http, https를 구분하지 않고 전송한다. Secure를 적용하면 https인 경우에만 전송    HttpOnly\n xSS 공격 방지 자바스크립트에서 접근 불가(document.cookie) HTTP 전송에만 사용    SameSite\n XSRF 공격방지 요청 도메인과 쿠키에 설정된 도메인이 같은 경우만 쿠키 전송     Reference  모든 개발자를 위한 HTTP 웹 기본지식 HTTP 헤더1- 일반 헤더  ","permalink":"http://jeha00.github.io/post/network/network_http_7/","summary":"representation, 콘텐츠 협상, 전송 방식, 일반 정보, 특별 정보, 인증 그리고 쿠키에 대해 알아본다.","title":"[TIL] Network HTTP Header 1"},{"content":"Intro   이번 내용은 Python basic 14: 파이썬 클래스(class)에 이어 진행한다.\n  예시코드는 Python basic 24에서 작성한 코드를 이어서 사용한다.\n  \u0026gt; class Airline(): ### 코드 추가 \u0026gt; \u0026#34;\u0026#34;\u0026#34; \u0026gt; Airline class \u0026gt; Author: Kim \u0026gt; Data: 2022.03.16 \u0026gt; Description: Class, Static, Instance Method \u0026gt; \u0026#34;\u0026#34;\u0026#34; \u0026gt; price_per_raise = 1.0 ### 코드 추가 끝 \u0026gt; def __init__(self, company, details): \u0026gt; self._company = company \u0026gt; self._details = details \u0026gt; def __str__(self): \u0026gt; return \u0026#39;str : {} - {}\u0026#39;.format(self._company, self._details) \u0026gt; def __repr__(self): \u0026gt; return \u0026#39;repr : {} - {}\u0026#39;.format(self._company, self._details) ### 코드 추가 ## Instance Method: # Self로 객체의 고유한 속성 값을 사용 \u0026gt; def detail_info(self): \u0026gt; print(\u0026#39;Current ID: {}\u0026#39;.format(id(self))) \u0026gt; print(\u0026#39;Airline Detail Info: {} {}\u0026#39;.format(self._company, self._details.get(\u0026#39;price\u0026#39;))) \u0026gt; def get_price(self): \u0026gt; return \u0026#39;Before Airline ticket price -\u0026gt; Company: {}, price: {}\u0026#39;.format(self._company, self._details.get(\u0026#39;price\u0026#39;)) \u0026gt; def get_price_culc(self): \u0026gt; return \u0026#39;After Airline ticket price -\u0026gt; Company: {}, price: {}\u0026#39;.format(self._company, self._details.get(\u0026#39;price\u0026#39;) * Airline.price_per_raise = 1.0) ## Class Method: # 클래스 변수를 다룰 때는 직접 사용하기보다는 class method로 사용하기. \u0026gt; @classmethod \u0026gt; def raise_price(cls,per) \u0026gt; if per \u0026lt;= 1: \u0026gt; print(\u0026#39;Please Enter 1 or More\u0026#39;) \u0026gt; return \u0026gt; cls.price_per_raise = per \u0026gt; print(\u0026#39;Succeed! price increased\u0026#39;) ## Static Method \u0026gt; @staticmethod \u0026gt; def is_Koreanair(inst): \u0026gt; if inst._company == \u0026#39;Koreanair\u0026#39;: \u0026gt; return \u0026#39;OK! This car is {}\u0026#39;.format(inst._company) \u0026gt; return \u0026#39;Sorry! This is not Koreanair\u0026#39; ### 코드 추가 끝 ## Instance \u0026gt; Airline1 = Airline(\u0026#39;Koreanair\u0026#39;, {\u0026#39;uniform_color\u0026#39;: \u0026#39;skyblue\u0026#39;, \u0026#39;kind\u0026#39;:\u0026#39;FSC\u0026#39;, \u0026#39;price\u0026#39;: 8000}) \u0026gt; Airline2 = Airline(\u0026#39;Asiana\u0026#39;, {\u0026#39;uniform_color\u0026#39;: \u0026#39;gray\u0026#39;, \u0026#39;kind\u0026#39;:\u0026#39;FSC\u0026#39;, \u0026#39;price\u0026#39;: 6000}) \u0026gt; Airline3 = Airline(\u0026#39;t-way\u0026#39;, {\u0026#39;uniform_color\u0026#39;: \u0026#39;red\u0026#39;, \u0026#39;kind\u0026#39;:\u0026#39;LCC\u0026#39;, \u0026#39;price\u0026#39;: 3000})  1. Self의 의미   각 인스턴스의 고유값을 저장하기 위한 예약어    그래서 각 instance 마다 고유의 ID 값을 가진다. self._속성으로 입력하기 때문에, 각 인스턴스마다 자신의 영역에 저장할 수 있다.   self._속성 처럼 언더바(_)를 사용하는 이유??\n개발자들은 instance variable를 만들 때 under bar 를 사용한다.\nPEP에서 권장한다.\n ## Instance의 ID 확인 \u0026gt; print(id(Airline1)) \u0026gt; print(id(Airline2)) \u0026gt; print(id(Airline3)) 2866211294752 2866211294368 2866211294176  Instance를 만들기 위한 Class도 고유 id 값을 가지고 있다.  ## Instance가 무슨 class로 만들어졌는지 알 수 있다. \u0026gt; print(Airline1.__class__, Airline2.__class__) \u0026lt;class \u0026#39;__main__.Airline\u0026#39;\u0026gt; ## class의 고유 id값을 알 수 있다. \u0026gt; print(id(Airline)) \u0026gt; print(id(Airline1.__class__), id(Airline2.__class__)) 3104262219664 3104262219664 3104262219664  2. dir, .__dict__ 그리고 __doc__   dir은 해당 instance가 가지고 있는 속성을 list로 보여준다. 그러나, 속성의 value들은 보여주지 않는다. __dict__는 각 instance의 namespace를 보고 싶을 때 사용한다. 즉, 속성과 속성의 value들을 보여준다.   # `dir`로 나온 속성들에서 뒷 부분을 보면 class Airline에 작성된 속성들과 method들을 확인할 수 있다. \u0026gt; print(dir(Airline1)) \u0026gt; print(dir(Airline2)) [\u0026#39;__class__\u0026#39;, \u0026#39;__dict__\u0026#39;, \u0026#39;__dir__\u0026#39;, \u0026#39;__doc__\u0026#39;, \u0026#39;__init__\u0026#39;, ..... ,\u0026#39;__repr__\u0026#39;, \u0026#39;__sizeof__\u0026#39;, \u0026#39;__str__\u0026#39;,\u0026#39;_company\u0026#39;, \u0026#39;_details\u0026#39;, \u0026#39;detail_info\u0026#39;, \u0026#39;get_price\u0026#39;, \u0026#39;get_price_culc\u0026#39;, \u0026#39;is_bmw\u0026#39;, \u0026#39;price_per_raise\u0026#39;, \u0026#39;raise_price\u0026#39;] # __init__ 으로 만들어진 instance variable 의 구체적인 값을 확인할 수 있다. \u0026gt; print(Airline1.__dict__) {\u0026#39;_company\u0026#39;: \u0026#39;Koreanair\u0026#39;, \u0026#39;_details\u0026#39;: {\u0026#39;uniform_color\u0026#39;: \u0026#39;skyblue\u0026#39;, \u0026#39;kind\u0026#39;: \u0026#39;FSC\u0026#39;, \u0026#39;price\u0026#39;: 8000}} \u0026gt; print(Airline2.__dict__) {\u0026#39;_company\u0026#39;: \u0026#39;Asiana\u0026#39;, \u0026#39;_details\u0026#39;: {\u0026#39;uniform_color\u0026#39;: \u0026#39;gray\u0026#39;, \u0026#39;kind\u0026#39;: \u0026#39;FSC\u0026#39;, \u0026#39;price\u0026#39;: 6000}}  코멘트를 입력할 때는 # 도 되지만, \u0026quot;\u0026quot;\u0026quot; \u0026quot;\u0026quot;\u0026quot; 을 통해서 multi-line으로 입력할 수 있다. __doc__ 를 통해서 \u0026quot;\u0026quot;\u0026quot; \u0026quot;\u0026quot;\u0026quot; 사이에 있는 comment 부분이 출력된다. 상세한 설명을 적으면 doc 예약어를 호출하여 다른 사람들이 확인할 수 있다. 필수적인 건 아니지만, 이러한 원칙을 정해서 개발하는게 실력 향상에 좋다. 그리고, 이런 게 하나 하나 모여서 실력 있는 개발자가 된다.  # 클래서로 접근한다. # Intro에 작성한 코드에서 \u0026#34;\u0026#34;\u0026#34; \u0026#34;\u0026#34;\u0026#34; 사이에 적은 comment가 출력된다. \u0026gt; print(Airline.__doc__) Airline class Author: Kim Data: 2022.03.16 Description: Class, Static, Instance Method  3. Method의 3종류  Method의 종류에는 Instance method, class method, static Method 세 종류가 있다.\n   그러면 언제 이 method 들을 사용하는가??\n  class에 속한 모든 변수들(class variables, instance variables)을 사용하기 위해서 method를 만들어 사용한다.\n 직접 접근할 수 있지만, 좋지 않은 방법이다. class는 캡슐화 되어있기 때문이다.    Instance method는 Instance variable을 사용하기 위해서 사용한다.\n instance를 첫 번째 인자로 받는다 (self).    Class method는 Class variable을 사용하기 위해서 사용한다.\n class를 첫 번째 인자로 받는다 (cls). 또한, @classmethod라는 decorator를 입력한다.        Static method는 그럼 무엇인가??\n python 전문 서적을 보면 static method가 굳이 필요한지 의문성을 보인다. 즉, 반드시 필요하진 않지만 개념적으로 알고 있자. 위 method들과는 달리, 아무것도 받지 않는다. 위 두 가지 변수(클래스 변수, 인스턴스 변수)를 받기에는 조금 적절하지 않을 때 대책으로 사용한다. 또한, @staticmethod라는 decorator를 입력한다.    ### Intro code에서 각 method는 다음과 같다. ## Instance Method(self): # 첫 번째 인자로, self 즉 instance를 받는다는 걸 알 수 있다. \u0026gt; def detail_info(self): \u0026gt; print(\u0026#39;Current ID: {}\u0026#39;.format(id(self))) \u0026gt; print(\u0026#39;Airline Detail Info: {} {}\u0026#39;.format(self._company, self._details.get(\u0026#39;price\u0026#39;))) \u0026gt; def get_price(self): \u0026gt; return \u0026#39;Before Airline ticket price -\u0026gt; Company: {}, price: {}\u0026#39;.format(self._company, self._details.get(\u0026#39;price\u0026#39;)) \u0026gt; def get_price_culc(self): \u0026gt; return \u0026#39;After Airline ticket price -\u0026gt; Company: {}, price: {}\u0026#39;.format(self._company, self._details.get(\u0026#39;price\u0026#39;) * Airline.price_per_raise = 1.0) ## Class Method(cls): # @classmethod라는 데코레이터를 입력한 것과 # 첫 번째 인자로, cls == class 를 받는다는 걸 알 수 있다. \u0026gt; @classmethod \u0026gt; def raise_price(cls,per) \u0026gt; if per \u0026lt;= 1: \u0026gt; print(\u0026#39;Please Enter 1 or More\u0026#39;) \u0026gt; return \u0026gt; cls.price_per_raise = per \u0026gt; print(\u0026#39;Succeed! price increased\u0026#39;) ## Static Method # @staticmehod라는 데코레이터를 입력한 걸 알 수 있다. \u0026gt; @staticmethod \u0026gt; def is_Koreaair(inst): \u0026gt; if inst._company == \u0026#39;Koreanair\u0026#39;: \u0026gt; return \u0026#39;OK! This car is {}\u0026#39;.format(inst._company) \u0026gt; return \u0026#39;Sorry! This is not Koreanair\u0026#39;  각 method를 사용하여 variable에 접근하자.  ## instance의 _details에 있는 price 정보에 접근하자. # 직접 접근하기 \u0026gt; print(Airline1._details.get(\u0026#39;price\u0026#39;)) 8000 # method를 통해 접근하기 \u0026gt; print(Airline1.get_price()) Before Airline ticket price -\u0026gt; Company: Koreanair, price: 8000 ## class variable인 price_per_raise에 접근하자. # 직접 접근하기 \u0026gt; Airline.price_per_raise = 1.4 # method를 통해 접근하기 \u0026gt; Airline.raise_price(1.4) Succeed! price increased \u0026gt; print(Airline1.get_price_culc()) After Airline ticket price -\u0026gt; Company: Koreanair, price: 12000.0 ## static method # airline이 Koreanair인지 아닌지 확인해보자. # instance로 접근하든, class로 접근하든 유연하다. # instance로 접근하기: 어느 instance로 접근하든 넘겨주는 값에 따라 결과가 나온다. \u0026gt; print(Airline1.is_koreanair(Airline1)) OK! This car is Koreanair \u0026gt; print(Airline1.is_koreanair(Airline2)) Sorry! This is not Koreanair # class로 접근하기 \u0026gt; print(Airline.is_koreanair(Airline1)) OK! This car is Koreanair  Reference  인프런 파이썬 중급  ","permalink":"http://jeha00.github.io/post/python_basic/python_basic_26_class2/","summary":"instance의 self가 무엇을 의미하는지, dir과 \u003ccode\u003e__dict__\u003c/code\u003e가 무슨 차이인지, 그리고 method 3종류에 대해 알아본다.","title":"[TIL] Python basic 26: class advanced"},{"content":"Intro  HTTP 학습내용의 기본 출처: 김영한님의 모든 개발자를 위한 HTTP 웹 기본지식 강의를 듣고 정리한 내용과 모르는 부분에 대한 추가 내용을 합쳐 올린다. 이 강의는 HTTP에 대한 웹 기본지식을 설명하는 강의이므로, 내용이 간략할 수 있다.   학습 이유: 프레임워크를 사용하여 웹 개발을 배우기 전에, HTTP에 대해 기본적인 지식을 알고자 HTTP 공부를 시작한다. 이 강의에 대해 공부 후, 네트워크 전반에 대해 공부한다.  이번 시간에는 상태 코드에 대해 알아본다.  상태 코드란??\n클라이언트가 보낸 요청의 처리 상태를 응답에서 알려주는 기능\n 상태 코드의 종류에는 다음과 같다.  1xx (Informational): 요청이 수신되어 처리중 2xx (Successful): 요청 정상 처리 3xx (Redirection): 요청을 완료하려면 추가 행동이 필요 4xx (Client Error): 클라이언트 오류, 잘못된 문법등으로 서버가 요청을 수행할 수 없음 5xx (Server Error): 서버 오류, 서버가 정상 요청을 처리하지 못함    만약 모르는 상태 코드가 나타나면??\n 클라이언트가 인식할 수 없는 상태코드를 서버가 반환하면?? 클라이언트는 상위 상태 코드로 해석해서 처리한다. 미래에 새로운 상태 코드가 추가되어도 클라이언트를 변경하지 않아도 된다. 예)  299 ??? -\u0026gt; 2xx (Successful) 451 ??? -\u0026gt; 4xx (Client Error) 599 ??? -\u0026gt; 5xx (Server Error)      그러면 각 상태 코드에 대해 알아보자.\n(1xx는 거의 사용하지 않으므로 생략한다. )\n   2xx (Successful)  클라이언트의 요청을 성공적으로 처리한 상태\n   2xx state code 종류  200 OK 201 Created 202 Accepted 204 No Content    200 OK    요청이 성공한 상태\n  200번대 모든 코드들을 사용하지 않고, 200과 201만 사용하는 경우가 많다. 그래서, 팀 내에서 코드를 어디까지 사용할지 결정한다.    201 Created    요청이 성공하여 새로운 리소스가 생성된 상태\n   202 Accepted    요청이 접수되었으나 처리가 완료되지 않은 상태\n  배치 처리(batch processing) 같은 곳에서 사용한다. 예) 요청 접수 후, 1시간 뒤에 배치 프로세스가 요청을 처리한다.   배치 처리(batch processing)란??\n일괄 처리라 하며, 데이터를 일괄적으로 모아서 처리하는 작업을 말한다.\n   204 No Content    서버가 요청을 성공적으로 수행했으나, 응답 페이로드 본문에 보낼 데이터가 없는 상태\n  예) 웹 문서 편집기에서 save 버튼 save 버튼의 겨로가로 아무 내용이 없어도 된다. save 버튼을 눌러도 같은 화면을 유지해야 한다. 결과 내용이 없어도, 204 메시지(2xx)만으로 성공을 인식할 수 있다.   3xx (Redirection)  요청을 완료하기 위해 유저 에이전트(웹 브라우저)의 추가 조치가 필요한 상태\n   3xx status code 종류  300 Multiple Choices 301 Moved Permanently 302 Found 303 See Other 304 Not Modified 307 Temporary Redirect 308 Permanent Redirect    리다이렉트란???\n 웹 브라우저가 3xx 응답의 결과에 Location 헤더가 있으면, Location 위치로 자동 이동하는 것      리다이렉션의 종류   영구 리다이렉션:\n 특정 리소스의 URI가 영구적으로 이동 예) /members -\u0026gt; /users 예) /event -\u0026gt; /new-event    일시 리다이렉션:\n 일시적인 변경 주문 완료 후 주문 내역 화면으로 이동한다. 자주 쓰이는 패턴: PRG (Post/Redirect/Get)    특수 리다이렉션:\n 결과 대신 캐시를 사용한다. 클라이언트가 캐시 사용 시간을 확인하기 위해 서버에게 보내어 서버가 캐시 생성일자로 응답하는 것을 말한다.        영구 리다이렉션 (301, 308)  리소스의 URI가 영구적으로 이동 원래의 URL를 사용X, 검색 엔진 등에서도 변경 인지      301 Moved Permanently  리다이렉트 시, 요청 메서드가 POST에서 GET으로 변하고, 본문이 제거될 수 있음(MAY) 본문이 제거될 수 있다는 문제점을 308이 해결할 수 있으나, 대부분 301을 사용한다. 왜냐하면 경로가 /new-event로 바뀌면 내부적으로 전달하는 데이터가 다 바뀌는 것이기 때문에, POST로 와도 GET으로 되돌리는 게 맞다.    308 Permanent Redirect   301과 기능은 같음\n  리다이렉트시 요청 메서드와 본문 유지\n(처음 POST를 보내면 리다이렉트도 POST 유지)\n  스펙에 나와 있어 설명한다. 실무에서는 거의 이렇게 사용하지 않는다.\n      일시적인 리다이렉션 (302, 307, 303)  리소스의 URI가 일시적으로 변경 따라서 검색 엔진 등에서 URL을 변경하면 안됨 302 Found  리다이렉트시 요청 메서드가 GET으로 변하고, 본문이 제거될 수 있음(MAY)   307 Temporary Redirect  302와 기능은 같음 리다이렉트시 요청 메서드와 본문 유지\n(요청 메서드를 변경하면 안된다. MUST NOT)   303 See Other  302와 기능은 같음 리다이렉트시 요청 메서드가 GET으로 변경        PRG 예시 (전, 후)   POST로 주문 후, 웹 브라우저를 새로고침하면??\n 새로 고침은 다시 요청하는 것이기 때문에, 중복 주문이 될 수 있다.    이를 해결하기 위해 자주 사용하는 패턴이 PRG다.\n PRG: POST/Redirect/Get    PRG 사용 전\n   PRG 사용 후   302 또는 303 사용한다. POST로 주문 후에도 새로 고침으로 인한 중복 주문을 방지한다. POST로 주문 후에도 주문 결과 화면을 GET method로 리다이렉트하여, 새로 고침해도 결과 화면을 GET 으로 조회한다. 즉, 중복 주문 대신에 결과 화면만 GET으로 다시 요청한다. PRG를 사용해서 경고창이 안뜨고, 서버 입장에서는 오류가 줄어든다.      [Summary]\n 302 Found -\u0026gt; GET으로 변할 수 있다. 307 Temporary Redirect -\u0026gt; 메서드가 변하면 안된다. 303 See Other -\u0026gt; 메서드가 GET으로 변경한다.    [History]\n 처음 302 스펙의 의도는 HTTP 메서드를 유지하는 것이다. 그런데 웹 브라우저들이 대부분 GET으로 바꿨다.(일부는 다르게 동작) 그래서 모호한 302를 대신하는 명확한 307, 303이 등장했다.\n(301 대응으로 308도 등장)    [Now]\n 307, 303을 권장하지만 현실적으로 이미 많은 애플리케이션 라이브러리들이 302를 기본값으로 사용 자동 리다이렉션시에 GET으로 변해도 되면 그냥 302를 사용해도 큰 문제 없음    기타 리다이렉션 (300, 304)  300 Multiple Choices: 안쓴다. 304 Not Modified  매우 많이 사용한다. 캐시를 목적으로 사용 클라이언트에게 리소스가 수정되지 않았음을 알려준다. 따라서 클라이언트는 로컬PC에 저장된 캐시를 재사용한다. (캐시로 리다이렉트 한다.) 304 응답은 응답에 메시지 바디를 포함하면 안된다. (로컬 캐시를 사용해야 하므로) 조건부 GET, HEAD 요청시 사용     4xx (Client Error)  오류의 원인이 \u0026lsquo;클라이언트\u0026rsquo;에게 있어서, 발생하는 클라이언트 오류\n  클라이언트의 요청에 잘못된 문법 등으로 서버가 요청을 수행할 수 없다. 클라이언트가 이미 잘못된 요청,데이터를 보내고 있어서, 똑같은 재시도는 실패한다.  400 Bad Request  클라이언트가 잘못된 요청을 해서 서버가 요청을 처리할 수 없다.\n  요청 구문, 메시지 등등으로 인한 오류가 발생한 상태다. 클라이언트는 요청 내용을 다시 검토하고, 보내야 한다. 예) 요청 파라미터가 잘못되거나, API 스펙이 맞지 않을 때  401 Unauthorized  클라이언트가 해당 리소스에 대한 인증이 필요하다.\n  인증(Authentication) 되지 않은 상태를 말한다.  401 오류 발생시 응답에 WWW-Authenticate 헤더와 함께 인증 방법을 설명한다.     [참고]\n 인증(Authentication): 본인이 누구인지 확인, (로그인) 인가(Authorization): 권한부여 (ADMIN 권한처럼 특정 리소스에 접근할 수 있는 권한, 인증이 있어야 인가가 있음) 오류 메시지가 Unauthorized 이지만 인증 되지 않음 (이름이 아쉬움)   403 Forbidden  서버가 요청을 이해했지만, 승인을 거부함\n  주로 인증 자격 증명은 있지만, 접근 권한이 부충분한 경우  예) Admin 등급이 아닌 사용자가 로그인하여, admin 등급의 resource에 접근하는 경우    404 Not Found  요청 리소스를 찾을 수 없다.\n  요청 리소스가 서버에 없다. 클라이언트가 권한이 부족한 리소스에 접근할 때 해당 리소스를 숨기고 싶을 때   5xx (Serve Error)  오류의 원인이 \u0026lsquo;서버\u0026rsquo;에게 있어서, 발생하는 서버 오류\n  Client Error와 달리 서버에 문제가 있기 때문에, 재시도하면 성공할 수 있다. 500대 에러는 서버에 심각한 문제가 터졌을 때를 의미한다. 고객의 잔고가 부족할 경우, 20세 이상만 이용 가능한데 15세가 들어왔을 경우 등등은 500번대 에러가 아니다.  500 Internal Server Error  서버 문제로 오류 발생, 애매하면 500 오류\n  서버 내부 문제로 오류가 발생한 상황 애매하면 500 오류를 사용  503 Service Unavailable  서비스 이용 불가\n  서버가 일시적인 과부하 또는 예정된 작업으로 잠시 요청을 처리할 수 없는 상황 Retry-After 헤더 필드로 얼마 뒤에 복구되는지 보낼 수 있다. 대부분의 서비스 에러는 예측 불가하기 때문에 500번이다.   Reference  모든 개발자를 위한 HTTP 웹 기본지식  ","permalink":"http://jeha00.github.io/post/network/network_http_6/","summary":"HTTP status 2xx, 3xx, 4xx, 5xx에 대해 각각 알아본다.","title":"[TIL] Network HTTP status"},{"content":"Intro  HTTP 학습내용의 기본 출처: 김영한님의 모든 개발자를 위한 HTTP 웹 기본지식 강의를 듣고 정리한 내용과 모르는 부분에 대한 추가 내용을 합쳐 올린다. 이 강의는 HTTP에 대한 웹 기본지식을 설명하는 강의이므로, 내용이 간략할 수 있다.   학습 이유: 프레임워크를 사용하여 웹 개발을 배우기 전에, HTTP에 대해 기본적인 지식을 알고자 HTTP 공부를 시작한다. 이 강의에 대해 공부 후, 네트워크 전반에 대해 공부한다.  1. 클라이언트에서 서버로 데이터 전송  1.1 정적 데이터 조회 1.2 동적 데이터 조회 1.3 HTML Form을 통한 데이터 전송 1.3 HTML API를 통한 데이터 전송\n  클라이언트에서 서버로 데이터를 전달하는 방식은 크게 2가지가 있다.  쿼리 파라미터를 통한 데이터 전송  GET을 많이 사용한다. 예) 주로 정렬 필터나 검색어를 사용할 때 쿼리 파라미터를 많이 사용한다.   메시지 바디를 통한 데이터 전송  POST, PUT, PATCH를 사용한다. 예) 회원 가입, 상품 주문, 리소스 등록, 리소스 변경하는데 사용한다.       그리고, 클라이언트가 서버로 데이터를 전송하는 4가지 상황이 있다. 각 상황에서 어떻게 클라이언트가 서버에 데이터를 전달하는지 알아보자.   1.1 정적 데이터 조회  예) 이미지, 정적 텍스트 문서 정적 데이터는 일반적으로 쿼리 파라미터 없이 GET method로 resource path만 적어, 단순하게 조회가 가능하다.   1.2 동적 데이터 조회  예) 주로 검색,게시판 목록에서 검색어를 사용하여 정렬 필터한다. (검색어) 조회 조건을 줄여주는 필터, 조회 결과를 정렬하는 정렬 조건에 주로 사용한다. 조회이기 때문에 GET 사용하지만, 정적 데이터가 아닌 동적 데이터이므로, 쿼리 파라미터를 사용해서 데이터를 클라이언트가 서버에게 넘겨줘야 한다. GET도 메세지 바디를 사용할 수 있지만, 지원하지 않는 경우가 많아서 사용하지 않는다.   1.3 HTML Form을 통한 데이터 전송  HTML Form 전송은 GET, POST만 지원한다. 예) 회원 가입, 상품 주문, 데이터 변경  POST 전송 - 저장  예) 회원 가입, 상품 주문, 데이터 변경 상황 전송 버튼을 누르면 웹 브라우저가 form 태그 정보를 읽어서, HTTP message를 생성한다. 그리고, action에 작성된 경로로 해당 method 요청을 보낸다. 쿼리 파라미터랑 동일한 형식으로 HTTP message body에 넣어 서버에 전송된다.  username=kim\u0026amp;age=20    GET 전송 - 저장 (오류)  GET이라 메세지 바디를 안쓰기 때문에, url 경로에다가 data를 넣는다. 즉, Query parameter 형식으로 넣어준다. 또한, GET은 조회용으로만 사용가능하므로 저장하는 곳에 사용하면 안된다. GET은 조회이므로, /members 등으로 조회가 가능한 곳으로 보내야 정상적으로 처리된다.   [결론]\nFORM에서 GET / POST의 사용에 맞춰서 웹 브라우저가 알아서 HTTP 요청 메세지의 구성을 Query 또는 Body 등으로 맞춰서 생성한다.\n multipart/form-data  다른 종류의 여러 파일과 폼의 내용을 함께 전송이 가능하다. 그래서 이름이 mulitpart다. 주로 binary data를 전송할 때 사용한다. 웹브라우저가 생성한 요청 HTTP 메시지의 content-type에 boundary 가 명시되어 있는데, form data 간 구분을 지어준다.   1.4. HTTP API를 통한 데이터 전송  HTML Form을 쓰지 않는 모든 상황을 말한다. 예) 회원 가입, 상품 주문, 데이터 변경에 사용 그러면 언제 사용하는가???  서버 to 서버: 백엔드 시스템 통신 앱 클라이언트에서 전송 시 (아이폰,안드로이드) 웹 클라이언트에서 HTML Form 전송 대신 자바 스크립트를 통한 통신에 사용 (AJAX)  예)React, Vue.JS 같은 웹 클라이언트와 API 통신     POST, PUT,PATCH: 사용하며, 메시지 바디를 통해 데이터를 전송 GET: 조회, 쿼리, 파라미터로 데이터를 전달 Content-type: application/json을 주로 사용 (사실상 표준)  TEXT, XML, JSON 등등이 있지만, XML이 읽기 어렵고, 복잡해서 지금은 JSON을 사용한다. 데이터 크기도 상대적으로 XML보다 작아서, 사실상 JSON이 표준이다.     2. HTTP API 설계  HTTP API 설계에는 3가지 종류가 있다.  HTTP API - collection  POST 기반 등록 서버가 리소스 URI 결정   HTTP API - store  PUT 기반 등록 클라이언트가 리소스 URI 결정   HTML FORM 사용  순수 HTML + HTML form 사용 GET, POST만 지원       이 3가지에 대해 각각 알아보자.  2.1 HTTP API - collection  서버가 새로 등록된 리소스 URI를 생성하고 관리하는 구조: Collection\n  회원 관리 시스템: API 설계 - POST 기반 등록  회원 목록 /members -\u0026gt; GET 회원 등록 /members -\u0026gt; POST 회원 조회 /members/{id} -\u0026gt; GET (회원 단권 조회) 회원 수정 /members/{id} -\u0026gt; PATCH, PUT, POST 회원 삭제 /members/{id} -\u0026gt; DELETE     실제로는 위의 경우처럼 명확하게 구분되지 않기 때문에, 컨트롤 URI 를 사용할 수 밖에 없다.\n  클라이언트는 등록될 리소소의 URI를 모른다.  회원 등록 /members -\u0026gt; POST POST /members   서버가 새로 등록된 리소스 URI를 생성한다.  HTTP/1.1 201 Created\nLocation: /members/100   Collection  서버가 관리하는 리소스 디렉토리 서버가 리소스의 URI를 생성하고 관리 여기서 collection은 /members     2.2 HTTP API - store  클라이언트가 직접 resource uri를 지정하고, 관리하는 구조: Store\n  파일 관리 시스템: API 설계 - PUT 기반 등록  파일 목록 /files -\u0026gt; GET 파일 조회 /files/{filename} -\u0026gt; GET 파일 등록 /files/{filename} -\u0026gt; PUT 파일 삭제 /files/{filename} -\u0026gt; DELETE 파일 대량 등록 /files -\u0026gt; POST  파일 등록에 PUT을 썼기 때문에, 대량 등록에는 POST를 썼다. 왜냐하면 POST는 임의로 의미를 만들 수 있다.       클라이언트가 리소스 URI를 알고 있어야 한다.  파일 등록/files/{filename} -\u0026gt; PUT PUT/files/star.jpg   클라이언트가 직접 리소스의 URI를 지정한다. Store  클라이언트가 관리하는 리소스 디렉토리 클라이언트가 리소스의 URI를 생성하고 관리 여기서 store는 /files     그럼 위 두 방식(Collection, Store) 중 무엇을 많이 사용할까??\n대부분 실무에서는 POST를 사용하는 Collection 구조를 사용한다. 하지만, file 관리의 경우, Store를 사용한다.\n  2.2 HTML FORM 사용  회원 목록 /members -\u0026gt; GET 회원 등록 폼 /members/new -\u0026gt; GET 회원 등록 /members/new, /members -\u0026gt; POST  위에 등록 폼과 같은 url을 쓰는 것을 추천한다.   회원 조회 /members/{id} -\u0026gt; GET 회원 수정 폼 /members/{id}/edit -\u0026gt; GET  실제로 수정일 일어나는 게 아니기 때문에, GET 을 사용한다.   회원 수정 /members/{id}/edit, /members/{id} -\u0026gt; POST  위에 수정 폼과 같은 url을 쓰는 것을 추천한다.   회원 삭제 /members/{id}/delete -\u0026gt; POST   HTML FORM은 GET, POST만 지원 하므로 제약이 있다. 이런 제약을 해결하기 위해 동사로 된 리소스 경로를 사용한다.  최대한 리소스 개념을 가지고 사용하지만, 안될 때 대체제로 컨트롤 URI를 사용한다.   AJAX 같은 기술을 사용해서 해결 가능하다 -\u0026gt; 회원 API 참고 여기서는 순수 HTML, HTML FORM 이야기다.   3. 참고하면 좋은 URI 설계 개념   문서(document)\n 단일 개념(파일 하나, 객체 인스턴스, 데이터베이스 row) 예) /members/100, /files/star.jpg    컬렉션(collection)\n 서버가 관리하는 리소스 디렉터리 서버가 리소스의 URI를 생성하고 관리 예) /members    스토어(store)\n 클라이언트가 관리하는 자원 저장소 클라이언트가 리소스의 URI를 알고 관리 예) /files    컨트롤러(controller), 컨트롤 URI\n 문서, 컬렉션, 스토어로 해결하기 어려운 추가 프로세스 실행 동사를 직접 사용 예) /members/{id}/delete     REST API를 보면 해결이 안되는 경우가 있다.\n그럴 때, 네 번째 개념인 컨트롤 URI가 꼭 있어야 한다.\n문서, collection, store 만으로 부족할 때, 컨트롤 URI 를 사용한다.\n  https://restfulapi.net/resource-naming 참고하기  여러 사람들이 HTTP API를 하다보니, 좋은 practice가 있다.     Reference  모든 개발자를 위한 HTTP 웹 기본지식 HTTP 메서드 활용  ","permalink":"http://jeha00.github.io/post/network/network_http_5/","summary":"HTTP method를 가지고 클라이언트가 서버에 어떻게 데이터를 전송하는지, 그리고 API 설계에는 무슨 종류가 있는지 알아본다.","title":"[TIL] Network HTTP method use"},{"content":"Intro  class에 대해 공부를 더 시작하면서 매직 메소드에 대해 알기 시작했다. 매직 메소드의 종류인 __str__ 과 __repr__ 에 대해 각각 알아보고, 차이점도 알아보자.  1.Magic method 의 종류: __str__ 과 __repr__   python에서 이미 만들어놓은 내장된 method special method 라고도 한다.     magic method의 종류 중 __str__ 과 __repr__에 대해 알아보겠다.\n  __repr__ 의 repr은 representation의 약어다.\n  예시코드는 Python basic 24에서 작성한 코드를 이어서 사용한다.\n  \u0026gt; class Airline(): \u0026gt; def __init__(self, company, details): \u0026gt; self._company = company \u0026gt; self._details = details \u0026gt; \u0026gt; \u0026gt; Airline1 = Airline(\u0026#39;Koreanair\u0026#39;, {\u0026#39;uniform_color\u0026#39;: \u0026#39;skyblue\u0026#39;, \u0026#39;kind\u0026#39;:\u0026#39;FSC\u0026#39;, \u0026#39;price\u0026#39;: 8000}) \u0026gt; Airline2 = Airline(\u0026#39;Asiana\u0026#39;, {\u0026#39;uniform_color\u0026#39;: \u0026#39;gray\u0026#39;, \u0026#39;kind\u0026#39;:\u0026#39;FSC\u0026#39;, \u0026#39;price\u0026#39;: 6000}) \u0026gt; Airline3 = Airline(\u0026#39;t-wau\u0026#39;, {\u0026#39;uniform_color\u0026#39;: \u0026#39;red\u0026#39;, \u0026#39;kind\u0026#39;:\u0026#39;LCC\u0026#39;, \u0026#39;price\u0026#39;: 3000}) \u0026gt; print(Airline1) \u0026gt; print(Airline2) \u0026gt; print(Airline3) \u0026lt;__main__.Airline object at 0x000002DFDFF06FD0\u0026gt; \u0026lt;__main__.Airline object at 0x000002DFDFF06F70\u0026gt; \u0026lt;__main__.Airline object at 0x000002DFDFF06400\u0026gt;  Airline 클래스의 인스턴스를 보이기 위해서, print()을 사용하면 출력할 instance의 memory address를 보인다.   그러면 Airline class 내부에 __str__ method를 추가해보자.  \u0026gt; class Airline(): \u0026gt; def __init__(self, company, details): \u0026gt; self._company = company \u0026gt; self._details = details \u0026gt; \u0026gt; def __str__(self): \u0026gt; return \u0026#39;str : {} - {}\u0026#39;.format(self._company, self._details) # instance 코드 부분은 생략한다. \u0026gt; print(Airline1) \u0026gt; print(Airline2) \u0026gt; print(Airline3) str : Koreanair - {\u0026#39;uniform_color\u0026#39;: \u0026#39;skyblue\u0026#39;, \u0026#39;kind\u0026#39;: \u0026#39;FSC\u0026#39;, \u0026#39;price\u0026#39;: 8000} str : Asiana - {\u0026#39;uniform_color\u0026#39;: \u0026#39;gray\u0026#39;, \u0026#39;kind\u0026#39;: \u0026#39;FSC\u0026#39;, \u0026#39;price\u0026#39;: 6000} str : t-wau - {\u0026#39;uniform_color\u0026#39;: \u0026#39;red\u0026#39;, \u0026#39;kind\u0026#39;: \u0026#39;LCC\u0026#39;, \u0026#39;price\u0026#39;: 3000}  __str__ method 를 사용하니, memory address를 출력하는 것이 아닌, __str__ method에서 return 값을 출력한다. 다음으로 __repr__ method를 사용해보자.  \u0026gt; class Airline(): \u0026gt; def __init__(self, company, details): \u0026gt; self._company = company \u0026gt; self._details = details \u0026gt; \u0026gt; def __repr__(self): \u0026gt; return \u0026#39;repr : {} - {}\u0026#39;.format(self._company, self._details) # instance 코드 부분은 생략한다. \u0026gt; print(Airline1) \u0026gt; print(Airline2) \u0026gt; print(Airline3) repr : Koreanair - {\u0026#39;uniform_color\u0026#39;: \u0026#39;skyblue\u0026#39;, \u0026#39;kind\u0026#39;: \u0026#39;FSC\u0026#39;, \u0026#39;price\u0026#39;: 8000} repr : Asiana - {\u0026#39;uniform_color\u0026#39;: \u0026#39;gray\u0026#39;, \u0026#39;kind\u0026#39;: \u0026#39;FSC\u0026#39;, \u0026#39;price\u0026#39;: 6000} repr : t-wau - {\u0026#39;uniform_color\u0026#39;: \u0026#39;red\u0026#39;, \u0026#39;kind\u0026#39;: \u0026#39;LCC\u0026#39;, \u0026#39;price\u0026#39;: 3000}  __repr__ method 를 사용하니, memory address를 출력하는 것이 아닌, __repr__ method에서 return 값을 출력한다. 그러면 __str__ 와 __repr__ 를 같이 사용해보자.  \u0026gt; class Airline(): \u0026gt; def __init__(self, company, details): \u0026gt; self._company = company \u0026gt; self._details = details \u0026gt; \u0026gt; def __str__(self): \u0026gt; return \u0026#39;str : {} - {}\u0026#39;.format(self._company, self._details) \u0026gt; \u0026gt; def __repr__(self): \u0026gt; return \u0026#39;repr : {} - {}\u0026#39;.format(self._company, self._details) # instance 코드 부분은 생략한다. \u0026gt; print(Airline1) \u0026gt; print(Airline2) \u0026gt; print(Airline3) str : Koreanair - {\u0026#39;uniform_color\u0026#39;: \u0026#39;skyblue\u0026#39;, \u0026#39;kind\u0026#39;: \u0026#39;FSC\u0026#39;, \u0026#39;price\u0026#39;: 8000} str : Asiana - {\u0026#39;uniform_color\u0026#39;: \u0026#39;gray\u0026#39;, \u0026#39;kind\u0026#39;: \u0026#39;FSC\u0026#39;, \u0026#39;price\u0026#39;: 6000} str : t-wau - {\u0026#39;uniform_color\u0026#39;: \u0026#39;red\u0026#39;, \u0026#39;kind\u0026#39;: \u0026#39;LCC\u0026#39;, \u0026#39;price\u0026#39;: 3000}  __str__ method의 return 문을 출력했다.    그러면 여태까지의 증명으로 다음과 같은 사실을 알 수 있다.\n  __str__ 와 __repr__ 는 클래스의 인스턴스에 대한 memory address를 출력하는 게 아닌, 사용자가 원하는 출력문을 출력한다. To customize the string representation of a class instance, the class needs to implement the __str__ magic method. from python __str__ 그리고 출력문은 위 메소드에서 반환한 형식으로 출력한다. __str__ 와 __repr__ 이 같이 사용되면 __str__이 출력된다.     2. __str__ 과 __repr__의 차이  __str__ 와 __repr__의 차이는 Python __repr__ 에 따르면 전달할 대상이 다르다고 한다.  __str__의 문자열 출력은 인간 친화적인 결과물로, \u0026ldquo;informal\u0026rdquo; string presentation.  사용자가 보기 쉬운 결과물 목적: 간결히 읽기 위함   __repr__의 문자열 출력은 기계가 읽기 쉬운 결과물로, \u0026ldquo;official\u0026rdquo; string presentation.  python interpreter가 읽을 수 있는, 공식적인 결과물. 목적: 문자열로 객체를 다시 생성하기 위함      \u0026gt; a = datetime.datetime(2022,3,13) \u0026gt; print(str(a)) 2022-03-13 00:00:00 \u0026gt; print(repr(a)) datetime.datetime(2022, 3, 13, 0, 0)  3. print function과 __str__ method의 관계   str(object)를 통해 문자열로 변환할 때, object.__str__를 호출하여, 이 메소드를 통해 변환된 것을 반환한다.\n  print() function을 사용하여 문자열로 변환할 때, str()에게 출력할 arguments를 전달하여 문자열로 변환 후, 출력이 된다.\n  즉, print() 는 object.__str__ 를 통해서 문자열로 반환된 걸 출력하는 것이다.\n  \u0026gt; class Airline(): \u0026gt; def __init__(self, company, details): \u0026gt; self._company = company \u0026gt; self._details = details \u0026gt; \u0026gt; def __str__(self): \u0026gt; return \u0026#39;str : {} - {}\u0026#39;.format(self._company, self._details) \u0026gt; print(str(Airline1)) str : Koreanair - {\u0026#39;uniform_color\u0026#39;: \u0026#39;skyblue\u0026#39;, \u0026#39;kind\u0026#39;: \u0026#39;FSC\u0026#39;, \u0026#39;price\u0026#39;: 8000}  repr() 또한 __repr__을 통해서 변환된 것을 반환한다.  \u0026gt; class Airline(): \u0026gt; def __init__(self, company, details): \u0026gt; self._company = company \u0026gt; self._details = details \u0026gt; \u0026gt; def __repr__(self): \u0026gt; return \u0026#39;repr : {} - {}\u0026#39;.format(self._company, self._details) # instance 코드 부분은 생략한다. \u0026gt; print(repr(Airline1)) repr : t-wau - {\u0026#39;uniform_color\u0026#39;: \u0026#39;red\u0026#39;, \u0026#39;kind\u0026#39;: \u0026#39;LCC\u0026#39;, \u0026#39;price\u0026#39;: 3000} \u0026gt; print(str(Airline1)) repr : t-wau - {\u0026#39;uniform_color\u0026#39;: \u0026#39;red\u0026#39;, \u0026#39;kind\u0026#39;: \u0026#39;LCC\u0026#39;, \u0026#39;price\u0026#39;: 3000}  또한, __str__이 별도로 정의되지 않았고, __repr__만 정의된 상황이라면 str()을 실행하면 __repr__가 실행된다.  from 파이썬 공식문서 Data model\n 4. 정리  __str__의 문자열 출력은 인간 친화적인 결과물로, \u0026ldquo;informal\u0026rdquo; string presentation.  사용자가 보기 쉬운 결과물 목적: 간결히 읽기 위함   __repr__의 문자열 출력은 기계가 읽기 쉬운 결과물로, \u0026ldquo;official\u0026rdquo; string presentation.  python interpreter가 읽을 수 있는, 공식적인 결과물. 목적: 문자열로 객체를 다시 생성하기 위함     print() function 은 str(object)을 호출한다. str(object)은 object.__str__을 호출하여, 이 메소드를 통해 변환된 것을 반환한다. repr(object)은 object.__repr__을 호출하여, 이 메소드를 통해 변환된 것을 반환한다. __str__은 내부적으로 default로 __repr__을 호출한다.\n   Reference  인프런 파이썬 중급 Python tutorial Data model  ","permalink":"http://jeha00.github.io/post/python_basic/python_basic_25_str_repr/","summary":"__str__ 과 __repr__ 이 각각 무엇인지 그리고, 이 둘의 차이가 뭔지 알아본다.","title":"[TIL] Python basic 25: \n_\n_str\n_\n_ vs \n_\n_repr\n_\n_"},{"content":"Intro  basic 14 class 에서 언급한 절차지향 프로그래밍이 구체적으로 무엇인지 간단히 구현한다. 그 다음 클래스를 사용한 객체지향 프로그래밍에 대해 알아보겠다.   절차지향 프로그래밍은 일반적인 과거의 코딩방식으로, 함수 중심이기 때문에, 데이터가 방대하여 복잡하다는 단점이 있다.   이에 대한 해결책이 OOP(Object Oriented Programming) 으로 객체지향 프로그래밍이다. 장점을 다시 한번 언급하자면 클래스 중심으로 사용하기 때문에 객체로 관리한다. 그래서,  코드의 재사용성이 낮다. 코드 중복을 방지할 수 있다. 유지보수가 좋다. 대형 프로젝트에 적합하다.     1. 절차지향 프로그래밍 (Procedural Programming)  그럼 예시 코드로 절차지향 프로그래밍을 구현해보자. 절차지향으로 프로그래밍할 경우, 항공사의 종류 갯수대로 직접 다 입력해야 한다.  # 항공사 1 \u0026gt; airline_company_1 = \u0026#39;Koreaair\u0026#39; \u0026gt; airline_detail_1 = [ \u0026gt; {\u0026#39;uniform_color\u0026#39;: \u0026#39;skyblue\u0026#39;}, \u0026gt; {\u0026#39;kind\u0026#39;:\u0026#39;FSC\u0026#39;}, \u0026gt; {\u0026#39;price\u0026#39;: 8000}, \u0026gt; ] # 항공사 2 \u0026gt; airline_company_2 = \u0026#39;Asiana\u0026#39; \u0026gt; airline_detail_2 = [ \u0026gt; {\u0026#39;color\u0026#39;: \u0026#39;gray\u0026#39;}, \u0026gt; {\u0026#39;kind\u0026#39;:\u0026#39;FSC\u0026#39;}, \u0026gt; {\u0026#39;price\u0026#39;: 6000}, \u0026gt; ] # 항공사 3 \u0026gt; airline_company_3 = \u0026#39;t-way\u0026#39; \u0026gt; airline_detail_3 = [ \u0026gt; {\u0026#39;color\u0026#39;: \u0026#39;red\u0026#39;}, \u0026gt; {\u0026#39;kind\u0026#39;: \u0026#39;LCC\u0026#39;}, \u0026gt; {\u0026#39;price\u0026#39;: 3000}, \u0026gt; ]  리스트 구조로 또 입력해보자.  \u0026gt; airline_company_list = [\u0026#39;Koreanair\u0026#39;, \u0026#39;Asiana\u0026#39;, \u0026#39;t-way\u0026#39;] \u0026gt; airline_detail_list = [ \u0026gt; {\u0026#39;uniform_color\u0026#39;: \u0026#39;skyblue\u0026#39;, \u0026#39;kind\u0026#39;:\u0026#39;FSC\u0026#39;, \u0026#39;price\u0026#39;: 8000}, \u0026gt; {\u0026#39;color\u0026#39;: \u0026#39;gray\u0026#39;, \u0026#39;kind\u0026#39;:\u0026#39;FSC\u0026#39;, \u0026#39;price\u0026#39;: 6000}, \u0026gt; {\u0026#39;color\u0026#39;: \u0026#39;red\u0026#39;, \u0026#39;kind\u0026#39;: \u0026#39;LCC\u0026#39;, \u0026#39;price\u0026#39;: 3000} \u0026gt; ] \u0026gt; del airline_company_list[1] \u0026gt; del airline_detail_list[1] \u0026gt; print(airline_company_list) [\u0026#39;Koreanair\u0026#39;, \u0026#39;t-way\u0026#39;] \u0026gt; print(airline_detail_list) [{\u0026#39;uniform_color\u0026#39;: \u0026#39;skyblue\u0026#39;, \u0026#39;kind\u0026#39;: \u0026#39;FSC\u0026#39;, \u0026#39;price\u0026#39;: 8000}, {\u0026#39;color\u0026#39;: \u0026#39;red\u0026#39;, \u0026#39;kind\u0026#39;: \u0026#39;LCC\u0026#39;, \u0026#39;price\u0026#39;: 3000}]  이런 방식으로 입력할 경우, 데이터를 삭제하기가 불편하다. index를 사용하여 삭제할 때, 데이터 양이 매우 많으면 index 번호를 알기가 어렵기 때문이다. 그리고, index로 접근 시, 실수할 가능성이 높다.   다음으로 딕셔너리 구조로 입력해보자.  \u0026gt; airlines_dicts = [ \u0026gt; {\u0026#39;airline_company\u0026#39;: \u0026#39;Koreanair\u0026#39;, \u0026#39;airline_detail\u0026#39;: {\u0026#39;uniform_color\u0026#39;: \u0026#39;skyblue\u0026#39;, \u0026#39;kind\u0026#39;:\u0026#39;FSC\u0026#39;, \u0026#39;price\u0026#39;: 8000}}, \u0026gt; {\u0026#39;airline_company\u0026#39;: \u0026#39;Asiana\u0026#39;, \u0026#39;airline_detail\u0026#39;: {\u0026#39;uniform_color\u0026#39;: \u0026#39;gray\u0026#39;, \u0026#39;kind\u0026#39;:\u0026#39;FSC\u0026#39;, \u0026#39;price\u0026#39;: 6000}}, \u0026gt; {\u0026#39;airline_company\u0026#39;: \u0026#39;t-way\u0026#39;, \u0026#39;airline_detail\u0026#39;: {\u0026#39;uniform_color\u0026#39;: \u0026#39;red\u0026#39;, \u0026#39;kind\u0026#39;:\u0026#39;LCC\u0026#39;, \u0026#39;price\u0026#39;: 3000}} \u0026gt; ] \u0026gt; airlines_dicts[1].pop(\u0026#39;airline_company\u0026#39;) \u0026gt; print(airlines_dicts) [{\u0026#39;airline_company\u0026#39;: \u0026#39;Koreanair\u0026#39;, \u0026#39;airline_detail\u0026#39;: {\u0026#39;uniform_color\u0026#39;: \u0026#39;skyblue\u0026#39;, \u0026#39;kind\u0026#39;: \u0026#39;FSC\u0026#39;, \u0026#39;price\u0026#39;: 8000}}, {\u0026#39;airline_detail\u0026#39;: {\u0026#39;uniform_color\u0026#39;: \u0026#39;gray\u0026#39;, \u0026#39;kind\u0026#39;: \u0026#39;FSC\u0026#39;, \u0026#39;price\u0026#39;: 6000}}, {\u0026#39;airline_company\u0026#39;: \u0026#39;t-way\u0026#39;, \u0026#39;airline_detail\u0026#39;: {\u0026#39;uniform_color\u0026#39;: \u0026#39;red\u0026#39;, \u0026#39;kind\u0026#39;: \u0026#39;LCC\u0026#39;, \u0026#39;price\u0026#39;: 3000}}] \u0026gt; del airlines_dicts[1] [{\u0026#39;airline_company\u0026#39;: \u0026#39;Koreanair\u0026#39;, \u0026#39;airline_detail\u0026#39;: {\u0026#39;uniform_color\u0026#39;: \u0026#39;skyblue\u0026#39;, \u0026#39;kind\u0026#39;: \u0026#39;FSC\u0026#39;, \u0026#39;price\u0026#39;: 8000}}, {\u0026#39;airline_company\u0026#39;: \u0026#39;t-way\u0026#39;, \u0026#39;airline_detail\u0026#39;: {\u0026#39;uniform_color\u0026#39;: \u0026#39;red\u0026#39;, \u0026#39;kind\u0026#39;: \u0026#39;LCC\u0026#39;, \u0026#39;price\u0026#39;: 3000}}]  딕셔너리 안에 딕셔너리가 있는 형식으로 작성했다. 여전히 코드의 반복은 지속되어, 개발자에게 피로도를 증가시킨다. 키 중첩 문제가 존재하며, 키 조회 시 예외 처리를 해야한다.   2. 객체지향 프로그래밍 (Object Oriented Programming) \u0026gt; class Airline(): \u0026gt; def __init__(self, company, details): \u0026gt; self._company = company \u0026gt; self._details = details \u0026gt; Airline1 = Airline(\u0026#39;Koreanair\u0026#39;, {\u0026#39;uniform_color\u0026#39;: \u0026#39;skyblue\u0026#39;, \u0026#39;kind\u0026#39;:\u0026#39;FSC\u0026#39;, \u0026#39;price\u0026#39;: 8000}) \u0026gt; Airline2 = Airline(\u0026#39;Asiana\u0026#39;, {\u0026#39;uniform_color\u0026#39;: \u0026#39;gray\u0026#39;, \u0026#39;kind\u0026#39;:\u0026#39;FSC\u0026#39;, \u0026#39;price\u0026#39;: 6000}) \u0026gt; Airline3 = Airline(\u0026#39;t-wau\u0026#39;, {\u0026#39;uniform_color\u0026#39;: \u0026#39;red\u0026#39;, \u0026#39;kind\u0026#39;:\u0026#39;LCC\u0026#39;, \u0026#39;price\u0026#39;: 3000}) \u0026gt; print(Airline1) \u0026gt; print(Airline2) \u0026gt; print(Airline3) \u0026lt;__main__.Airline object at 0x000001AC6C87CFD0\u0026gt; \u0026lt;__main__.Airline object at 0x000001AC6C87CF70\u0026gt; \u0026lt;__main__.Airline object at 0x000001AC6C87CEE0\u0026gt; \u0026gt; print(Airline1.__dict__) \u0026gt; print(Airline2.__dict__) \u0026gt; print(Airline3.__dict__) {\u0026#39;_company\u0026#39;: \u0026#39;Koreanair\u0026#39;, \u0026#39;_details\u0026#39;: {\u0026#39;uniform_color\u0026#39;: \u0026#39;skyblue\u0026#39;, \u0026#39;kind\u0026#39;: \u0026#39;FSC\u0026#39;, \u0026#39;price\u0026#39;: 8000}} {\u0026#39;_company\u0026#39;: \u0026#39;Asiana\u0026#39;, \u0026#39;_details\u0026#39;: {\u0026#39;uniform_color\u0026#39;: \u0026#39;gray\u0026#39;, \u0026#39;kind\u0026#39;: \u0026#39;FSC\u0026#39;, \u0026#39;price\u0026#39;: 6000}} {\u0026#39;_company\u0026#39;: \u0026#39;t-wau\u0026#39;, \u0026#39;_details\u0026#39;: {\u0026#39;uniform_color\u0026#39;: \u0026#39;red\u0026#39;, \u0026#39;kind\u0026#39;: \u0026#39;LCC\u0026#39;, \u0026#39;price\u0026#39;: 3000}}  class 로 틀을 만들어서 airline instance를 손쉽게 만들었다. instance에 담긴 구체적인 정보를 알고싶을 때는 __dict__ 를 사용하는 것도 알 수 있다.   이렇듯 절차지향과 객체지향 다 장단점이 있어 적절한 곳에 사용해야 한다. 하지만, 절차지향의 단점을 해결하는 객체지향을 잘 사용해서 코드의 재사용성과 유지보수까지 고려하자.   Reference  파이썬 중급  ","permalink":"http://jeha00.github.io/post/python_basic/python_basic_24_oop/","summary":"절차형 프로그래밍과 객체지향 프로그래밍 각 방식으로 작성하여 직접 차이를 느껴본다.","title":"[TIL] Python basic 24: Procedural Programming vs OOP"},{"content":"Intro  [TIL] Python basic 15: module에서 학습했지만, 내용이 빈약하여 별도로 정리한다.   1. __name__ 에 대해 알아보자. 1.1 __name__이란??  The file name is the module name with the suffix .py appended.\nWithin a module, the module’s name (as a string) is available as the value of the global variable __name__\n출처: 파이썬 공식 문서\n  위 내용을 요약하면 __name__이란?   __name__은 .py인 파이썬 모듈 파일이 가지고 있는 global variable(전역변수)이다.\n그리고, 모듈의 이름을 담고 있다.\n 1.2 __name__이 다르게 출력되는 상황 2가지  그리고, 다음 두 가지 상황에서 다르게 출력된다.    첫 번째, script 프로그램이 \u0026lsquo;직접\u0026rsquo; 실행될 때 변수 __name__은 \u0026lsquo;__main__\u0026rsquo; 이다. 두 번째, 스크립트 프로그램이 import될 때 변수 __name__은 원래의 모듈 이름이다.    2개의 파일 (hello.py 와 python.py) 을 작성하자. 그리고 이 두 개의 파일을 module로서 import하는 test.py 를 작성하자. 그러면 총 3개의 파일을 작성한 상태다.   hello.py, python.py 그리고 test.py의 내용은 다음과 같다.  # hello.py \u0026gt; print(\u0026#34;hello.py: \u0026#34;, __name__) # python.py \u0026gt; print(\u0026#34;python.py: \u0026#34;, __name__) # test.py \u0026gt; import hello \u0026gt; import python  첫 번째 경우  hello.py 와 python.py 를 직접 실행해보겠다. 두 파일 모두 다음과 같이 출력되었다.    hello.py: __main__ python.py: __main__  두 번째 경우  test.py 를 실행해보겠다. 아래 코드를 보면 __main__ 이 아닌, import된 모듈명이 출력된다. 즉, 원래의 모듈 이름이 출력된다.    hello.py: hello python.py: python   결론\n__name__은 직접 실행될 때 __main__\u0026lsquo;이 출력되거나, import될 때에는 원래의 모듈이름이 담겨진다.    하지만, 이걸로 완전히 의문점을 해결되지 않았다. 그러면 __main__은 무엇을 의미하는 것인가???   2. __main__ 에 대해 알아보자. 2.1 Main Module이란??  파이썬 공식 문서를 보면 __main__에 대해 다음과 같이 설명한다.   the name of the main module is always \u0026ldquo;__main__\u0026rdquo;\nmain module에서의 __name__ 은 항상 \u0026ldquo;__main__\u0026rdquo; 이다.\n출처: Modules\n  그러면 main module의 정의는 무엇인가???   main module (the collection of variables that you have access to in a script executed at the top level and in calculator mode)\ntop level에서 실행되는 script 안에 접근 권한을 가지고 있는 변수들의 집합을 말한다.\n출처: 파이썬 공식 문서: Module\n  2.2 Top level 이란??  __main__ is the name of the environment where top-level code is run.\n“Top-level code” is the first user-specified Python module that starts running.\nIt’s “top-level” because it imports all other modules that the program needs.\nSometimes “top-level code” is called an entry point to the application.\n__main__은 top-level code 가 운영되는 환경의 이름인데,\nTop-level code는 사용자가 지정한 Python module 중에서 최초로 실행하기 시작하는 Python module이다.\n즉, 프로그램이 필요한 다른 모듈들을 import 하는 module이다.\n\u0026ldquo;top-level code\u0026rdquo; 는 애플리케이션의 관점에서 entry point (시작점) 이라 불린다. __main__이 출력되는 모듈이 entry point라는 걸 알 수 있다. 그리고, 다른 module들을 import 하는 파일을 말한다.\n출처: 파이썬 공식 문서: __main__\n  [결론]\n_ __name__ 변수를 통해서 현재 진행되는 파일이 entry point인지, module인지 판단할 수가 있다._\n  3. if __name__ == \u0026lsquo;__main__\u0026rsquo; 에 대해 알아보자. 3.1 if __name__ == '__main__' 이란 무엇인가??  그러면 if __name__ == '__main__ 의미는 다음과 같다.   이 조건문이 있는 파일을 import가 아닌 직접 실행을 한다면 아래 코드들을 실행하라.\n  마지막으로 한 예를 들고 끝내겠다. 예시의 출처는 What does if name == \u0026ldquo;main\u0026quot;: do?이다.  \u0026gt; print(\u0026#34;before import\u0026#34;) \u0026gt; import math \u0026gt; print(\u0026#34;before functionA\u0026#34;) \u0026gt; def functionA(): \u0026gt; print(\u0026#34;Function A\u0026#34;) \u0026gt; print(\u0026#34;before functionB\u0026#34;) \u0026gt; def functionB(): \u0026gt; print(\u0026#34;Function B {}\u0026#34;.format(math.sqrt(100))) \u0026gt; print(\u0026#34;before __name__ guard\u0026#34;) \u0026gt; if __name__ == \u0026#39;__main__\u0026#39;: \u0026gt; functionA() \u0026gt; functionB() \u0026gt; print(\u0026#34;after __name__ guard\u0026#34;)  위 code가 import 되어 실행된다면 다음과 같다.  before import before functionA before functionB before __name__guard \u0026lt;- after __name__guard \u0026lt;-  직접 실행한다면 다음과 같다.  before import before functionA before functionB before __name__guard \u0026lt;- Function A Function B 10.0 after __name__guard \u0026lt;-  import되어 실행할 떄는 \u0026lt;- 사이에 아무것도 출력되지 않았지만, 직접 실행할 때는 무언가 출력된 걸 확인할 수 있다. if __name__ == '__main__' 조건문에서 출력된 결과물이다. 직접 실행되었기 때문에 출력되었다.   3.2 if __name__ == '__main__' 을 왜 사용하는 걸까??  stack-over-flow What does if__name__ == \u0026lsquo;__main__': do? [TIL] Python basic 15: module    위 두 링크에 따르면 다음과 같은 이유로 작성한다.\n 외부 module file을 import 시, import된 파일에 있는 script 중 의도치 않게 호출한 것으로부터 보호하기 위해 사용하는 상용구 코드다. 스크립트에서 이 guard를 생략하면 구체적으로 다음과 같은 문제가 발생한다. 첫 번째, run time 시 의도치 않게 불러온 script에 있는 여러 인자들로 main script가 작동된다. 두 번째, guard를 생략한 script를 저장할 파일에 담아 저장하면, 이 파일을 불러올 때 guard를 생략한 script를 import 할 수 있다.    즉, if __name__ == '__main__' code는 의도치 않고 불필요한 코드를 호출하는걸 방지하기 위한 guard로서 사용한다.\n   Reference  [TIL] Python basic 15: module [python] if __name__ == \u0026lsquo;__main__\u0026rsquo; : 의 정체 자료구조와 함께 배우는 알고리즘 입문 파이썬편 What does if__name__ == \u0026lsquo;__main__': do? 파이썬 공식 문서: Modules 파이썬 공식 문서: __main__  ","permalink":"http://jeha00.github.io/post/python_basic/python_basic_23_ifnamemain/","summary":"'\n_\n_name\n_\n_' 과 '\n_\n_main\n_\n_' 를 이해한 걸 바탕으로, if\n_\n_name\n_\n_ == '\n_\n_main\n_\n_' 에 대해 알아본다.","title":"[TIL] Python basic 23:  if \n_\n_name\n_\n_ == '\n_\n_main\n_\n_'"},{"content":"Intro  HTTP 학습내용의 기본 출처: 김영한님의 모든 개발자를 위한 HTTP 웹 기본지식 강의를 듣고 정리한 내용과 모르는 부분에 대한 추가 내용을 합쳐 올린다. 이 강의는 HTTP에 대한 웹 기본지식을 설명하는 강의이므로, 내용이 간략할 수 있다.   학습 이유: 프레임워크를 사용하여 웹 개발을 배우기 전에, HTTP에 대해 기본적인 지식을 알고자 HTTP 공부를 시작한다. 이 강의에 대해 공부 후, 네트워크 전반에 대해 공부한다.   1. HTTP API 설계해보기   API 설계에서 가장 중요한 것은 리소스를 식별하는 게 중요하다.\n  그 다음으로 해야할 것이 리소스와 행위를 분리하는 것이다.\n  회원 정보 관리 API를 만든다고 가정하자.\n 회원 목록 조회 회원 조회 회원 등록 회원 수정 회원 삭제      그러면 초보 개발자인 경우, 다음과 같이 API URI 설계할 수 있다.\n 회원 목록 조회 /read-member-list 회원 조회 /read-member-by-id 회원 등록 /create-member 회원 수정 /update-member 회원 삭제 /delete-member    위 방식의 문제점은 URI의 정의를 정확히 살리지 못하는 방법이다.\n URI = Uniform Resource Identifier    가장 중요한 것은 리소스 식별 이다.\n  리소스의 의미는\n 회원을 등록하고, 수정하고 조회하는 게 리소스가 아니다.  예) 미네랄을 캐라 -\u0026gt; 미네랄이 리소스   회원이라는 개념 자체가 바로 리소스다.    그러면 리소스를 어떻게 식별하는게 좋을까??\n 회원을 등록하고, 수정하고, 조회하는 것을 모두 배제한 다음 회원이라는 리소스만 식별하면 된다 -\u0026gt; 회원 리소스를 URI에 매핑한다.       위 사항들을 반영하면 다음과 같다. (리소스 식별, URI 계층 구조 활용)\n  참고: 계층 구조상 상위를 컬렉션으로 보고 복수단어 사용 권장(member -\u0026gt; members)\n 회원 목록 조회 /members 회원 조회 /members/{id} 회원 등록 /members/{id} 회원 수정 /members/{id} 회원 삭제 /members/{id}    그러면 회원 조회부터 삭제는 어떻게 구분할 수 있을까???\n 리소스와 행위를 분리 하여 구분한다. 리소스: 회원 행위: 조회, 등록,삭제, 변경 리소스는 명사, 행위는 동사     행위는 어떻게 구분할 수 있을까??  HTTP method를 사용하여 구분한다. HTTP method에 대해 알아보자.     2. HTTP method - GET, POST   HTTP 주요 method\n GET: 리소스 조회 POST: 요청 데이터 처리, 주로 등록에 사용 PUT: 리소스를 대체, 해당 리소스가 없으면 생성 PATCH: 리소스 부분 변경 DELETE: 리소스 삭제    HTTP 기타 method\n HEAT: GET과 동일하지만 메시지 바디 부분을 제외하고, 상태 줄과 헤더만 반환 OPTIONS: 대상 리소스에 대한 통신 가능 옵션(메서드)을 설명(주로 CORS에서 사용) CONNECT: 대상 자원으로 식별되는 서버에 대한 터널을 설정 TRACE: 대상 리소스에 대한 경로를 따라 메시지 루프백 테스트를 수행  CONNECT 와 TRACE는 거의 사용안한다.       이번 단원에서는 GET과 POST에 대해 자세히 알아보자.   2.1 HTTP method - GET GET /search?q=hello\u0026amp;hl=ko HTTP/1.1 Host: www.google.com  리소스 조회 (/search?q=hello\u0026amp;hl=ko에 있는 자원을 가져와라.) 서버에 전달하고 싶은 데이터는 query (쿼리 파라미터, 쿼리 스트링)를 통해서 전달 메시지 바디를 사용해서 데이터를 전달할 수 있다. 하지만, 지원하지 않는 곳이 많아서 권장하지 않는다.  실무에서는 GET에 메시지 바디를 안넣는다.     리소스 조회 예시   클라이언트에서 /members/100 으로 100번 유저를 조회한다. 그 후, 정보를 달라고 GET 요청을 보낸다. 서버에서는 받은 메세지를 분석하여 내부의 유저 정보를 조회한다. 그 후, JSON data 형태로 결과 Response를 만든다. 응답 메세지를 받았고, 정상적으로 받았기에 200 OK status를 가진다. 또한, 회원 정보도 담겨있다.  위 에시에는 JSON이지만, 실제로는 HTML일수도 있고, 다양한다.     2.2 HTTP method - POST 2.2.1 POST란? POST /members HTTP/1.1 Content-Type: application/json { \u0026#34;username\u0026#34;: \u0026#34;hello\u0026#34;, \u0026#34;age\u0026#34;: 20 }  요청 데이터 처리하는 method 메시지 바디를 통해 서버로 요청 데이터를 전달한다.  GET과의 차이점   서버는 요청 데이터를 처리  메시지 바디를 통해 들어온 데이터를 처리하는 모든 기능을 수행한다.   주로 전달된 데이터로 신규 리소스 등록, 프로세스 처리에 사용  2.2.2 POST를 사용한 리소스 등록 과정  첫 번째: 메세지 전달   클라이언트는 메세지 바디에 등록할 회원 정보를 JSON형태로 만들어 담는다. 그리고 해당 정보를 서버로 전송한다.\n( 정보를 전달하기 전에, 사전에 서버가 무엇을 할지 미리 약속이 되어 있어야 한다.)   두 번째: 신규 리소스 생성   서버에서 받는 메세지를 분석해 데이터베이스에 등록한다. 이 때 신규 아이디도 생성.   세 번째: 응답 데이터   Location이라는 헤더 정보로 회원이 생성된 경로를 첨부한다. 신규회원에 대한 데이터를 바디에 담아서 보내준다. 만들어졌기 때문에 Created라 뜬다. 그리고, 자원의 신규 생성된 URL을 보내준다.  2.2.3 요청 데이터를 어떻게 처리한다는 뜻일까??  리소스 URI에 POST 요청이 오면, 요청 데이터를 어떻게 처리할지 리소스마다 따로 정해야한다 -\u0026gt; 정해진 것이 없다.\n  예를 들어 POST는 다음과 같은 기능에 사용된다.  HTML 양식에 입력된 필드와 같은 데이터 블록을 데이터 처리 프로세스에 제공  예) HTML, FORM에 입력한 정보로 회원 가입, 주문 등에서 사용   게시판, 뉴스 그룹, 메일링 리스트, 블로그 또는 유사한 기사 그룹에 메시지 게시  예) 게시판 글쓰기, 댓글 달기   서버가 아직 식별하지 않은 새 리소스 생성  예) 신규 주문 생성   기존 자원에 데이터 추가  예) 한 문서 끝에 내용 추가하기      2.2.4 POST method 정리 1. 새 리소스 생성(등록)\n 서버가 아직 식별하지 않은 새 리소스 생성  2. 중요! 요청 데이터 처리\n 단순히 데이터를 생성하거나, 변경하는 것을 넘어서 프로세스를 처리해야 하는 경우 상태가 변하기 위해서 POST를 사용하기 때문에, 새로운 리소스가 생성되지 않을 수 있다. 그렇다 할지라도, 서버에 큰 변화를 일으킬 때는 POST를 생성해야 한다.  예) 주문에서 결제완료 -\u0026gt; 배달시작 -\u0026gt; 배달완료처럼 단순히 값 변경을 넘어 프로세스의 상태가 변경되는 경우   POST의 결과로 새로운 리소스가 생성되지 않을 수도 있음  예) POST/orders/{orderld}/start-delivery (컨트롤 URI)  URI를 설계할 때는 resource 단위로 설계해야 하지만, 어쩔 수 없이 행동으로 할 때가 있다. 이 때 동사의 URI가 나올 수 있다. 이 URI를 컨트롤 URI 라 한다.      3. 다른 메서드로 처리하기 애매한 경우\n 예) JSON으로 조회 데이터를 넘겨야 하는데, GET 메서드를 사용하기 어려운 경우 애매하면 POST   3. HTTP method - PUT,PATCH,DELETE 3.1 HTTP method - PUT PUT /members/100 HTTP/1.1 Content-Type: application/json { \u0026#34;username\u0026#34;: \u0026#34;hello\u0026#34;, \u0026#34;age\u0026#34;: 20 }   리소스를 대체\n 리소스가 있으면 대체하고, 없으면 생성한다. (Overwirte)    POST와의 차이점: 클라이언트가 리소스를 식별한다.\n 클라이언트가 리소스 위치를 알고 URI 지정한다.     예) 리소스가 없는 경우  /members/100 이라는 신규 리소스를 생성한다. 신규 리소스의 내용은 다음과 같다.    { \u0026#34;username\u0026#34;: \u0026#34;hello\u0026#34;, \u0026#34;age\u0026#34;: 20 }  예) 리소스가 있는 경우  /members/100 경로에 아래 내용으로 리소스가 있다면    { \u0026#34;username\u0026#34;: \u0026#34;young\u0026#34;, \u0026#34;age\u0026#34;: 50 }  PUT method로 보내면 다음과 같이 대체된다.  { \u0026#34;username\u0026#34;: \u0026#34;hello\u0026#34;, \u0026#34;age\u0026#34;: 20 }  하지만 아래 내용으로 리소스를 보낸다면 아래 내용으로 완전히 대체된다. username 필드가 삭제된다.  { \u0026#34;age\u0026#34;: 50 }  3.2 HTTP method - PATCH PUT /members/100 HTTP/1.1 Content-Type: application/json { \u0026#34;age\u0026#34;: 50 }  그러면 기존 리소스를 갈아치우는 게 아니라, 수정하고 싶으면 어떻게 해야할까?? PATCH method 를 사용한다.  만약 PATCH가 지원되지 않은 서버라면 POST를 사용한다.   PUT과 양식은 비슷하지만, 서버에서 PATCH로 전송된 경우 필요한 부분만 업데이트된다.   그 결과, PUT과는 다르게 회원 정보에서 age만 변경된다.  { \u0026#34;age\u0026#34;: 50 }  3.3 HTTP method - DELETE DELETE /members/100 HTTP/1.1 Host: localhost:8080  클라이언트가 보내면 위 리소스 url에 해당되는 회원 정보를 서버에서 삭제한다.   4. HTTP method의 속성   HTTP 메서드별 속성   메서드의 속성\n 안전(Safe Methods) 멱등(idempotent Methods) 캐시가능(Cacheable Methods)     4.1 안전(Safe)  호출해도 리소스를 변경하지 않는 속성\n  GET은 단지 조회만 하기 때문에 안전하지만, 나머지는 아니다.  Q. 그래도 변경을 요청하면 변경되진 않아도, 로그에 계속 남게되어 터지지 않을까?? A: 안전은 해당 리소스만 고려한다. 그런 부분까지 고려하지 않는다.     4.2 멱등(Idempotent Methods)   f(f(x)) = f(x) 몇 번을 호출하든 결과가 똑같은 속성    멱등 메서드  GET: 몇 번을 조회하든 같은 결과가 조회된다. PUT: 결과를 대체한다. 따라서 같은 요청을 여러번 해도 최종 결과는 동일. DELETE: 결과를 삭제한다. 같은 요청을 여러번 해도 결과는 동일. POST : 멱등이 아니다! 두 번 호출하면 같은 결제가 중복해서 발생할 수 있다.     활용  자동 복구 메커니즘 서버가 TIMEOUT 등으로 정상 응답을 못 주었을 때, 클라이언트가 같은 요청을 다시 해도 되는가?? 판단근거     멱등은 외부 요인으로 인해 리소스가 변경되는 건 고려하지 않는다.  내가 호출하는 것에 한정한다. 예시:  사용자1: GET -\u0026gt; username:A, age:20 사용자2: PUT -\u0026gt; username:A, age:30 사용자1: GET -\u0026gt; username:A, age:30 -\u0026gt; 사용자2의 영향으로 바뀐 데이터 조회   이런 부분은 멱등하지 않다고 생각하자.     4.3 캐시가능(Cacheable Methods)  응답 결과 리소스를 캐시해서 사용해도 될까? GET, HEAD, POST, PATCH 캐시가 가능하지만, 실제로는 GET, HEAD 정도만 캐시로 사용한다.  POST, PATCH는 본문 내용까지 캐시 키로 고려해야 하는데, 구현이 쉽지 않다. GET은 URL만 캐시 키로 관리하면서 구현이 쉽기에 사용이 편하다.     Reference  모든 개발자를 위한 HTTP 웹 기본지식 HTTP 메서드  ","permalink":"http://jeha00.github.io/post/network/network_http_4/","summary":"HTTP method인 GET, POST, PUT, PATCH, DELETE 그리고 속성에 대해 알아본다.","title":"[TIL] Network HTTP method"},{"content":"Intro  HTTP 학습내용의 기본 출처: 김영한님의 모든 개발자를 위한 HTTP 웹 기본지식 이다. 강의를 듣고 정리한 내용과 모르는 부분에 대한 추가 내용을 합쳐 올린다. 이 강의는 HTTP에 대한 웹 기본지식을 설명하는 강의이므로, 내용이 간략할 수 있다.   학습 이유: 프레임워크를 사용하여 웹 개발을 배우기 전에, HTTP에 대해 기본적인 지식을 알고자 HTTP 공부를 시작한다. 이 강의에 대해 공부 후, 네트워크 전반에 대해 공부한다.  1. 모든 것이 HTTP 1.1 HTTP란? (지금은 HTTP 시대!) : HTML 같은 문서 간에 링크를 통해 연결할 수 있는 프로토콜을 의미한다. 하지만, 이제는 문서 뿐만 아니라 HTTP 메세지에 모든 것을 전송한다.\n HTML, TEXT IMAGE, 음성, 영상, 파일 JSON, XML (API) 거의 모든 형태의 데이터를 저장하여 전송 가능하다. 서버 간에 데이터를 주고 받을 때도 대부분 HTTP를 사용한다.  1.2 HTTP 역사 (HTTP/1.1을 기준으로 학습)  HTTP/0.9 1991년: GET 메서드만 지원, HTTP 헤더X HTTP/1.0 1996년: 메서드, 헤더 추가 HTTP/1.1 1997년: 가장 많이 사용, 우리에게 가장 중요한 버전  HTTP 강의는 이 버전을 기준으로 설명한다. RFC2068 (1997) -\u0026gt; RFC2616 (1999) -\u0026gt; RFC7230~7235 (2014) 현재는 RFC7230 버전부터 본다.   HTTP/2 2015년: 성능 개선 HTTP/3 진행중: TCP 대신에 UDP 사용, 성능 개선  1.3 기반 프로토콜  TCP 기반으로 작동하는 프로토콜은 HTTP/1.1, HTTP/2 다. UDP 기반으로 작동하는 프로토콜은 HTTP/3 다.  기본적으로 HTTP/1.1에서 개선된 것이므로 우리는 HTTP/1.1을 공부한다.   현재 HTTP/1.1 주로 사용한다.  HTTP/2, HTTP/3도 점점 증가하고 있다.     [HTTP/3가 UDP 기반인 이유]\n기본 TCP는 3 way handshake로 신뢰성이나 연결성이 보장되지만, 속도가 떨어진다. 그래서 UDP를 애플리케이션 레벨에서 재설계되어 나온게 HTTP/3다.\n  사이트에서 기반 프로토콜을 확인하려면 검사(F12)에 들어가 Network tab을 클릭 한다. 하단에 Name tab을 오른쪽 마우스 클릭하여 Protocol을 체크한다. h3는 http/3 고, h2는 http/2 를 의미한다. 구글은 h3를 사용하고, 네이버는 h2를 사용한다.  1.4 HTTP 특징  클라이언트 서버 구조 무상태 프로토콜(stateless), 비연결성 HTTP 메시지 단순함, 확장 가능  HTTP는 단순하고, 스펙도 읽어볼만 하다. HTTP 메시지도 매우 단순하다. 크게 성공하는 표준 기술의 하나의 예로, 단순하지만 확장 가능한 기술이다.    각 특징들에 대해 알아보자.\n 2. 클라이언트 서버 구조  HTTP는 클라이언트와 서버 구조로 되어있다. 클라이언트는 HTTP 메세지를 만들어서 서버에 요청(request)을 보낸 후, 서버로부터 응답(response)이 올 때까지 기다린다. 서버는 클라이언트로부터 온 요청(request)에 대한 결과를 만들어서 응답(response)한다.   [클라이언트 서버 구조가 중요한 이유]\n독립적 구조 -\u0026gt; 각자의 역할에 집중\n옛날에는 클라이언트와 서버가 분리되어 있지 않고, 합쳐져 있었다. 분리되고 나서 비지니스 로직과 데이터는 서버가 담당하여 집중하고, 클라이언트는 UI 사용성에 집중했다. 이로 인해서 클라이언트와 서버는 각각 독립적으로 진화할 수 있었다.\n  3. Stateful, Stateless 3.1 Stateful  Stateful 이란??  한 서버가 클라이언트의 이전 상태를 보존(기억)하기 때문에, 클라이언트의 요청에 응답하는 서버가 항상 같은 서버로 유지되어야 하는 상태를 말한다.\n Stateful(상태 유지) 의 문제점은 무엇일까??  서버가 멈추거나 하는 여러 이유로 해당 서버를 쓸 수가 없는 상황이 발생했다. 다른 서버를 이용해야 한다. 이런 경우, 새로운 서버에서 이전 서버에 가지고 있던 상태값들을 가지고 있지 않아 에러가 발생된다.\n  예시: 고객을 클라이언트, 점원을 서버라고 생각하자.\n 서버가 문제 없이 유지되는 경우  고객: 이 `노트북` 얼마인가요? 점원: 100만원 입니다. (노트북 상태 유지) 고객: `2개` 구매하겠습니다. 점원: 200만원 입니다. 신용카드, 현금중에 어떤 걸로 구매 하시겠어요? (노트북, 2개 상태 유지) 고객: `신용카드`로 구매하겠습니다. 점원: 200만원 결제 완료되었습니다. (노트북, 2개, 신용카드 상태 유지)  서버가 바뀔 경우  고객: 이 `노트북` 얼마인가요? 점원 A: 100만원 입니다. 고객: `2개` 구매하겠습니다. 점원 B: ? 무엇을 2개 구매하시겠어요? (상태유지 X) 고객: `신용카드`로 구매하겠습니다. 점원C: ? 무슨 제품을 몇 개 신용카드로 구매하시겠어요? (상태 유지 X)   한 서버에서 클라이언트의 상태를 기억하기 때문에, 서버가 변경되면서 기존 서버에 저장된 클라이언트의 상태를 기억하지 못하여 에러가 발생했다. 그래서 항상 같은 서버로 유지되어야 한다.\n3.2 Stateless  Stateless 란??  서버가 클라이언트의 이전 상태를 보존(기억)하지 않고, 클라이언트가 요청할 때마다 매번 모든 상태 값들을 전달하기 때문에, 서버 변경이 용이하다.\n  예시: 고객을 클라이언트, 점원을 서버라고 생각하자.\n 서버가 문제 없이 유지되는 경우  고객: 이 `노트북` 얼마인가요? 점원: 100만원 입니다. 고객: `노트북 2개` 구매하겠습니다. 점원: 노트북 2개는 200만원 입니다. 신용카드, 현금중에 어떤 걸로 구매 하시겠어요? 고객: `노트북 2개`를 `신용카드`로 구매하겠습니다. 점원: 200만원 결제 완료되었습니다.  서버가 바뀔 경우  고객: 이 \u0026#39;노트북\u0026#39; 얼마인가요? 점원A: 100만원 입니다. 고객: \u0026#39;노트북 2개\u0026#39; 구매하겠습니다. 점원B: 노트북 2개는 200만원 입니다. 신용카드, 현금중에 어떤 걸로 구매 하시겠어요? 고객: \u0026#39;노트북 2개\u0026#39;를 \u0026#39;신용카드\u0026#39;로 구매하겠습니다. 점원C: 200만원 결제 완료되었습니다.   클라이언트가 모든 상태 값을 서버에 전달하기 때문에, 서버가 중간에 바뀌어도 문제가 되지 않는다. 항상 같은 서버로 유지될 필요없다. 그래서 서버 변경이 용이하기 때문에, Stateless 는 무한한 서버 증설 가능하다.\n 그러면 서버 증설이 무한히 가능하다면 어떤 이점이 있을까???  같은 기능을 하는 서버들 안에서 서버의 수평 확장 에 유리하다.\n좋은 이점들이 많지만, 모든 것을 stateless(무상태) 로 할 수 없다. 실무 한계가 존재한다.\n 무상태 예시: 로그인이 필요 없는 단순한 서비스 소개 화면 상태 유지 예시: 로그인  로그인한 사용자의 경우, 로그인 했다는 상태를 서버에 유지해야 한다.   일반적으로 브라우저 쿠키와 서버 세션등을 사용해서 상태를 유지한다. 그래서 상태유지는 최소한만 사용하고, 최대한 무상태로 서버를 설계한다.  3.3 정리   Stateful (상태유지): 중간에 서버가 변경되면 안된다.\n (만약 서버가 변경되야 한다면 상태 정보를 전부 다른 서버에게 미리 알려줘야 한다.)    Stateless (무상태): 중간에 서버가 바뀌어도 된다.\n 그래서 서버는 수평적 확장에 유리한다. (scale out) 하지만 모든 것을 무상태로 할 수 없기 때문에, 무상태로 서버를 최대한 설계하며, 상태 유지로 서버를 최소한 설계한다.    4. 비연결성 (connectionless) 4.1 연결을 유지하는 모델  TCP/IP 연결로 새로운 클라이언트와 연결하면서 이전 클라이언트와의 연결을 유지한다. 서버의 자원이 연결을 유지하는데 계속 소모된다. 연결된 클라이언트가 놀고 있어도 서버가 유지해야 하는게 단점이다.  4.2 연결을 유지하지 않는 모델 (비연결성)  TCP/IP 연결 후, 클라이언트와 서버의 요청 응답 흐름이 끝나면 연결을 종료한다. 그리고 다른 클라이언트와 연결 시, 이전 클라이언트와의 연결을 하지 않는다. 즉, 서버는 연결 유지를 하지 않아, 최소한의 자원만 사용할 수 있다.    HTTP의 비연결성\n HTTP는 기본이 연결을 유지하지 않는 모델이고, 일반적으로 초 단위 이하의 빠른 속도로 응답한다. 그래서 1시간 동안 수천명이 서비스를 사용해도 실제 서버에서 동시에 처리하는 요청은 수십개 이하로 매우 적다.  예) 웹 브라우저에서 계속 연속해서 검색 버튼을 누르지 않는다.   즉, 서버 자원을 매우 효율적으로 사용할 수 있다.     비연결성의 한계와 해결 방법  한계  TCP/IP 연결을 새로 맺어야 하기 때문에, 3 way handshake 시간이 추가된다. 웹 브라우저로 사이트를 요청하면 HTML 뿐만 아니라 JavaScript, css, 추가 이미지 등 수많은 자원이 함께 다운로드된다.   해결 방법  지금은 HTTP 지속 연결(Persistent Connections)로 문제 해결했다. HTTP/2 와 HTTP/3에서 더 많은 최적화를 한다.      4.3 HTTP 지속 연결: 비연결성의 한계 해결 방법 비연결성의 한계를 해결한 방법인 HTTP 지속 연결에 대해 알아보자.\nHTTP 초기에는 모든 자료에 대해서 비연결성으로 \u0026lsquo;연결 -\u0026gt; 응답 -\u0026gt; 종료\u0026rsquo; 를 반복하여, 시간이 대략적으로 1초 가량 소모되었다고 한다.\n아래 이미지를 참조하자.\n그러면 HTTP 지속 연결로 어떻게 변했을까??\n클라이언트는 서버와 연결을 한 다음, 필요한 자원들을 모두 다운받을 떄까지 요청/응답이 반복된 뒤 종료된다.\n또한, HTTP/2,3으로 오면서 더 빨라졌다. 특히, HTTP 3으로 오면서 UDP를 사용하여 연결 속도 자체도 줄어들었다.\n  실무 상황에서 특정 시간에 발생하는 대용량 트랙픽의 경우, 수만명이 동시 요청하기 떄문에 무상태로 서버를 설계해야 대응할 수 있는 부분이 매우 많아진다.\n예) 선착순 이벤트, 명절 KTX 예약, 학과 수업 등록, 선착순 할인 이벤트    5. HTTP 메시지  HTTP 메시지 구조를 알아보자.  공백 라인은 아래 순서로, 필수로 존재해야 한다.    5.1 시작 라인(start line)   start line은 요청 메시지와 응답 메시지 로 나눠진다.\n  start line = request - line (요청 메시지) / status - line (응답 메시지)\n request-line = method SP(공백) request-target SP HTTP-version CRLF(엔터) status-line = HTTP-version SP status-code SP reason-phrase CRLF    5.1.1 요청 메시지   start line = request - line (요청 메시지) / status - line (응답 메시지)\n  request-line = method SP(공백) request-target SP HTTP-version CRLF(엔터)\n  HTTP method (GET /search?q=hello\u0026amp;hl=ko HTTP/1.1)\n 종류: GET, POST, PUT, DELETE \u0026hellip; 서버가 수행해야 할 동작 지정  GET: 리소스 조회 / POST: 요청 내역 처리      request-target (GET /search?q=hello\u0026amp;hl=ko HTTP/1.1)\n absolute-path[?query] (절대경로[?쿼리]) 절대경로= \u0026ldquo;/\u0026rdquo; 로 시작하는 경로 참고: *, http://\u0026hellip;?x=y 와 같이 다른 유형의 경로지정 방법도 있다.    HTTP verison (GET /search?q=hello\u0026amp;hl=ko HTTP/1.1)\n    5.1.2 응답 메시지  start line = request - line (요청 메시지) / status - line (응답 메시지)  status-line = HTTP-version SP status-code SP reason-phrase CRLF HTTP version HTTP 상태 코드: 요청 성공, 실패를 나타냄  200: 성공 400: 클라이언트 요청 오류 500: 서버 내부 오류   이유 문구: 사람이 이해할 수 있는 짧은 상태 코드 설명 글    5.2 HTTP header  healder - field = field - name \u0026ldquo;:\u0026rdquo; OWS field - value OWS\n(OWS: 띄어쓰기 허용)\n  field - name: 대소문자 구분 없음 field - value: 대소문자 구문 있음 용도  HTTP 전송에 필요한 모든 부가정보가 담겨져 있다.  예) 메시지 바디의 내용, 크기, 압축, 인증 예) 요청 클라이언트(브라우저) 정보, 서버 애플리케이션 정보, 캐시 관리 정보   표준 헤더가 너무 많다. (https://en.wikipedia.org/wiki/List_of_HTTP_header_fields) 필요한 경우, 임의의 헤더 추가 가능    5.3 HTTP message body  실제 전송할 데이터 HTML 문서, 이미지, 영상, JSON 등등 byte로 표현할 수 있는 모든 데이터 전송 가능   HTTP 정리  HTTP 메시지에 모든 것을 전송한다. HTTP 역사: HTTP/1.1을 기준으로 학습한다. 클라이언트 서버 구조이다. 무상태 프로토콜(stateless)다. HTTP 메시지 단순하며 확장 가능하다. 지금은 HTTP 시대다.   Reference  모든 개발자를 위한 HTTP 웹 기본지식 HTTP 기본  ","permalink":"http://jeha00.github.io/post/network/network_http_3/","summary":"HTTP란 무엇이고, HTTP의 특징인 클라이언트 서버 구조, stateless, connectionless, HTTP mesage에 대해 알아본다.","title":"[TIL] Network HTTP basic"},{"content":"Intro  HTTP에 관한 학습내용의 기본 출처: 김영한님의 모든 개발자를 위한 HTTP 웹 기본지식 강의를 듣고 정리한 내용과 모르는 부분에 대한 추가 내용을 합쳐 올린다. 이 강의는 HTTP에 대한 웹 기본지식을 설명하는 강의이므로, 내용이 간략할 수 있다.   학습 이유: 프레임워크를 사용하여 웹 개발을 배우기 전에, HTTP에 대해 기본적인 지식을 알고 시작하고 싶어 HTTP 공부를 시작한다. 이 강의에 대해 공부 후, 네트워크 전반에 대해 공부한다.   1. URI  URI (Uniform Resource Identifier)란??  로케이터(locater), 이름(name) 또는 둘 다 추가로 분류될 수 있다.  from https://www.ietf.org/rfc/rfc3986.txt - 1.1.3. URI, URL, and URN      1.1 URI, URL, URN의 각 의미  URI의 단어 뜻  Uniform: 리소스를 식별하는 통일된 방식 Resource: URI로 식별하는 수 있는 모든 자원으로, 제한 없다. Identifier: 다른 항목과 구분하는데 필요한 정보 (식별자)   URL의 단어 뜻  Locator: resource가 있는 위치를 지정한다.   URN의 단어 뜻  Name: resource에 이름을 부여한다.   위치는 변할 수 있지만, 이름은 변하지 않는다. urn:isbn:8960777331 (어떤 책의 isbn URN) URN 이름만으로 실제 리소스를 찾을 수 있는 방법이 보편화 되지 않았다. 그래서 앞으로 URI를 URL과 같은 의미로 이야기하겠다  1.2 URL 분석  URL 전체 문법 구조\nscheme://[userinfo@]host[:port][/path][?query][#fragment]\n  예시: https://www.google.com:443/search?q=hello\u0026amp;hl=ko 프로토콜: https 호스트명: google.com 포트번호: 443 path: \\search query parameter: ?q=hello\u0026amp;hl=ko  - scheme (ex: https)\n scheme://[userinfo@]host[:port][/path][?query][#fragment]\nhttps://www.google.com:443/search?q=hello\u0026amp;hl=ko\n  주로 프로토콜을 사용한다.  프로토콜이란 어떤 방식으로 자원에 접근할건지 약속된 규칙이다. 예: http, https, ftp 등등   http는 80포트, https는 443포트를 주로 사용하며 포트는 생략 가능하다. https는 http에 보안 사용을 추가한 것이다. (HTTP Secure)  - userinfo\n scheme://**[userinfo@]**host[:port][/path][?query][#fragment]\nhttps://www.google.com:443/search?q=hello\u0026amp;hl=ko\n  URL에 사용자 정보를 포함해서 인증할 때 사용한다. 하지만 거의 사용하지 않는다.  - host (ex: www.google.com)\n scheme://[userinfo@]host[:port][/path][?query][#fragment]\nhttps://www.google.com:443/search?q=hello\u0026amp;hl=ko\n  호스트명이다. domain 명 또는 IP 주소를 직접 입력한다.  - PORT (ex: 443)\n scheme://[userinfo@]host [:port][/path][?query][#fragment]\nhttps://www.google.com:443/search?q=hello\u0026amp;hl=ko\n  접속 포트 일반적으로 생략한다. 생략시 http는 80, https는 443이다.  - path (ex: /search)\n scheme://[userinfo@]host[:port][/path][?query][#fragment]\nhttps://www.google.com:443/search?q=hello\u0026amp;hl=ko\n  리소스의 경로다. 계층적 구조로 되어있다.  /home/file1.jpg /members /members/100, /item/iphone12    - query (ex: q=hello\u0026amp;hl=ko)\n scheme://[userinfo@]host[:port][/path][?query][#fragment]\nhttps://www.google.com:443/search?q=hello\u0026amp;hl=ko\n  key = value 형태로 되어 있다. ?로 시작하며 \u0026amp;로 추가 가능하다.  ex) ?keyA=valueA\u0026amp;keyB=valueB   query parameer, query string 등으로 불린다. 웹서버에 제공하는 파라미터, 문자형태다.\n  - fragment (ex: getting-started-introducing-spring-boot)\n scheme://[userinfo@]host[:port][/path][?query][#fragment]\nhttps://docs.spring.io/spring-boot/docs/current/reference/html/gettingstarted.html#getting-started-introducing-spring-boot\n  html 내부 북마크 등에 사용한다. 서버에 전송하는 정보가 아니다.   2. 웹 브라우저 요청 흐름 다음 URL을 가지고 https://www.google.com:443/search?q=hello\u0026amp;hl=ko 웹 브라우저가 어떻게 요청해서 진행되는지 흐름을 파악해보자.\n DNS 조회: google.comd을 DNS에서 조회하여 해당 IP 주소를 찾는다. HTTPS PORT는 생략한다. 443 HTTP 요청 메시지를 클라이언트가 생성한다. HTTP 요청 메시지는 다음과 같다.  그러면 \u0026lsquo;Itroduction 1: Internet Network\u0026rsquo; 에서 학습한 과정이 진행된다.\nHTTP 메시지 전송  resource 요청 시, Application layer에서 HTTP 메세지를 생성한다. 3 way handshake를 통해 socket에 연결한다. socket library를 통해 transmission layer 계층으로 데이터를 전송한다. transmission layer 계층에서 HTTP를 포함한 TCP 정보를 씌운다. TCP 정보를 포함하는 IP 패킷을 생성한다.  패킷이 도착하면 서버는 패킷 내부 HTTP method를 해석하여 정보에 맞는 동작을 한다. 서버에서 HTTP 응답 메세지를 생성한다.  클라이언트에서는 응답 메세지를 받아 HTML 렌더링을 한다.   Reference  모든 개발자를 위한 HTTP 웹 기본지식 URI와 웹 브라우저 요청 흐름  ","permalink":"http://jeha00.github.io/post/network/network_http_2/","summary":"URI, URL, URN 에 대해 알아보고, 웹 브라우저의 요청 흐름에 대해 알아본다.","title":"[TIL] Network HTTP intro. 2: URI 와 웹 브라우저 요청 흐름"},{"content":"HTTP에 관한 학습내용의 기본 출처는 김영한님의 모든 개발자를 위한 HTTP 웹 기본지식 이다. 강의를 듣고 정리한 내용과 모르는 부분에 대한 추가 내용을 합쳐 올린다.\n이 강의는 HTTP에 대한 웹 기본지식으르 설명하는 강의이므로, 내용이 간략할 수 있다.\n프레임워크를 사용하여 웹 개발을 배우기 전에, HTTP에 대해 기본적인 지식을 알고 시작하고 싶어 HTTP 공부를 시작한다. 이 강의에 대해 공부 후, 네트워크 전반에 대해 학습한다.\n 1. IP에 대해서 컴퓨터는 랜선 또는 인터넷 망을 통해서 통신한다. 그리고 인터넷 망은 수 많은 서버들로 구성되어 있으며, 이 서버들을 node(노드)라 한다.\n그러면 수 많은 node들을 거쳐서 \u0026lsquo;어떻게\u0026rsquo; data를 보낼 수 있을까??\n바로 IP 라는 규약을 통해서 보낸다.\n1.1 IP란??  Internet Protocol 약어로, 인터넷 데이터 통신을 원활히 하기 위해 필요한 통신 \u0026lsquo;규약\u0026rsquo; 을 말한다.\n IP의 역할은\n 지정한 IP 주소로, packet이라는 통신 단위로, 데이터를 전달하는 역할이다.  그래서, 원하는 서버와 클라이언트에 데이터가 도달하기 위해서는 컴퓨터를 구분하는 고유 IP 주소(IP address)를 부여받아야 한다. 이 IP 주소의 형식은 100.100.100.1 같이 각 부분을 점으로 구분하여 표현한다.\n IP 주소 형식에 대해서도 IPv4, IPv6 로 분류된다. IPv4는 점으로 구분된 부분이 4개의 part고, IPv6는 6개의 파트로 구분된다. IPv4로는 주소 수가 부족하여 IPv6가 등장했다.\n  1.2 Packet이란? 수화물을 의미하는 Package와 덩어리를 의미하는 bucket의 합성어로, packet이라 한다. 통신 단위 packet에는 여러 데이터가 담겨져 있지만, 기본적으로 \u0026lsquo;주소지 정보\u0026rsquo;(출발지의 IP 주소, 도착지의 IP 주소) 그리고, 전달하려는 \u0026lsquo;전송 데이터\u0026rsquo;가 있다.\n인터넷 망을 구성하는 node들은 다 IP를 따르기 때문에, 중간 과정에 있는 node들은 출발지가 어디고, 도착지인지 이해할 수 있다. 그래서 node들이 IP를 참고하여 서로 packet을 던지면서 원하는 목적지로 보내진다.\n위의 이미지는 클라이언트의 패킷을 전달하는 내용이다.\n서버의 패킷을 전달하는 것도 동일한 원리다.\n 2. IP 문제점의 해결책: TCP 이 IP는 3가지 문제점(한계)이 있다.\n  비연결성 문제\n 패킷을 받는 대상이 없거나(컴퓨터가 off된 경우), 서비스 불능 상태여도 패킷을 전송한다. 연결이 안되도 보내지는 문제점이 존재한다. ex) 우편물을 A 주소로 보냈지만, 도착해서 보니 A 주소에 집이 없는 경우를 말한다.    비신뢰성 문제\n 손실 문제: packet이 전송되는 과정에 중간에 사라지는 경우  ex) 노드 서버에 도착했는데, 갑자기 케이블이 끊어지는 경우   순서 바뀜 문제: packet의 용량 문제로 나눠 보낼 때 순서에 문제가 발생한 경우    프로그램 구분 문제\n 한 IP 주소에서 2개 이상의 application을 사용하고 있을 때, 무슨 application에 관한 정보인지 어떻게 구분하는가??    2.1 인터넷 프로토콜 스택의 4계층 이를 해결한 것이 바로 TCP 다.\nTCP에 대해 알기에 앞서 인터넷 프로토콜 스택의 4계층에 대해 알아보자.\n인터넷 프로토콜은 4계층으로, 순서는 애플리케이션 계층 \u0026gt; 전송 계층 \u0026gt; 인터넷 계층 \u0026gt; 네트워크 인터페이스 순으로 구성된다.\n 애플리케이션 계층(Application layer) - HTTP, FTP 전송계층(Transmission layer) - TCP, UDP 인터넷 계층(Internet layer) - IP 네트워크 인터페이스 계층(Network Access layer)  이 계층 순서로 어떻게 packet을 보내는지 알아보자.\n resource 요청 시, Application layer에서 HTTP 메세지를 생성한다.\n-\u0026gt; 3 way handshake를 통해 socket에 연결한다.\n-\u0026gt; socket library를 통해 transmission layer 계층으로 데이터를 전송한다.\n-\u0026gt; transmission layer 계층에서 HTTP를 포함한 TCP 정보를 씌운다.\n-\u0026gt; TCP 정보를 포함하는 IP 패킷을 생성한다.\n-\u0026gt; 패킷 정보가 인터넷을 거쳐서 서버에 도착한다.\n-\u0026gt; 패킷이 서버에 도착하면 패킷과 TCP 세그먼트는 버리고, HTTP 메세지를 서버가 해석한다.\n-\u0026gt; HTTP 응답 메시지를 마찬가지 방식으로 packet을 생성하여 응답 패킷을 전달한다.\n-\u0026gt; 수 많은 노드들을 통해서 응답 패킷이 도착하면, 웹 브라우저가 HTML 렌더링하여 화면에 보여준다.  TCP 정보와 IP packet을 생성한 데이터 안에 담겨진 구체적인 내용은 다음과 같다.\n  socket이란??\napplication layer와 transport layer 사이에 위치하여, process가 메시지를 송신하고 수신할 수 있도록 API를 제공해주는 역할을 한다.    2.2 IP 문제점의 해결책: TCP TCP (Transmisstion Control Protocol)는 전송 제어 프로토콜로, IP 의 3가지 문제점에 대한 해결책이다. TCP에 여러 특징들이 있지만, 위 문제점을 해결하는 3가지 특징에 대해 중점적으로 알아보자.\n2.2.1 연결지향 - TCP 3 way handshake (가상 연결) 클라이언트가 서버에 데이터를 전송하기 전에 \u0026lsquo;연결과정\u0026rsquo;을 거친다. 이 과정으로 IP의 비연결성 문제를 해결한다.\n 첫 번째, 클라이언트가 서버에 접속 요청(SYN)한다. 접속 요청하는 걸 SYN(Synchronization) 이라 한다. 두 번째, 그 후 서버는 클라이언트의 요청을 수락(ACK)한다. 서버도 클라이언트에게 접속 요청(SYN)한다. 요청을 수락하는 걸 ACK(Acknowledgement) 라 한다. 세 번째, 클라이언트가 서버의 접속 요청에 수락(ACK)한다.  이 3가지 단계를 거친 후, 클라이언트가 서버에 데이터를 전송한다. 그래서 SYN -\u0026gt; SYN + ACK -\u0026gt; ACK 순서로 3 way handshake가 진행된 후, 데이터를 전송한다.\n하지만, 때로는 세 번째 단계 ACK할 때 데이터를 함께 전송한다.\n 3 way handshake 방식은 물리적으로 직접 연결된 상태가 아니라, 논리적으로 연결된 상태이다. 이 의미는 클라이언트와 서버 사이에 무수히 많은 노드들을 거쳐서 연결된 것을 의미한다. 물리적으로 직접 연결된 상태라는 건 클라이언트와 서버가 직섭 랜선으로 연결된 경우를 말한다.\n  2.2.2 데이터 전달 보증 데이터를 전송하면 수신 확인 메세지를 클라이언트에게 보내준다. IP의 \u0026lsquo;비신뢰성\u0026rsquo; 문제를 해결한다.\n 2.2.3 순서 보장 생성한 HTTP data에 TCP 정보를 씌울 때, 순서 정보가 들어가기 때문에, 데이터를 받고 나서 의도한 순서대로 온 건지 판단할 수 있다. IP의 \u0026lsquo;순서 바뀜\u0026rsquo; 문제를 해결한다.\n 3. TCP 문제점의 해결책: UDP IP의 여러 문제점을 해결하는 TCP이지만, 위에 TCP segment에 들어가는 정보들처럼 정보양이 많기 때문에 시간이 오래 걸리고, 최적화가 어렵다. 또한, 인터넷 자체도 이미 TCP 기반이라 다듬을 수 없다. 그래서 UDP를 최적화하여 속도를 증가시킬 수 있다. 최근에 이 UDP가 뜨고 있다. 웹 브라우저가 TCP handshake 과정을 줄일려고 하기 때문이다.\n TCP의 속도 문제를 해결할 수 있는게 UDP(User Datagram Protocol)이다. 데이터를 데이터그램 단위로 처리하는 프로토콜이란 의미다. 연결지향 X, 데이터 전달 보증과 순서보장 X 지만, 단순하고 빠르다. IP와 거의 같지만, 차이점은 PORT와 checksum 기능이 있다.  그리고 바로 이 PORT라는 기능이 IP의 세 번째 문제점을 해결해준다.\n 4. Port와 DNS란 무엇인가?? 4.1 Port란? 한 IP에서 여러 Application을 사용하고 있을 때, 데이터를 원하는 Application으로 보내기 위해서 PORT 가 필요하다. 이 port 정보는 TCP 세그먼트에 포함되어 있다.\n그래서 IP packet에 있는 IP 주소로 원하는 클라 또는 서버에 도달한다. 그리고, 클라 또는 서버 안에 원하는 Application에 데이터를 제공하기 위해서 PORT 정보를 활용한다.\nPort number는\n 0 ~ 65535번까지 할당이 가능하다. 0 ~ 1023번은 잘 알려진 포트이기 때문에, 사용하지 않는 것이 낫다.  FTP - 20, 21 TELNET - 23 HTTP - 80 HTTPS - 443    위 이미지를 예를 들어 server IP 200.200.200.3 에서 클라이언트의 웹 브라우저 요청에 응답하기를 원한다면 도착지 IP는 100.100.100.1 이고, PORT는 10010 이다.\n 4.2 DNS란? DNS는 Domain Name System으로, 기억하기 어렵고 변경될 수 있는 IP address 대신에 Domain Name을 사용하면 DNS에서 이 Domain name에 해당되는 IP주소로 응답하여 접속하는 시스템을 말한다.\n Reference  모든 개발자를 위한 HTTP 웹 기본지식 1. 인터넷 네트워크 Application layer Socket  ","permalink":"http://jeha00.github.io/post/network/network_http_1/","summary":"HTTP를 학습하기 위해 사전지식으로 IP,TCP/UDP, PORT, DNS를 알아본다.","title":"[TIL] Network HTTP intro. 1: Internet network"},{"content":"1. Error 종류와 원인  Python basic 과정 강의를 끝내고, 간단한 프로젝트로 Hangman game 만들기를 해봤다. 그 과정에서 발생한 오류를 기록하고자 한다. 만드는 과정에서 모르는 에러가 발생했다. 바로 이 에러(: TypeError: 'NoneType' object is not subscriptable) 다.   에러가 발생한 코드는 다음과 같다.  \u0026gt; import csv \u0026gt; import random \u0026gt; words = [] \u0026gt; with open(\u0026#39;./resource/word_list.csv\u0026#39;, \u0026#39;r\u0026#39;, encoding = \u0026#39;utf-8\u0026#39;) as f: \u0026gt; reader = csv.reader(f) \u0026gt; next(reader) \u0026gt; for v in reader: \u0026gt; words.append(v) \u0026gt; q = random.shuffle(words) # 이 line에서 에러가 발생했다. \u0026gt; print(q[0]) 2. Error 해결과정 위 코드를 작성한 이유는 words 의 성분들을 섞은 상태로 다른 변수에 할당하고 나서, Hangman game의 답을 random으로 q에서 뽑아내고자 했다. 지금 보면 터무니 없는 코드로 당연히 오류날만한 부분이었고, 너무 어렵게 생각했다. 왜 이렇게 작성한 것인지 원인을 생각해보았고, 어떻게 접근해야할지 생각해 보았다.\n random.shuffle() 의 내부 원리를 정확히 이해하지 못 했다. 급하게 생각하여 차근 차근 생각하지 못 했다. A 과정을 거쳐 B 과정을 수행한다고 했을 때, 각 과정을 위해서 무슨 함수를 사용할지 정한다. 각 함수의 기능을 영문으로 찾아보자.  그래서 결과부터 말하자면 위 코드는 다음과 같이 수정했다.\n\u0026gt; random.shuffle(words) \u0026gt; q = random.choice(words) 그러면 하나 하나 파악해보자.\n제일 먼저 .shuffle()의 의미를 확인해보았다.\n random.shuffle(x) : Shuffle list x in place, and return None.  random.shuffle(x) 은 list x의 성분들의 순서를 섞지만, 아무것도 반환하지 않는 함수라는 의미다. q에는 아무것도 할당되지 않았다는 의미다.\n그렇기 때문에 'Nonetype'으로 object가 떴다. subscriptable은 구글 영문 사전, 네이버 영영 사전을 검색해도 의미가 나오지 않아, stackoverflow를 검색해보았다. What does it mean if a Python object is \u0026ldquo;subscriptable\u0026rdquo; or not? 이 글을 보면 다음과 같은 의미를 가진다.\n The [...] indexing syntax is called a subscript, because it's equivalent to mathematical notation that uses actual subscripts; e.g. a[1] is Python for what mathematicians would write as a₁. So \u0026quot;subscriptable\u0026quot; means \u0026quot;able to be subscripted\u0026quot;. Which, in Python terms, means it has to implement __getitem__(), since a[1] is just syntactic sugar for a.__getitem__(1). - Mark Reed Apr 2, 2020 at 14:15  [\u0026hellip;] 는 인덱싱 문법에 사용되는 기호로, subscript라 한다. 왜냐하면 수학 표기법에서 a[1]은 a₁ 와 같기 때문이다. 즉, subscriptable는 able to be subscripted: 인덱싱에 사용할 수 있다를 의미한다. 파이썬 용어의 관점에서 [] indexing은 __getitem__을 실행한다는 의미다. (ex) a[1] == a.__getitem__(1)\n 결론\n- TypeError: 'NoneType' object is not subscriptable : data type error의 종류이며, NoneType 객체는 인덱싱에 사용할 수 없다.\n- 구글 번역도 좋지만 보다 직접 번역하며 분석하는 게 훨씬 공부에 도움이 된다.\n Reference  What does it mean if a Python object is \u0026ldquo;subscriptable\u0026rdquo; or not?  ","permalink":"http://jeha00.github.io/post/python_basic/python_basic_22_nonetypeerror/","summary":"Python basic 과정을 마치고, 간단한 프로젝트로 Hangman game을 만들었다. 그 과정에서 NoneTypeError가 발생했다. \u0026lsquo;TypeError:\u0026lsquo;NoneType\u0026rsquo; object is not subscriptable\u0026rsquo; 에 대해 알아보자.","title":"[TIL] Python basic 22: NoneTypeError"},{"content":"Intro  csv 파일이란??  Comma-Separated Values의 약자로, 콤마로 구분된 텍스트 파일이다. 확장자 명은 .csv이다. csv 파일은 data science 분야에서 주로 사용하여, 데이터를 주고 받을 때 사용하는 형식이다. data science 분야나 전처리할 때, csv로 임시로 저장을 했다가 나중에 활용하는 형식으로도 많이 사용하고 있다.   csv의 MIME 형식은 text/csv 이다.  MIME type이란 client에서 전송하는 문서의 종류를 표시하는 기능이다. 서버에서 이 type을 이용해서 각각 파일의 확장자를 확인할 수 있다.   csv의 파일 1행을 열머리글로 header라고 한다. 콤마(,)로 반드시 구분되는 게 아니지만, 정석은 콤마다.  1. Read csv file (csv 파일 읽기)  두 개의 예제를 통해 읽기 실습을 해보겠다. 첫 번째 예제는 정석으로 콤마(,)로 구분되는 파일이다. (text1.csv) 두 번째 예제는 코마가 아닌 합기호로 구분되는 파일이다. (text2.csv) csv 파일을 읽기 위해서는 csv.reader 함수를 사용해야한다. csv.reader: Return a reader object which will iterate over lines in the given csvfile. csvfile can be any object which supports the iterator protocol. the iterator protocol을 지원하는지 알기 위해서 dir() 함수를 사용하여 __iter__이 있는지 확인한다. 그리고, 파이썬은 list 형태로 가져오고, 작성한다.   예제 파일 내용은 아래와 같다.  ## text1.csv # 콤마로 구분 Name,Code Afghanistan,AF Åland Islands,AX Albania,AL Algeria,DZ American Samoa,AS Andorra,AD ## text2.csv # 합기호로 구분 Name|Code Afghanistan|AF Åland Islands|AX Albania|AL Algeria|DZ American Samoa|AS Andorra|AD  첫 번째 예제 csv 파일의 첫 행 부분을 Header라고 한다. Header skip을 원한다면 next() 함수를 사용한다. next(): Return the next item from the iterator.  괄호 안에 입력한 iterator의 두 번째 행부터 출력하겠단 의미다. seek() 함수처럼 cursor를 이동한다.    # 외장 함수를 import 한다. \u0026gt; import csv # 별도로 close 하지 않기 위해 with open 함수를 사용한다. # 현재 경로에서 resource 폴더에 있는 tes1.csv 파일을 읽고, f에 연결한다. \u0026gt; with open(\u0026#39;./resource/test1.csv\u0026#39;, \u0026#39;r\u0026#39;) as f: \u0026gt; reader = csv.reader(f) \u0026gt; print(reader) \u0026lt;_csv.reader object at 0x00000206CB2F5100\u0026gt; \u0026gt; print(type(reader)) \u0026lt;class \u0026#39;_csv.reader\u0026#39;\u0026gt; ## __iter__을 확인한다. \u0026gt; print(dir(reader)) [\u0026#39;__class__\u0026#39;, \u0026#39;__delattr__\u0026#39;, \u0026#39;__dir__\u0026#39;, \u0026#39;__doc__\u0026#39;, \u0026#39;__eq__\u0026#39;, \u0026#39;__format__\u0026#39;, \u0026#39;__ge__\u0026#39;, \u0026#39;__getattribute__\u0026#39;, \u0026#39;__gt__\u0026#39;, \u0026#39;__hash__\u0026#39;, \u0026#39;__init__\u0026#39;, \u0026#39;__init_subclass__\u0026#39;, \u0026#39;__iter__\u0026#39;, \u0026#39;__le__\u0026#39;, \u0026#39;__lt__\u0026#39;, \u0026#39;__ne__\u0026#39;, \u0026#39;__new__\u0026#39;, \u0026#39;__next__\u0026#39;, \u0026#39;__reduce__\u0026#39;, \u0026#39;__reduce_ex__\u0026#39;, \u0026#39;__repr__\u0026#39;, \u0026#39;__setattr__\u0026#39;, \u0026#39;__sizeof__\u0026#39;, \u0026#39;__str__\u0026#39;, \u0026#39;__subclasshook__\u0026#39;, \u0026#39;dialect\u0026#39;, \u0026#39;line_num\u0026#39;] ## __iter__이면 for문에도 사용할 수 있다. # list 형식으로 가져온다는 걸 확인할 수 있다. \u0026gt; for c in reader: \u0026gt; print(type(c)) \u0026gt; print(c) \u0026lt;class \u0026#39;list\u0026#39;\u0026gt; [\u0026#39;Name\u0026#39;, \u0026#39;Code\u0026#39;] \u0026lt;class \u0026#39;list\u0026#39;\u0026gt; [\u0026#39;Afghanistan\u0026#39;, \u0026#39;AF\u0026#39;] \u0026lt;class \u0026#39;list\u0026#39;\u0026gt; [\u0026#39;횇land Islands\u0026#39;, \u0026#39;AX\u0026#39;] \u0026lt;class \u0026#39;list\u0026#39;\u0026gt; [\u0026#39;Albania\u0026#39;, \u0026#39;AL\u0026#39;] \u0026lt;class \u0026#39;list\u0026#39;\u0026gt; [\u0026#39;Algeria\u0026#39;, \u0026#39;DZ\u0026#39;] \u0026lt;class \u0026#39;list\u0026#39;\u0026gt; [\u0026#39;American Samoa\u0026#39;, \u0026#39;AS\u0026#39;] \u0026lt;class \u0026#39;list\u0026#39;\u0026gt; [\u0026#39;Andorra\u0026#39;, \u0026#39;AD\u0026#39;] ## list를 string 형식으로 바꿔보자. # 첫 번째 Name, Code가 헤더로, 열정보 다. \u0026gt; print(\u0026#39;\u0026#39;.join(c)) NameCode AfghanistanAF 횇land IslandsAX AlbaniaAL AlgeriaDZ American SamoaAS AndorraAD ## 헤더를 출력하고 싶지 않으면?? \u0026gt; with open(\u0026#39;./resource/test1.csv\u0026#39;, \u0026#39;r\u0026#39;) as f: \u0026gt; reader = csv.reader(f) # with open 문 안에 아래 함수를 추가한다. # Header Skip: csv 파일의 첫 행 부분은 보통 헤더값이라 하며, 생략한다. \u0026gt; next(reader) # 다시 실행시켜보자. # NameCode가 없는 걸 확인할 수 있다. \u0026gt; print(\u0026#39;\u0026#39;.join(c)) AfghanistanAF 횇land IslandsAX AlbaniaAL AlgeriaDZ American SamoaAS AndorraAD  두 번째 예제 (test2.csv)  \u0026gt; import csv \u0026gt; with open(\u0026#39;./resource/test2.csv\u0026#39;, \u0026#39;r\u0026#39;) as f: \u0026gt; reader = csv.reader(f, delimiter = \u0026#39;|\u0026#39;) \u0026gt; next(reader) \u0026gt; for c in reader: \u0026gt; print(c) [\u0026#39;Afghanistan\u0026#39;, \u0026#39;AF\u0026#39;] [\u0026#39;횇land Islands\u0026#39;, \u0026#39;AX\u0026#39;] [\u0026#39;Albania\u0026#39;, \u0026#39;AL\u0026#39;] [\u0026#39;Algeria\u0026#39;, \u0026#39;DZ\u0026#39;] [\u0026#39;American Samoa\u0026#39;, \u0026#39;AS\u0026#39;] [\u0026#39;Andorra\u0026#39;, \u0026#39;AD\u0026#39;] ## 만약 delimiter = \u0026#39;|\u0026#39; 를 입력하지 않는다면?? # name과 code가 하나의 값으로 인식된다. [\u0026#39;Afghanistan|AF\u0026#39;] [\u0026#39;횇land Islands|AX\u0026#39;] [\u0026#39;Albania|AL\u0026#39;] [\u0026#39;Algeria|DZ\u0026#39;] [\u0026#39;American Samoa|AS\u0026#39;] [\u0026#39;Andorra|AD\u0026#39;]  DictReader 를 사용하여 test2.csv의 내용을 dictionary 형태로 formatting한다.  \u0026gt; import csv \u0026gt; with open(\u0026#39;./resource/test1.csv\u0026#39;, \u0026#39;r\u0026#39;) as f: \u0026gt; reader = csv.DictReader(f) \u0026gt; print(reader) \u0026lt;csv.DictReader object at 0x000001DD1A8A2F70\u0026gt; \u0026gt; print(type(reader)) \u0026lt;class \u0026#39;csv.DictReader\u0026#39;\u0026gt; \u0026gt; print(dir(reader)) [\u0026#39;__class__\u0026#39;, \u0026#39;__delattr__\u0026#39;, \u0026#39;__dict__\u0026#39;, \u0026#39;__dir__\u0026#39;, \u0026#39;__doc__\u0026#39;, \u0026#39;__eq__\u0026#39;, \u0026#39;__format__\u0026#39;, \u0026#39;__ge__\u0026#39;, \u0026#39;__getattribute__\u0026#39;, \u0026#39;__gt__\u0026#39;, \u0026#39;__hash__\u0026#39;, \u0026#39;__init__\u0026#39;, \u0026#39;__init_subclass__\u0026#39;, \u0026#39;__iter__\u0026#39;, \u0026#39;__le__\u0026#39;, \u0026#39;__lt__\u0026#39;, \u0026#39;__module__\u0026#39;, \u0026#39;__ne__\u0026#39;, \u0026#39;__new__\u0026#39;, \u0026#39;__next__\u0026#39;, \u0026#39;__reduce__\u0026#39;, \u0026#39;__reduce_ex__\u0026#39;, \u0026#39;__repr__\u0026#39;, \u0026#39;__setattr__\u0026#39;, \u0026#39;__sizeof__\u0026#39;, \u0026#39;__str__\u0026#39;, \u0026#39;__subclasshook__\u0026#39;, \u0026#39;__weakref__\u0026#39;, \u0026#39;_fieldnames\u0026#39;, \u0026#39;dialect\u0026#39;, \u0026#39;fieldnames\u0026#39;, \u0026#39;line_num\u0026#39;, \u0026#39;reader\u0026#39;, \u0026#39;restkey\u0026#39;, \u0026#39;restval\u0026#39;] ## __iter__ 확인 완료 \u0026gt; for c in reader: \u0026gt; print(c) {\u0026#39;Name\u0026#39;: \u0026#39;Afghanistan\u0026#39;, \u0026#39;Code\u0026#39;: \u0026#39;AF\u0026#39;} {\u0026#39;Name\u0026#39;: \u0026#39;횇land Islands\u0026#39;, \u0026#39;Code\u0026#39;: \u0026#39;AX\u0026#39;} {\u0026#39;Name\u0026#39;: \u0026#39;Albania\u0026#39;, \u0026#39;Code\u0026#39;: \u0026#39;AL\u0026#39;} {\u0026#39;Name\u0026#39;: \u0026#39;Algeria\u0026#39;, \u0026#39;Code\u0026#39;: \u0026#39;DZ\u0026#39;} {\u0026#39;Name\u0026#39;: \u0026#39;American Samoa\u0026#39;, \u0026#39;Code\u0026#39;: \u0026#39;AS\u0026#39;} {\u0026#39;Name\u0026#39;: \u0026#39;Andorra\u0026#39;, \u0026#39;Code\u0026#39;: \u0026#39;AD\u0026#39;} ## 위 내용을 Name과 Code로 나누고 싶으면?? \u0026gt; for c in readers: \u0026gt; for k, v in c.items() \u0026gt; print(k) Name Code Name Code Name Code Name Code Name Code Name Code \u0026gt; print(v) Afghanistan AF 횇land Islands AX Albania AL Algeria DZ American Samoa AS Andorra AD \u0026gt; print(k,v) Name Afghanistan Code AF Name 횇land Islands Code AX Name Albania Code AL Name Algeria Code DZ Name American Samoa Code AS Name Andorra Code AD  2. Write csv file (csv 파일 쓰기) \u0026gt; import csv \u0026gt; w = [[1, 2, 3], [4, 5, 6], [7, 8, 9], [10, 11, 12], [13, 14, 15], [16, 17, 18], [19, 20, 21]] \u0026gt; with open(\u0026#39;./resoucre/write1.csv\u0026#39;, \u0026#39;w\u0026#39;, encoding = \u0026#39;utf-8\u0026#39;) as f: \u0026gt; wt = csv.writer(f) \u0026lt;class \u0026#39;_csv.writer\u0026#39;\u0026gt; \u0026gt; for v in w \u0026gt; # v를 wt에 작성한다. 하나의 list가 하나의 record가 된다. \u0026gt; wt.writerow(v) 1,2,3 4,5,6 7,8,9 10,11,12 13,14,15 16,17,18 19,20,21  dict의 key 값을 field명으로 활용해서 써보기 .writeheader: Write a row with the field names (as specified in the constructor) to the writer’s file object .writerow: Write the row parameter to the writer’s file object, formatted according to the current Dialect.  \u0026gt; import csv \u0026gt; w = [[1, 2, 3], [4, 5, 6], [7, 8, 9], [10, 11, 12], [13, 14, 15], [16, 17, 18], [19, 20, 21]] \u0026gt; with open(\u0026#39;./resource/write2.csv\u0026#39;, \u0026#39;w\u0026#39;, encoding = \u0026#39;utf - 8\u0026#39;) as f: \u0026gt; # w의 list 성분이 3개의 성분을 가지고 있으므로, 3개를 입력 \u0026gt; fields = [\u0026#39;one\u0026#39;, \u0026#39;two\u0026#39;, \u0026#39;three\u0026#39;] \u0026gt; wt = csv.DictWriter(f, fieldnames = fields) \u0026gt; # header write \u0026gt; # header로 one, two, three가 작성된 상태다. \u0026gt; wt.writeheader() \u0026gt; for v in w: \u0026gt; wt.writerow({\u0026#39;one\u0026#39;: v[0], \u0026#39;two\u0026#39;:v[1], \u0026#39;three\u0026#39;:v[2]}) one,two,three 1,2,3 4,5,6 7,8,9 10,11,12 13,14,15 16,17,18 19,20,21  Reference  CSV란??  ","permalink":"http://jeha00.github.io/post/python_basic/python_basic_21_filereadwrite_2/","summary":"with open() as 를 사용하여 외부 csv 파일을 읽고, 쓰는 방법을 알아보자.","title":"[TIL] Python basic 21: csv.read, write"},{"content":"Intro   이번 chapter에서는 외부에서 수집하거나 작성한 어떠한 text 파일, csv 파일, json 같은 다양한 형식의 외부 파일들을 읽고 쓰는 작업을 알아본다.\n  이번 chapter에서 중요한 것은\n 첫 번째, 외부 resource를 파이썬에 list type으로 읽어와서 저장하고, list type으로 원하는 파일을 쓴다는 것  readlines 함수와 writelines 함수   두 번째, 사용한 resource는 반드시 close를 해야 한다. 그래서 with문을 사용한다.  close를 하는 이유는 하지 않을 경우 다음 코드를 사용할 때 원활하지 않을 수 있다.      1. Read file (파일 읽기)  파일을 읽고 쓰는 작업을 하기 위해 open 이란 함수를 사용한다. 이 함수에서 사용하는 몇 가지 용어와 경로의 두 종류에 대해 알아보자.  r: 읽기모드 (read) w: 쓰기모드 (write) a: 추가모드 (append) t: text 모드 (기본모드라 생략 가능) b: binary 모드 경로의 종류: 상대 경로와 절대 경로  상대 경로(../, ./): 점 하나는 현재 위치를, 점 두 개는 상위 폴더를 의미한다. 절대 경로: C:\\Django\\example..' 다른 컴퓨터에 다운을 받을 때는 절대 경로보다 상대 경로가 맞다. 그 이유는 경로가 절대적으로 같지 않기 때문이다.       외부에 있는 파일을 읽을 때는 먼저 함수를 사용하여 연결한 후, 내용을 읽는다. Encoding 이란 사람의 언어를 컴퓨터 언어로 암호화하는 걸 의미한다.  Ecoding의 한 방식이 \u0026lsquo;UTF-8\u0026rsquo; 이다. 원문이 무엇으로 인코딩되었는지를 알아야 파이썬으로 불러왔을 때 깨지지 않는다.   먼저 원하는 경로에 파일을 만들어놓은 후, 실습을 진행했다.  ## open(\u0026#39;경로\u0026#39;, \u0026#39;rt\u0026#39; \u0026#39;rb\u0026#39; \u0026#39;w\u0026#39; \u0026#39;a\u0026#39; \u0026#39;a\u0026#39;, A) # 1) 현재 경로를 기준으로 상대 경로로 입력한다. # 2) rt이지만, t는 기본값이므로 r만 입력한다. # 3) encoding 방식으로 UTF-8 사용 \u0026gt; f = open(\u0026#39;./resource/it_news.txt\u0026#39;, \u0026#39;r\u0026#39;, encoding = \u0026#39;UTF-8\u0026#39;) ## 인코딩 방식 확인 \u0026gt; print(f.encoding) UTF - 8 ## 파일 이름 \u0026gt; print(f.name) ./resource/it_news.txt ## 모드 확인 \u0026gt; print(f.mode) r ## 외부 파일 읽은 후, 변수에 할당하기 \u0026gt; content = f.read() \u0026gt; print(content) Right now gamers can pay just $1 for access to hundreds of titles across PC and Xbox via Microsoft Xbox Game Pass Ultimate service?but dont activate that insanely cheap one-month trial just yet. You can lock in up to three years of Xbox Game Pass Ultimate with that same dollar if you play your cards right. ## 사용 후 반드시 close 한다. \u0026gt; f.close()  open하여 사용 후, 반드시 close를 해야한다. 하지만, with 문을 사용하면 close를 하지 않아도, 저절로 반환하기 때문에 with문을 사용하자.  \u0026gt; with open(\u0026#39;./resource/it_news.txt\u0026#39;, \u0026#39;r\u0026#39;, encoding = \u0026#39;UTF-8\u0026#39;) as f: \u0026gt; c = f.read() \u0026gt; print(c) # it_news.txt 파일의 내용이 문자 하나 하나로 쪼개져서 list로 출력된다. \u0026gt; print(list(c))  read() 함수에 intger type의 인자를 넣으면, 입력한 값만큼의 Byte를 읽는다. 그리고, 또 실행하면 이어서 읽는다. 왜냐하면 cursor가 움직이기 때문이다. seek() 함수를 사용하여 이 cursor의 위치를 초기화할 수 있다.  \u0026gt; with open(\u0026#39;./resource/it_news.txt\u0026#39;, \u0026#39;r\u0026#39;, encoding=\u0026#39;UTF-8\u0026#39;) as f: \u0026gt; c = f.read(20) \u0026gt; print(c) Right now gamers can # 다시 처음부터 20Byte를 읽어오는 것이 아니라, 전 마지막 읽은 부분부터 시작한다. \u0026gt; c = f.read(20) \u0026gt; print(c) pay just $1 for acc # seek은 커서의 이동 위치를 말해준다. 0,0으로 이동하고 다시 20byte 만큼 읽겠다. \u0026gt; f.seek(0,0) \u0026gt; c = f.read(20) \u0026gt; print(c) Right now gamers can  readline 함수를 사용하여 한 줄 씩 읽기  \u0026gt; with open(\u0026#39;./resource/it_news.txt\u0026#39;, \u0026#39;r\u0026#39;, encoding=\u0026#39;UTF-8\u0026#39;) as f: \u0026gt; line = f.readline() \u0026gt; print(line) Right now gamers can pay just $1 for access to hundreds of titles across PC \u0026gt; line = f.readline() \u0026gt; print(line) and Xbox via Microsoft Xbox Game Pass Ultimate service?but dont  처음부터 다시 읽는 것이 아닌, 이어서 읽기 때문에 반복문을 통해서 처리하자. readlines 함수를 사용한다. 전체를 읽은 후, 라인 단위 리스트로 저장한다. 즉, 파일을 list로 만든다. list로 만들어 원하는 부분만 가져와 텍스트 처리를 할 수 있기 때문에, 반드시 알고 있어야 하는 함수다.  \u0026gt; with open(\u0026#39;./resource/it_news.txt\u0026#39;, \u0026#39;r\u0026#39;, encoding=\u0026#39;UTF-8\u0026#39;) as f: \u0026gt; cts = f.readlines() \u0026gt; for c in cts: \u0026gt; print(c, end=\u0026#39;\u0026#39;) Right now gamers can pay just $1 for access to hundreds of titles across PC and Xbox via Microsoft Xbox Game Pass Ultimate service?but dont activate that insanely cheap one-month trial just yet. You can lock in up to three years of Xbox Game Pass Ultimate with that same dollar if you play your cards right.  2. Write file (파일 쓰기)  없는 파일을 쓰고자 할 때도 연결하기 위해 open함수를 사용한다. write이기 때문에 t 말고 w를 입력한다.  ## contents1.txt 라는 파일 만들기 \u0026gt; with open(\u0026#39;./resources/contents1.txt\u0026#39;, \u0026#39;w\u0026#39;) as f: \u0026gt; f.write(\u0026#39;I love python/n\u0026#39;) ## 위 ./resources 경로로 contents1.txt 파일이 생성된다. 그 파일 안에 내용은 I love python이 있다.  a(append) 를 사용하여 내용 추가하기  \u0026gt; with open(\u0026#39;./resources/contents1.txt\u0026#39;, \u0026#39;a\u0026#39;) as f: \u0026gt; f.write(\u0026#39;I love python2\\n\u0026#39;) ## contents1.txt 파일 내용을 보면 다음과 같이 되어 있다. I love python I love python2  writelines 함수를 사용하여 line list를 파일에 작성하기  \u0026gt; with open(\u0026#39;./resource/content2.txt\u0026#39;, \u0026#39;w\u0026#39;) as f: \u0026gt; list = [\u0026#39;Orange\\n\u0026#39;, \u0026#39;Apple\\n\u0026#39;, \u0026#39;Banana\\n\u0026#39;, \u0026#39;Melon\\n\u0026#39;] \u0026gt; f.writelines(list) Orange Apple Banana Melon  terminal이 아닌 파일로 출력을 해주는 방법  \u0026gt; with open(\u0026#39;./resource/contents3.txt\u0026#39;, \u0026#39;w\u0026#39;) as f: \u0026gt; print(\u0026#39;Test Text Write!\u0026#39;, file=f) \u0026gt; print(\u0026#39;Test Text Write!\u0026#39;, file=f) \u0026gt; print(\u0026#39;Test Text Write!\u0026#39;, file=f) # contents3.txt 파일을 보면 다음과 같다. Test Text Write! Test Text Write! Test Text Write! # 위에 file = f 를 없애면 terminal로 출력된다.  ","permalink":"http://jeha00.github.io/post/python_basic/python_basic_20_filewriteread_1/","summary":"with open() as 함수를 사용해서 외부 파일을 읽고, 작성하는 방법을 알아보겠다.","title":"[TIL] Python basic 20: with open as"},{"content":" 여러 외장 함수들 중 sys, pickle, os, time, random, webbrowser 에 대해 예제 실습으로 알아보겠다. 특히 sys, os, time은 훨씬 자주 사용되므로 중요하다. 외장함수는 import를 하는 것부터 시작한다. 이 포스팅의 목적은 외장 함수에는 이런 것들이 있다는 기록하기 위해서다. 해당 포스팅으로는 각 외장 모듈에 대한 내용이 부족하니, 추가적인 학습을 반드시 해서 TIL에 올리자.  1. sys   sys 모듈은 파이썬 인터프리터가 제공하는 변수와 함수를 직접 제어할 수 있게 해주는 모듈이다.\n  sys.argv는 명령행에 인수를 전달하도록 하는 명령어다.\n  \u0026gt; import sys ## module 파일이 있는 위치들이 출력된다. \u0026gt; print(sys.path) ## 강제 종료 함수다. 함부로 사용하지 않는다. # visual studio code에서는 작동되지 않는다. 해당 언어 shell에서 작동한다. \u0026gt; sys.exit()  2. pickle  pickle 모듈은 텍스트 상태의 데이터가 아닌 객체의 형태를 그대로 유지하면서, 파일에 저장하고 불러올 수 있게 하는 파이썬이 제공하는 모듈이다. 파이썬 객체를 파일에 저장하는 과정을 피클링(pickling)이라 하고, 파일에서 객체를 읽어오는 과정을 언피클링(unpickling)이라 한다. test.obj라는 파일이 binary 형식으로 작성된다. 이 test.obj에 pickle.dump() 명령어로 obj 변수 내용을 저장한다. 그리고 나서, pickle.load() 명령어로 test.obj 파일을 읽는다.  \u0026gt; import pickle # w: write , b: binary, r: read \u0026gt; f = open(\u0026#39;test.obj\u0026#39;, \u0026#39;wb\u0026#39;) \u0026gt; obj = {1: \u0026#39;python\u0026#39;, 2: \u0026#39;study\u0026#39;, 3: \u0026#39;basic\u0026#39;} \u0026gt; pickle.dump(obj, f) # 열고 나서 반드시 닫아야 한다. # 쓴 resource는 컴퓨터한테 반드시 반환해야 한다. \u0026gt; f.close() ## binary file은 컴퓨터가 처리하는 파일 형식이다. ## 사람이 알아보기 힘든 상태로, txt 파일은 이 binary 파일을 사람이 읽기 쉽게 만든 파일 형식이다. ## 그러면 이걸 어떻게 열 수 있을까?? \u0026gt; f = open(\u0026#34;test.obj\u0026#34;, \u0026#39;rb\u0026#39;) \u0026gt; data = pickle.load(f) \u0026gt; print(data) \u0026gt; f.close()  3. os  OS 모듈은 환경 변수나 디렉터리, 파일 등의 OS 자원을 제어할 수 있게 해주는 모듈이다.  \u0026gt; import os # 사용자의 운영체제 정보를 파이썬에게 넘겨준다. \u0026gt; print(os.environ) environ({{\u0026#39;ALLUSERSPROFILE\u0026#39;: \u0026#39;C:\\\\ProgramData\u0026#39;, \u0026#39;APPDATA\u0026#39;: C:\\\\Users\\\\rudtl\\\\AppData\\\\Roaming\u0026#39;, ....}) \u0026gt; print(os.environ[\u0026#39;USERNAME\u0026#39;]) rudtl  4. time  time 모듈은 시간과 관련된 모듈이다.  \u0026gt; import time ## 1970년 1월 1일 0시 0분 0초를 기준으로 지난 시간을 초 단위로 반환한다. \u0026gt; print(time.time()) 1646220813.7009172 ## 하지만 위 방식은 알아보기가 힘들다. # time.time이 반환한 시간을 사용하여 연도,월,일,시,분,초의 형태로 바꿔주는 함수다. \u0026gt; print(time.localtime(time.time())) time.struct_time(tm_year=2022, tm_mon=3, tm_mday=2, tm_hour=20, tm_min=41, tm_sec=0, tm_wday=2, tm_yday=61, tm_isdst=0) ## local.time 보다 더 간단히 표현하는 모듈이다. \u0026gt; print(time.ctime()) Wed Mar 2 20:42:50 2022 ## 원하는 형식으로 시간을 출력해주는 모듈이다. # Year, Month, Day, hour , Minute, Second \u0026gt; print(time.strftime(\u0026#39;%Y-%m-%d %H:%M:%S\u0026#39;, time.localtime(time.time()))) 2022-03-02 20:42:50 ## 시간 간격 발생 # 출력 간 delay를 1초로 한다. \u0026gt; for i in range(5): \u0026gt; print(i) \u0026gt; time.sleep(1) 0 1 2 3 4  5. random  random은 난수(규칙이 없는 임의의 수)를 발생시키는 모듈  \u0026gt; import random ## 0에서 1 사이의 아무 난수를 반환한다. \u0026gt; print(random.random()) ## 1에서 45 사이의 정수값을 랜덤으로 갖고 온다. \u0026gt; print(random.randint(1, 45)) ## 1에서 44 사이의 정수값을 랜덤으로 갖고 온다. \u0026gt; print(random.randrange(1, 45)) ## Iterable object의 argument의 순서를 섞어서 출력한다. # 출력할 때마다 순서가 바뀐다. \u0026gt; d = [1, 2, 3, 4, 5] \u0026gt; random.shuffle(d) \u0026gt; print(d) [2, 5, 3, 4, 1] [2, 4, 1, 3, 5] ... ## Iterable object의 argument들 중 무작위로 선택하는 함수 \u0026gt; d = [1, 2, 3, 4, 5] \u0026gt; c = random.choice(d) \u0026gt; print(c) 1 4 3 2  6. webbrowser  webbrowser는 본인 OS의 web browser를 실행한다.  \u0026gt; import webbrowser ## 기본 웹 브라우저를 사용하여 아래 url로 자동으로 이동한다. 이미 실행된 상태라면 기존에 있던 tab이 이동된다. \u0026gt; webbrowser.open(\u0026#34;https://google.com\u0026#34;) ## 기본 웹 브라우저에 새로운 탭이 생기면서 아래 url로 이동한다. \u0026gt; webbrowser.open_new(\u0026#34;https://google.com\u0026#34;)  Reference  라이브러리 pickling  ","permalink":"http://jeha00.github.io/post/python_basic/python_basic_19_external_functions/","summary":"외장 함수를 실행하는 방법과 외장 함수의 여러 종류들을 알아보겠다.","title":"[TIL] Python basic 19: external functions"},{"content":" 내장 함수란 프로그래밍 언어의 라이브러리에(파이썬의 인터프리터에) 이미 등록되어 있는 함수를 말한다. 그래서 별도의 정의나 설치가 필요없다. 외장 내장 구분하는 건 중요하지 않고, 필요한 곳에 이미 파이썬에 내장된 함수를 찾아서 프로그램을 개발할 때, 적합한 어떤 위치에서 사용하는 게 중요하다. 예시를 사용하여 내장함수에 대해 알아보겠다. 아래에 예시로 사용하는 내장함수는 반드시 알고 있자.   abs(): 입력된 숫자형 데이터를 절대값으로 반환해주는 함수  \u0026gt; print(abs(-3)) 3  all() , any: interable 요소를 검사하여 성분이 참인지 거짓인지 검사하는 함수 (True or False) all() 은 안에 있는 요소가 논리 연산자 and처럼 다 True여야 True를 반환한다. any() 는 논리 연산자 or처럼 안에 있는 요소들 중 하나라도 True가 있으면 True다.  \u0026gt; print(all([1, 2, 3])) True \u0026gt; print(all([False, True])) False \u0026gt; print(any([False, True])) True \u0026gt; print(any([False, False])) False  chr(): 아스키 코드를 문자로 반환하는 함수 ord(): 문자를 아스키 코드로 반환하는 함수  \u0026gt; print(chr(67)) C \u0026gt; print(ord(\u0026#39;c\u0026#39;)) 67  enumerate(): index + Iterable 객체(list, tuple, dictionary, set)을 생성한다.  \u0026gt; for i, name in enumerate([\u0026#39;abc\u0026#39;, \u0026#39;bcd\u0026#39;, \u0026#39;eft\u0026#39;]): \u0026gt; print(i, name) 0 abc 1 bcd 2 efg  filter(): Iterable 객체를 지정한 함수 조건에 맞는 값만 추출한다. filter(function or None, iterable) \u0026ndash;\u0026gt; filter object  \u0026gt; def conv_positive(x): \u0026gt; return abs(x) \u0026gt; 2 # 위에서 지정한 함수 조건은 \u0026#39;conv_posotive\u0026#39; 에 의해서 주어지고, interable 데이터가 입력된다. \u0026gt; print(filter(conv_positive, [1, -3, 2, 0, -5, 6])) \u0026lt;filter object at 0x0000025A0B362FA0\u0026gt; \u0026gt; print(list(filter(conv_pos, [1, -3, 2, 0, -5, 6]))) [-3, -5, 6] ## 단 한 번 쓸 함수를 위해 위에처럼 정의하면 분량이 늘어난다. 이럴 때, lamda 함수를 사용한다. \u0026gt; print(list(filter(lambda x: abs(x) \u0026gt; 2, [1, -3, 2, 0, -5, 6])))  id(): 객체의 주소값(reference)를 반환한다. id(): Return the identity of an object.  \u0026gt; print(id(5)) 2144671066544 \u0026gt; print(id(float(4))) 2144671700368  len: 요소의 길이를 반환한다. len: Return the number of items in a container.  \u0026gt; print(len(\u0026#39;123456789\u0026#39;)) 9 \u0026gt; print(len([1,2,3,4,5,6,7])) 7  max: 입력된 iterable 자료형 중에 가장 큰 값을 반환한다. max: With a single iterable argument, return its biggest item. With two or more arguments, return the largest argument. min: max와 반대로 가장 작은 값을 반환한다.  \u0026gt; print(max([1,2,3])) 3 ## 오름차순 시, y가 제일 크다. \u0026gt; print(max(\u0026#39;python study\u0026#39;)) y \u0026gt; print(min([1,2,3])) 1 # blank가 제일 작은 값이라, 아무것도 없어보인다. \u0026gt; print(min(\u0026#39;python study\u0026#39;))  map: iterable 객체 요소를 지정한 함수를 실행 후 추출 map: map(func, *iterables) \u0026ndash;\u0026gt; map object  Make an iterator that computes the function using arguments from each of the iterables.   데이터 전처리 과정에서 많이 사용한다.  \u0026gt; def conv_abs(x): \u0026gt; return abs(x) \u0026gt; print(list(map(conv_abs,[1,-3,2,0,-5,6]))) [1, 3, 2, 0, 5, 6] ## 또는 위에 함수 정의를 하지 않고, 람다 함수를 사용한다. \u0026gt; print(list(map(lambda x:abs(x),[1,-3,2,0,-5,6]))) [1, 3, 2, 0, 5, 6]  pow : 제곱값 반환  \u0026gt; print(pow(2,10)) 1024  range: 반복가능한 객체(Iterable) 반환  \u0026gt; print(range(1,10,2)) range(1, 10, 2) \u0026gt; print(list(range(1,10,2))) [1, 3, 5, 7, 9] \u0026gt; print(list(range(0,-15,-1)) [0, -1, -2, -3, -4, -5, -6, -7, -8, -9, -10, -11, -12, -13, -14]  round: 반올림  ## 소수점 둘쨰자리에서 반올림한다. \u0026gt; print(round(6.5781, 2)) 6.58 \u0026gt; print(round(5.6)) 6  sum: 반복가능한 객체(Iterable) 합 반환  \u0026gt; print(sum([6, 7, 8, 9, 10])) 40 \u0026gt; print(sum(range(1,101))) 5050  type: 자료형의 type을 확인  \u0026gt; print(type(3)) \u0026lt;class \u0026#39;int\u0026#39;\u0026gt; \u0026gt; print(type({})) \u0026lt;class \u0026#39;dict\u0026#39;\u0026gt; \u0026gt; print(type(())) \u0026lt;class \u0026#39;tuple\u0026#39;\u0026gt; \u0026gt; print(type([])) \u0026lt;class \u0026#39;list\u0026#39;\u0026gt;  zip: Iterable 객체의 요소를 묶어서 tuple type으로 반환 zip: A zip object yielding tuples until an input is exhausted.  \u0026gt; print(list(zip([10,20,30],[40,50,777]))) [(10, 40), (20, 50), (30, 777)] # 짝이 맞는 것만 반환한다. # list 안에 tuple type의 argument가 담겨져있다. \u0026gt; print(list(zip([10,20,],[40,50,777]))) [(10, 40), (20, 50)] \u0026gt; print(type(list(zip([10,20,30],[40,50,777]))[0])) \u0026lt;class \u0026#39;tuple\u0026#39;\u0026gt; ","permalink":"http://jeha00.github.io/post/python_basic/python_basic_18_built_in_fuctions/","summary":"내장 함수란 무엇이고, 내장 함수에서 자주 사용된 것들로 실습을 해보겠다.","title":"[TIL] Python basic 18: built-in functions"},{"content":"1. Exception(예외) and Error(에러)의 차이점  Exception(예외) 와 Error(에러)에 대해 설명하겠다. 예외는 무엇이고 에러는 무엇이다라고 외우진 말자. 예외를 에러의 범주에 포함하기도 하기 때문이다. 다만, 예외와 에러에 대한 틀을 잡기 위해 설명한다.   Exception(예외)는 우리가 작성한 로직에서 비정상적으로 발생한 사건(event)이다.  예외에는 예측이 가능한 예외와 예측이 불가능한 예외로 나눠진다. 예측 가능한 예외의 경우는 id 입력을 생각해보자. 영어로 입력해야하는데, 한글을 입력했을 경우 예외가 발생한다. 예측 불가능한 예외의 경우는 메모리의 용량이 부족해서, OS에서 발생한 에러, 하드웨어적인 에러 등등이 해당된다.   이 예외와 에러를 잘 처리해야 내가 의도한대로 작동하는 어플리케이션을 만들 수 있다.   2. Error의 종류 2.1 SyntaxError: 문법 오류 # 조건문의 헤더에 콜론(:)을 하지 않아 발생했다. \u0026gt; print(\u0026#39;error\u0026#39;) \u0026gt; print(\u0026#39;error\u0026#39;) \u0026gt; if True \u0026gt; pass SyntaxError: invalid syntax 2.2 TypeError: 자료형에 맞지 않는 연산을 수행하여 발생하는 오류 \u0026gt; x = [1,2] \u0026gt; y = (1,2) \u0026gt; z = \u0026#39;test\u0026#39; # list와 tuple은 합칠 수 없다. \u0026gt; print(x + y) TypeError: can only concatenate list (not \u0026#34;tuple\u0026#34;) to list # string과 list는 합칠 수 없다. \u0026gt; print(x + z) TypeError: can only concatenate list (not \u0026#34;str\u0026#34;) to list # tuple과 string은 합칠 수 없다. \u0026gt; print(y + z) TypeError: can only concatenate list (not \u0026#34;str\u0026#34;) to list 2.3 NameError: 참조가 없을 때 발생하는 오류 \u0026gt; a = 10 \u0026gt; b = 15 \u0026gt; print(c) NameError: name \u0026#39;c\u0026#39; is not defined 2.4 IndexError: index가 존재하지 않아 발생하는 오류 \u0026gt; x = [50, 70, 90] \u0026gt; print(x[1]) 70 \u0026gt; print(x[4] IndexError: list index out of range # 알고리즘에서 op을 사용할 때 발생할 수 있는 에러 \u0026gt; print(x.pop()) 50 \u0026gt; print(x.pop()) 70 \u0026gt; print(x.pop()) 90 \u0026gt; print(x.pop()) IndexError: pop from empty list 2.5 ValueError: 참조값이 없을 때 발생하는 오류 \u0026gt; x = [10, 50, 90] \u0026gt; x.remove(50) \u0026gt; print(x) [10, 90] \u0026gt; x.remove(200) ValueError: list.remove(x): x not in list 2.6 KeyError: 해당되는 key가 없을 때 발생하는 오류 # `key` 값으로 `value` 값을 출력할 때는 `.get()` 함수를 사용한다. \u0026gt; x = {\u0026#39;A\u0026#39;: \u0026#39;apple\u0026#39;, \u0026#39;B\u0026#39;: \u0026#39;Banana\u0026#39;, \u0026#39;C\u0026#39;: \u0026#39;coffee\u0026#39;} \u0026gt; print(x[\u0026#39;D\u0026#39;]) KeyError: \u0026#39;D\u0026#39; \u0026gt; print(x.get(\u0026#39;D\u0026#39;)) None 2.7 AttributeError: 모듈, 클래스에 있는 잘못된 속성을 사용하여 발생한 오류 \u0026gt; import time \u0026gt; print(time.time2()) AttributeError: module \u0026#39;time\u0026#39; has no attribute \u0026#39;time2\u0026#39; 2.8 FileNotFoundError: 파일을 찾을 수 없을 때 발생하는 오류 \u0026gt; f = open(\u0026#39;test.txt\u0026#39;) FileNotFoundError: [Errno 2] No such file or directory: \u0026#39;test.txt\u0026#39; 2.9 ZeroDivisionError: 0으로 나눠서 발생하는 오류 \u0026gt; print(100 / 0) ZeroDivisionError: division by zero  3. 예외 처리 (try ~ exception)  try: 에러가 발생할 가능성이 있는 코드 실행  이 에러는 내 코드가 정확해도, 방문한 사이트 서버나 여러 프로그램이 외부와 연결될 때, 문제가 있을 수 있기 때문이다. 그래서 외부적으로 문제가 발생해도 try ~ except로 대비한다.   except 에러명 1~n:  error가 발생했을 때 잡아내어 다음 코드로 넘어가도록 해준다. 여러 개 가능하다. 어떤 Error만 잡을지 정할 수 있다. 모든 error 잡아내기  except Exception:은 모든 예외의 부모격이라 모든 error를 잡아낸다. except: 또한, 모든 error을 잡아낸다. 하지만, 정확히 어떤 error가 발생했는지 알 수 없다. 정확히 어떤 error가 발생했는지 알아야 로그를 남길 때 정확히 남길 수 있다.   예제 3에서처럼 예제 2에서 alias를 줘서 except Exception as e 와 print(e) 을 사용하여, 대략적인 error 내용을 확인하여 출력하도록 할 수 있다.   else: try block에 에러가 없을 경우 실행한다.  정상적으로 흘러갈 때 실행된다. for ~ else 에서도 for문에 break를 만나지 않으면 else가 실행했듯이, except를 만나지 않으면 실행된다.   finally: 에러발생 유무와 상관없이 무조건 실행된다.  error 발생 유무에 상관없이 항상 실행해줘야 하는 구문으로 finally를 사용한다. 예를 들어 error가 발생했을 경우, 연결된 메모리를 끊어줘야 메모리가 새지 않기 때문에 finally를 통해서 실행한다.    ## 예제 1 ## error 발생하지 않는 코드 \u0026gt; name = [\u0026#39;Kim\u0026#39;, \u0026#39;Lee\u0026#39;, \u0026#39;Park\u0026#39;] \u0026gt; print(name.index(\u0026#39;Kim\u0026#39;)) \u0026gt; try : \u0026gt; z = \u0026#39;Kim\u0026#39; \u0026gt; x = name.index(z) \u0026gt; print(\u0026#39;{} Found it! {} in name\u0026#39;.format(z, x + 1)) # error 중 ValueError 만 잡는다. # error 처리 시, 이렇게 error의 정확한 유형대로 잡아내느 것이 제일 좋은 case다. \u0026gt; except ValueError: \u0026gt; print(\u0026#39;Not found it! - Occurred ValueError!\u0026#39;) # error가 발생되지 않았으므로 else 구문이 작동된다. \u0026gt; else: \u0026gt; print(\u0026#39;Ok! else.\u0026#39;) \u0026gt; print(\u0026#39; \u0026#39; ) 0 Kim Found it! 1 in name Ok! else. ## 예제 2 # error 발생 코드 # error가 발생했어도 except로 잡아냈기 때문에 else 구문을 출력된다. # 그리고, 그 다음 코드를 계속해서 실행한다. print(\u0026#39;pass\u0026#39;)가 출력된 걸 확인할 수 있다. # 또한, 예제 1에서의 ValueError를 지웠기 때문에 모든 Error를 잡아낸다. # 하지만, 그래서 어떤 Error를 잡았는지 정확히 알 수 없다. \u0026gt; name = [\u0026#39;Kim\u0026#39;, \u0026#39;Lee\u0026#39;, \u0026#39;Park\u0026#39;] \u0026gt; try: \u0026gt; z = \u0026#39;Cho\u0026#39; \u0026gt; x = name.index(z) \u0026gt; print(\u0026#39;{} Found it! {} in name\u0026#39;.format(z, x + 1)) # except Exception: \u0026gt; except: \u0026gt; print(\u0026#39;Not found it! - Occurred Error!\u0026#39;) \u0026gt; else: \u0026gt; print(\u0026#39;Ok! else.\u0026#39;) \u0026gt; \u0026gt; print(\u0026#39;pass\u0026#39;) Not found it! - Occurred Error! pass ## 예제 3 # 예제 2를 보완한 코드 \u0026gt; name = [\u0026#39;Kim\u0026#39;, \u0026#39;Lee\u0026#39;, \u0026#39;Park\u0026#39;] \u0026gt; try: \u0026gt; z = \u0026#39;Cho\u0026#39; \u0026gt; x = name.index(z) \u0026gt; print(\u0026#39;{} Found it! {} in name\u0026#39;.format(z, x + 1)) # 예제 2와 달리 추가된 부분 \u0026gt; except Exception as e: \u0026gt; print(e) # \u0026gt; print(\u0026#39;Not found it! - Occurred Error!\u0026#39;) \u0026gt; else: \u0026gt; print(\u0026#39;Ok! else.\u0026#39;) # 예외 유무에 상관없이 finally는 실행된다. \u0026gt; finally: \u0026gt; print(\u0026#39;Ok! finally\u0026#39;) \u0026#39;Cho\u0026#39; is not in list Not found it! - Occurred Error! Ok! finally  error를 일부러 발생시킨 경우를 생각해보자. 언제 일부러 error를 발생시킬까?? 여기서 error란 Python에서 발생시킨 게 아니라, 설계자가 회사에서 요구하는 논리상 알기 위해서 일부러 발생시킨 error를 말한다. 아래 코드로 설명을 하자면 a가 Kim이 아니라면 이는 파이썬 내에 ValueError가 발생된 것이 아니다. 하지만 회사에서 Kim이 아닌 경우에 대해 알기 위해서 error를 발생시켰다. 이를 토대로 언제 Kim이 아닌지 역으로 분석할 수 있다.  ## error 발생 X \u0026gt; name = [\u0026#39;Kim\u0026#39;, \u0026#39;Lee\u0026#39;, \u0026#39;Park\u0026#39;] \u0026gt; try: \u0026gt; a = \u0026#39;Park\u0026#39; \u0026gt; if a == \u0026#39;Park\u0026#39;: \u0026gt; print(\u0026#39;OK! Pass!\u0026#39;) \u0026gt; else: \u0026gt; raise ValueError \u0026gt; except ValueError: \u0026gt; print(\u0026#39;Occurred! Exception!\u0026#39;) \u0026gt; else: \u0026gt; print(\u0026#39;Ok! else!\u0026#39;) OK! Pass! Ok! else! ## error 발생 O \u0026gt; name = [\u0026#39;Kim\u0026#39;, \u0026#39;Lee\u0026#39;, \u0026#39;Park\u0026#39;] \u0026gt; try: \u0026gt; a = \u0026#39;Park\u0026#39; \u0026gt; if a == \u0026#39;Kim\u0026#39;: \u0026gt; print(\u0026#39;OK! Pass!\u0026#39;) \u0026gt; else: \u0026gt; raise ValueError \u0026gt; except ValueError: \u0026gt; print(\u0026#39;Occurred! Exception!\u0026#39;) \u0026gt; else: \u0026gt; print(\u0026#39;Ok! else!\u0026#39;) Occurred! Exception!  a에는 \u0026lsquo;Park\u0026rsquo;가 할당되었다. \u0026lsquo;Kim\u0026rsquo;이 아니기 때문에, 일부러 ValueError를 발생시켰다. 그래서 except ValueError 문이 실행이 되어 print문이 출력되었다. 일부러 Error를 일으키고, ErrorType도 정할 수 있다는 걸 알고 있자.  ","permalink":"http://jeha00.github.io/post/python_basic/python_basic_17_try_exception/","summary":"Error의 종류와 예외 처리문에 대해 알아보고, 일부러 에러를 일으키는 이유와 방법에 대해 알아보겠다.","title":"[TIL] Python basic 17: try ~ exception"},{"content":"1. Pacakge 구조  Package는 module의 묶음을 의미하며, 폴더에 담아 관리한다. 그러면 이 pacakge를 불러와서 사용하기 위해서는 2가지 방법이 있다.  첫 번째 방법: 현재 경로를 기준으로 상대 경로 개념을 사용하여, module 경로를 직접 입력하여 사용하는 방식 두 번째 방법: import와 from을 사용하는 방식   경로 이동: cd .. 을 하면 상위 directory로 이동된다. 다 같이 여러명과 project를 진행한다면 위 방법 2가지 보다는 컴퓨터 공용 위치에 package 파일들을 두고, sys.path 또는 환경설정에서 경로를 설정하는 방법을 사용하자.   2. 패키지 경로 및 패키지 함수 실행 2.1 패키지 경로 와 inspect.getfile 함수  예제를 설명하기에 앞서 module로 사용할 package인 module1.py 와 module2.py의 위치는 다음과 같다. __init__.py 파일도 기억해놓자.  sub ├─sub1 │ │─ module1.py │ │─ __init__.py │ └─ __pycache__ ├─sub2 │ │─ module2.py │ │─ __init__.py │ └─__pycache__ └─__pycache__  그리고 module 파일인 module1.py와 module2.py의 내부 코드는 다음과 같다. inspect 함수는 파이썬의 객체들로부터 유용한 정보를 얻고자 할 때 사용하는 함수다.  inspect: get useful imformation from live Python objects   inspect 에 의해 제공되는 함수가 .getfile 이다. .getfile은 object가 어느 위치에 있는지 알고자 할 때 사용한다. .currentframe 은 실행 중인 파일의 이름과 경로를 보여준다.  ## module1.py \u0026gt; import sys \u0026gt; import inspect # from ..sub2 import module2 \u0026gt; def mod1_test1(): \u0026gt; print (\u0026#34;Module1 -\u0026gt; Test1\u0026#34;) \u0026gt; print(\u0026#34;Path : \u0026#34;, inspect.getfile(inspect.currentframe())) \u0026gt; def mod1_test2(): \u0026gt; print (\u0026#34;Module1 -\u0026gt; Test2\u0026#34;) \u0026gt; print(\u0026#34;Path : \u0026#34;, inspect.getfile(inspect.currentframe())) # 만약 inspect.currentframe()만 입력하면 다음과 같이 뜬다. # \u0026lt;frame at 0x00000296CE1BB7C0, file c:\\\\Users ~~ \\module1.py, line 9, code mod1_test1\u0026gt; # 파일 경로와, 파일 내의 몇 번째 줄인지까지 확인할 수 있다. # 하지만, insepct.getfile(inspect.currentframe())) 을 입력하면 다음과 같이 뜬다. # c:\\Users\\ ~ sub\\sub1\\module1.py # 경로만 출력된다. # 코드 경로를 넘어서 더 상세한 위치를 알고 싶다면 `inspect.currentframe()`을 사용해야겠다. ## module2.py \u0026gt; import sys \u0026gt; import inspect \u0026gt; def mod2_test1(): \u0026gt; print (\u0026#34;Module2 -\u0026gt; Test1\u0026#34;) \u0026gt; print(\u0026#34;Path : \u0026#34;, inspect.getfile(inspect.currentframe())) \u0026gt; def mod2_test2(): \u0026gt; print (\u0026#34;Module2 -\u0026gt; Test2\u0026#34;) \u0026gt; print(\u0026#34;Path : \u0026#34;, inspect.getfile(inspect.currentframe())) 2.2 패키지 함수 실행하기: 2가지 방법   그러면 패키지를 불러오는 방법 2가지에 대해 알아보자.\n  폴더명을 입력하고 점.을 입력하면 입력했던 폴더명의 하위 object가 뜬다.\n 폴더, 파일, method 등등이 뜬다.     첫 번째 방법의 장단점  경로를 하나 하나 입력하는 방법이다. 단점:  경로가 너무 다르면 입력해야할 경로가 너무 길어진다. 그래서 현재 경로와 같을 경우에 사용한다. 경로가 길어질 경우를 대비해서 from을 사용한다. (두 번째 방법)   장점:  sys.path.append() 함수로 경로를 추가하지 않아도 불러올 수 있다.      ## 첫 번째 방법 \u0026gt; sub.sub1.module1.mod1_test1() \u0026gt; sub.sub2.module2.mod2_test1() # 또는 \u0026gt; import sub.sub1.module1 \u0026gt; import sub.sub2.module2  두 번째 방법: from ~ import ~ as 사용하기  첫 번째보다 경로를 짧게 입력할 수 있기 때문에, 깔끔하고 가독성이 좋다. from을 통해 패키지의 정확한 경로를 찾아서 사용하고 싶은 모듈만 import 하여 사용한다. as는 alias로 별명, 별칭이다. as를 설정하면 모듈 이름을 다 입력할 필요 없이, as만 입력하면 된다.    ## 두 번째 방법 \u0026gt; from sub.sub1 import module1 \u0026gt; from sub.sub1 import module2 as m2 # 호출하기 \u0026gt; module1.mod1_test1() Module1 -\u0026gt; Test1 Path : c:\\Users\\ ~ \\sub\\sub1\\module1.py \u0026gt; module1.mod1_test2() Module1 -\u0026gt; Test2 Path : c:\\Users\\ ~ \\sub\\sub1\\module1.py # 아래 2가지는 서로 같다. \u0026gt; module2.mod2_test1() \u0026gt; m2.mod2_test1() Module2 -\u0026gt; Test1 Path : c:\\Users\\ ~ \\sub\\sub2\\module2.py  from ~ import * 로 모든 module 파일을 가져올 수도 있다. * 이 모든 파일을 의미한다. 하지만 이런 경우 안쓰는 파일을 가져온다. 현재 HW의 발달로 눈에 띄는 성능 저하는 드러나지 않지만, 이런 것들이 쌓이면 run time에서 메모리를 잡아먹는다. 항상 메모리를 신경쓰는 습관을 가지자.  \u0026gt; from sub.sub1 import * \u0026gt; from sub.sub2 import * \u0026gt; module1.mod1_test1() Module1 -\u0026gt; Test1 Path : c:\\Users\\ ~ \\sub\\sub1\\module1.py \u0026gt; module1.mod1_test2() Module1 -\u0026gt; Test2 Path : c:\\Users\\ ~ \\sub\\sub1\\module1.py \u0026gt; module2.mod2_test1() Module2 -\u0026gt; Test1 Path : c:\\Users\\ ~ \\sub\\sub2\\module2.py \u0026gt; module2.mod2_test2() Module2 -\u0026gt; Test2 Path : c:\\Users\\ ~ \\sub\\sub2\\module2.py  3. __init__.py 가 존재하는 이유  __init__.py 파일은 파이썬에게 해당 폴더가 package로 인식하도록 해준다. __init__.py 이 없으면 파이썬은 그 폴더를 package로 인식하지 않는다. 하지만, Python 3.3 부터는 __init__.py 파일이 없어도 package로 인식한다. 그러면 __init__.py 을 작성할 필요가 없을까?? 아니다.  Python 3.3 이전 버전으로 의뢰가 들어올 경우가 있기 때문에, 그리고 하위 호환을 위해 작성한다. Python 3.3 이전 버전으로 작성하다가 새롭게 업데이트를 하면 거의 작동되겠지만, 예상치 못한 side effect가 있을 수 있기 때문에 작성한다.   package 폴더에 있는 pyecache 파일은 빠른 실행을 위해 파이썬 엔진이 만드는 것이기 때문에, 지워도 실행하면 다시 생긴다.   그러면 __init__.py 파일 내부를 살펴보자.  # sub1 폴더에는 module1.py 이 있다. # sub1 의 __init__.py 작성 명령어는 다음과 같다. \u0026gt; __all__ = [\u0026#39;module1\u0026#39;] # sub2 폴더에는 module2.py 이 있다. # sub2 의 __init__.py 작성 명령어는 다음과 같다. \u0026gt; __all__ = [\u0026#39;module2\u0026#39;]  아래 내용은 Python 3.3 이전 버전에 관한 내용이다. 이후부터는 필수가 아니다. __all__ = [ ] 에서 대괄호에 module 파일명이 적혀 있어야, 외부에서 import 할 때 해당 module 파일을 허가해준다. 이 list에 파일명이 다르면 작동할 수 없다. 파이썬이 import할 때, __init__을 먼저 검사하기 때문에, all에 없으면 error가 발생된다. Python 3.3부터는 __init__.py 가 필수가 아니어도, 아직도 많은 오픈 소스에는 __init__.py 가 존재한다.  ","permalink":"http://jeha00.github.io/post/python_basic/python_basic_16/","summary":"package란 무엇인지, package의 경로와 함수를 어떻게 실행하는지, \u003cstrong\u003einit\u003c/strong\u003e.py가 존재하는 이유에 대해 알아보겠다.","title":"[TIL] Python basic 16: package"},{"content":"Module이란?? 그리고 Module 관련 함수  Module이란 하나의 파일 안에 함수, 변수, 클래스 등 파이썬 구성 요소 등을 모아놓아 공용적으로 쓸 수 있도록 만든 파일 타인으로부터 웹으로부터 가져다 사용한다. 이 Module 파일이 모여지면 Package가 된다. 외부 module을 사용하기 위해서는 import 를 사용한다. module 을 사용하기 위해서, 사용하기 전에 모듈파일이 있는 경로를 추가해야한다. sys.path는 영구적으로 경로를 등록하는 것이 아닌 일시적으로 등록하는 방법이다. 영구적으로 등록하고 싶으면 환경 변수에 있는 python path에 추가하기  \u0026gt; import math \u0026gt; print(math.pi) 3.1415926535 # random은 0부터 1 사이의 난수를 출력한다. \u0026gt; import random \u0026gt; random.random()) 0.71924824 ## import 된 module 파일의 module 타입을 알 수 있다. \u0026gt; import sys \u0026gt; print(sys) \u0026lt;module \u0026#39;sys\u0026#39; (built-in)\u0026gt; # built-in은 내장 파일을 말한다. # sys는 파이썬의 내장 모듈 파일임을 알 수 있다. ## Python 파일이 설치된 경로들이 출력된다. ## 이 경로들에 있는 파일을 파이썬이 가져다가 사용하는 것이 파이썬의 원리다. # 파이썬 모듈 파일들의 경로들이다. # 파이썬 내부에 있기 때문에 import로 가져다가 사용할 수 있다. \u0026gt; print(sys.path) [\u0026#39;c:\\\\Users\\\\rudtl\\\\Desktop\\\\Dev\\\\Python 강의\\\\Inflearn Original\\\\Level 1 입문_프로그래밍 시작하기\u0026#39;, \u0026#39;C:\\\\Users\\\\rudtl\\\\AppData\\\\Local\\\\Programs\\\\Python\\\\Python39\\\\python39.zip\u0026#39;, \u0026#39;C:\\\\Users\\\\rudtl\\\\AppData\\\\Local\\\\Programs\\\\Python\\\\Python39\\\\DLLs\u0026#39;, \u0026#39;C:\\\\Users\\\\rudtl\\\\AppData\\\\Local\\\\Programs\\\\Python\\\\Python39\\\\lib\u0026#39;, \u0026#39;C:\\\\Users\\\\rudtl\\\\AppData\\\\Local\\\\Programs\\\\Python\\\\Python39\u0026#39;, \u0026#39;C:\\\\Users\\\\rudtl\\\\AppData\\\\Local\\\\Programs\\\\Python\\\\Python39\\\\lib\\\\site-packages\u0026#39;] ## 모듈 경로 추가하기 # 추가하기 위해 모듈 경로의 데이터 타입을 확인한다. \u0026gt; print(type(sys.path)) \u0026lt;class \u0026#39;list\u0026#39;\u0026gt; # 경로를 추가하기 전에 밑에 경로로 동일한 명칭의 폴더를 만들어놔야 한다. # 끝에 경로가 추가된 걸 확인할 수 있다. \u0026gt; sys.path.append(\u0026#39;C:/math\u0026#39;) \u0026gt; print(sys.path) [\u0026#39;c:\\\\Users\\\\rudtl\\\\Desktop\\\\Dev\\\\Python 강의\\\\Inflearn Original\\\\Level 1 입문_프로그래밍 시작하기\u0026#39;, \u0026#39;C:\\\\Users\\\\rudtl\\\\AppData\\\\Local\\\\Programs\\\\Python\\\\Python39\\\\python39.zip\u0026#39;, \u0026#39;C:\\\\Users\\\\rudtl\\\\AppData\\\\Local\\\\Programs\\\\Python\\\\Python39\\\\DLLs\u0026#39;, \u0026#39;C:\\\\Users\\\\rudtl\\\\AppData\\\\Local\\\\Programs\\\\Python\\\\Python39\\\\lib\u0026#39;, \u0026#39;C:\\\\Users\\\\rudtl\\\\AppData\\\\Local\\\\Programs\\\\Python\\\\Python39\u0026#39;, \u0026#39;C:\\\\Users\\\\rudtl\\\\AppData\\\\Local\\\\Programs\\\\Python\\\\Python39\\\\lib\\\\site-packages\u0026#39;, \u0026#39;C:/math\u0026#39;] # 폴더를 만들었으면 module 파일을 이 폴더에 넣어놔야 한다. # \u0026#39;module_test` 란 이름으로 파이썬 파일을 만든다. # module 파일의 내용은 다음과 같다. \u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt; \u0026gt; def add(x, y): \u0026gt; return x + y \u0026gt; def subtract(x, y): \u0026gt; return x - y \u0026gt; def multiply(x, y): \u0026gt; return x * y \u0026gt; def divide(x , y): \u0026gt; return x / y \u0026gt; def power(x, y): \u0026gt; return x ** y \u0026gt; print(\u0026#39;-\u0026#39; * 15) \u0026gt; print(\u0026#39;called! inner!\u0026#39;) \u0026gt; print(add(5,5)) \u0026gt; print(subtract(15,5)) \u0026gt; print(multiply(5,5)) \u0026gt; print(divide(10,2)) \u0026gt; print(power(5,3)) \u0026gt; print(\u0026#39;-\u0026#39; * 15) \u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt; ## import를 실행할 파일로 돌아온 후, import 를 실행한다. \u0026gt; import module_test ## import가 되자마다 바로 명령어들이 실행된다. --------------- called! inner! 10 10 25 5.0 125 --------------- ## import된 module 내의 함수를 사용해보기 \u0026gt; import module_test \u0026gt; print(test_module.power(10, 3)) --------------- called! inner! 10 10 25 5.0 125 --------------- 1000  위와 같은 방식은 module을 외부에서 가져오는 사람들에게 편의성이 좋지 않다.    called! innter! 출력을 방지하기 위해서 print 문을 삭제하거나 주석처리를 하는 방법을 사용할 수도 있다.\n  하지만, python에서는 이에 대해 다른 방법을 만들어놨다. 예약어를 사용하여 아래 2가지로 나눠서 실행할 수 있다.\n 다른 곳에서 외부적으로 import를 할 경우 자기 자신을 스스로 실행할 경우    if __name__ == \u0026quot;__main__\u0026quot;: 을 추가한다.\n 이 명령어는 해당 모듈이 import 된 경우가 아니라, 인터프리터에서 직접 실행된 경우에만 if 문 이하의 코드를 돌리라를 명령이다.    module 파일에 아래 코드를 추가한다.\n  ## __name__ 사용 \u0026gt; if __name__ == \u0026#34;__main__\u0026#34;: \u0026gt; print(\u0026#39;-\u0026#39; * 15) \u0026gt; print(\u0026#39;called! __main__\u0026#39;) \u0026gt; print(add(5,5)) \u0026gt; print(subtract(15,5)) \u0026gt; print(multiply(5,5)) \u0026gt; print(divide(10,2)) \u0026gt; print(power(5,3)) \u0026gt; print(\u0026#39;-\u0026#39; * 15)  main은 실행되는 대상을 의미한다. import를 하면 바로 실행되지 않는다. 왜냐면 실행되는 대상이 아니기 때문이다. 하지만, module 파일에서 인터프리터로 직접 실행하면, 실행대상이기 때문에 출력된다. import 한 파일에서는 명령어를 입력하면 실행된다.  \u0026gt; import module_test \u0026gt; print(module_test.power(10,3)) 1000  그래서 바로 실행되지 않도록 if __name__ == \u0026quot;__main__\u0026quot;놔둔다.   ","permalink":"http://jeha00.github.io/post/python_basic/python_basic_15/","summary":"Module이란 무엇인지, Module을 어떻게 사용하는지, Module 관련 함수에 대해 알아본다.","title":"[TIL] Python basic 15: module"},{"content":"Intro  OOP를 요약하여 간단히 핵심만 짚고, 이 이론을 바탕으로 python에서 class와 instance를 구현하겠다.  1. OOP란?  OOP : Object Oriented Programming으로, 객체 지향 프로그래밍이라 한다. Object(객체) : 소프트웨어로 구현할 대상 OOP의 특징  Encapsulation(캡슐화) : attribute 와 method를 하나로 묶어서 객체로 구성하는 것   OOP의 이점  눈에 보이는 사물들을 객체화할 수 있다 == 소프트웨어로 구현할 수 있다 Encapsulation(캡슐화)를 통해서 주변에 악영향 (side effect)을 최소화할 수 있다.  이를 Infomation hiding(정보 은폐)이라 한다.   class를 통해 만들기 때문에 코드의 재사용성이 용이하다. =\u0026gt; 경제적이다.  코드의 개선, 수정이 용이하다. 버그가 발생했을 때 유지보수 또한 용이하다.     하지만, OOP가 항상 빠르진 않다. 경우에 따라서는 객체 지향보다 절차 지향이 더 빠른 퍼포먼스를 가질 수 있으므로, 객체 지향과 절차 지향을 적절히 섞어 사용하자.  절차 지향 : 위에서부터 아래로 실행하는 것     절차지향과 OOP 비교해보기\n[TIL] Python basic 24: Procedural Programming vs OOP\n  2. Class와 instatnce의 차이  눈에 보이는 실체들 중에서 소프트웨어로 구현할 대상을 선정한다. 소프트웨어로 구현할 대상을 객체(Object)라 한다. 그리고, 이 객체(Object)를 class라는 틀을 통해서 소프트웨어적으로 묘사한 것을 instance라 한다. 그렇기 때문에 instance는 객체(Object)라는 개념에 포함된다.   Class variable(클래스 변수) 는  직접 접근이 가능하다. 클래스 변수는 공유된다. == 모든 인스턴스에서 동일하게 가지고 있는 것   instance variable(인스턴스 변수) 는  self가 붙은 것들이 instance varible(인스턴스 변수)다. 인스턴스화된 변수로 접근이 가능하다. 객체마다 별도로 존재한다. 위에 설명한대로 namespace라는 그 인스턴스만의 공간을 별도로 갖고 있어서, namespace를 통해 확인한다.    2.1 Class 만들기  class 만들기 위한 상황  애완견 용품에서 사용하는 소프트웨어를 개발한다고 가정하자. 개의 종은 매우 다양하기 때문에, 개의 종이 추가될 때마다 변수를 입력한다면 그 양이 매우 많아지고, 가독성도 떨어진다. 하지만, 클래스를 이용한다면 눈에 보이는 애완견 실체를 클래스 형태로 구성해서 instance로 만들 수 있다.     class를 만들어보자. __init__은 파이썬에서 클래스가 초기화될 때, 반드시 호출되는 함수다.  ## class 만들기 # class라는 예약어로 class를 만들기 시작한다. # Dog라는 class를 생성한다. # 파이썬의 모든 class는 object를 상속받기 때문에, 선언 방법은 자유롭다. \u0026gt; class Dog(): # class Dog 도 가능하다. \u0026gt; ## 클래스 변수 지정 \u0026gt; # 클래스 변수는 모든 인스턴스에서 동일하다. \u0026gt; species = \u0026#34;firstdog\u0026#34; \u0026gt; \u0026gt; # 모든 class는 초기화 method 및 인스턴스 속성을 가질 수 있다. \u0026gt; # self 후에, 인스턴스에 사용할 변수 속성들을 입력한다. \u0026gt; def __init__(self, name, age): \u0026gt; # 초기화 method를 입력하고 나서, 입력한 인스턴스 속성들에 정확히 mapping 한다. \u0026gt; self.name = name \u0026gt; self.age = age 2.2 Class 호출하기  class 정보를 호출해보자.  ## class 정보 호출하기 # 클래스가 코드로 구현된 걸 확인할 수 있다. \u0026gt; print(Dog) \u0026lt;class \u0026#39;__main__.Dog\u0026#39;\u0026gt; 2.3 인스턴스화하기   인스턴스화 == class를 통해 구현된 instance를 변수에 할당하는 것 인스턴스화한 것은 모두 다 다른 id값을 가진다.    즉, instance는 변수에 할당하여 활용될 수 있다. 변수에 할당했기 때문에, 메모리에 올라가고 id값을 받는다. 각 instance는 동일한 속성값을 가져도, 파이썬에게는 전혀 다른 객체로 간주된다.  ## 인스턴스화 # 할당될 변수 = 클래스 이름(instance 속성들) \u0026gt; a = Dog(\u0026#34;mikky\u0026#34;, 2) \u0026gt; b = Dog(\u0026#34;baby\u0026#34;, 3) \u0026gt; c = Dog(\u0026#34;mikky\u0026#34;, 2) # 모두 다른 id값을 가진다. \u0026gt; print(a == c, id(a), id(b), id(c)) False 2542532857088 2542532856992 2542532856560 2.4 namespace 확인하기  namespace 란 객체를 인스턴스화 할 때, instance의 속성들이 dictionary 형태로 저장되는 공간\n  namespace 를 통해서 instance들이 가지고 있는 속성들을 확인할 수 있다. class는 하나지만, 서로 다른 속성들을 확인할 수 있다. instance만의 공간이다. instance의 namespace를 확인할 때는 __dict__ 를 사용한다.  ## namespace 확인하기 \u0026gt; print(\u0026#39;dog1\u0026#39;, a.__dict__) \u0026gt; print(\u0026#39;dog2\u0026#39;, b.__dict__) dog1 {\u0026#39;name\u0026#39;: \u0026#39;mikky\u0026#39;, \u0026#39;age\u0026#39;: 2} dog2 {\u0026#39;name\u0026#39;: \u0026#39;baby\u0026#39;, \u0026#39;age\u0026#39;: 3} 2.5 class 속성, instance 속성 확인하기  Class variable(클래스 변수) 는  직접 접근이 가능하다. 클래스 변수는 공유된다. == 모든 인스턴스에서 동일하게 가지고 있다.   instance variable(인스턴스 변수) 는  self가 붙은 것들이 instance varible(인스턴스 변수)다. 인스턴스화된 변수로 접근이 가능하다. 객체마다 별도로 존재한다. namespace라는 그 인스턴스만의 공간을 별도로 갖고 있어서, namespace를 통해 확인한다.     클래스 변수에 접근하기  ## 클래스로 직접 접근하기 \u0026gt; print(Dog.species) firstdog ## 인스턴스화된 변수를 통해서 접근하기 \u0026gt; print(a.species) firstdog \u0026gt; print(b.species) firstdog # 직접 접근이 가능하며, 하나의 값을 공유한다는 걸 알 수 있다.  instance 변수에 접근하기  ## 인스턴스화된 변수를 통해서 instance 속성에 접근하기 # a와 b를 인스턴스화했기 때문에 a와 b로 접근이 가능하다. \u0026gt; print(\u0026#39;{} is {} and {} is {}\u0026#39;.format(a.name, a.age, b.name, b.age)) mikky is 2 and baby is 3 \u0026gt; if a.species == \u0026#39;firstdog\u0026#39;: \u0026gt; print(\u0026#39;{0} is a {1}\u0026#39;.format(a.name, a.species)) mikky is a firstdog   위 예제들을 통해서 class의 장점을 다시 한 번 확인할 수 있다.\n  class의 장점\n class 하나를 만들어놓고 찍어내듯이 사용할 수 있다. instance만의 공간도 있고, 공유하는 공간이 있다. 그래서 코드의 재사용성이 좋다는 것이다. 코드의 재사용성이 좋다는 의미는 더 구체적으로 말하자면  객체지향에 입각하여 불필요한 중복을 방지한다. 깔끔한 코드를 통해 프로그램 개발을 할 수 있다. 생산성이 향상되고, 성능도 코드에 따라 좋아진다.       3. Self 의 이해: class method, instance method  __init__이 없으면 파이썬이 알아서 클래스를 만들 때 내부적으로 실행한다. instance 변수를 만들지 않고 사용할 것이기 때문에 __init__을 만들지 않는다. dir()로 변수 내부를 확인할 수 있다. 매개변수에 self 가 있으면 instance method다. 매개변수에 self가 없다면 class method 다. method 호출하기  class method 1가지 방법  주의 사항: 인스턴스화한 변수를 통해서 class method를 호출하면 error가 뜬다. class로 바로 호출하는 방법 (1-1 방법)   instance method 2가지 방법  첫 번째: 인스턴스화한 변수를 통해서 instance method를 호출하는 방법 (2-1 방법) 두 번째: 클래스로 접근하여 매개변수에 인스턴스를 넘겨주는 방법 (2-2 방법)      \u0026gt; class SelfTest: \u0026gt; def func1(): \u0026gt; print(\u0026#39;Func1 called\u0026#39;) \u0026gt; def func2(self): \u0026gt; print(id(self)) \u0026gt; print(\u0026#39;Func2 called\u0026#39;) ## 변수를 인스턴스화 한다. \u0026gt; f = SelfTest() ## dir로 변수 내부를 확인한다. \u0026gt; print(dir(f)) [\u0026#39;__class__\u0026#39;, \u0026#39;__delattr__\u0026#39;, \u0026#39;__dict__\u0026#39;, \u0026#39;__dir__\u0026#39;, \u0026#39;__doc__\u0026#39;, \u0026#39;__eq__\u0026#39;, \u0026#39;__format__\u0026#39;, \u0026#39;__ge__\u0026#39;, \u0026#39;__getattribute__\u0026#39;, \u0026#39;__gt__\u0026#39;, \u0026#39;__hash__\u0026#39;, \u0026#39;__init__\u0026#39;, \u0026#39;__init_subclass__\u0026#39;, \u0026#39;__le__\u0026#39;, \u0026#39;__lt__\u0026#39;, \u0026#39;__module__\u0026#39;, \u0026#39;__ne__\u0026#39;, \u0026#39;__new__\u0026#39;, \u0026#39;__reduce__\u0026#39;, \u0026#39;__reduce_ex__\u0026#39;, \u0026#39;__repr__\u0026#39;, \u0026#39;__setattr__\u0026#39;, \u0026#39;__sizeof__\u0026#39;, \u0026#39;__str__\u0026#39;, \u0026#39;__subclasshook__\u0026#39;, \u0026#39;__weakref__\u0026#39;, \u0026#39;func1\u0026#39;, \u0026#39;func2\u0026#39;] ## 인스턴스화된 f를 통해서 func1을 호출해보자. # func1에는 매개변수가 없는데, 1개가 넘어갔다는 걸 알 수 있다. \u0026gt; f.func1() TypeError: func1() takes 0 positional arguments but 1 was given ## 그러면 인스턴스화된 f를 통해서 func2를 호출해보자. (2-1 방법) \u0026gt; f.func2() 2799723753424 Func2 called ## 그리고, f의 id 값을 호출해보자. \u0026gt; print(id(f)) 2799723753424 ## id(f.func2) 와 id(f) 가 같다는 걸 알 수 있다. ## 즉, self가 있는 method는 instance의 method인 걸 알 수 있다. ## f는 인스턴스화한 변수이기 때문에 func1로 넘어가는 것이 아닌, self가 있는 func2로 넘어간다. ## class method 호출하기 (1-1 방법) \u0026gt; SelfTest.func1() Func1 called ## 만약 역으로 클래스로 접근하여 func2를 호출한다면?? # func2가 요구하는 매개변수 1개를 놓쳐다는 error를 확인했다. \u0026gt; SelfTest.func2() Typeerror: func2() missing 1 required positional argument: \u0026#39;self\u0026#39; # 그러면 매개변수 1개를 입력해보자. (2-2 방법) \u0026gt; SelfTest.func2(f) 2332370018256 Func2 called  4. class, instance variable  class variable은 instance의 공통된 변수이기 때문에, instance의 namespace에 있을 것 같지만 없다. class variable은 class의 namespace에 있다. 하지만, 인스턴스화된 변수를 통해서 class variable에 접근한다면 namespace에서 찾을 수 없어도 class variable만 출력할 수 있다. instance attribute를 만들어서 사용할 것이기 때문에 __init__ 생성자를 사용한다. 그리고 생성자와는 반대로 소멸자를 사용했다. 소멸자: 객체가 소멸될 때 즉, 메모리에서 지워질 때 자동으로 호출되는 함수  \u0026gt; class Warehouse(): \u0026gt; # class variable \u0026gt; stock_num = 0 \u0026gt; \u0026gt; def __init__(self, name): # 생성자 \u0026gt; # instance variable \u0026gt; # mapping \u0026gt; self.name = name \u0026gt; Warehouse.stock_num += 1 \u0026gt; \u0026gt; def __del__(self): # 소멸자 \u0026gt; Warehouse.stock_num -= 1 # user1 instance의 name을 Lee로 한다. \u0026gt; user1 = Warehouse(\u0026#39;Lee\u0026#39;) # user2 instance의 name을 Cho로 한다. \u0026gt; user2 = Warehouse(\u0026#39;Cho\u0026#39;) \u0026gt; print(Warehouse.stock_num) 2 \u0026gt; print(user1.name) Lee \u0026gt; print(user2.name) Cho ## instance의 namespace에서는 공통적으로 가지고 있는 클래스 변수를 찾을 수 없다. \u0026gt; print(user1.__dict__) {\u0026#39;name\u0026#39;: \u0026#39;Lee\u0026#39;} \u0026gt; print(user2.__dict__) {\u0026#39;name\u0026#39;: \u0026#39;Cho\u0026#39;} ## class의 namespace에서 찾을 수 있다. \u0026gt; print(Warehouse.__dict__) {\u0026#39;__module__\u0026#39;: \u0026#39;__main__\u0026#39;, \u0026#39;stock_num\u0026#39;: 2, \u0026#39;__init__\u0026#39;: \u0026lt;function Warehouse.__init__ at 0x000002DC6B59F8B0\u0026gt;, \u0026#39;__del__\u0026#39;: \u0026lt;function Warehouse.__del__ at 0x000002DC6B59F940\u0026gt;, \u0026#39;__dict__\u0026#39;: \u0026lt;attribute \u0026#39;__dict__\u0026#39; of \u0026#39;Warehouse\u0026#39; objects\u0026gt;, \u0026#39;__weakref__\u0026#39;: \u0026lt;attribute \u0026#39;__weakref__\u0026#39; of \u0026#39;Warehouse\u0026#39; objects\u0026gt;, \u0026#39;__doc__\u0026#39;: None} ## 그런데 \u0026lt;instance name\u0026gt;.\u0026lt;class variable name\u0026gt; 을 입력하면 `class variable`의 값이 출력된다. ## 이는 class의 namespace에서 python이 찾아서 출력한 것이다. \u0026gt; print(user1.stock_num) 2 ## 소멸자를 사용하여 instance를 삭제하면, stock_num이 1로 감소한 걸 확인할 수 있다. \u0026gt; del user1 \u0026gt; print(\u0026#39;after\u0026#39;, Warehouse.__dict__) {\u0026#39;__module__\u0026#39;: \u0026#39;__main__\u0026#39;, \u0026#39;stock_num\u0026#39;: 1, \u0026#39;__init__\u0026#39;: \u0026lt;function Warehouse.__init__ at 0x000002DC6B59F8B0\u0026gt;, \u0026#39;__del__\u0026#39;: \u0026lt;function Warehouse.__del__ at 0x000002DC6B59F940\u0026gt;, \u0026#39;__dict__\u0026#39;: \u0026lt;attribute \u0026#39;__dict__\u0026#39; of \u0026#39;Warehouse\u0026#39; objects\u0026gt;, \u0026#39;__weakref__\u0026#39;: \u0026lt;attribute \u0026#39;__weakref__\u0026#39; of \u0026#39;Warehouse\u0026#39; objects\u0026gt;, \u0026#39;__doc__\u0026#39;: None}  파이썬은 object의 이름을 다음 순서로 찾는다.  instance의 namespace -\u0026gt; class의 namespace -\u0026gt; super의 namespace super class: 해당 class의 상위 class를 의미     마지막 예제  ## Dog라는 class를 만든다. \u0026gt; class Dog(): \u0026gt; # 클래스 변수 선언 \u0026gt; species = \u0026#39;Firstdog\u0026#39; \u0026gt; # 생성자 및 인스턴스 속성 생성 그리고 mapping \u0026gt; def __init__(self, name, age): \u0026gt; self.name = name \u0026gt; self.age = age \u0026gt; # 인스턴스 메소드 \u0026gt; def info(self): \u0026gt; return \u0026#39;{} is {} years old\u0026#39;.format(self.name, self.age) \u0026gt; # 인스턴스 메소드 \u0026gt; # sound는 호출 시에 입력한다. \u0026gt; def speak(self, sound): \u0026gt; return \u0026#39;{} says {}!\u0026#39;.format(self.name, sound) ## 인스턴스화 + 인스턴스 속성값 입력 \u0026gt; c = Dog(\u0026#39;july\u0026#39;, 4) \u0026gt; d = Dog(\u0026#39;Marry\u0026#39;, 10) ## 인스턴스 메소드 호출 \u0026gt; print(c.info()) july is 4 years old \u0026gt; print(d.info()) Marry is 10 years old ## 인스턴스 메소드 호출 + sound 매개변수 입력 \u0026gt; print(c.speak(\u0026#39;wal wal\u0026#39;)) july says wal wal! \u0026gt; print(d.speak(\u0026#39;Mung Mung\u0026#39;)) Marry says Mung Mung! ","permalink":"http://jeha00.github.io/post/python_basic/python_basic_14/","summary":"OOP의 의미가 무엇인지, Class와 Instance의 차이가 무엇인지, self가 무엇을 의미하는지, class variable과 instance variable에 대해 알아본다.","title":"[TIL] Python basic 14: class"},{"content":"1. 사용자 입력 \u0026gt; name = input(\u0026#39;Enter Your Name : \u0026#39;) \u0026gt; grade = input(\u0026#39;Enter Your grade : \u0026#39;) \u0026gt; school = input(\u0026#39;Enter Your school : \u0026#39;) \u0026gt; print(name, grade, school) \u0026gt; print(type(name), type(grade), type(school)) Jeha A+ here \u0026lt;class \u0026#39;str\u0026#39;\u0026gt; \u0026lt;class \u0026#39;str\u0026#39;\u0026gt; \u0026lt;class \u0026#39;str\u0026#39;\u0026gt;  2. 형 변환 입력  input 함수는 기본 타입은 string 이다. string 외의 원하는 형태가 있다면 반드시 형 변환을 해야 한다.  \u0026gt; first_number = int(input(\u0026#34;Enter number1 : \u0026#34;)) Enter number1 : 20 \u0026gt; second_number = int(input(\u0026#34;Enter number2 : \u0026#34;)) Enter number2 : 15 \u0026gt; total = first_number + second_number \u0026gt; print(\u0026#34;fist_number + second_number : \u0026#34;, total) fist_number + second_number : 35 \u0026gt; float_number = float(input(\u0026#34;Enter a float number : \u0026#34;)) Enter a float number : 15 \u0026gt; print(\u0026#34;input float : \u0026#34;, float_number) input float : 15 \u0026gt; print(\u0026#34;input type : \u0026#34;, type(float_number)) \u0026lt;class \u0026#39;float\u0026#39;\u0026gt;  ","permalink":"http://jeha00.github.io/post/python_basic/python_basic_13/","summary":"input을 통한 사용자 입력과 형 변환(type conversion) 입력을 알아본다.","title":"[TIL] Python basic 13: input"},{"content":"1. 함수 중요성  첫 번째 , 코드의 흐름을 원활히 할 수 있다.  요즘은 코드의 복잡도가 커지면서 코드 양이 매우 많아졌다. 그래서 이 코드를 일괄작성하기가 힘들다. 이에 대한 대책으로 단계별로 생각하여 각 단계마다 함수를 사용하여 개발을 원활하게 풀어갈 수 있다.   두 번째, 함수로 사용하면 코드의 재사용성이 향상된다.  하나의 기능을 각 소스마다 중복하여 집어 넣으면, 그 기능을 수정해야할 경우, 다 수정해야하는 번거로움이 있다. 이런 것들이 비효율적이기 때문에, 함수로 만들면 한 번의 수정으로 다 수정할 수 있다.   세 번째, 코드의 안정성이 좋아진다.  그 이유는 개발자가 자신이 담당하는 함수에만 집중할 수 있기 때문에, 함수 이외의 부분과 나눠서 생각할 수 있다.     2. 함수 선언 및 사용   함수에서 return 사용하지 않으면\n print로 출력할 수 없다. unpacking을 사용할 수 없다.    여러 값을 return 으로 반환하는 것을 다중 반환이라 한다.\n  ## return 명령어가 없을 경우 \u0026gt; def func_mul(x): \u0026gt; y1 = x * 10 \u0026gt; x1 = func_mul(10) \u0026gt; print(x1, type(x1)) None \u0026lt;class \u0026#39;NoneType\u0026#39;\u0026gt; # 출력할 수 없다. ## return 명령어가 있을 경우 \u0026gt; def func_mul(x): \u0026gt; y1 = x * 10 \u0026gt; return y1 \u0026gt; x1 = func_mul(10) \u0026gt; print(x1) 100 ## No return and unpacking \u0026gt; def func_mul1(x): \u0026gt; y1 = x * 10 \u0026gt; y2 = x * 20 \u0026gt; y3 = x * 30 # unpacking \u0026gt; x1, x2, x3 = func_mul1(10) \u0026gt; print(x1, x2, x3) TypeError: cannot unpack non-iterable NoneType object # 다중 반환 확인하기 \u0026gt; def func_mul1(x): \u0026gt; y1 = x * 10 \u0026gt; y2 = x * 20 \u0026gt; y3 = x * 30 \u0026gt; return y1, y2, y3 # unpacking \u0026gt; x1, x2, x3 = func_mul1(10) \u0026gt; print(x1, x2, x3) 100 200 300  원하는 data type으로 함수값을 출력하려면 어떻게 해야하는지 알아보자. return 할 data의 type이 출력할 data type이 된다.  ## tuple return \u0026gt; def func_mul1(x): \u0026gt; y1 = x * 10 \u0026gt; y2 = x * 20 \u0026gt; y3 = x * 30 \u0026gt; return (y1, y2, y3) # tuple 형식 \u0026gt; t1 = func_mul1(10) \u0026gt; print(t1, type(t1)) (100, 200, 300) \u0026lt;class \u0026#39;tuple\u0026#39;\u0026gt; ## list return \u0026gt; def func_mul2(x): \u0026gt; y1 = x * 10 \u0026gt; y2 = x * 20 \u0026gt; y3 = x * 30 \u0026gt; return [y1, y2, y3] # list 형식 \u0026gt; t1 = func_mul2(10) \u0026gt; print(t1, type(t1)) [100, 200, 300] \u0026lt;class \u0026#39;list\u0026#39;\u0026gt; ## dictionary return \u0026gt; def func_mul3(x): \u0026gt; y1 = x * 10 \u0026gt; y2 = x * 20 \u0026gt; y3 = x * 30 \u0026gt; return {\u0026#39;v1\u0026#39; : y1, \u0026#39;v2\u0026#39; : y2, \u0026#39;v3\u0026#39; : y3} # keyword 형식 \u0026gt; t1 = func_mul3(10) \u0026gt; print(t1, type(t1)) \u0026gt; print(t1.values()) {\u0026#39;v1\u0026#39;: 100, \u0026#39;v2\u0026#39;: 200, \u0026#39;v3\u0026#39;: 300} \u0026lt;class \u0026#39;dict\u0026#39;\u0026gt; dict_values([100, 200, 300]) \u0026gt; d = func_mul3(30) \u0026gt; print(type(d), d, d.get(\u0026#39;v2\u0026#39;), d.items(), d.keys()) \u0026lt;class \u0026#39;dict\u0026#39;\u0026gt; {\u0026#39;v1\u0026#39;: 300, \u0026#39;v2\u0026#39;: 600, \u0026#39;v3\u0026#39;: 900} 600 dict_items([(\u0026#39;v1\u0026#39;, 300), (\u0026#39;v2\u0026#39;, 600), (\u0026#39;v3\u0026#39;, 900)]) dict_keys([\u0026#39;v1\u0026#39;, \u0026#39;v2\u0026#39;, \u0026#39;v3\u0026#39;])  3. Packing, Unpacking 3.1 Positional argument, Keyword argument  함수 인자에는 Positional argument(위치인자)와 Keyword argument(키워드 인자)가 있다.  인자란 함수 기능에 필요한 값을 말한다. 기본값이 있다.  기본값이란 미리 기본으로 지정된 값을 말한다.   Positional argument는 인자값이 위치에 의해 결정되는 인자다.  순서가 중요하다.   Keyword argument는 key value가 key에 의해 결정되는 인자다.  순서 상관 없이 keyword가 중요하다.      # Positional argument(위치인자) # real number (실수)는 앞에, imaginary number(허수)는 뒤에 위치해야 된다. # 위치 즉, 순서가 중요하다. \u0026gt; complex(3, 5) (3 + 5j) # Keyword argument(키워드 인자) # key = value \u0026gt; complex (real = 3, imag = 5) (3 + 5j) 3.2 Packing  print 함수는 객체의 갯수에 제한 없이 출력한다.  # 1개 \u0026gt; print(\u0026#39;123 456 789\u0026#39;) 123 456 789 # 3개 \u0026gt; print(\u0026#39;123, \u0026#39;456, \u0026#39;789\u0026#39;) 123 456 789  print 함수처럼 함수가 받을 인자의 갯수를 유연하게 지정하기 위해 Python은 packing을 지원한다. packing 은  arguments를 하나의 객체로 합쳐서 받을 수 있도록 한다. positional argument packing 과 keyword argument packing이 있다.   positional argument packing은  * 한 개를 매개변수 앞에 붙여서 사용한다. 이 때는 tuple type 으로 하나의 객체가 된다.   keyword argument packing은  * 두 개 즉, **를 매개변수 앞에 붙여서 사용한다. keyword와 value로 구성된 dictionary type으로 하나의 객체가 된다.     positional argument packing을 사용하는 방법  parameter를 입력할 때, 입력되는 수만큼 (x, y, z, a, b)로 입력할 수 있다. 하지만, *args를 사용하여 하나의 객체로서 packing 하여 간단히 관리할 수 있다. args는 매개변수 명으로, 자유롭게 명명한다.     positional argument에 대해 앞서서 enumerate () 에 대해 알아보겠다.  # enumerate() # enumerate는 index 와 value 를 `tuple` 형식으로 하나의 성분으로서 맺어주고, return 해주는 함수다. \u0026gt; seasons = [\u0026#39;Spring\u0026#39;, \u0026#39;Summber\u0026#39;, \u0026#39;Fall\u0026#39;, \u0026#39;Winter\u0026#39;] # enumerate()를 하면 바로 id 값만 출력된다. \u0026gt; print(enumerate(seasons)) \u0026lt;enumerate object at 0x000002957E6DE640\u0026gt; \u0026gt; print(list(enumerate(seasons))) [(0, \u0026#39;Spring\u0026#39;), (1, \u0026#39;Summber\u0026#39;), (2, \u0026#39;Fall\u0026#39;), (3, \u0026#39;Winter\u0026#39;)] \u0026gt; print(tuple(enumerate(seasons))) ((0, \u0026#39;Spring\u0026#39;), (1, \u0026#39;Summber\u0026#39;), (2, \u0026#39;Fall\u0026#39;), (3, \u0026#39;Winter\u0026#39;))  enumerate () 를 사용하여 positional arguments packing을 설명하겠다. enumerate ()를 for ~ in문에 사용하겠다.  # args == arguments \u0026gt; def args_func(*args): \u0026gt; for i, v in enumerate(args): \u0026gt; print(\u0026#39;Result : {}\u0026#39;.format(i), v) # 인자의 수가 다양해도 다 받아지는 걸 알 수 있다. \u0026gt; args_func(\u0026#39;Lee\u0026#39;) Result : 0 Lee # 위치인자로 보낸 모든 객체들(\u0026#39;Lee\u0026#39;, \u0026#39;Park\u0026#39;)을 *args로 하나의 객체로서 관리해준다. \u0026gt; args_func(\u0026#39;Lee\u0026#39;, \u0026#39;Park\u0026#39;) Result : 0 Lee Result : 1 Park \u0026gt; args_func(\u0026#39;Lee\u0026#39;, \u0026#39;Park\u0026#39;, \u0026#39;Kim\u0026#39;) Result : 0 Lee Result : 1 Park Result : 2 Kim  keyword argument packing을 사용하는 방법  \u0026gt; def kwargs_func(**kwargs): \u0026gt; for v in kwargs.keys(): \u0026gt; print(\u0026#34;{}\u0026#34;.format(v), kwargs[v]) # keyword arguments를 packing 하여 dictionary로 관리한다. \u0026gt; kwargs_func(name1=\u0026#39;Apple\u0026#39;) name1 Apple \u0026gt; kwargs_func(name1=\u0026#39;Apple\u0026#39;, name2=\u0026#39;Window\u0026#39;) name1 Apple name2 Window \u0026gt; kwargs_func(name1=\u0026#39;Apple\u0026#39;, name2=\u0026#39;Window\u0026#39;, name3=\u0026#39;Choice\u0026#39;) name1 Apple name2 Window name3 Choice  positional argument 와 keyword argument를 같이 사용해보자.  \u0026gt; def example(args_1, args_2, *args, **kwargs): \u0026gt; print(args_1, args_2, args, kwargs) \u0026gt; example(10, 20, \u0026#39;Lee\u0026#39;, \u0026#39;Kim\u0026#39;, \u0026#39;Park\u0026#39;, \u0026#39;Cho\u0026#39;, age1=20, age2=30, age3=40) 10 20 (\u0026#39;Lee\u0026#39;, \u0026#39;Kim\u0026#39;, \u0026#39;Park\u0026#39;, \u0026#39;Cho\u0026#39;) {\u0026#39;age1\u0026#39;: 20, \u0026#39;age2\u0026#39;: 30, \u0026#39;age3\u0026#39;: 40} # args_1, args_2 로 총 2개이므로, print의 매개변수 앞에서 2개까지가 일반적인 positional argument이다. # 그 뒤에, *args 는 positional argument packing이므로 제한 없다. tuple 로 출력된 걸 확인할 수 있다. # 맨 마지막 인자는 ** 이므로, keyword argument packing이다. dictionary로 출력된 걸 확인할 수 있다. 3.3 Unpacking  Unpacking은 packing과는 반대로 여러개의 객체를 포함하고 있는 하나의 객체를 푼다. Unpacking 시 해체되는 인자의 수와 매칭되는 변수의 수가 동일해야 가능하다. packing 시에는 매개변수에 *을 붙였지만, unpacking 시에는 argument 앞에 *를 붙여서 사용한다.  \u0026gt; def sum(a, b, c): \u0026gt; return a + b + c \u0026gt; number = (1, 2, 3) \u0026gt; print(sum(*number)) 6  또는 다음과 같은 방식으로 unpacking 할 수 있다.  \u0026gt; def func_mul1(x): \u0026gt; y1 = x * 10 \u0026gt; y2 = x * 20 \u0026gt; y3 = x * 30 \u0026gt; return y1, y2, y3 # unpacking \u0026gt; x1, x2, x3 = func_mul1(10)  4. 중첩 함수 (Nested function)  중첩 함수란 함수 내부에 정의된 또 다른 함수 중첩 함수는 함수형 프로그래밍에서 많이 사용된다. 호출하는 함수는 부모 함수 이다. 부모 함수의 하위 함수를 호출할 수 없고,부모 함수의 매개변수를 받아서 사용한다.  # 중첩 함수 \u0026gt; def nested_func(num): # 부모 함수 \u0026gt; def func_in_func(num): # 부모 함수의 매개변수를 받아서 사용 가능 \u0026gt; print(num) \u0026gt; print(\u0026#34;In func\u0026#34;) \u0026gt; func_in_func(num + 100) \u0026gt; nested_func(100) 200 # 부모 함수의 하위 함수를 호출하여 사용할 수 없다. \u0026gt; func_in_func(100) NameError: name \u0026#39;func_in_func\u0026#39; is not defined  5. 람다(lambda) 함수 (익명함수)   람다식의 장점 from python 공식 사이트\n 메모리 절약 가독성 향상 코드 간결    람다식의 단점 (많은 실력자 분들이 람다식을 부정적으로 피력한다.)\n 과한 사용 시, 가독성 감소된다. 왜냐하면 익명 함수이기 때문이다. (빈번히 언급됨) (일반적인 함수는 함수명을 보고 그 기능을 추측할 수 있다.)    일반적인 함수와 람다식 함수의 차이\n  일반적인 함수는 함수명이 있기 때문에, 객체 생성 된다.\n  그 후, resource(memory)를 할당한다.\n  하지만, 람다식 함수는\n 즉시 실행 함수 라서, 일회성이고, Heap 영역에 저장되고 (Heap 초기화), 파이썬의 garbage collection에 의해 메모리 초기화를 한다. 초기화로 메모리를 효율적으로 사용할 수 있다. 함수명이 존재하지 않아, 익명 함수라 한다. 그래서 별도의 변수에 할당해야 한다.    \u0026gt; def mul_func(x, y): \u0026gt; return x * y \u0026gt; print(mul_func(10, 50)) 500 # 첫 번째: 이미 변수에 할당해 놓은 일반적인 함수를 넣는 방법 \u0026gt; mul_func_var = mul_func \u0026gt; print(mul_func_var(10, 50)) 500 # 두 번째: 자주 쓰는 람다 함수이기 때문에, 정의를 해서 변수로 넘기는 방식 # 일시적으로 그 자리에서 함수가 필요할 때 사용한다. # def 와 return이 없어도 가능하다. # 람다식을 넣은 함수 \u0026gt; lambda_mul_func = lambda x,y : x * y \u0026gt; print(lambda_mul_func(10, 50)) 500 # 함수 안에서 함수를 인자로 받는 함수 \u0026gt; def func_final(x, y, func): \u0026gt; print(x * y * func(1,1)) # 첫 번째 방식 \u0026gt; func_final(10, 50, mul_func_var) 500 # 두 번째 방식 \u0026gt; func_final(10, 50, lambda_mul_func) 500 # 세 번째 방식: 바로 그 자리에서 람다식을 써서 넘기는 방법 \u0026gt; func_final(10, 50, lambda x,y : x * y)  위 방식대로 총 함수를 정의하는데 3가지 방식이 있다. 각 방식에 대해서 언제 무엇을 써야할지 생각해보자.   6. 함수 Type Hint: Annotation  함수의 매개변수와 함수의 결과값의 데이터 타입을 알려주기 위해 python 3.5 부터 나온 기능이다. def \u0026lt;function-name\u0026gt;(parameter1: \u0026lt;data type\u0026gt;) -\u0026gt; \u0026lt;함수 결과값의 data type\u0026gt;  # 아래 예시처럼 각 매개변수의 데이터 타입이 무엇인지 알려준다. # 그리고, 함수의 결과값의 데이터 타입도 알려준다. \u0026gt; def tot_length1(word: str, num: int) -\u0026gt; int: \u0026gt; return len(word) * num # 아래 함수는 위 함수와 동일하다. \u0026gt; def tot_length1(word, num): \u0026gt; return len(word) * num \u0026gt; print(\u0026#39;hint exam1 : \u0026#39;, tot_length1(\u0026#34;i love you\u0026#34;, 10)) \u0026gt; print(type(tot_length1(\u0026#34;i love you\u0026#34;, 10))) hint exam1 : 100 \u0026lt;class \u0026#39;int\u0026#39;\u0026gt; \u0026gt; def tot_length2(word: str, num: int) -\u0026gt; None: \u0026gt; print(\u0026#39;hint exam2 : \u0026#39;, len(word) * num) \u0026gt; print(tot_length2(\u0026#34;niceman\u0026#34;, 10)) \u0026gt; print(type(tot_length2(\u0026#34;i love you\u0026#34;, 10))) hint exam2 : 70 \u0026lt;class \u0026#39;Nonetype\u0026#39;\u0026gt;  tot_length2의 data type이 Nonetype인 이유는 return 값이 없기 때문이다.   Reference  Positional argument, Keyword argument Packing, Unpacking enumerate lambda function  ","permalink":"http://jeha00.github.io/post/python_basic/python_basic_12/","summary":"함수의 중요성 및 선언, Packing \u0026amp; Unpacking, 중첩 함수(Nested function), 람바 함사(익명 함수), 함수 Type hint 에 대해 알아본다.","title":"[TIL] Python basic 12: Method"},{"content":"Intro  for, if, while 문을 흐름 제어문 이라 한다. for문은 원하는 \u0026lt;collection\u0026gt;의 갯수만큼 반복한다면, while 문은 if처럼 조건을 만족할 때까지 계속 반복한다. While문은 if문처럼 조건이 들어간다. 그런데, 무한 반복될 수도 있기 때문에, 조건의 변화가 필요하다. 아니면 break 를 사용한다. 조건을 만족하면 while문을 빠져나온다. python 공식 사이트에서 while 의 구조는 다음과 같다. [expr]은 expression을 의미한다.  \u0026gt; while [expr]: \u0026gt; [statement(s)] 1. While 기본 사용법  whlie 문은 무한 반복문이 되지 않도록, 조건의 변화를 일으키는 코드를 넣어야 한다. 그래서 while문의 경우, 눈으로 중간 결과를 디버깅해서 무한 반복문인지 확인한다.  # 예제 1 \u0026gt; m = 3 \u0026gt; while m \u0026gt; 0: \u0026gt; print(m) # 여기까지 쓰면 계속해서 m \u0026gt; 0 이므로 `무한 반복문`이 된다. \u0026gt; m -= 1 3 2 1 # 예제 2 \u0026gt; z = [\u0026#39;foo\u0026#39;, \u0026#39;bar\u0026#39;, \u0026#39;baz\u0026#39;] \u0026gt; whlie z: # z 변수 안에 데이터가 존재하므로 True 상태이기 때문에 무한 반복문이다. # 위험한 코드이므로, 조건의 변화를 일으켜 무한 반복문을 방지한다. \u0026gt; print(a.pop()) # pop으로 성분의 갯수가 0이 되면 False가 되므로 중단된다.  2. Break, continue  조건의 변화를 일으키면서, 원하는 조건에서 중단하거나, 조건 판단문으로 되돌아가기 위해서 break와 continue를 사용한다. break 문과 continue문은 while문과 자주 사용된다. 중간에 if조건문이 껴져 있는 방식이 많다.  # 예제 3 \u0026gt; m = 5 \u0026gt; while m \u0026gt; 0: \u0026gt; m -= 1 \u0026gt; if m == 2: \u0026gt; break \u0026gt; print(m) \u0026gt; print(\u0026#39;Loop Ended\u0026#39;) 4 3 Loop Ended # 예제 4 \u0026gt; m = 5 \u0026gt; while m \u0026gt; 0: \u0026gt; m -= 1 \u0026gt; if m == 2: # 위에서 break를 continue로 바꿨다. \u0026gt; continue \u0026gt; print(m) \u0026gt; print(\u0026#39;Loop Ended\u0026#39;) 4 3 1 0 Loop Ended # 예제 5 \u0026gt; i = 1 \u0026gt; while i \u0026lt;= 10: \u0026gt; print(\u0026#39;i : \u0026#39;, i) \u0026gt; if i ==6: \u0026gt; break \u0026gt; i += 1 i : 1 i : 2 i : 3 i : 4 i : 5 i : 6  3. While ~ else 구문 # 예제 6 \u0026gt; n = 5 \u0026gt; while n \u0026gt; 0: \u0026gt; print(n) \u0026gt; n -= 1 \u0026gt; if n == 3: \u0026gt; break \u0026gt; else: \u0026gt; print(\u0026#39;else out.\u0026#39;) 5 4 # 예제 7 \u0026gt; g = [\u0026#39;red\u0026#39;, \u0026#39;blue\u0026#39;, \u0026#39;white\u0026#39;, \u0026#39;black\u0026#39;] \u0026gt; c = \u0026#39;black\u0026#39; \u0026gt; i = 0 \u0026gt; while i \u0026lt; len(g): \u0026gt; if g[i] == c: \u0026gt; print(\u0026#39;find {}\u0026#39;.format(c)) \u0026gt; break \u0026gt; i += 1 \u0026gt; else: \u0026gt; print(\u0026#39;not found in lise.\u0026#39;) find black  4. 무한 반복 구문  무한정 반복되는 구문을 말한다. 이 구문이 실행되면 다운되므로, break와 continue로 방지한다. 무한 반복문의 한 예가 다음과 같다.  \u0026gt; while True: \u0026gt; print(\u0026#39;Foo\u0026#39;)  무한 반복문을 방지하기 위해 다음과 같이 수정한다.  \u0026gt; a = [\u0026#39;foo\u0026#39;, \u0026#39;bar\u0026#39;, \u0026#39;baz\u0026#39;] \u0026gt; while True: \u0026gt; if not a: \u0026gt; break \u0026gt; print(a.pop()) baz bar foo  a의 원소가 존재하지 않으므로 if not a가 참이 되어 break가 실행된다.  ","permalink":"http://jeha00.github.io/post/python_basic/python_basic_11/","summary":"While 반복문의 기본 사용법, break \u0026amp; continue 문, While ~ else 구문, 무한 반복 구문에 대해 알아본다.","title":"[TIL] Python basic 11: 흐름 제어문 (while 반복문)"},{"content":"Intro  코딩의 핵심 파이썬의 for 문은 다른 for 문과 달리 독자적인 특징이 있다. if else 처럼 for else도 가능하나, 자주 사용하지 않는다. for 문은 코딩에서 중요하다. 파이썬 공식 사이트에서는 다음과 같은 구조로 설명한다. \u0026lt;collection\u0026gt; 이란 반복 가능한 객체, iterable object (= interator)를 말한다. 그러면 어떤 게 iterator 인가?? dir() method를 사용했을 때 __iter__ 을 확인할 수 있으면 iterator다. 예를 들어서 string, list, tuple, dictionary, set을 말한다.  \u0026gt; for i in \u0026lt;collection\u0026gt;: \u0026gt; \u0026lt;loop body\u0026gt; 1. for ~ range pattern: 3가지  첫 번째 패턴  for n in range(j) : 변수 n이 0부터 j가 아닌 (j-1)까지 반복된다.    \u0026gt; for v in range(10): \u0026gt; pritn(\u0026#34;v is : \u0026#34;, v) v is : 0 v is : 1 v is : 2 v is : 3 v is : 4 v is : 5 v is : 6 v is : 7 v is : 8 v is : 9  두 번째 패턴  for n in range(i,j): n이 i부터 (j-1)까지 반복된다.    \u0026gt; for v in range(1, 11): \u0026gt; print(\u0026#34;v is : \u0026#34;, v) v is : 1 v is : 2 v is : 3 v is : 4 v is : 5 v is : 6 v is : 7 v is : 8 v is : 9 v is : 10  세 번째 패턴  for n in range(i,j,k): n이 i부터 k씩 증가하여 (j-1)까지 반복된다.    \u0026gt; for v in range(1, 11, 2): \u0026gt; print(\u0026#34;v is :\u0026#34;, v) v is : 1 v is : 3 v is : 5 v is : 7 v is : 9 \u0026gt; for v in range(1, 11, 3): \u0026gt; print(\u0026#34;v is :\u0026#34;, v) v is : 1 v is : 4 v is : 7 v is : 10  1 ~ 1000까지 합 구하기  # 첫 번째 방법 \u0026gt; sum = 0 \u0026gt; for v in range(1, 1001): \u0026gt; sum += v \u0026gt; print(\u0026#39;1 ~ 1000 Sum : \u0026#39;, sum) 1 ~ 1000 sum : 500500 # 두 번째 방법 \u0026gt; print(\u0026#39;1 ~ 1000 Sum : \u0026#39;, sum(range(1, 1001))) 1 ~ 1000 Sum : 500500 \u0026gt; print(\u0026#39;1 ~ 1000 안에 4의 배수의 합 : \u0026#39;, sum(range(1, 1001, 4))) 1 ~ 1000 안에 4의 배수의 합 : 124750 \u0026gt; print(type(range(1,11))) \u0026lt;class \u0026#39;range\u0026#39;\u0026gt;  2. Iterator 자료형 활용과 Iterable 함수 # iterable 리턴 함수 : range, reversed, enumerate, filter, map, zip (이런 것들 다 for 문에서 사용할 수 있다.) # 예제1 # Iterator: string으로 구성된 list \u0026gt; names = [\u0026#34;Kim\u0026#34;, \u0026#34;Park\u0026#34;, \u0026#34;Cho\u0026#34;, \u0026#34;Lee\u0026#34;, \u0026#34;Choi\u0026#34;, \u0026#34;Yoo\u0026#34;] \u0026gt; for name in names: \u0026gt; print(\u0026#34;You are\u0026#34;, name) You are Kim You are Park You are Cho You are Lee You are Choi You are Yoo # 예제2 # Iterator: interger 로 구성된 list \u0026gt; lotto_numbers = [11, 19, 21, 28, 36, 37] \u0026gt; for number in lotto_numbers: \u0026gt; print(\u0026#34;Current number : \u0026#34;, number) Current number : 11 Current number : 19 Current number : 21 Current number : 28 Current number : 36 Current number : 37 # 예제3 # Iterator : string \u0026gt; word = \u0026#39;Beautiful\u0026#39; \u0026gt; for s in word: \u0026gt; print(\u0026#39;word : \u0026#39;, s) word : B word : e word : a word : u word : t word : i word : f word : u word : l # 예제4 # Iterator: dictionary \u0026gt; my_info = { \u0026gt; \u0026#34;name\u0026#34;: \u0026#34;Lee\u0026#34;, \u0026gt; \u0026#34;Age\u0026#34;: 33, \u0026gt; \u0026#34;City\u0026#34;: \u0026#34;Seoul\u0026#34; \u0026gt; } \u0026gt; for key in my_info: \u0026gt; print(\u0026#34;value :\u0026#34;, my_info[key]) value : Lee value : 33 value: Seoul # 또는 아래 방법으로 value만 순차적으로 출력할 수 있다. \u0026gt; for val in my_info.values(): \u0026gt; print(val) Lee 33 Seoul  Iterable에 사용되는 함수를 사용하여 대문자로 출력해보자. \u0026lt;string iterator\u0026gt;.isupper : 문자가 대문자인지 확인하는 함수 \u0026lt;string iterator\u0026gt;.islower : 문자가 소문자인지 확인하는 함수 \u0026lt;string iterator\u0026gt;.upper : 문자열을 대문자로 변경하는 함수 \u0026lt;string iterator\u0026gt;.lower : 문자열을 소문자로 변경하는 함수  # Iterator : string \u0026gt; name = \u0026#39;FineApplE\u0026#39; # 지난 시간에 배운 중첩 조건문을 의미 \u0026gt; for n in name: \u0026gt; if n.isupper(): \u0026gt; print(n) \u0026gt; else: \u0026gt; print(n.upper()) F I N E A P P L E  3. break, continue 문  break 문: 가장 가까운 반복문을 강제로 탈출한다.  내가 원하는 특정 조건에서, 멈추기 원할 때 사용된다. 현업에서는 수집하는 데이터량이 매우 많기 때문에, break로 반복문을 조절하는 게 중요하다.   continue 문: break문과 달리 특정 조건이 되면 탈출하는 것이 아니라, continue 문 아래의 코드가 실행되지 않고, 조건을 판단하는 곳으로 점프한다.  많은 데이터 중에 내가 보기 싫은 또는 불필요하게 출력되거나 계산되지 말아야 하는 것이 list에 있을 때, 스킵할 수 있다.    # break \u0026gt; numbers = [14, 3, 4, 7, 10, 24, 17, 2, 33, 15, 34, 36, 38] \u0026gt; for num in numbers: \u0026gt; if num == 34: \u0026gt; print(\u0026#34;Found : 34!\u0026#34;) \u0026gt; break \u0026gt; else: \u0026gt; print(\u0026#34;Not found : \u0026#34;, num) Not found : 14 Not found : 3 Not found : 4 Not found : 7 Not found : 10 Not found : 24 Not found : 17 Not found : 2 Not found : 33 Not found : 15 Found : 34! # continue \u0026gt; lt = [2, 5, True, 4.3, complex(4)] \u0026gt; for v in lt: \u0026gt; if type(v) is bool: \u0026gt; continue \u0026gt; print(\u0026#34;current type : \u0026#34;, type(v)) \u0026gt; print(\u0026#34;multiply by 2:\u0026#34;, v * 2) \u0026gt; print(True * 3) current type : \u0026lt;class \u0026#39;int\u0026#39;\u0026gt; multiply by 2: 4 3 current type : \u0026lt;class \u0026#39;int\u0026#39;\u0026gt; multiply by 2: 10 3 current type : \u0026lt;class \u0026#39;float\u0026#39;\u0026gt; multiply by 2: 8.6 3 current type : \u0026lt;class \u0026#39;complex\u0026#39;\u0026gt; multiply by 2: (8+0j) 3 # true가 1이기 때문에 3이 나온다. 5. for ~ else 구문  for ~ else 구문: python에만 있는 for-else 구문으로, 자주 사용하지는 않지만, 알고 있자.  \u0026gt; numbers = [14, 3, 4, 7, 10, 24, 17, 2, 33, 15, 34, 36, 38] \u0026gt; for num in numbers: \u0026gt; if num == 34: \u0026gt; print(\u0026#34;Found : 34!\u0026#34;) \u0026gt; break \u0026gt; else: \u0026gt; print(\u0026#34;Not Found 45...\u0026#34;) ","permalink":"http://jeha00.github.io/post/python_basic/python_basic_10/","summary":"for ~ range의 3가지 pattern, for문에 interable 자료형 활용하기, break 문과 continue 문 사용하기, for ~ else 구문에 대해 알아본다.","title":"[TIL] Python basic 10: 흐름 제어문 (for 반복문)"},{"content":"1. 조건문 기본 형식  콜론(:)으로 끝나는 부분을 헤더(Header)라고 한다. 헤더의 마지막 콜론은 바로 뒤에 스위트가 이어진다. 스위트는 헤더와 한 세트로 따라다니는 실행문을 의미한다. if - elif - else  if 식: 스위트 =\u0026gt; if 문으로, 반드시 1개 필요하다.\nelif 식: 스위트 =\u0026gt; elif 문으로, 없어도 되며 있으면 n개 가능 (여러개 가능)\nelse 식: 스위트 =\u0026gt; else 문으로, 없어도 되며 있으면 1개만 가능\n    반드시 True 여야 제어문이 실행된다.  \u0026gt; print(type(True)) \u0026gt; print(type(False)) \u0026lt;class \u0026#39;bool\u0026#39;\u0026gt; \u0026gt; if True: \u0026gt; print(\u0026#34;Good\u0026#34;) Good \u0026gt; if False: \u0026gt; print(\u0026#34;Bad\u0026#34;) 실행 X  2. 연산자  연산자에는 지난 번에 봤던 산술 연산자 그리고, 관계 연산자, 논리 연산자가 있다. 관계 연산자에는 \u0026gt;, \u0026gt;=, \u0026lt;, \u0026lt;=, ==, != 가 있다.  \u0026gt; x = 15 \u0026gt; y = 10 # == 양 변이 같을 때 참 \u0026gt; print(x == y) False # != 양변이 다를 때 참 \u0026gt; print(x != y) True # \u0026gt; 왼쪽이 클 때 참 \u0026gt; print(x \u0026gt; y) True # \u0026gt;= 왼쪽이 크거나 같을 때 참 \u0026gt; print(x \u0026gt;= y) True # \u0026lt; 오른쪽이 클 때 참 \u0026gt; print(x \u0026lt; y) False # \u0026lt;= 오른쪽이 크거나 같을 때 참 \u0026gt; print(x \u0026lt;= y) False  논리 연산자에는 and, or, not이 있다.  \u0026gt; a = 75 \u0026gt; b = 40 \u0026gt; c = 10 \u0026gt; print(\u0026#39;and : \u0026#39;, a \u0026gt; b and b \u0026gt; c) and : True \u0026gt; print(\u0026#39;or : \u0026#39;, a \u0026gt; b or b \u0026gt; c) or : True \u0026gt; print(\u0026#39;not : \u0026#39;, not a \u0026gt; b) not : False \u0026gt; print(\u0026#39;not : \u0026#39;, not b \u0026gt; c) not : False  산술, 관계, 논리 우선순위  산술 \u0026gt; 관계 \u0026gt; 논리 순서로 적용한다.    \u0026gt; print(\u0026#39;e1 : \u0026#39;, 3 + 12 \u0026gt; 7 + 3) e1 : True \u0026gt; print(\u0026#39;e2 : \u0026#39;, 5 + 10 * 3 \u0026gt; 7 + 3 * 20) e2 : False \u0026gt; print(\u0026#39;e3 : \u0026#39;, 5 + 10 \u0026gt; 3 and 7 + 3 == 10) e3 : True \u0026gt; print(\u0026#39;e4 : \u0026#39;, 5 + 10 \u0026gt; 0 and not 7 + 3 == 10) e4 : False  3. 참거짓 판별 종류  참 : \u0026ldquo;values\u0026rdquo;, [values], (values), {values}, 1 거짓 : \u0026ldquo;\u0026rdquo;, [], (), {}, 0, None  # city가 공란이므로 False를 의미한다. # 그래서 else 문을 출력한다. \u0026gt; city = \u0026#34;\u0026#34; \u0026gt; \u0026gt; if city: \u0026gt; print(\u0026#34;You are in:\u0026#34;, city) \u0026gt; else: \u0026gt; print(\u0026#34;Please enter your city\u0026#34;) Please enter your city # city에 값이 value가 있으므로 True를 의미한다. # 그래서 if 문을 출력한다. \u0026gt; city = \u0026#34;Seoul\u0026#34; \u0026gt; \u0026gt; if city: \u0026gt; print(\u0026#34;You are in:\u0026#34;, city) \u0026gt; else: \u0026gt; print(\u0026#34;Please enter your city\u0026#34;) You are in: Seoul  4. 다중 조건문, 중첩 조건문, in \u0026amp; not in 4.1 다중 조건문  동일한 syntax의 조건문이 여러 개일 조건문을 다중 조건문이라 한다.  \u0026gt; nume = 90 \u0026gt; if num \u0026gt;= 90: \u0026gt; print(\u0026#39;Grade : A\u0026#39;) \u0026gt; elif num \u0026gt;= 80: \u0026gt; print(\u0026#39;Grade : B\u0026#39;) \u0026gt; elif num \u0026gt;= 70: \u0026gt; print(\u0026#39;Grade : C\u0026#39;) \u0026gt; else: \u0026gt; print(\u0026#39;과락\u0026#39;) Grade : A 4.2 중첩 조건문  한 syntax 조건문 하에 여러 개의 조건문을 중첩 조건문이라 한다.  \u0026gt; grade = \u0026#39;A\u0026#39; \u0026gt; total = 80 \u0026gt; if grade == \u0026#39;A\u0026#39;: \u0026gt; if total \u0026gt;= 90: \u0026gt; print(\u0026#34;장학금 100%\u0026#34;) \u0026gt; elif total \u0026gt;= 80: \u0026gt; print(\u0026#34;장학금 80%\u0026#34;) \u0026gt; else: \u0026gt; print(\u0026#34;장학금 70%\u0026#34;) \u0026gt; else: \u0026gt; print(\u0026#34;장학금 50%\u0026#34;) 장학금 80% 4.3 in \u0026amp; not in  A in B : B 안에 A가 있으면 참 A not in B : B 안에 A가 없으면 참  # list \u0026gt; q = [10, 20, 30] # sets \u0026gt; w = {70, 80, 90, 90} # dictionary \u0026gt; e = {\u0026#34;name\u0026#34;: \u0026#39;Lee\u0026#39;, \u0026#34;city\u0026#34;: \u0026#34;Seoul\u0026#34;, \u0026#34;grade\u0026#34;: \u0026#34;A\u0026#34;} # tuple \u0026gt; r = (10, 12, 14) \u0026gt; print(15 in q) False \u0026gt; print(90 in w) True \u0026gt; print(12 not in r) False # key 검색. dictionary를 in 사용하여 검색할 때 default는 keys 다. \u0026gt; print(\u0026#34;name\u0026#34; in e) True # value 검색 \u0026gt; print(\u0026#34;seoul\u0026#34; in e.values()) False  ","permalink":"http://jeha00.github.io/post/python_basic/python_basic_9/","summary":"조건문의 기본 형식, 연산자를 통해서 제어하는 방법, 참거짓을 의미하는 값들, 다중 및 중첩 조건문, in \u0026amp; not in 으로 제어하는 방법을 알아본다.","title":"[TIL] Python basic 9: 흐름 제어문 (if 조건문)"},{"content":"Intro  Sets은 한국어로 집합을 의미한다. 수학의 집합을 생각해보자. sequence X, 중복 X  순서가 없기 때문에, 출력할 때마다 달라진다.   mutable 자료형 =\u0026gt; 수정 O, 삭제 O 집합 자료형 활용에 핵심이다.   1. Sets 선언  dictionary 처럼 sets 도 다양한 선언 방식이 있다. 빈집합, list 형식으로도, 중괄호로도 가능하다.  \u0026gt; a = set() \u0026gt; b = set([1,2,3,4,4]) \u0026gt; c = set([1, 4, 5, 6]) # 서로 다른 자료형을 저장할 수 있다. \u0026gt; d = set([1, 2, \u0026#39;Pen\u0026#39;, \u0026#39;Cap\u0026#39;, \u0026#39;Plate\u0026#39;]) \u0026gt; e = {\u0026#39;foo\u0026#39;, \u0026#39;bar\u0026#39;, \u0026#39;bz\u0026#39;, \u0026#39;foo\u0026#39;, \u0026#39;qux\u0026#39;} # 튜플도, 실수형도 넣을 수 있다. \u0026gt; f = {42, \u0026#39;foo\u0026#39;, (1,2,3), 3.14159} \u0026gt; print(\u0026#39;a\u0026#39;, type(a), a, 2 in a) a \u0026lt;class \u0026#39;set\u0026#39;\u0026gt; set() False # b에 4를 중복으로 입력했지만, 출력은 하나만 나온다. \u0026gt; print(\u0026#39;b\u0026#39;, type(b), b) b \u0026lt;class \u0026#39;set\u0026#39;\u0026gt; {1, 2, 3, 4} \u0026gt; print(\u0026#39;c\u0026#39;, type(c), c) c \u0026lt;class \u0026#39;set\u0026#39;\u0026gt; {1, 4, 5, 6} \u0026gt; print(\u0026#39;d\u0026#39;, type(d), d) d \u0026lt;class \u0026#39;set\u0026#39;\u0026gt; {1, 2, \u0026#39;Pen\u0026#39;, \u0026#39;Cap\u0026#39;, \u0026#39;Plate\u0026#39;} # foo를 중복으로 입력했지만, 출력은 하나만 나온다. \u0026gt; print(\u0026#39;e\u0026#39;, type(e), e) e \u0026lt;class \u0026#39;set\u0026#39;\u0026gt; {\u0026#39;qux\u0026#39;, \u0026#39;bz\u0026#39;, \u0026#39;foo\u0026#39;, \u0026#39;bar\u0026#39;} \u0026gt; print(\u0026#39;f\u0026#39;, type(f), f) f \u0026lt;class \u0026#39;set\u0026#39;\u0026gt; {42, 3.14159, \u0026#39;foo\u0026#39;, (1, 2, 3)}  2. Sets type converison  파이썬의 장점 중 하나: 간단한 형 변환 sets에 중복으로 값을 입력해도, 중복을 허락하지 않기 때문에 type conversion 시에도 중복된 값들은 하나만 있는 걸 확인할 수 있다. tuple로 변환  \u0026gt; t = tuple(b) \u0026gt; print(\u0026#39;t - \u0026#39;, type(t), t) t - \u0026lt;class \u0026#39;tuple\u0026#39;\u0026gt; (1, 2, 3, 4) \u0026gt; print(\u0026#39;t - \u0026#39;, t[0], t[1:3]) t - 1 (2, 3)  list로 변환  \u0026gt; l = list(c) \u0026gt; print(\u0026#39;l - \u0026#39;, type(l), l) l - \u0026lt;class \u0026#39;list\u0026#39;\u0026gt; [1, 4, 5, 6] \u0026gt; print(\u0026#39;l - \u0026#39;, l[0], l[1:3]) l - 1 [4, 5] \u0026gt; le = list(e) \u0026gt; print(\u0026#39;le - \u0026#39;, type(le), le) le - \u0026lt;class \u0026#39;list\u0026#39;\u0026gt; [\u0026#39;bz\u0026#39;, \u0026#39;foo\u0026#39;, \u0026#39;qux\u0026#39;, \u0026#39;bar\u0026#39;] # reversed() 함수와 함께 해보자. \u0026gt; name = \u0026#39;Aceman\u0026#39; # id 값이 나오므로, 뒤집어진 값을 원하면 형 변환을 해야 한다. \u0026gt; print(\u0026#39;Reversed : \u0026#39;, reversed(name)) \u0026gt; print(\u0026#39;List : \u0026#39;, list(reversed(name))) \u0026gt; print(\u0026#39;Tuple : \u0026#39;, tuple(reversed(name))) \u0026gt; print(\u0026#39;Set : \u0026#39;, set(reversed(name))) Reversed : \u0026lt;reversed object at 0x000001F1E690AFA0\u0026gt; List : [\u0026#39;n\u0026#39;, \u0026#39;a\u0026#39;, \u0026#39;m\u0026#39;, \u0026#39;e\u0026#39;, \u0026#39;c\u0026#39;, \u0026#39;A\u0026#39;] Tuple : (\u0026#39;n\u0026#39;, \u0026#39;a\u0026#39;, \u0026#39;m\u0026#39;, \u0026#39;e\u0026#39;, \u0026#39;c\u0026#39;, \u0026#39;A\u0026#39;) Set : {\u0026#39;m\u0026#39;, \u0026#39;a\u0026#39;, \u0026#39;c\u0026#39;, \u0026#39;e\u0026#39;, \u0026#39;n\u0026#39;, \u0026#39;A\u0026#39;} # set은 출력할 떄마다 순서가 달라진다.  또한 len 함수로 길이를 구할 수 있다.  \u0026gt; print(len(a)) 0 \u0026gt; print(len(b)) 4 \u0026gt; print(len(c)) 4 \u0026gt; print(len(d)) 5 \u0026gt; print(len(e)) 4  3. 집합 자료형 함수: Sets 함수 \u0026gt; s1 = set([1, 2, 3, 4, 5, 6]) \u0026gt; s2 = set([4, 5, 6, 7, 8, 9]) # 교집합 \u0026gt; print(\u0026#39;l - \u0026#39;, s1 \u0026amp; s2) \u0026gt; print(\u0026#39;l - \u0026#39;, s1.intersection(s2)) l - {4, 5, 6} # 합집합 \u0026gt; print(\u0026#39;l - \u0026#39;, s1 | s2) \u0026gt; print(\u0026#39;l - \u0026#39;, s1.union(s2)) l - {1, 2, 3, 4, 5, 6, 7, 8, 9} # 차집합 \u0026gt; print(\u0026#39;l - \u0026#39;, s1 - s2) \u0026gt; print(\u0026#39;l - \u0026#39;, s1.difference(s2)) l - {1, 2, 3} \u0026gt; print(\u0026#39;l - \u0026#39;, s2 - s1) \u0026gt; print(\u0026#39;l - \u0026#39;, s2.difference(s1)) l - {8, 9, 7} # 중복 원소 확인 # 겹치는 원소가 없는지에 대해 알려주는 함수 # 겹치는 원소가 없으면 True, 있으면 False 다. \u0026gt; print(s1.isdisjoint(s2)) False # 부분집합 확인 # s1은 s2의 부분 집합인가요?? # 아니면 False, 맞으면 True \u0026gt; print(s1.issubset(s2)) False # 상위 집합 확인 # s1은 s2의 상위 집합인가요? # 아니면 False, 맞으면 True \u0026gt; print(s1.issuperset(s2)) False  4. Sets 수정, 추가, 제거   추가하는 건 .add(추가하려는 원소) 를 사용한다.\n  삭제하는 건 .remove(삭제하려는 원소) 또는 .discard(삭제하려는 원소)를 사용한다.\n 전자는 error가 뜨지만, 후자는 error를 발생시키지 않는다.    모두 제거하는 건 .clear() 함수를 사용한다.\n  \u0026gt; s1 = set([1,2,3,4]) \u0026gt; s1.add(5) \u0026gt; print(sl) {1, 2, 3, 4, 5} \u0026gt; s1.remove(5) \u0026gt; print(sl) {1, 2, 3, 4} \u0026gt; s1.discard(4) \u0026gt; print(sl) {1, 2, 3} \u0026gt; s1.clear() \u0026gt; print(s1) set() ","permalink":"http://jeha00.github.io/post/python_basic/python_basic_8/","summary":"set 선언법, set type conversion, 집합 자료형 활용을 위한 함수, set type의 수정하기를 알아본다.","title":"[TIL] Python basic 8: set"},{"content":"Intro  범용적으로 가장 많이 사용되는 기초 자료형 sequence X key: value로 구성된다. key 중복 X \u0026lt;= key 값으로 index 하기 때문에 key 값은 중복되면 안된다.  key는 숫자, 문자 다 가능하다. key만 존재하면 value는 어떤 자료 형태든 가능하다.   value 중복 O mutable 자료형 =\u0026gt; 수정 O, 삭제 O 중괄호 {} 를 사용한다.   1. dictionary 선언  dictionary 선언에는 매우 다양한 방법이 있다. 이 다양한 방법들의 공통점은 { }, key, value 로 기본적으로 구성된다.  # key와 value 모두 string \u0026gt; a = {\u0026#39;name\u0026#39; : \u0026#39;Kim\u0026#39;, \u0026#39;phone\u0026#39;: \u0026#39;01012345678\u0026#39;, \u0026#39;birth\u0026#39;: \u0026#39;870124\u0026#39;} # key는 integer 자료형, value는 string \u0026gt; b = {0 : \u0026#39;Hello Python!\u0026#39;} # key는 string, value는 list \u0026gt; c = {\u0026#39;arr\u0026#39;: [1, 2, 3, 4]} \u0026gt; d = { \u0026#39;Name\u0026#39; : \u0026#39;Niceman\u0026#39;, \u0026#39;City\u0026#39; : \u0026#39;Seoul\u0026#39;, \u0026#39;Age\u0026#39; : 33, \u0026#39;Grade\u0026#39; : \u0026#39;A\u0026#39;, \u0026#39;Status\u0026#39; : True } # 하나 하나 튜플 형식으로 입력한다. 가독성이 좋지 않은 단점이 있다. # 그래서 개선된 방법이 f 다. \u0026gt; e = dict([ ( \u0026#39;Name\u0026#39;, \u0026#39;Niceman\u0026#39;), (\u0026#39;City\u0026#39;, \u0026#39;Seoul\u0026#39;), (\u0026#39;Age\u0026#39;, \u0026#39;33\u0026#39;), (\u0026#39;Grade\u0026#39;, \u0026#39;A\u0026#39;), (\u0026#39;Status\u0026#39;, True) \u0026gt; ]) # 이 형태로 DB에 저장하거나, 엑셀이 쓰거나, 웹 서비스 형태에 사용된다. # java에서는 map 이라고 한다. # JSON 형태도 이런 방식으로 되어 있다. \u0026gt; f = dict( Name = \u0026#39;Niceman\u0026#39;, City = \u0026#39;Seoul\u0026#39;, Age = \u0026#39;33\u0026#39;, Grade = \u0026#39;A\u0026#39;, Status = True \u0026gt; ) \u0026gt; print(\u0026#39;a - \u0026#39;, type(a),a) a - \u0026lt;class \u0026#39;dict\u0026#39;\u0026gt; {\u0026#39;name\u0026#39;: \u0026#39;Kim\u0026#39;, \u0026#39;phone\u0026#39;: \u0026#39;01012345678\u0026#39;, \u0026#39;birth\u0026#39;: \u0026#39;870124\u0026#39;} \u0026gt; print(\u0026#39;b - \u0026#39;, type(b),b) b - \u0026lt;class \u0026#39;dict\u0026#39;\u0026gt; {0: \u0026#39;Hello Python!\u0026#39;} \u0026gt; print(\u0026#39;c - \u0026#39;, type(c),c) c - \u0026lt;class \u0026#39;dict\u0026#39;\u0026gt; {\u0026#39;arr\u0026#39;: [1, 2, 3, 4]} \u0026gt; print(\u0026#39;d - \u0026#39;, type(d),d) d - \u0026lt;class \u0026#39;dict\u0026#39;\u0026gt; {\u0026#39;Name\u0026#39;: \u0026#39;Niceman\u0026#39;, \u0026#39;City\u0026#39;: \u0026#39;Seoul\u0026#39;, \u0026#39;Age\u0026#39;: 33, \u0026#39;Grade\u0026#39;: \u0026#39;A\u0026#39;, \u0026#39;Status\u0026#39;: True} \u0026gt; print(\u0026#39;e - \u0026#39;, type(e),e) e - \u0026lt;class \u0026#39;dict\u0026#39;\u0026gt; {\u0026#39;Name\u0026#39;: \u0026#39;Niceman\u0026#39;, \u0026#39;City\u0026#39;: \u0026#39;Seoul\u0026#39;, \u0026#39;Age\u0026#39;: \u0026#39;33\u0026#39;, \u0026#39;Grade\u0026#39;: \u0026#39;A\u0026#39;, \u0026#39;Status\u0026#39;: True} \u0026gt; print(\u0026#39;f - \u0026#39;, type(f),f) f - \u0026lt;class \u0026#39;dict\u0026#39;\u0026gt; {\u0026#39;Name\u0026#39;: \u0026#39;Niceman\u0026#39;, \u0026#39;City\u0026#39;: \u0026#39;Seoul\u0026#39;, \u0026#39;Age\u0026#39;: \u0026#39;33\u0026#39;, \u0026#39;Grade\u0026#39;: \u0026#39;A\u0026#39;, \u0026#39;Status\u0026#39;: True}  2. dictionary value 출력과 수정 2.1 dictionary value 출력  value 출력에는 2가지 방법이 있다.  print(a[key]) 로 출력하는 방법 print(a.get(key))로 출력하는 방법     첫 번째 방법은 key에 해당하는 value 값이 존재하지 않으면 error가 발생한다. 두 번째 방법은 key에 해당하는 value 값이 존재하지 않으면 none처리를 한다. error가 발생하면 중단되기 때문에, 실무에서는 두 번째 방법을 많이 사용한다.\n결론: Key에 해당하는 값을 사용할 때는 함수 .get(key) 를 사용하자.  \u0026gt; print(\u0026#39;a - \u0026#39;, a.get(\u0026#39;name1\u0026#39;)) None \u0026gt; print(\u0026#39;a - \u0026#39;, a[\u0026#39;name1\u0026#39;]) # error 발생으로 중단 \u0026gt; print(\u0026#39;b - \u0026#39;, b[0]) \u0026gt; print(\u0026#39;b - \u0026#39;, b.get(0)) Hello Python! \u0026gt; print(\u0026#39;c - \u0026#39;, c[\u0026#39;arr\u0026#39;]) \u0026gt; print(\u0026#39;c - \u0026#39;, c.get(\u0026#39;arr\u0026#39;)) [1, 2, 3, 4] # value 값이 여러 원소를 가지고 있을 경우, index를 사용하여 출력할 수 있다. \u0026gt; print(\u0026#39;c - \u0026#39;, c[\u0026#39;arr\u0026#39;][3]) \u0026gt; print(\u0026#39;c - \u0026#39;, c.get(\u0026#39;arr\u0026#39;)[3]) 4 \u0026gt; print(\u0026#39;d - \u0026#39;, d.get(\u0026#39;Age\u0026#39;)) 33 \u0026gt; print(\u0026#39;e - \u0026#39;, e.get(\u0026#39;Status\u0026#39;)) True \u0026gt; print(\u0026#39;f - \u0026#39;, f.get(\u0026#39;City\u0026#39;)) Seoul 2.2 dictionary 수정  index에 key 값을 입력했을 때, 기존에 있던 key 면 수정이 되고, 없는 key면 추가된다.  # 수정 \u0026gt; b = {0 : \u0026#39;Hello Python!\u0026#39;} \u0026gt; b[0] = \u0026#39;Good backend developer\u0026#39; \u0026gt; print(b) {0: \u0026#39;Good backend developer\u0026#39;} # 추가 \u0026gt; b[2] = \u0026#39;Python Python\u0026#39; \u0026gt; print(b) {0: \u0026#39;Good backend developer\u0026#39;, 2: \u0026#39;Python Python\u0026#39;}  3. dictionary 함수  len : key의 갯수 구하기 .keys(): key 값만 출력 .values(): value 값만 출력 .items(): key, value 다 출력 .pop(): list에서 배운 것과 동일하다. .popitem(): key와 value 중 아무거나 하나를 임의로 도출하여 없앤다. .update(): 다른 리스트를 넣어서, 키가 똑같은 것을 수정할 수 있다. in 연산자를 사용해서 해당하는 키 값이 있는지 알 수 있다.  \u0026gt; a = {\u0026#39;name\u0026#39; : \u0026#39;Kim\u0026#39;, \u0026#39;phone\u0026#39;: \u0026#39;01012345678\u0026#39;, \u0026#39;birth\u0026#39;: \u0026#39;870124\u0026#39;} \u0026gt; d = { \u0026#39;Name\u0026#39; : \u0026#39;Niceman\u0026#39;, \u0026#39;City\u0026#39; : \u0026#39;Seoul\u0026#39;, \u0026#39;Age\u0026#39; : 33, \u0026#39;Grade\u0026#39; : \u0026#39;A\u0026#39;, \u0026#39;Status\u0026#39; : True } # len \u0026gt; print(len(a)) 3 \u0026gt; print(len(d)) 5 # .keys() \u0026gt; print(a.keys()) dict_keys([\u0026#39;name\u0026#39;, \u0026#39;phone\u0026#39;, \u0026#39;birth\u0026#39;]) \u0026gt; print(d.keys()) dict_keys([\u0026#39;Name\u0026#39;, \u0026#39;City\u0026#39;, \u0026#39;Age\u0026#39;, \u0026#39;Grade\u0026#39;, \u0026#39;Status\u0026#39;]) # .values() \u0026gt; print(a.values()) dict_values([\u0026#39;Kim\u0026#39;, \u0026#39;01012345678\u0026#39;, \u0026#39;870124\u0026#39;]) \u0026gt; print(d.values()) dict_values([\u0026#39;Niceman\u0026#39;, \u0026#39;Seoul\u0026#39;, 33, \u0026#39;A\u0026#39;, True]) # .items() \u0026gt; print(a.items()) dict_items([(\u0026#39;name\u0026#39;, \u0026#39;Kim\u0026#39;), (\u0026#39;phone\u0026#39;, \u0026#39;01012345678\u0026#39;), (\u0026#39;birth\u0026#39;, \u0026#39;870124\u0026#39;)]) \u0026gt; print(d.items()) dict_items([(\u0026#39;Name\u0026#39;, \u0026#39;Niceman\u0026#39;), (\u0026#39;City\u0026#39;, \u0026#39;Seoul\u0026#39;), (\u0026#39;Age\u0026#39;, 33), (\u0026#39;Grade\u0026#39;, \u0026#39;A\u0026#39;), (\u0026#39;Status\u0026#39;, True)]) # list 안에 넣으면 key 값들만, value 값들만, item 값들만으로 list를 만든다. \u0026gt; print(list(a.keys()) [\u0026#39;name\u0026#39;, \u0026#39;phone\u0026#39;, \u0026#39;birth\u0026#39;] \u0026gt; print(list(a.values()) [\u0026#39;Kim\u0026#39;, \u0026#39;01012345678\u0026#39;, \u0026#39;870124\u0026#39;] \u0026gt; print(list(a.items()) [(\u0026#39;name\u0026#39;, \u0026#39;Kim\u0026#39;), (\u0026#39;phone\u0026#39;, \u0026#39;01012345678\u0026#39;), (\u0026#39;birth\u0026#39;, \u0026#39;870124\u0026#39;)] # .pop() \u0026gt; print(a.pop(\u0026#39;birth\u0026#39;)) 870124 \u0026gt; print(a) {\u0026#39;name\u0026#39;: \u0026#39;Kim\u0026#39;, \u0026#39;phone\u0026#39;: \u0026#39;01012345678\u0026#39;} \u0026gt; print(d.pop(\u0026#39;Age\u0026#39;)) 33 \u0026gt; print(d) {\u0026#39;Name\u0026#39;: \u0026#39;Niceman\u0026#39;, \u0026#39;City\u0026#39;: \u0026#39;Seoul\u0026#39;, \u0026#39;Grade\u0026#39;: \u0026#39;A\u0026#39;, \u0026#39;Status\u0026#39;: True} # .popitem(): 추첨기에 사용할 수 있다. \u0026gt; print(d.popitem()) (\u0026#39;Status\u0026#39;, True) \u0026gt; print(d) {\u0026#39;Name\u0026#39;: \u0026#39;Niceman\u0026#39;, \u0026#39;City\u0026#39;: \u0026#39;Seoul\u0026#39;, \u0026#39;Grade\u0026#39;: \u0026#39;A\u0026#39;} \u0026gt; print(d.popitem()) (\u0026#39;Grade\u0026#39;, \u0026#39;A\u0026#39;) \u0026gt; print(d) {\u0026#39;Name\u0026#39;: \u0026#39;Niceman\u0026#39;, \u0026#39;City\u0026#39;: \u0026#39;Seoul\u0026#39;, \u0026#39;Grade\u0026#39;: \u0026#39;A\u0026#39;}  in 연산자 사용하여 key 값 존재유무 확인  \u0026gt; a = {\u0026#39;name\u0026#39; : \u0026#39;Kim\u0026#39;, \u0026#39;phone\u0026#39;: \u0026#39;01012345678\u0026#39;, \u0026#39;birth\u0026#39;: \u0026#39;870124\u0026#39;} \u0026gt; print(\u0026#39;name\u0026#39; in a) True \u0026gt; print(\u0026#39;addr\u0026#39; in a) False ","permalink":"http://jeha00.github.io/post/python_basic/python_basic_7/","summary":"dictionary type의 선언, 출력과 수정 그리고, dictionary에 사용되는 함수에 대해 알아본다.","title":"[TIL] Python basic 7: dictionary "},{"content":"Intro  list와 tuple의 차이를 알아야 비교해서 무엇을 쓸 지 결정한다. tuple은 sequence형, immutable이기 때문에  순서가 있다.  하지만, list의 순서는 변할 수 있고, tuple의 순서는 불변이다. tuple의 순서는 한 번 생성되면 변경할 수 없다.   중복이 가능하다. =\u0026gt; list와 동일 수정이 안된다. =\u0026gt; del, remove, slicing, insert 로 값 변경이 안된다. list 와 마찬가지로 다양한 타입이 함께 포함될 수 있다.     1. tuple 선언  list는 대괄호다. tuple은 소괄호 또는 무괄호다. 소괄호는 괄호만 해도 tuple로 인식된다. 무괄호는 최소 원소 하나 이상이어야 하며, 쉼표가 있어야 한다. 소괄호 또한 최소 원소 하나 이상 입력할 때, 쉼표가 있어야 한다.  # tuple 선언 \u0026gt; a = () \u0026gt; b = (1,) \u0026gt; b = 1, \u0026gt; print(type(a)) # 위 방식 다 tuple 선언법이다. \u0026lt;class \u0026#39;tuple\u0026#39;\u0026gt; \u0026gt; c = (11, 12, 13, 14) \u0026gt; d = (100, 1000, \u0026#39;Ace\u0026#39;, \u0026#39;Base\u0026#39;, \u0026#39;Captine\u0026#39;) \u0026gt; e = (100, 1000, (\u0026#39;Ace\u0026#39;, \u0026#39;Base\u0026#39;, \u0026#39;Captine\u0026#39;))  2. tuple indexing, slicing, 연산  tuple에 indexing 사용하기  \u0026gt; c = (11, 12, 13, 14) \u0026gt; d = (100, 1000, \u0026#39;Ace\u0026#39;, \u0026#39;Base\u0026#39;, \u0026#39;Captine\u0026#39;) \u0026gt; e = (100, 1000, (\u0026#39;Ace\u0026#39;, \u0026#39;Base\u0026#39;, \u0026#39;Captine\u0026#39;)) \u0026gt; print(\u0026#39;d - \u0026#39;, type(d), d) d - \u0026lt;class \u0026#39;tuple\u0026#39;\u0026gt;, (100, 1000, \u0026#39;Ace\u0026#39;, \u0026#39;Base\u0026#39;, \u0026#39;Captine\u0026#39;) \u0026gt; print(\u0026#39;d - \u0026#39;, d[1]) d - 1000 \u0026gt; print(\u0026#39;d - \u0026#39;, d[0] + d[1] * 2) d - 2100 \u0026gt; print(\u0026#39;d - \u0026#39;, d[-1]) d - Captine \u0026gt; print(\u0026#39;e - \u0026#39;, e[-1]) e - (\u0026#39;Ace\u0026#39;, \u0026#39;Base\u0026#39;, \u0026#39;Captine\u0026#39;) \u0026gt; print(\u0026#39;e - \u0026#39;, e[-1][1]) e - Base \u0026gt; print(\u0026#39;e - \u0026#39;, list(e[-1][1])) e - [\u0026#39;B\u0026#39;, \u0026#39;a\u0026#39;, \u0026#39;s\u0026#39;, \u0026#39;e\u0026#39;]  tuple에 slicing 사용하기  \u0026gt; print(\u0026#39;d - \u0026#39;, d[0:3]) d - (100, 1000, \u0026#39;Ace\u0026#39;) \u0026gt; print(\u0026#39;d - \u0026#39;, d[2:]) d - (\u0026#39;Ace\u0026#39;, \u0026#39;Base\u0026#39;, \u0026#39;Captine\u0026#39;) \u0026gt; print(\u0026#39;e - \u0026#39;, e[2][1:3]) e - (\u0026#39;Ace\u0026#39;, \u0026#39;Base\u0026#39;)  tuple로 연산하기  \u0026gt; print(\u0026#39;c + d - \u0026#39;, c + d) c + d - (11, 12, 13, 14, 100, 1000, \u0026#39;Ace\u0026#39;, \u0026#39;Base\u0026#39;, \u0026#39;Captine\u0026#39;) \u0026gt; print(\u0026#39;c * 3 - \u0026#39;, c * 3) c * 3 -(11, 12, 13, 14, 11, 12, 13, 14, 11, 12, 13, 14) \u0026gt; print(\u0026#34;\u0026#39;Test\u0026#39; + c[0] - \u0026#34;, \u0026#39;Test\u0026#39; + c[0]) \u0026#39;Test\u0026#39; + c[0] - Test11  3. tuple 함수: index, count  index(): 함수는 원하는 성분 값의 index를 구하는 함수다. count(): 원하는 성분의 수량을 구하는 함수다.  \u0026gt; a = (5, 2, 3, 1, 4) \u0026gt; print(\u0026#39;a - \u0026#39;, a) a - (5, 2, 3, 1, 4) \u0026gt; print(\u0026#39;a - \u0026#39;, a.index(5)) a - 0 \u0026gt; print(\u0026#39;a - \u0026#39;, a.count(4)) a - 1 4. tuple의 중요한 특징: packing \u0026amp; unpacking  packing이란 단어 그대로의 의미로, 하나로 묶는 것을 말한다. unpacking은 하나로 묶여있던 tuple을 풀어서 각각 할당하는 것을 말한다.  # packing \u0026gt; t = (\u0026#39;foo\u0026#39;, \u0026#39;bar\u0026#39;, \u0026#39;baz\u0026#39;, \u0026#39;qux\u0026#39;) #출력 확인 \u0026gt; print(t) (\u0026#39;foo\u0026#39;, \u0026#39;bar\u0026#39;, \u0026#39;baz\u0026#39;, \u0026#39;qux\u0026#39;) \u0026gt; print(t[0]) foo \u0026gt; print(t[-1]) qux # unpacking 1 \u0026gt; (x1, x2, x3, x4) = t # 출력 확인 \u0026gt; print(x1, x2, x3, x4) foo bar baz qux # unpacking 2 \u0026gt; (x1, x2, x3, x4) = (\u0026#39;foo\u0026#39;, \u0026#39;bar\u0026#39;, \u0026#39;baz\u0026#39;, \u0026#39;qux\u0026#39;) \u0026gt; print(x1, x2, x3, x4) foo bar baz qux # unpacking 3 \u0026gt; t2 = 2, 3, 4 \u0026gt; t3 = 4, \u0026gt; x1, x2, x3 = t2 \u0026gt; x4, x5, x6 = 4, 5, 6 # tuple을 출력하는 것이므로 괄호가 존재한다. \u0026gt; print(t2) (2, 3, 4) \u0026gt; print(t3) (4, ) # 각 원소 값을 출력하는 것이므로 괄호가 없다. \u0026gt; print(x1, x2, x3) 2 3 4 \u0026gt; print(x4, x5, x6) 4 5 6 ","permalink":"http://jeha00.github.io/post/python_basic/python_basic_6/","summary":"list와 tuple의 차이. tuple의 indexing, slicing, 연산. 그리고, tuple의 중요한 특징 중 하나인 packing \u0026amp; unpacking에 대해 알아본다.","title":"[TIL] Python basic 6: tuple"},{"content":"Intro   List 자료형은 sequence형이고, mutable이기 때문에\n 순서 존재한다. =\u0026gt; len, index, slicing 이 가능 중복이 가능하다. 수정, 삭제가 가능하다.    다른 언어에서는 배열이라 하는데 알고리즘을 풀기 위해서 굉장히 중요한 자료 형태다.\n   1. List 선언 # 빈 리스트 선언 \u0026gt; a = [] \u0026gt; print(type(a)) \u0026lt;class \u0026#39;list\u0026#39;\u0026gt; \u0026gt; b = list() \u0026gt; print(type(b)) \u0026lt;class \u0026#39;list\u0026#39;\u0026gt; # 값은 동일하지만, id 값이 다르다. \u0026gt; print(id(a), id(b)) # 정수만 list 구성 \u0026gt; c = [70, 75, 80 ,85] # 문자열, 정수, 실수형으로 list 구성 \u0026gt; d = [1000, 1000.5, \u0026#39;Ace\u0026#39;, \u0026#39;Base\u0026#39;, \u0026#39;Captine\u0026#39;] # list 안에 list를 넣을 수 있다. \u0026gt; e = [1000, 1000.5, [\u0026#39;Ace\u0026#39;, \u0026#39;Base\u0026#39;, \u0026#39;Captine\u0026#39;]] \u0026gt; f = [21.42, \u0026#39;foobar\u0026#39;, 3, 4, \u0026#39;bark\u0026#39;, False, 3.14159]  2. List indexing, slicing  list도 string처럼 sequence 형이기 때문에, len, index, slicing을 사용할 수 있다.\n  indexing: 원하는 데이터를 꺼내는 과정  \u0026gt; print(\u0026#39;d - \u0026#39;, type(d), d) d - \u0026lt;class \u0026#39;list\u0026#39;\u0026gt; [1000, 10000.1, \u0026#39;Ace\u0026#39;, \u0026#39;Base\u0026#39;, \u0026#39;Captine\u0026#39;] # index의 시작은 0부터이기 때문 \u0026gt; print(\u0026#39;d - \u0026#39;, d[1]) d - 1000.5 \u0026gt; print(\u0026#39;d - \u0026#39;, d[0] + d[1] + d[1]) d - 3001 \u0026gt; print(\u0026#39;d - \u0026#39;, d[-1]) d - Captine # list의 성분이 list이기 때문에, 성분 list의 [1] 성분을 말한다. \u0026gt; print(\u0026#39;e - \u0026#39;, e[-1][1]) e - Base # 문자열을 문자행 단위로 쪼개서 list로 만든다. \u0026gt; print(\u0026#39;e - \u0026#39;, list(e[-1][1])) e - [\u0026#39;B\u0026#39;, \u0026#39;a\u0026#39;, \u0026#39;s\u0026#39;, \u0026#39;e\u0026#39;]  slicing: 같은 데이터 타입으로, 원하는 부분의 데이터를 뽑아내는 것  \u0026gt; d = [1000, 1000.5, \u0026#39;Ace\u0026#39;, \u0026#39;Base\u0026#39;, \u0026#39;Captine\u0026#39;] \u0026gt; e = [1000, 1000.5, [\u0026#39;Ace\u0026#39;, \u0026#39;Base\u0026#39;, \u0026#39;Captine\u0026#39;]] \u0026gt; print(\u0026#39;d - \u0026#39;, d[0:3]) d - [1000, 1000.5, \u0026#39;Ace\u0026#39;] \u0026gt; print(\u0026#39;d - \u0026#39;, d[2:]) d - [\u0026#39;Ace\u0026#39;, \u0026#39;Base\u0026#39;, \u0026#39;Captine\u0026#39;] \u0026gt; print(\u0026#39;e - \u0026#39;, e[2][1:3]) e - [\u0026#39;Ace\u0026#39;, \u0026#39;Base\u0026#39;] \u0026gt; print(\u0026#39;e - \u0026#39;, e[-1][1:3]) e - [\u0026#39;Ace\u0026#39;, \u0026#39;Base\u0026#39;]  3. List 연산 \u0026gt; c = [70, 75, 80 ,85] \u0026gt; print(\u0026#39;c + d -\u0026#39;, c + d) [70, 75, 80 ,85, 1000, 1000.5, \u0026#39;Ace\u0026#39;, \u0026#39;Base\u0026#39;, \u0026#39;Captine\u0026#39;] \u0026gt; print(\u0026#39;c * 3 -\u0026#39;, c * 3) [70, 75, 80 ,85, 70, 75, 80 ,85, 70, 75, 80 ,85] \u0026gt; print(\u0026#39;Test + c[0] - \u0026#39;, \u0026#39;Test\u0026#39; + str(c[0])) Test + c[0] - Test70 # 값 비교 \u0026gt; print(c == c[:3] + c[3:]) True # 동일한 id 값 \u0026gt; python = c \u0026gt; print (python == c) True # 동일한 id가 출력된다. \u0026gt; print(id(c), id(python))  4. List 함수 a = [5, 3, 4, 7, 8 ] # 끝에 데이터를 삽입할 때 사용 # append가 매달다 라는 의미이므로 \u0026gt; a.append(6) \u0026gt; print(a) [5, 3, 4, 7, 8, 6] # 정렬 \u0026gt; a.sort() \u0026gt; print(a) [3, 4, 5, 7, 8] # 뒤집음 \u0026gt; a.reverse() \u0026gt; print(a) [8, 7, 5, 4, 3] # sort와 reverse는 데이터가 많으면 오랜 시간이 걸린다. # index(x) 는 x 값의 첫 번째 index를 출력한다. \u0026gt; print(\u0026#39;a - \u0026#39;, a.index(3), a[3]) a - 4 4 # insert(추가할 위치, 추가할 값) \u0026gt; a.insert(2,7) \u0026gt; print(a) [8, 7, 7, 5, 4, 3] # count(): 원하는 값의 갯수를 새는 method다. # a list에 7이 2개가 있으므로 출력값 2가 나온다. \u0026gt; print(\u0026#39;a - \u0026#39;, a.count(7)) a - 2 # extend(): 괄호 안에 값을 list에 연장한다. \u0026gt; ad = [2, 1] \u0026gt; a.extend(ad) \u0026gt; print(a) [8, 7, 7, 5, 4, 3, 2, 1] 결론\n a.append(): 끝에 데이터를 삽입한다. 매달은다 a.sort(): 데이터를 정렬한다. a.reverse(): 데이터 방향을 뒤집는다. a.index(): 괄호 값의 첫 번째 index를 알려준다. a.insert(x,y): index x 번째 있는 자리에 y 값을 삽입한다. a.count(): 원하는 값의 갯수를 세는 method a.extend(): 괄호 안의 값을 list에 연장한다.   5. List 수정, 삭제 5.1 slicing과 index를 사용하여 수정, 삭제하는 방법  수정하기  \u0026gt; c = [70, 75, 80 ,85] ## 수정하기 # index 번호로 접근하여 수정 \u0026gt; c[0] = 4 \u0026gt; print(c) [4, 75, 80, 85] # insert 되는 결과 \u0026gt; c[1:2] = [\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;] \u0026gt; print(c) [4, \u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;, 80, 85] # 하지만 slicing이 아닌 index로 명령하면 선언한 value 그대로 원소가 된다. \u0026gt; c[1] = [\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;] \u0026gt; print(c) [70, [\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;], 80, 85] # list 자체가 하나의 원소로 list에 들어갔다. # slicing으로 list를 원소로 넣고 싶으면 다음과 같이 한다. \u0026gt; c[1:2] = [[\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;]] \u0026gt; print(c) [70, [\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;], 80, 85] ## list 안에 list가 들어간 걸 `중첩`이라 한다.  삭제하기  # 빈 값을 선언하는 것이 삭제하는 걸 의미한다. \u0026gt; c = [70, 75, 80 ,85] \u0026gt; c[1:3] = [] \u0026gt; print(c) [70, 85] # c[1], c[2] 원소가 삭제된다. 5.2 함수를 사용하여 삭제하는 방법: remove, pop, del \u0026gt; c = [70, 75, 80 ,85] # remove(삭제할 데이터값) # remove는 삭제할 데이터값을 직접 지정한다. \u0026gt; c.remove(70) \u0026gt; print(c) [75, 80, 85] # pop() : 마지막 원소를 뽑아내고, 나머지로 만든다. \u0026gt; print(\u0026#39;c - \u0026#39;, c.pop()) c - 85 # del은 지울려는 데이터가 몇 번째인지 알아야 한다. # 하지만, list의 데이터는 많아질 경우, 세기가 어렵다. # 그럴 때는 위에 remove를 사용한다. \u0026gt; del c[1] \u0026gt; print(c) 75   pop( )\n stack 자료 구조에서 마지막에 들어온 애가 가장 먼저 나갑니다: last in, first out로 LIFO라 한다.\n예1) 음식을 접시에 담을 때, 마지막에 쌓은 접시를 꺼내서 사용한다. 예2) 웹 브라우저를 뒤로 가기 버튼을 누르면, 마지막 페이지가 먼저 나온다.\n이런 자료 구조에서 많이 사용되는 method가 pop 입니다.\n   Queue 는 stack과 반대로 가장 처음에 들어온 것을 빼는 구조로, first in, first out로 FIFO라 한다.\n   반복문을 활용하여 제거하는 방법도 있다. 따로 break 를 사용하지 않아도, a가 비워지면 끝난다.  \u0026gt; a = [8, 7, 7, 5, 4, 3] \u0026gt; while a: \u0026gt; data = a.pop() \u0026gt; print(data) ","permalink":"http://jeha00.github.io/post/python_basic/python_basic_5/","summary":"list의 생성, indexing, slicing, 연산, list에 쓰이는 함수 그리고, list를 수정하고 삭제하는 방법에 대해 알아보겠다.","title":"[TIL] Python basic 5: list"},{"content":"1. 문자열 생성, 출력 그리고, 길이  문자열 생성하기(선언하기) 및 출력하기  # 문자열 생성 \u0026gt; str1 = \u0026#34;I am Python\u0026#34; \u0026gt; str2 = \u0026#39;Python\u0026#39; # 빈 문자열 생성 \u0026gt; str_t1 = \u0026#39;\u0026#39; \u0026gt; str_t2 = str() # 문자열 출력 \u0026gt; print(str1, type(str1)) I am Python \u0026lt;class \u0026#39;str\u0026#39;\u0026gt; \u0026gt; print(str2, type(str2)) Pyton \u0026lt;class \u0026#39;str\u0026#39;\u0026gt; \u0026gt; print(str_t1, type(str_t1)) \u0026lt;class \u0026#39;str\u0026#39;\u0026gt; \u0026gt; print(str_t2, type(str_t2)) \u0026lt;class \u0026#39;str\u0026#39;\u0026gt;  문자열 길이 측정: **len()**을 많이 사용한다. 길이에는 공백을 포함한다.  \u0026gt; print(len(str1)) 11 \u0026gt; print(len(str2)) 6 결론\n 문자열 선언에는 \u0026ldquo;\u0026rdquo;, \u0026lsquo;\u0026rsquo;, \u0026ldquo;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026rdquo;, '''''' 을 사용한다. 문자열 출력에는 다른 출력과 동일하게 print를 사용한다. 문자열 길이 측정에는 len() 함수를 사용한다. 길이에는 공백을 포함한다.\n  2. Escape, raw string and multi line 2.1 Escape code \\n: 개행(줄바꿈) \\t: 탭키를 누른 만큼 벌어짐 \\\\: 문자 삽입 \\\u0026#39;: 문자 삽입 \\\u0026#34;: 문자 삽입  위에 escape code 예시를 작성해보자.  ## 문자 삽입 escape code \u0026gt; escape_str1 = \u0026#34;do you have a \\\u0026#34;retro games\\\u0026#34;?\u0026#34; \u0026gt; print(escape_str1) do you have a \u0026#34;retro games?\u0026#34; # 홀따옴표 사용 \u0026gt; escape_str2 = \u0026#39;What\\\u0026#39;s on TV??\u0026#39; # 쌍따옴표 사용 \u0026gt; escape_Str3 = \u0026#34;what\u0026#39;s one TV??\u0026#34; \u0026gt; print(escape_str2) \u0026gt; print(escape_str3) What\u0026#39;s on TV?? ## 개행, 탭 # tab 누른 만큼 떨어져서 출력 \u0026gt; t_s1 = \u0026#34;Click \\t Start!\u0026#34; \u0026gt; print(t_s1) Click Start! # 줄 바껴서 출력 \u0026gt; t_s2 = \u0026#34;New Line\\n Check!\u0026#34; \u0026gt; print(t_s2) New Line Check! 2.2 Raw String  소문자 r을 붙이면 Escape 표현을 무시하고 그대로 다 출력한다. Escape 표현을 사용하지 않기 위해 선언! 이런 게 있다는 정도만 알고 있기  # raw string 미포함 \u0026gt; raw_s1 = \u0026#34;\\\\x\\y\\z\\q\u0026#34; \u0026gt; print(raw_s1) \\x\\y\\z\\q # raw string 포함 \u0026gt; raw_s1 = r\u0026#34;\\\\x\\y\\z\\q\u0026#34; \u0026gt; print(raw_s1) \\\\x\\y\\z\\q 2.3 Multi Line  여러 줄 출력하는 방법으로 \\(역슬러쉬) 를 사용한다. 역슬러쉬를 사용하여 파이썬에게 어떤 변수를 binding 한다는 걸 의미한다. 그래서 다음 줄에 변수를 선언한다는 걸 의미한다. 콤마는 ```,\u0026quot;\u0026quot;\u0026quot; 처럼 3개 이상을 사용한다.  \u0026gt; multi_str1 \\ \u0026#34;\u0026#34;\u0026#34; 문자열 멀티라인 입력 테스트 \u0026#34;\u0026#34;\u0026#34; \u0026gt; print(multi_str1) 문자열 멀티라인 입력 테스트 결말\n  이스케이프 코드를 사용하여 개행, 탭만큼 띄우기, 따옴표 문자 삽입이 가능하다. 이스케이프 코드를 사용하고 싶지 않을 때는 string code를 사용한다. 한 줄로는 너무 길어서 여러 줄로 표현하고 싶을 때, 백슬러쉬와 따옴표 3개를 사용하여 멀티라인으로 출력한다.    3. 문자형 연산 \u0026gt; str_o1 = \u0026#34;python\u0026#34; \u0026gt; str_o2 = \u0026#34;Apple\u0026#34; \u0026gt; str_o3 = \u0026#34;How are you doing\u0026#34; \u0026gt; str_o4 = \u0026#34;Korea Japan America\u0026#34; \u0026gt; print(3 * str_o1) pythonpythonpython \u0026gt; print(str_o1 + str_o2) pythonApple \u0026gt; print(\u0026#39;y\u0026#39; in str_o1) True \u0026gt; print(\u0026#39;n\u0026#39; in str_o1) True \u0026gt; print(\u0026#39;P\u0026#39; not in str_o1) False  4. 문자형 형 변환(Type conversion), 문자형 함수 4.1 Type Conversion  파이썬에서 type conversion은 자유롭게 가능하다고 생각하자.  # 정수 -\u0026gt; 문자열 \u0026gt; print(str(66)) # 실수 -\u0026gt; 문자열 \u0026gt; print(str(10.1)) # boolean -\u0026gt; string \u0026gt; print(str(True), type(str)) True \u0026lt;class \u0026#39;str\u0026#39;\u0026gt; # complex -\u0026gt; string \u0026gt; print(str(complex(12))) 12 + 0j 4.2 문자열 함수  print(dir()) 함수에 변수를 입력하면 그 변수가 사용할 수 있는 함수를 보여준다. string type의 data를 넣으면 string이 사용할 수 있는 함수를 보여준다. list면 list가 사용할 수 있는 함수를 보여준다.\n \u0026gt; im_str = \u0026#34;Good Boy\u0026#34; \u0026gt; print(dir(im_str)) [\u0026#39;capitalize\u0026#39;, \u0026#39;encode\u0026#39;, \u0026#39;endswith\u0026#39;, \u0026#39;expandtabs\u0026#39;, \u0026#39;find\u0026#39;, \u0026#39;format\u0026#39;, \u0026#39;lower\u0026#39;, \u0026#39;lstrip\u0026#39;, \u0026#39;maketrans\u0026#39;, \u0026#39;partition\u0026#39;, \u0026#39;removeprefix\u0026#39;, \u0026#39;removesuffix\u0026#39;, \u0026#39;replace\u0026#39;, \u0026#39;rfind\u0026#39;, \u0026#39;rindex\u0026#39;, \u0026#39;rjust\u0026#39;, \u0026#39;rpartition\u0026#39;, \u0026#39;rsplit\u0026#39;, \u0026#39;rstrip\u0026#39;, \u0026#39;split\u0026#39;, \u0026#39;splitlines\u0026#39;, \u0026#39;startswith\u0026#39;, \u0026#39;strip\u0026#39;, \u0026#39;swapcase\u0026#39;, \u0026#39;title\u0026#39;, \u0026#39;translate\u0026#39;, \u0026#39;upper\u0026#39;, \u0026#39;zfill\u0026#39;.....]  위 함수들에서 일부만 출력해보겠다.  \u0026gt; str_o1 = \u0026#34;python\u0026#34; \u0026gt; str_o2 = \u0026#34;Apple\u0026#34; \u0026gt; str_o3 = \u0026#34;How are you doing\u0026#34; \u0026gt; str_o4 = \u0026#34;Korea Japan America\u0026#34; # 첫 글자를 대문자로 바꿔주는 함수 \u0026gt; print(\u0026#34;Capitalize : \u0026#34;, str_o1.capitalize()) Capitalize : Python # 모든 문자를 대문자로 바꿔주는 함수 \u0026gt; print(\u0026#34;upper : \u0026#34;, str_o1.upper()) upper : PYTHON # 모든 문자를 소문자로 바꿔주는 함수 \u0026gt; print(\u0026#34;lower : \u0026#34;, str_o2.lower()) lower : apple # 마지막 글자가 s로 끝나는가? \u0026gt; print(\u0026#34;endswith? : \u0026#34;, str_o1.endswith(\u0026#39;s\u0026#39;)) endswith : False # 해당 문자열 앞 뒤로 join하는 함수 \u0026gt; print(\u0026#34;join str : \u0026#34;, str_o1.join([\u0026#34;I\u0026#39;m\u0026#34;, \u0026#34;!\u0026#34;])) join str : I\u0026#39;m python! # 해당 문자열을 입력한 다른 문자열로 바꿔주는 함수 \u0026gt; print(\u0026#34;replace : \u0026#34;, str_o1.replace(\u0026#39;thon\u0026#39;, \u0026#39;Good\u0026#39;)) replace : pyGood # 해당 문자열을 입력한 문자열을 기준으로 쪼개어 list로 만드는 함수 \u0026gt; print(\u0026#34;split : \u0026#34;, str_o4.split(\u0026#39; \u0026#39;)) split : Korea Japan America # 최소 단위까지 쪼개어 알파벳 순으로 list로 만드는 함수 \u0026gt; print(\u0026#39;sorted : \u0026#39;, sorted(str_o3)) sorted : [\u0026#39; \u0026#39;, \u0026#39; \u0026#39;, \u0026#39; \u0026#39;, \u0026#39;?\u0026#39;, \u0026#39;H\u0026#39;, \u0026#39;a\u0026#39;, \u0026#39;d\u0026#39;, \u0026#39;e\u0026#39;, \u0026#39;g\u0026#39;, \u0026#39;i\u0026#39;, \u0026#39;n\u0026#39;, \u0026#39;o\u0026#39;, \u0026#39;o\u0026#39;, \u0026#39;o\u0026#39;, \u0026#39;r\u0026#39;, \u0026#39;u\u0026#39;, \u0026#39;w\u0026#39;, \u0026#39;y\u0026#39;] \u0026gt; print(\u0026#39;reversed1: \u0026#39;, reversed(str_o2)) reversed1: \u0026lt;reversed object at 0x000001ECEA15CFD0\u0026gt; # reversed는 return 값이 존재하기에 list로 출력이 가능하다. \u0026gt; print(\u0026#39;reversed2: \u0026#39;, list(reversed(str_o2)) reversed2: [\u0026#39;e\u0026#39;, \u0026#39;l\u0026#39;, \u0026#39;p\u0026#39;, \u0026#39;p\u0026#39;, \u0026#39;A\u0026#39;]  reverse 와 reversed 의 차이\n reverse 는 list 함수를 단순히 뒤집어서 저장해주는 역할로, 리턴값이 없어서 for문 같은 조건문 반복문에 사용하지 못 한다. reversed는 id 값으로 나온다. 그래서 reverse 값을 원하면 형 변환을 해야 한다. 또한, 기존 리스트의 값을 변경하지 않으면서 return 값만을 원할 때 reversed 함수를 사용한다.    5. Slicing  문자열의 일부분을 원하는 대로 잘라오는 것을 말한다.\n \u0026gt; sl = \u0026#39;Nice Python\u0026#39; \u0026gt; print(sl[0:3]) Nic # index[0] 부터 [3]까지가 아닌, [2]까지이기 때문이다. \u0026gt; print(sl[5:]) Python # 아무런 값이 없으면 끝까지 또는 처음부터라는 의미다. \u0026gt; print(sl[:len(sl)]) Nice Python # 끝부분의 index를 모를 때, len 함수를 사용한다. 끝까지 출력된다. # 위에 [0:3] 처럼 끝에가 -1 이 되지 않는다. \u0026gt; print(sl[:len(sl)-1]) Nice Pytho # 처음과 끝을 의미한다. \u0026gt; print(sl[:]) Nice Python # index[1]부터 시작하여 2씩 증가하며, index[4] 미만까지 한다. \u0026gt; print(sl[1:4:2]) ie # index[-4]부터 시작하여 [-3] 미만까지 한다. \u0026gt; print(sl[-4:-2]) th # index를 역으로 해도 가능하다. \u0026gt; print(sl[-5:]) Python # index를 역으로 하는 것과 정방향으로 하는 것을 같이 해도 가능하다. \u0026gt; print(sl[1:-2]) ice Pyth # 역으로 출력된다. \u0026gt; print(sl[::-1]) nohtyP eciN 결론: slicing을 사용하여 원하는 정보를 추출해야한다. 그렇기 떄문에 slicing은 중요하다.\n","permalink":"http://jeha00.github.io/post/python_basic/python_basic_4/","summary":"string type의 생성부터 연산, len 함수 사용, type conversion, 문자형 함수 그리고 slicing을 알아보겠다.","title":"[TIL] Python basic 4: string"},{"content":"1. 파이썬의 모든 자료형  파이썬이 지원하는 자료형은 다음과 같다.  int: 정수 float: 실수 complex: 복소수 bool: 불린 (True or False) str: 문자열(시퀀스) list: 리스트(시퀀스) tuple: 튜플(시퀀스) set: 집합 dict: 사전  그러면 각 자료형의 구체적인 예를 알아보자.  # str : string 의 약어로, 문자열 자료형을 의미한다. \u0026gt; str1 = \u0026#34;Jeha\u0026#34; \u0026gt; str2 = \u0026#34;Anacondacong\u0026#34; # bool: boolean 의 약어로, True or False 자료형을 의미한다. \u0026gt; bool1 = True # float: 실수형 자료형을 의미한다. 소수점이 존재한다. # 소수점 아래가 0이어도, 소수점이 존재하므로 실수형 데이터다. \u0026gt; float1 = 10.0 # int : integer의 약어로, 정수형 데이터를 말한다. \u0026gt; int1 = 7 # list : 리스트형으로 대괄호 안에 열거된 데이터 타입을 말합니다. \u0026gt; list1 = [str1, str2] # tuple: 튜플이라 하며, 소괄호 또는 괄호 없이 , 마로만 열거된 형태를 말합니다. # dict : dictionary의 약어로, 중괄호 안에 key : value 로 구성된 데이터 형태입니다. \u0026gt; dict1 = { \u0026#34;name : \u0026#34;Machine Learning\u0026#34;, \u0026#34;version\u0026#34; : 2.0 } # set : 집합형 데이터 타입으로, dict 와 마찬가지로 중괄호 형태의 데이터입니다. \u0026gt; set1 = {7, 8, 9}  각 데이터 타입 출력은 다음과 같이 한다.  \u0026gt; print(type(str1)) \u0026lt;class \u0026#39;str\u0026#39;\u0026gt; \u0026gt; print(type(bool1)) \u0026lt;class \u0026#39;bool\u0026#39;\u0026gt; \u0026gt; print(type(str2)) \u0026lt;class \u0026#39;str\u0026#39;\u0026gt; \u0026gt; print(type(float1)) \u0026lt;class \u0026#39;float\u0026#39;\u0026gt; \u0026gt; print(type(int1)) \u0026lt;class \u0026#39;int\u0026#39;\u0026gt; \u0026gt; print(type(dict1)) \u0026lt;class \u0026#39;dict\u0026#39;\u0026gt; \u0026gt; print(type(tuple1)) \u0026lt;class \u0026#39;tuple\u0026#39;\u0026gt; \u0026gt; print(type(set1)) \u0026lt;class \u0026#39;set\u0026#39;\u0026gt; - 결론: 데이터 타입의 종류에는 숫자형, 문자형, 리스트, 튜플, 딕셔너리가 있다.\n 2. 숫자형 데이터 선언 # 정수 선언 \u0026gt; i = 77 \u0026gt; i2 = -14 \u0026gt; big_int = 888888888888888 #정수 출력 \u0026gt; print(i) 77 \u0026gt; print(i2) -14 \u0026gt; print(big_int) 888888888888888 # 실수 선언 \u0026gt; f = 0.9999 \u0026gt; f2 = 3.141592358 \u0026gt; f3 = - 4.2 # 실수 출력 \u0026gt; print(f) 0.9999 \u0026gt; print(f2) 3.141592358 \u0026gt; print(f3) -4.2 - 결론: 변수명 = 할당할 value값\n 3. 연산자 활용  숫자형 연산자 종류에는 다음과 같다.  + : 덧셈 - : 뺼셈 * : 곱셈 / = 나누기를 의마하며, 몫과 나머지로 구성된다. // : 나누기의 몫 부분을 출력한다. % : 나누기의 나머지 부분을 출력한다. x ** y : 제곱으로, x의 y제곱 을 의미한다.  그러면 연산 실습을 해보겠다.  # 변수 선언 \u0026gt; i1 = 39 \u0026gt; i2 = 939 \u0026gt; big_int1 = 123456789123456789012345678901234567890 \u0026gt; big_int2 = 999999999999999999999999999999999999999 \u0026gt; f1 = 1.234 \u0026gt; f2 = 3.939 # + \u0026gt; print(\u0026#34;i1 + i2 : \u0026#34;, i1 + i2) i1 + i2 : 978 \u0026gt; print(\u0026#34;f1 + f2 : \u0026#34;, f1 + f2) f1 + f2 : 5.173 \u0026gt; print(\u0026#34;big_int1 + big_int2 : \u0026#34;, big_int1 + big_int2) big_int1 + big_int2 : 1123456789123456789012345678901234567889 # 큰 값들도 연산이 가능하다. \u0026gt; a = 3 + 1.0 \u0026gt; print(a, type(a)) 4.1 \u0026lt;class \u0026#39;float\u0026#39; \u0026gt; # 정수형과 실수형을 같이 연산할 때, 정수형을 자동적으로 실수형으로 변환하여 계산한다. # - \u0026gt; print(\u0026#34;i1 - i2: \u0026#34;, i1 - i2) i1 - i2: -900 \u0026gt; print(\u0026#34;f1 - f2: \u0026#34;, f1 - f2) f1 - f2: -2.705 \u0026gt; print(\u0026#34;big_int1 - big_int2: \u0026#34;, big_int1 - big_int2) big_int1 - big_int2: -876543210876543210987654321098765432109 # * \u0026gt; print(\u0026#34;i1 * i2: \u0026#34;, i1 * i2) i1 * i2: 36621 \u0026gt; print(\u0026#34;f1 * f2: \u0026#34;, f1 * f2) f1 * f2: 4.860726 \u0026gt; print(\u0026#34;big_int1 * big_int2: \u0026#34;, big_int1 * big_int2) big_int1 * big_int2: 123456789123456789012345678901234567889876543210876543210987654321098765432110 # / \u0026gt; print(\u0026#34;i2 / i1: \u0026#34;, i2 / i1) i2 / i1: 24.076923076923077 \u0026gt; print(\u0026#34;f2 / f1: \u0026#34;, f2 / f1) f2 / f1: 3.1920583468395463 \u0026gt; print(\u0026#34;big_int2 / big_int1: \u0026#34;, big_int2 / big_int1) big_int2 / big_int1: 8.10000006561 # // \u0026gt; print(\u0026#34;i2 // i1: \u0026#34;, i2 // i1) i2 // i1: 24 # i2 / i1 의 연산값의 몫 부분임을 알 수 있다. \u0026gt; print(\u0026#34;f2 // f1: \u0026#34;, f2 // f1) f2 // f1: 3.0 # f2 / f1 의 연산값의 몫 부분임을 알 수 있다. \u0026gt; print(\u0026#34;big_int2 // big_int1: \u0026#34;, big_int2 // big_int1) big_int2 // big_int1: 8 # big_int2 / big_int1 의 연산값의 몫 부분임을 알 수 있다. # % \u0026gt; print(\u0026#34;i2 % i1 :\u0026#34;, i2 % i1) i2 % i1 : 3 # i1 * (i2 // i1) 으로 i2를 나누고 나온 나머지값 \u0026gt; print(\u0026#34;f2 % f1 :\u0026#34;, f2 % f1) f2 % f1 : 0.2370000000000001 \u0026gt; print(\u0026#34;big_int1 % big_int2 :\u0026#34;, big_int1 % big_int2) big_int1 % big_int2 : 123456789123456789012345678901234567890 # ** 와 pow(x,y) \u0026gt; print(\u0026#34;2 ** 3: \u0026#34;, 2 ** 3) \u0026gt; print(\u0026#34;2 ** 3: \u0026#34;, pow(2,3)) 2 ** 3: 8 2 ** 3: 8 \u0026gt; print(\u0026#34;i1 ** i2: \u0026#34;, i1 ** i2) \u0026gt; print(\u0026#34;i1 ** i2: \u0026#34;, pow(i1,i2)) i1 ** i2: 102250631262663558380..... i1 ** i2: 102250631262663558380..... # 너무 길어서 생략 \u0026gt; print(\u0026#34;f1 ** f2: \u0026#34;, f1 ** f2) \u0026gt; print(\u0026#34;f1 ** f2: \u0026#34;, pow(f1,f2)) f1 ** f2: 2.289235194260789 f1 ** f2: 2.289235194260789 4. 형 변환  형 변환 함수는 다음과 같다.  abs(x): absolute의 약어로, 절대값으로 변환한다. int(x): 정수형으로 만듭니다. 실수를 입력했다면 실수의 정수 부분을 출력한다. float(x): 실수형으로 만듭니다. 정수를 입력했다면 소수점 .0 으로 나온다. complex(x): 복소수로 허수까지 포함해서 a+bi 형태로 변환한다. pow(x, y): x의 y승 제곱으로 출력된다. a = 3. b = 9 c = .65 d = 13.55 # type 출력 \u0026gt; print(type(a), type(b), type(c), type(d)) \u0026lt;class \u0026#39;float\u0026#39;\u0026gt; \u0026lt;class \u0026#39;int\u0026#39;\u0026gt; \u0026lt;class \u0026#39;float\u0026#39;\u0026gt; \u0026lt;class \u0026#39;float\u0026#39;\u0026gt; # 형 변환 \u0026gt; print(float(b)) #정수 -\u0026gt; 실수 9.0 \u0026gt; print(int(c)) # 실수 -\u0026gt; 정수 0 \u0026gt; print(ind(D)) # 실수 -\u0026gt; 정수 13 \u0026gt; print(int(True)) # Bool -\u0026gt; 정수 1 \u0026gt; print(float(True)) # Bool -\u0026gt; 실수 1.0 \u0026gt; print(int(False)) 0 \u0026gt; print(float(False)) 0.0 \u0026gt; print(complex(3)) # 정수 -\u0026gt; 복소수 3 +0j \u0026gt; print(complex(\u0026#39;3\u0026#39;)) # 문자형 -\u0026gt; 복소수 3 + 0j # string data type을 숫자형으로 바꾸고 나서 복소수를 처리해야 하는데, 바로 처리된다. \u0026gt; print(complex(False)) # Bool -\u0026gt; 복소수 0j # 수치 연산 함수 \u0026gt; print(abs(-7)) 7 # divmod(x,y) : x를 y로 나눴을 때, 몫과 나머지를 반환한다. 많이 사용되는 함수로 중요하다. \u0026gt; x, y = divmod(100, 8) #몫 과 나머지 \u0026gt; print(x, y) 12 4 \u0026gt; print(pow(5, 3)) \u0026gt; print(5**3) 125 125 - 결론: 다른 data type으로 형 변환이 가능하다.\n5. 외부 모듈 사용  import 를 사용한다.  # 외부 모듈을 불러오는 함수 \u0026gt; import math # math 모듈에서 ceil 이란 함수를 사용하겠다. # ceil(x) : x 이상의 수중에서 가장 작은 정수를 반환한다. \u0026gt; print(math.ceil(5.2)) 6 \u0026gt; print(math.pi) 3.1415926535 - 결론: import를 사용하여 외부 module을 가져온다.\nReference  Python tutorial  ","permalink":"http://jeha00.github.io/post/python_basic/python_basic_3/","summary":"첫 번째, python의 자료형 종류에는 무엇이 있는지 알아본다. 두 번째, 숫자형 데이터 타입의 선언, 연산, 그리고 형 변환에 대해 중점적으로 알아보겠다.","title":"[TIL] Python basic 3: numeric data"},{"content":"1. 기본 출력 1.1 Escape 코드 \\n: 개행 \\t: 탭 \\\\: 문자 \\\u0026#39;: 문자 \\\u0026#34;: 문자 \\000: 널 문자 1.2 기본 출력  '' 또는 \u0026quot;\u0026quot; 를 자주 사용한다.  \u0026gt; print(\u0026#39;JeHa start!\u0026#39;) \u0026gt; print(\u0026#34;JeHa start!\u0026#34;) \u0026gt; print() \u0026gt; print(\u0026#39;\u0026#39;\u0026#39;JeHa start!\u0026#39;\u0026#39;\u0026#39;) \u0026gt; print(\u0026#39;\u0026#39;) \u0026gt; print(\u0026#34;\u0026#34;\u0026#34;JeHa start!\u0026#34;\u0026#34;\u0026#34;) # 아무것도 출력되지 않는다. \u0026gt; print(\u0026#39;\u0026#39;) \u0026gt; print()  결과는 다음과 같다.  JeHa start! JeHa start! JeHa start! JeHa start! 1.3 Separator 옵션  여러 data를 열거하여 출력할 때, 각 data 사이 사이를 분리할 string을 입력할 수 있다.  \u0026gt; print(\u0026#39;python\u0026#39;, \u0026#39;start!\u0026#39;, sep=\u0026#39;@\u0026#39;) python @ start! \u0026gt; print(\u0026#39;p\u0026#39;,\u0026#39;y\u0026#39;,\u0026#39;t\u0026#39;,\u0026#39;h\u0026#39;,\u0026#39;o\u0026#39;,\u0026#39;n\u0026#39;) p y t h o n \u0026gt; print(\u0026#39;p\u0026#39;,\u0026#39;y\u0026#39;,\u0026#39;t\u0026#39;,\u0026#39;h\u0026#39;,\u0026#39;o\u0026#39;,\u0026#39;n\u0026#39;, sep = \u0026#39;\u0026#39;) python \u0026gt; print(\u0026#39;010\u0026#39;, \u0026#39;6677\u0026#39;, \u0026#39;6677\u0026#39;, sep = \u0026#39;-\u0026#39; ) 010-6677-6677 \u0026gt; print(\u0026#39;python\u0026#39;, \u0026#39;google.com\u0026#39;, sep = \u0026#39;@\u0026#39;) python@google.com 1.4 End 옵션  print에는 자동적으로 행간을 나누는 기능이 있다. 이를 end를 통해서 합칠 수 있다.  \u0026gt; print(\u0026#39;I\u0026#39;) \u0026gt; print(\u0026#39;love\u0026#39;) \u0026gt; print(\u0026#39;u\u0026#39;) I Love u \u0026gt; print(\u0026#39;I\u0026#39;, end = \u0026#39; \u0026#39;) \u0026gt; print(\u0026#39;love\u0026#39;, end = \u0026#39; \u0026#39;) \u0026gt; print(\u0026#39;u\u0026#39;) I love u 2. String 문자열 출력 (s)  d는 정수, s는 string, f는 실수를 의미한다. % 로 formatting 하는 방법과 .format 을 사용해서 formatting하는 방법이 있다. 다 익숙해져야 하지만, 후자를 더 빈번히 사용한다. formatting을 하면 특정 케이스에 원하는 형식대로 출력할 수 있고, 가독성이 높아진다.  # 순서에 맞게 자동적으로 mapping 해준다. \u0026gt; print(\u0026#39;%s %s\u0026#39; % (\u0026#39;one\u0026#39;,\u0026#39;two)) \u0026gt; print(\u0026#39;{} {}\u0026#39;.format(\u0026#39;one\u0026#39;,\u0026#39;two\u0026#39;)) # 순서를 지정해서도 할 수 있다. # index[1] 은 two, index[0]은 one 이므로, 교차해서 mapping 된다. \u0026gt; print(\u0026#39;{1} {0}\u0026#39;.format(\u0026#39;one\u0026#39;,\u0026#39;two\u0026#39;)) one two one two two one  전체 자릿수를 지정하는 방법과 정렬 방향을 바꾸는 방법을 알아보겠다.  # 문자열 총 자리 수는 10자리를 의미한다. # 오른쪽 정렬 # 즉, blank 시작은 왼쪽부터다. \u0026gt; print(\u0026#39;%10s\u0026#39; % (likelike)) # 왼쪽 blank는 2칸이다. likelike # 방향을 반대로 하기 위해서는 (-)를 붙힌다: 왼쪽정렬 \u0026gt; print(\u0026#39;%-10s\u0026#39; % (likelike)) likelike  위 내용을 .format으로 표현해보자. .format은 string을 입력할 때 \u0026rsquo;s\u0026rsquo;를 입력하지 않아도 된다.  # 오른쪽 정렬 \u0026gt; print(\u0026#39;{:\u0026gt;10}\u0026#39;.format(\u0026#39;likelike\u0026#39;)) likelike # 왼쪽 정렬 \u0026gt; print(\u0026#39;{:\u0026lt;10}\u0026#39;.format(\u0026#39;likelike\u0026#39;)) likelike \u0026gt; print(\u0026#39;{:10}\u0026#39;.format(\u0026#39;likelike\u0026#39;)) likelike # 가운데 정렬 \u0026gt; print(\u0026#39;{:^10}\u0026#39;.format(\u0026#39;likelike\u0026#39;)) likelike # blank에는 언더바가 있도록 하는 것 \u0026gt; print(\u0026#39;{:_\u0026gt;10}\u0026#39;.format(\u0026#39;like\u0026#39;)) ______like  그러면 지정한 자릿수보다 문자열이 더 길다면??  \u0026gt; print(\u0026#39;%5s\u0026#39; % (\u0026#39;likelike\u0026#39;)) likelike # 다 출력된다.  지정한 자릿수를 넘는 문자열 부분들을 절삭하고 싶다면??  # . 점을 아래와 같이 표시한다. \u0026gt; print(\u0026#39;%.5s\u0026#39; % \u0026#39;likelike\u0026#39;) likel # 이것은 어떻게 출력될까?? \u0026gt; print(\u0026#39;%10.5s\u0026#39; % (\u0026#39;likelike\u0026#39;)) # 지정한 문자열 총 자리수는 10자리고, 5자리를 넘으면 절삭한다. # blank가 5자리고, 왼쪽에서부터 오른쪽 방향으로 채워진다. # 나머지 5자리에 문자가 채워진다. _____likel # format으로 표현해보자 \u0026gt; print(\u0026#39;{:\u0026gt;10.5}\u0026#39;.format(\u0026#39;likelike\u0026#39;)) 결론\n print('-%n1.n2s' % (\u0026lsquo;출력하기 원하는 문자열\u0026rsquo;))   n1은 전체 자릿수 n2는 출력되길 원하는 문자열의 총 자리수를 의미 \u0026lsquo;-\u0026lsquo;는 정렬 방향을 역으로 한다. 정렬 방향 default는 오른쪽, (-)는 왼쪽 정렬을 의미    print('{:^ \u0026gt; \u0026lt; n1.n2}'.format(\u0026lsquo;string\u0026rsquo;))   n1은 전체 자릿수 n2는 출력되길 원하는 문자열의 총 자리수를 의미 \u0026lsquo;^\u0026rsquo; 는 가운데 정렬 \u0026lsquo;\u0026gt;\u0026lsquo;은 오른쪽 정렬, \u0026lsquo;\u0026lt;\u0026rsquo; 는 왼쪽 정렬을 의미 .format은 s를 입력하지 않는다.      3. Integer 정수형 출력 (d)  .format 은 문자열 s는 입력하지 않는다. 정수형 d or i, 실수형 f 은 입력한다.  \u0026gt; print(\u0026#39;%d %d\u0026#39; % (1, 2)) 1,2 \u0026gt; print(\u0026#39;{} {}\u0026#39;.format(1,2)) 1,2 \u0026gt; print(\u0026#39;{1} {0}.format(1,2)\u0026#39;) 2,1 \u0026gt; print(\u0026#39;%4d\u0026#39; % (24)) \u0026gt; print(\u0026#39;{:\u0026gt;4d}\u0026#39;.format(24)) \u0026gt; print(\u0026#39;{:4d}\u0026#39;.format(24)) 24 \u0026gt; print(\u0026#39;%-4d\u0026#39; % (24)) \u0026gt; print(\u0026#39;{:\u0026lt;4d}\u0026#39;.format(24)) 24 \u0026gt; print(\u0026#39;{:^4d}\u0026#39;.format(24)) 24 \u0026gt; print(\u0026#39;{:_\u0026gt;4d}\u0026#39;.format(24)) __24 \u0026gt; print(\u0026#39;{:_\u0026lt;4d}\u0026#39;.format(24)) 24__ \u0026gt; print(\u0026#39;{:_^4d}\u0026#39;.format(24)) _24_ 결론\n print('-%n1d\u0026rsquo; % (integer))   n1은 전체 자릿수 \u0026lsquo;-\u0026lsquo;는 정렬 방향을 역으로 한다. 정렬 방향 default는 오른쪽, (-)는 왼쪽 정렬을 의미    print('{:^ \u0026gt; \u0026lt; n1d}'.format(integer))   n1은 전체 자릿수 \u0026lsquo;^\u0026rsquo; 는 가운데 정렬 default와 \u0026lsquo;\u0026gt;\u0026lsquo;은 오른쪽 정렬, \u0026lsquo;\u0026lt;\u0026rsquo; 는 왼쪽 정렬을 의미      3. Float 실수형 출력 (f) # 전체 실수자리를 따로 지정하지 않으면 8자리까지 출력된다. \u0026gt; print(\u0026#39;%f\u0026#39; % (3.1415926535)) \u0026gt; print(\u0026#39;{:f}\u0026#39;.format(3.1415926535)) 3.141593 # 3.141592가 아니고, 반올림되어 3.141593 이다. # 소수 부분 8자리 \u0026gt; print(\u0026#39;%.8f\u0026#39; % (3.1415926535)) 3.14159265 # 반올림 되어 맨 마지막 자리 수가 5다. # 소수 부분 12자리 \u0026gt; print(\u0026#39;%.12f\u0026#39; % (3.1415926535)) 3.1415926535 # 소수점(.)까지 포함하여 6자리고, 소수 부분은 2자리, 빈 부분은 0으로 표시한다. \u0026gt; print(\u0026#39;%06.2f\u0026#39; % (3.1415926535)) \u0026gt; print(\u0026#39;{:06.2f}\u0026#39;.format(3.1415926535)) 003.14 # 소수점(.)까지 포함하여 6자리고, 소수 부분은 2자리, 빈 부분은 blank로 둔다. # blank가 있기 때문에 정렬 개념이 적용된다. 그래서 오른쪽 정렬된 상태 \u0026gt; print(\u0026#39;%6.2f\u0026#39; % (3.1415926535)) 3.14 # 왼쪽 정렬 상태 \u0026gt; print(\u0026#39;%-6.2f\u0026#39; % (3.1415926535)) 3.14 결론\nprint('%n1.n2f\u0026rsquo; % ())\nprint('{:n1.n2f}'.format())\n n1 은 전체 자릿수로서, 소수점을 포함한다. n2는 소수점 자리를 말한다. n1 앞에 0이 붙으면 정수 부분에서 비어있는 자리수는 0으로 표기된다.   Reference  Python tutorial  ","permalink":"http://jeha00.github.io/post/python_basic/python_basic_2/","summary":"첫 번째 print 함수를 사용할 때, separator와 end를 사용하여 다양하게 사용하는 것과 두 번째, stirng type, numeric type을 다양하게 출력을 해봄으로서 print 함수에 대해 이해해보겠다.","title":"[TIL] Python basic 2: print 사용법"},{"content":"1. 변수 할당 설명 1.1 기본 선언  다른 프로그래밍 언어는 변수 타입을 정하고 나서 값을 할당한다. 반면에, Python은 값을 정하고 나서 변수 타입을 알아서 할당해준다. 이 변수를 할당한다는 건 물리적으로 즉, 컴퓨터 내부적으로 컴퓨터 메모리의 일부를 할당하는 의미로, \u0026lsquo;고유 주소\u0026rsquo;가 지정된다는 걸 의미한다. 이 \u0026lsquo;고유 주소\u0026rsquo;는 id 라는 명령어로 확인할 수 있다. 함수 id: 객체(object)의 고유값 id(identity) 을 확인  # 700이라는 int type의 data를 n에 할당한다. \u0026gt; n = 700 # \u0026#39;n\u0026#39;이라는 변수의 data type을 확인해보자. \u0026gt; print(type(n)) # \u0026#39;n\u0026#39; 이라는 변수에 할당된 메모리 고유주소를 확인해보자. \u0026gt; print(id(n)) - 결론 : 선언을 한다는 건 메모리 값을 할당하는 걸 의미한다. 이는 id 값을 통해 고유주소를 확인하여 알 수 있다.\n1.2 동시 선언  만약 명칭만 다른 세 변수에 동일한 value가 할당된 경우, id는 어떻게 나올까?  # x, y, z에 동일한 값을 할당한다. # 동일한 object 참조 \u0026gt; x = y = z = 700 \u0026gt; print(x, y, z) # x의 id 와 y의 id는 같은가? \u0026gt; print(id(x) == id(y)) \u0026gt; print(id(x), id(y)) # y의 id 와 z의 id는 같은가? \u0026gt; print(id(y) == id(z)) \u0026gt; print(id(z))  위 두 질문의 결과는 True가 나온다. 동일한 값과 type을 가지고 있기 때문에 메모리 주소가 동일하다는 걸 알 수 있다. 즉, 3개를 선언했지만 실제로 존재하는 건 1개라는 의미다. 파이썬이 하나의 오브젝트로 생성해버린다. 이러한 걸 동시선언 이라고 하며, 파이썬에서는 가능하다. 이처럼 하나 하나 최적화를 시키면 원활하고 빠른 프로그램 실행 흐름이 가능하다.  - 결론: 여러 변수에 똑같은 값을 할당하면 파이썬은 내부에서 하나만 만들어진다.\n1.3 재선언  변수의 명칭은 동일하나 다른 value를 할당해보겠다.  # 동일 명칭의 변수가 다른 object를 참조 # var이란 변수에 75라는 정수형 데이터를 할당되었다. \u0026gt; var = 75 \u0026gt; print(var) \u0026gt; print(id(var)) # int. 형이 아닌 string 형 데이터를 재할당한다. \u0026gt; var = \u0026#34;Change Value\u0026#34; \u0026gt; print(var) \u0026gt; print(id(var))  결과는 다음과 같다.  \u0026lt;class \u0026#39;int\u0026#39;\u0026gt; 2298218369712 Change Value \u0026lt;class \u0026#39;str\u0026#39;\u0026gt; 2298224531568  data type과 value가 변하자 id값이 달라진 걸 알 수 있다. 이것이 가능한 이유가 파이썬에는 garbage collector 가 있기 때문이다. 실제로 재선언할 때는 프로그램의 흐름이 끝날 떄까지 잘 추적하는 게 중요하다. 재선언을 통해서 프로그램의 흐름이 꼬여질 수도 있기 때문이다. 그래서 큰 project에서는 변수의 사전이 엑셀이나 기타 문서로 존재한다고 한다.  - 결론: 동일한 명칭의 변수여도 할당된 값이 변하면 파이썬이 알아서 id 값을 바꾼다.\n 2. Object References 변수가 할당 상태일 때, 아래와 같은 상태가 일어나는 걸 의미한다. (예 : n = 700이라 선언했을 때)\n첫 번째, type에 맞는 object를 생성: type을 통해서 class \u0026lsquo;int\u0026rsquo;라는 오브제트가 생성됨을 알 수 있다. 두 번쨰, 값 생성: 700을 안에서 생성 세 번째, 콘솔 출력 : 700이 출력된다.\n 더 다양한 예제를 살펴보자.  #예1) 아래 출력은 동일하다. 즉, int() 를 하지 않아도 내부적으로 처리된다. \u0026gt; print(300) \u0026gt; print(int(300)) #예2) \u0026gt; n = 800 \u0026gt; print(n, type(n)) # int형의 오브젝트임로 생성되었다. 그리고 출력된다. \u0026gt; m = n \u0026gt; print(m, n) \u0026gt; print(type(m), type(n)) \u0026gt; m = 400 \u0026gt; print(m, n) \u0026gt; print(type(m), type(n)) \u0026gt; m = 800 \u0026gt; n = 600 #m과 n의 고유값이 다르다. \u0026gt; print(id(m), id(n)) \u0026gt; print(id(m)==id(n)) 3. 다양한 변수 선언방법과 예약어  이 규칙들을 가지고 변수를 선언하면 세련되고, 코드를 재활용할 때 가독성이 좋은 소스 코드로 만들 수 있다.   Camel Case : method를 선언할 때 사용. ex) numberOfCollegeGraduates Pascal Case : 언어 상관 없이 class를 주로 선언할 때 사용. ex) umberOfCollegeGraduates snake case: 파이썬에서 변수를 선언 시 사용. ex) number_of_college_graduates\n Camel과 Pascal의 차이는 첫 문자가 소문자냐 대문자냐의 차이다.\n 이외에 허용하는 변수 선언 법은 다음과 같다.  숫자로 시작하지 않는다. 변수는 되도록 snake case로 선언한다. 예약어 같이 문법에 사용되는 단어는 변수명으로 불가능하다.\n   \u0026gt; age = 1 \u0026gt; Age = 2 \u0026gt; aGe = 3 \u0026gt; AGE = 4 \u0026gt; a_g_e = 5 \u0026gt; _age = 6 \u0026gt; age_ = 7 \u0026gt; _AGE_ = 8  예약어는 python reserved words로 검색하면 나온다. 예약어의 종류는 다음과 같다.  False\tdef\tif\traise None\tdel\timport\treturn True\telif\tin\ttry and\telse\tis\twhile as\texcept\tlambda\twith assert\tfinally\tnonlocal\tyield break\tfor\tnot class\tfrom\tor continue\tglobal\tpass  Reference  Python tutorial  ","permalink":"http://jeha00.github.io/post/python_basic/python_basic_1/","summary":"첫 번째, 기본적인 선언 방법과 동시 선언, 재선언을 알아본다. 두 번째, 각 선언에 따른 id 값을 확인하여 파이썬 내부 원리를 이해한다. 세 번째, 선언 방법의 종류인 Camel case, Pascal case, Snake case가 무엇인지 알아본다.","title":"[TIL] Python basic 1: 변수 선언"},{"content":"Intro window 10 환경에서 Hugo 라는 SSG의 한 종류를 사용해서 \u0026lt;user-id\u0026gt;.github.io 주소의 github page를 만들고 배포한 후, contents를 업로드하는 것까지 내용을 다룬다. 이를 위해 총 5단계를 거쳐서 진행한다.\n위 과정들에서 필요한 개념들, 부딪혔던 error 및 해결책도 각 단계 마지막 부분에 작성했다.\n 동일한 주제로 다룬 블로그들을 보면 3단계와 4단계의 순서를 바꿔서 진행한다. 4단계 진행 후, 3단계를 진행해도 무방하다. 다만, 나는 그 과정에서 헷갈린 부분이 있어서 마지막에 theme 적용을 하기로 선택했다.\n  1. Static Site Generator 로 Hugo를 선택한 이유 Github page를 만들 때 SSG의 종류들로 Jekyll, Hexo, Hugo 가 많이 언급된다. 그러면 SSG란 무엇인가?? 정적 페이지(Static Site)란 HTML,CSS,JS를 미리 올려서 서버가 바뀌지 않는 HTML page를 보여주는 것을 말한다. 이 정적 페이지를 보다 간편하게 만들어주는 것이 SSG(Static Site Generator)다. 이와 반대로 동적 페이지는 client에 반응하여 HTML page를 동적으로 만들어진 페이지를 말한다. 더 상세한 정보를 원하시는 분은 정적 웹은 뭐고 동적 웹은 뭔가요? 이 영상을 참고하시길 바란다.\nhugo를 선택하기에 앞서 각 SSG의 특징들에 대해 알아야 하기 때문에, Jekyll, Hexo, Hugo의 각 특징들은 다음과 같다.\n Jekyll -루비 기반 -현재 가장 인기 있음(깃헙 별 수 제일 많음) -한글 레퍼런스도 제일 많음 -느리다는 제보가 많음(몇 십개의 포스팅 뿐인데도 빌드 하는데 5분씩 걸린다고) -윈도우 공식 지원 안됨 Hexo -자바스크립트(Node.js) 기반 -한글 레퍼런스 꽤 많음 -메인 개발자가 손을 놓은 듯 -개발자가 중국인? 이라 구글링하면 중국어 글이 많이 나옴 Hugo -Golang 기반 -빌드 빠름 -문서화 잘돼있음 -깃헙 별 수가 헥소보다 많음 -한글 레퍼런스가 거의 없음 출처: http://tadakichi.tistory.com/188 그래서 4가지 이유로 Hugo를 선택했다.\n 남들이 안해본 걸 해보자. 한글 레퍼런스가 거의 없기 때문에, 기여할 수 있는 부분이 다른 것보다 있을 것이다. 내가 원하는 디자인 대부분이 Hugo였다. 앞으로 계속해서 기술 블로그를 작성할 것이기 때문에, 빠른 빌드를 원했다.  두 번째 이유의 경우, 맨 처음에 Hugo의 존재를 모른 상태에서 jekyll이 많이 사용된다고 하여, 처음에 jekyll로 github page를 만들었다. 그래서 Hugo와 비교했을 때, 훨씬 Jekyll이 한글 레퍼런스가 많다는 걸 알았다.\n 2. Github page 만들기 위한 local 환경 조성   git을 설치한다. 그리고, github 에 가입한다. Visual Studio Code (VSC), Atom 같은 에디터를 설치한다. window 환경에 Hugo를 설치한다.   첫 번째, github 가입은 Github 에 들어가서 오른쪽 상단에 있는 Sign up을 클릭하여 진행한다. 그러면 최종적으로 https://github.com/user-name/ 을 가진다. 이것이 github blog다. github page는 [user-name].github.io 로 가진다.\n두 번째, 나는 visual studio code를 사용한다. visual studio code 여기에 들어가 설치한다.\n세 번째, window 환경에 hugo를 설치한다. window에서 Hugo 설치하기 이 영상 하나 따라하면 쉽다. 하지만, 글로 보고 싶은 분들을 위해 작성한다.\n hugo 다운로드 로 들어가서 아래로 scroll을 내리면 window 버전을 다운받아 C:\\Hugo\\bin 디렉토리를 생성해서 다운받은 압축 파일을 해제 어느 위치에서나 Hugo가 실행할 수 있도록 윈도우 검색으로 시스템 환경 변수 편집을 검색하여 들어간다. 고급 탭의 환경 변수 로 들어간다. 사용자 변수 란의 path를 클릭 후, 편집 을 클릭한다. 새로 만들기를 클릭하여 C:\\Hugo\\bin 경로를 추가한다. cmd에 echo %PATH% 를 입력하여 추가한 경로가 있는지 확인한다. 해제한 압축 파일에서 hugo 실행하여 설치 후, cmd에 hugo version 으로 동작 확인한다.   3. 새로운 2개 github repo 와 local 연결하기 3.1 Submodule 개념 이해하기 이 단계를 진행하기 전에 submodule 개념을 알아야 한다. 영어 독해가 가능하신 분들은 How to Set Up a Hugo Site on Github Pages - with Git Submodules! 이 링크에 들어가 보시기 바란다. submodule에 대해 그림과 함께 잘 설명되어있다. 아래 내용은 위 블로그에서 submodule에 대한 부분을 번역한 내용이다. 오역이 있다면 댓글로 알려주시면 감사하겠다.\n public folder는 [3.4 B repo를 public 폴더에 submodule로 연결하기] 파트에서 아래 명령어로 만들어진다.\n지금 이 명령어를 입력하지 않고, 이런 개념이 있구나 정도만 이해하기.\n# blog 폴더의 submodule로 branch main에 B repo를 add 한다. # sample: git submodule add https://github.com/JeHa00/JeHa00.github.io.git public \u0026gt; git submodule add -b main https://github.com/\u0026lt;user-name\u0026gt;/\u0026lt;B repo 명칭\u0026gt;.git public  출처: How to Set Up a Hugo Site on Github Pages - with Git Submodules!\n왜 Git submodule인가?? 모든 git project는 repository에 저장된다. 이 git submodule은 한 레포 안에서 다른 레포를 참조하도록 해준다. 그래서 프로젝트 안에 프로젝트를 효과적으로 운영할 수 있다. 중요한 건 submodule은 main project와 달리 자신만의 commit과 branch histroy를 가진다. 그래서 프로젝트들을 분리시킬 수 있다. 이는 매우 강력한 도구다. 아래 그림에서는 git project에서 submodule을 사용할 시, 어떻게 코드가 포함되는지를 보여준다. .... 메인 repository의 submodule로 `public` folder를 하위 폴더로 설정하여, 독립된 branch history를 갖는 개체로 대할 수 있다. 출처: https://www.adamormsby.com/posts/000/how-to-set-up-a-hugo-site-on-github-pages-with-submodules/  A repo가 blog 에 remote origin으로 연결된다. B repo가 public 폴더 형태로, blog의 submodule로 들어간다.  출처: How to Set Up a Hugo Site on Github Pages - with Git Submodules!\n3.2 New repository 2개 만들기  자신의 github에 2개의 repository를 만든다.\n  2개의 repository를 각각 A,B라고 하자. 2개의 repository는 public과 private 중 public으로 만든다. private 으로 하면 site에 배포가 안될 수도 있다.  3.2.1 ⚠️ 두 repo를 만들 때 주의사항 ⚠️   A repo에는 README.md 만들지 말기: README.md가 있다면 나중에 git push 시에 충돌이 일어난다.\n  B repo에 README.md를 만들기: repo가 비어있으면 submodule로 연결이 안된다.\n  A는 user-name/blog 로, B는 user-name/user-name.github.io 로 명칭을 만든다.\nex) A의 url은 github.com/JeHa00/blog / B의 url은 github/JeHa00/JeHa00.github.io\n  B repo의 이름이 github page로 쓰일 url.\n  3.3 Hugo new site 생성및 remote add origin A repo 실행  Visual Studio Code의 terminal 또는 Window의 cmd에 입력한다.\n 경로 C:\\Hugo # 새로운 Hugo project 생성 # sample: Hugo new site blog \u0026gt; Hugo new site \u0026lt;project 명칭\u0026gt; # project folder인 blog로 이동 # sample: cd blog \u0026gt; cd \u0026lt;project 명칭\u0026gt; #3. local git 초기화 \u0026gt; git init # blog의 remote origin으로 A repo 추가하기 # sample: git remote add origin https://github.com/Jeha00/blog.git \u0026gt; git remote add origin https://github.com/\u0026lt;user-name\u0026gt;/\u0026lt;A repo 명칭\u0026gt;.git # commit 하기 위해 모든 파일을 stage에 올리기 \u0026gt; git add . # commit \u0026gt; git commit -m \u0026#34;add origin\u0026#34; # the remote origin 에 push 하겠다. branch는 master로 하겠다. \u0026gt; git push origin master   remote origin이 잘 되었는지 확인하기 위해서는 git remote -v를 입력하면 뜬다.\n  error: src refspec master does not match any 가 뜬다면 이는 stage에 오른 파일이 없다는 의미이므로, git add . 를 했는지 확인하기\n  hugo new site \u0026lt;project 명칭\u0026gt; 명령으로 local에서 컨텐츠를 관리하기 위한 장소 생성\n  이 때 경로는 C:\\Hugo 인 상태에서 terminal에 입력한다.\n  \u0026lt;project 명칭\u0026gt;을 A repo 이름과 똑같이 한다.\n  project를 새로 생성해서 project 파일 경로는 C:\\Hugo\\\u0026lt;project 명칭\u0026gt; 일 것이다.\n  위 명령어로 생긴 tree는 다음과 같다.\n  Hugo/project 명칭 ├─archetypes ├─content ├─data ├─layouts ├─static ├─themes └─config.toml   git remote add origin https://github.com/\u0026lt;user-name\u0026gt;/\u0026lt;A repo 명칭\u0026gt;.git Hugo new site로 만든 project 에 대한 remote origin으로 A repo를 추가하겠다는 의미다.\n  C:\\Hugo\\\u0026lt;project 명칭\u0026gt; 경로에서 git push를 하면 앞으로 A repo에 저장된다.\n  그 결과, A repo안에 구성은 다음과 같다.\n  \u0026lt;user-name\u0026gt;/A repo 이름 ├─archetypes └─config.toml 3.4 B repo를 public 폴더에 submodule로 연결하기 # blog 폴더의 submodule로 branch main에 B repo를 add 한다. # sample: git submodule add https://github.com/JeHa00/JeHa00.github.io.git public \u0026gt; git submodule add -b main https://github.com/\u0026lt;user-name\u0026gt;/\u0026lt;B repo 명칭\u0026gt;.git public  이 명령어로 public 폴더가 생성되고, 이 폴더의 remote origin이 B repo가 된다. public 폴더가 생긴 걸 알 수 있다.  Hugo/project 명칭 ├─archetypes ├─content ├─data ├─layouts ├─public ├─static ├─themes ├─.gitmodules └─config.toml  하지만 public 폴더가 생긴다고 연결된 게 아니다. 확실하게 연결이 되었다면 .gitmodules 파일이 생기고, 이 안에 아래와 같은 코드가 생겨야 한다.  [submodule \u0026quot;public\u0026quot;] path = public url = https://github.com/JeHa00/jeha0.github.io.git branch = main   만약 public folder는 생겼지만, .gitmodules와 위 코드가 없다면 다음 조치를 취한다.\n  첫 번째, public folder를 삭제한다.\n  두 번째, local 문서에서 C:\\Hugo\\\u0026lt;new project 명칭\u0026gt; folder로 들어가 숨긴 파일 보이기를 하여, .git 폴더의 modules 폴더를 삭제한다.\n  세 번째, terminal에 C:\\Hugo\\\u0026lt;new project 명칭\u0026gt; 경로에서 git rm --cached public 을 입력한다.\n  첫 번째, 두 번째만 실행한다면 다음과 같은 error 종류들이 뜰 수 있다.\nerror: 'public' does not have a commit checked out\nerror: 'public' already exists in the index\nerror: a git directory for 'public' is found locally with remote(s)\n  이렇게 뜨는 이유는 cach에 public이 아직 남아있기 때문이다. 그래서 이를 제거하고자 git rm --cached public 을 입력한다.\n  그리고, 다시 submodule 명령어를 실행하여, .gitmodules 에 위 코드가 생기는지 확인한다.\n  다시 https://github.com/\u0026lt;user-name\u0026gt;/blog.git 에 public @ 폴더가 생겼는지 확인한다. 이 폴더가 생겼다면 submodule 등록이 확실하게 완료되었다.\n  만약, Permission denied (publickey) 오류가 뜬다면 SSH 보안키를 등록해야한다.\n  위 방법대로 했지만 public 폴더와 B repo가 submodule 연결이 되지 않는다면, B repo에 아무런 file이 존재하지 않아서다.\n  3.2 New repository 2개 만들기 내용처럼 B repo에 README.md를 추가하여 empty repo로 만들지 말자.\n  3.5 public directory와 project root directoy git push 단계 # public directory에 site build 수행하기 \u0026gt; hugo # public dicrectory로 이동 \u0026gt; cd public \u0026gt; git add . \u0026gt; git commit -m \u0026#39;first build\u0026#39; \u0026gt; git push origin main # the project root 로 되돌아가기 \u0026gt; cd .. \u0026gt; git add . \u0026gt; git commit -m \u0026#39;first build - update submodule reference\u0026#39; \u0026gt; git push origin master  위 명령어로 생긴 tree는 다음과 같다.  Hugo/\u0026lt;project 명칭\u0026gt; ├─archetypes ├─content ├─data ├─layouts ├─public │ ├─categories │ └─tags ├─resources │ │─_gen │ ├─assets │ └─images ├─static │─themes ├─.gitmodules └─config.toml  A repo의 directory 내부 구성은 아래와 같다. 아래 image처럼 public@가 떠야 한다. submodule이 잘 연결되었다는 의미다.    4. Github page에 theme 적용  원하는 테마 찾기\n   Hugo Theme Star Ranking, jamstackthemes 그리고, Hugo Themes: Complete List 이 3가지 사이트 정도라면 충분히 찾을 수 있다.\n  처음에 테마 찾는 데 많은 시간을 썼는데, 지금 생각해보면 기본 테마를 찾은 다음에 customizing 하는 방법이 더 빠른 방향이었다.\n   submodule을 사용하여 테마 적용하기\n   submodule로 테마를 적용한 이유는 업데이트된 테마를 쉽게 가져올 수 있기 때문에, clone보다 submodule로 만드는 게 더 낫다고 한다. (by submodule이 나은 이유)\n  테마 또한 submodule로 적용한다. 구조는 아래와 같다.   출처: How to Set Up a Hugo Site on Github Pages - with Git Submodules!\n경로 C:\\Hugo\\\u0026lt;New Project 명칭\u0026gt; # root project folder에 submodule로 테마를 적용한다 # git submodule add .git themes/Paper-Mod \u0026gt; git submodule add \u0026lt;theme 경로\u0026gt;.git themes/\u0026lt;테마명\u0026gt;   원하는 theme을 fork 한다.\n  fork를 하는 이유는 테마를 직접 수정할 수 없고, 수정한 버전을 유지하기 어렵기 때문에, fork하여 자신의 github으로 가져온다.\n  fork한 테마의 경로를 복사하는 방법은 다음과 같다.   위 이미지에서 url 옆에 있는 버튼을 클릭하면 복사된다.\n  git submodule add \u0026lt;theme 경로\u0026gt;.git themes/\u0026lt;테마명\u0026gt; 에서 themes란 밑에 이미지의 themes folder를 말한다. 이 folder 밑에 \u0026lt;테마명\u0026gt; folder를 만들어, 테마 자료들을 다운받는다는 의미다.\n  Hugo/\u0026lt;project 명칭\u0026gt; ├─archetypes ├─content ├─data ├─layouts ├─public │ ├─categories │ └─tags ├─resources │ │─_gen │ ├─assets │ └─images ├─static │─themes │ └─\u0026lt;테마명\u0026gt; ├─.gitmodules └─config.toml  다음으로 config.toml 에 theme = 이 없으면 추가하여, theme = \u0026lt;테마명\u0026gt; 을 적는다. BaseURL을 B repo의 끝 부분인 https://\u0026lt;user-name\u0026gt;.github.io/ 로 수정한다. 이 경로가 앞으로 github page의 URL이 된다. theme 적용 또한 submodule이므로 .gitmodules 파일에 다음과 같이 2개가 등록되었다.  #example [submodule \u0026#34;public\u0026#34;] path = public url = https://github.com/\u0026lt;user-name\u0026gt;/\u0026lt;B repo 명칭\u0026gt;.git branch = main [submodule \u0026#34;\u0026lt;테마명\u0026gt;\u0026#34;] path = themes/\u0026lt;테마명\u0026gt; url = 테마 url  theme 적용 후, theme 폴더 안에 examplesite 란 의미의 폴더가 있다면, 그 폴더 안에 있는 config.toml을 복사하여 C:\\Hugo\\\u0026lt;New Project 명칭\u0026gt; 경로에 있는 config.toml에 복사 붙여 넣는다. BaseURL만 다시 수정한다.   테마 적용되었는지 테스트하기\n 경로 C:\\Hugo\\\u0026lt;New Project 명칭\u0026gt; # D 란 draft 문서까지 포함해서 보겠다는 의미다. \u0026gt; hugo server -D  그러면 https://localhost:1313/ 이 뜬다. 이를 클릭하면 테마가 적용되었는지 알 수 있다. terminal 작업을 다시 할려면 Ctrl + C를 눌러 중단한다. hugo server -D 가 돌아가는 동안에는 글의 수정을 바로 확인할 수 있다.   5. Contents 생성과 업로드, utterances로 댓글 기능 추가, 업로드 자동화 5.1 Contents 생성과 업로드  Contents 생성과 public folder에 반영하기\n 경로 C:\\Hugo\\\u0026lt;New Project 명칭\u0026gt; # contents 생성 \u0026gt; hugo new post/test1.md # 생성된 글 public 폴더에 반영하기 \u0026gt; hugo -t \u0026lt;테마이름\u0026gt;   hugo new post/test1.md는 \\content\\post\\test1.md 경로로 생성된다.\n  contents 생성 후, hugo server -D로 localhost에는 생성한 contents가 보이는데, github page에는 안보인다면 hugo -t \u0026lt;테마이름\u0026gt;명령을 하지 않았기 때문이다.\n  여기서 \u0026lt;테마이름\u0026gt;은 git submodule add \u0026lt;theme 경로\u0026gt;.git themes/\u0026lt;테마명\u0026gt; 에서 테마명과 동일해야 한다.\n   컨텐츠 업로드\n # public dicrectory로 이동 \u0026gt; cd public \u0026gt; git add . \u0026gt; git commit -m \u0026#39;commit message\u0026#39; \u0026gt; git push origin main # the project root 로 되돌아가기 \u0026gt; cd .. \u0026gt; git add . \u0026gt; git commit -m \u0026#39;commit message\u0026#39; \u0026gt; git push origin master 5.2 Utterances로 댓글 기능 추가  사용 방법\n Github에 \u0026lt;user-name\u0026gt;/blog-comments 같이 private이 아닌 public 저장소를 만든다. Utterance에서 1번에서 만든 repository를 입력한다. Utterance에서 Mapping 방식 6가지 중 한 가지를 선택한다. 2번 3번에 따라 Utterance에서 생성된 script를 복사하여 각자의 적절한 템플릿 위치가 추가한다. 추가 위치는 각 theme의 README.md 를 꼼꼼히 읽어본다.   아웃사이더님의 블로그 글에서 보고 가져온다.\n5.3 deploy.sh로 자동화  deploy.sh 파일명으로 아래 코드를 저장한 후, C:\\Hugo\\\u0026lt;프로젝트 명칭\u0026gt; 경로에 저장한다. 이후 Git Bash 프로그램을 사용하여 C:\\Hugo\\\u0026lt;프로젝트 명칭\u0026gt; 경로로 이동 후, bash deploy.sh를 입력하면 the project root와 submodule 모두 순차적으로 push가 실행된다. 나는 submodule은 main default branch에, the project root는 master default branch로 설정했다.\n #!/bin/bash echo -e \u0026#34;\\033[0;32mDeploying updates to GitHub...\\033[0m\u0026#34; # Build the project. hugo -t \u0026lt;테마명\u0026gt; # Go To Public folder cd public # Add changes to git. git add . # Commit changes. msg=\u0026#34;rebuilding site `date`\u0026#34; if [ $# -eq 1 ] then msg=\u0026#34;$1\u0026#34; fi git commit -m \u0026#34;$msg\u0026#34; # Push source and build repos. ## master 대신 각자 연결한 branch 명으로 수정하면 된다. git push origin main # Come Back up to the Project Root cd .. # blog 저장소 Commit \u0026amp; Push git add . msg=\u0026#34;rebuilding site `date`\u0026#34; if [ $# -eq 1 ] then msg=\u0026#34;$1\u0026#34; fi git commit -m \u0026#34;$msg\u0026#34; ## master 대신 각자 연결한 branch 명으로 수정하면 된다. git push origin master  6. To customize blog theme   커스텀마이징을 위한 제일 좋은 방법은 각자 선택한 테마 템플릿의 README.md를 꼼꼼히 읽어보는 게 제일 빠른 지름길이라 생각한다. 사용자가 원하는 기능들을 어떻게 추가하면 되는지 설명해논 템플릿이 많기 때문에, 반드시 README.md 를 꼼꼼히 읽기 바란다.   7. 후기   git에 대해 더 숙지를 하고 나서 git page를 만들기 시작했다면 시간 소모를 줄일 수 있었을 것이다. 급한 마음에 github page를 시작하여 생각보다 많은 시행착오와 error들을 격었다. 이 error들은 대체로 git을 정확히 이해하지 못해서 발생하는 문제점들이다. 이번 일을 통해서 git이 개발자에게 사람의 숨쉬기와 같다는 걸 느껴서 Pro git 이란 책을 사서 꾸준히 공부하기로 결정했다. gith page를 만들었으니, TIL부터 시작하여 꾸준히 공부하자. Hugo를 선택한 것이 처음 시도할 때는 매우 힘들었지만, 지금 와서는 잘한 선택임을 느낀다. 진행하다가 부딪힌 error들에 대해서는 바로 바로 기록을 하자. 이는 반복적인 똑같은 삽질을 예방할 수 있다.   Reference   정적 웹은 뭐고 동적 웹은 뭔가요?\n  Jekyll, Hexo, Hugo 차이점 설명\n  Hugo로 Github.io 블로그 만들기\n  How to Set Up a Hugo Site on Github Pages - with Git Submodules!\n  theme 적용에 submodule이 나은 이유\n  아웃사이더님의 블로그 글\n  ","permalink":"http://jeha00.github.io/post/hugo%EB%A1%9C-github-page-%EB%A7%8C%EB%93%A4%EA%B3%A0-%EB%B0%B0%ED%8F%AC%ED%95%98%EA%B8%B0/","summary":"SSG의 한 종류 \u0026lsquo;Hugo\u0026rsquo;와 \u0026lsquo;git remote, git submodule\u0026rsquo;로 Github page를 만든다. 그 후, 컨텐츠 생성과 업로드를 한다. 마지막으로 utterances로 댓글 기능 추가, deploy.sh를 사용하여 업로드하는 방법을 다룬다.","title":"Window에서 Hugo로 Github page 만들고 배포하기"}]