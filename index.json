[{"content":"Intro  csv 파일이란??  Comma-Separated Values의 약자로, 콤마로 구분된 텍스트 파일이다. 확장자 명은 .csv이다. csv 파일은 data science 분야에서 주로 사용하여, 데이터를 주고 받을 때 사용하는 형식이다. data science 분야나 전처리할 때, csv로 임시로 저장을 했다가 나중에 활용하는 형식으로도 많이 사용하고 있다.   csv의 MIME 형식은 text/csv 이다.  MIME type이란 client에서 전송하는 문서의 종류를 표시하는 기능이다. 서버에서 이 type을 이용해서 각각 파일의 확장자를 확인할 수 있다.   csv의 파일 1행을 열머리글로 header라고 한다. 콤마(,)로 반드시 구분되는 게 아니지만, 정석은 콤마다.  1. Read csv file (csv 파일 읽기)  두 개의 예제를 통해 읽기 실습을 해보겠다. 첫 번째 예제는 정석으로 콤마(,)로 구분되는 파일이다. (text1.csv) 두 번째 예제는 코마가 아닌 합기호로 구분되는 파일이다. (text2.csv) csv 파일을 읽기 위해서는 csv.reader 함수를 사용해야한다. csv.reader: Return a reader object which will iterate over lines in the given csvfile. csvfile can be any object which supports the iterator protocol. the iterator protocol을 지원하는지 알기 위해서 dir() 함수를 사용하여 __iter__이 있는지 확인한다. 그리고, 파이썬은 list 형태로 가져오고, 작성한다.   예제 파일 내용은 아래와 같다.  ## text1.csv # 콤마로 구분 Name,Code Afghanistan,AF Åland Islands,AX Albania,AL Algeria,DZ American Samoa,AS Andorra,AD ## text2.csv # 합기호로 구분 Name|Code Afghanistan|AF Åland Islands|AX Albania|AL Algeria|DZ American Samoa|AS Andorra|AD  첫 번째 예제 csv 파일의 첫 행 부분을 Header라고 한다. Header skip을 원한다면 next() 함수를 사용한다. next(): Return the next item from the iterator.  괄호 안에 입력한 iterator의 두 번째 행부터 출력하겠단 의미다. seek() 함수처럼 cursor를 이동한다.    # 외장 함수를 import 한다. \u0026gt; import csv # 별도로 close 하지 않기 위해 with open 함수를 사용한다. # 현재 경로에서 resource 폴더에 있는 tes1.csv 파일을 읽고, f에 연결한다. \u0026gt; with open(\u0026#39;./resource/test1.csv\u0026#39;, \u0026#39;r\u0026#39;) as f: \u0026gt; reader = csv.reader(f) \u0026gt; print(reader) \u0026lt;_csv.reader object at 0x00000206CB2F5100\u0026gt; \u0026gt; print(type(reader)) \u0026lt;class \u0026#39;_csv.reader\u0026#39;\u0026gt; ## __iter__을 확인한다. \u0026gt; print(dir(reader)) [\u0026#39;__class__\u0026#39;, \u0026#39;__delattr__\u0026#39;, \u0026#39;__dir__\u0026#39;, \u0026#39;__doc__\u0026#39;, \u0026#39;__eq__\u0026#39;, \u0026#39;__format__\u0026#39;, \u0026#39;__ge__\u0026#39;, \u0026#39;__getattribute__\u0026#39;, \u0026#39;__gt__\u0026#39;, \u0026#39;__hash__\u0026#39;, \u0026#39;__init__\u0026#39;, \u0026#39;__init_subclass__\u0026#39;, \u0026#39;__iter__\u0026#39;, \u0026#39;__le__\u0026#39;, \u0026#39;__lt__\u0026#39;, \u0026#39;__ne__\u0026#39;, \u0026#39;__new__\u0026#39;, \u0026#39;__next__\u0026#39;, \u0026#39;__reduce__\u0026#39;, \u0026#39;__reduce_ex__\u0026#39;, \u0026#39;__repr__\u0026#39;, \u0026#39;__setattr__\u0026#39;, \u0026#39;__sizeof__\u0026#39;, \u0026#39;__str__\u0026#39;, \u0026#39;__subclasshook__\u0026#39;, \u0026#39;dialect\u0026#39;, \u0026#39;line_num\u0026#39;] ## __iter__이면 for문에도 사용할 수 있다. # list 형식으로 가져온다는 걸 확인할 수 있다. \u0026gt; for c in reader: \u0026gt; print(type(c)) \u0026gt; print(c) \u0026lt;class \u0026#39;list\u0026#39;\u0026gt; [\u0026#39;Name\u0026#39;, \u0026#39;Code\u0026#39;] \u0026lt;class \u0026#39;list\u0026#39;\u0026gt; [\u0026#39;Afghanistan\u0026#39;, \u0026#39;AF\u0026#39;] \u0026lt;class \u0026#39;list\u0026#39;\u0026gt; [\u0026#39;횇land Islands\u0026#39;, \u0026#39;AX\u0026#39;] \u0026lt;class \u0026#39;list\u0026#39;\u0026gt; [\u0026#39;Albania\u0026#39;, \u0026#39;AL\u0026#39;] \u0026lt;class \u0026#39;list\u0026#39;\u0026gt; [\u0026#39;Algeria\u0026#39;, \u0026#39;DZ\u0026#39;] \u0026lt;class \u0026#39;list\u0026#39;\u0026gt; [\u0026#39;American Samoa\u0026#39;, \u0026#39;AS\u0026#39;] \u0026lt;class \u0026#39;list\u0026#39;\u0026gt; [\u0026#39;Andorra\u0026#39;, \u0026#39;AD\u0026#39;] ## list를 string 형식으로 바꿔보자. # 첫 번째 Name, Code가 헤더로, 열정보 다. \u0026gt; print(\u0026#39;\u0026#39;.join(c)) NameCode AfghanistanAF 횇land IslandsAX AlbaniaAL AlgeriaDZ American SamoaAS AndorraAD ## 헤더를 출력하고 싶지 않으면?? \u0026gt; with open(\u0026#39;./resource/test1.csv\u0026#39;, \u0026#39;r\u0026#39;) as f: \u0026gt; reader = csv.reader(f) # with open 문 안에 아래 함수를 추가한다. # Header Skip: csv 파일의 첫 행 부분은 보통 헤더값이라 하며, 생략한다. \u0026gt; next(reader) # 다시 실행시켜보자. # NameCode가 없는 걸 확인할 수 있다. \u0026gt; print(\u0026#39;\u0026#39;.join(c)) AfghanistanAF 횇land IslandsAX AlbaniaAL AlgeriaDZ American SamoaAS AndorraAD  두 번째 예제 (test2.csv)  \u0026gt; import csv \u0026gt; with open(\u0026#39;./resource/test2.csv\u0026#39;, \u0026#39;r\u0026#39;) as f: \u0026gt; reader = csv.reader(f, delimiter = \u0026#39;|\u0026#39;) \u0026gt; next(reader) \u0026gt; for c in reader: \u0026gt; print(c) [\u0026#39;Afghanistan\u0026#39;, \u0026#39;AF\u0026#39;] [\u0026#39;횇land Islands\u0026#39;, \u0026#39;AX\u0026#39;] [\u0026#39;Albania\u0026#39;, \u0026#39;AL\u0026#39;] [\u0026#39;Algeria\u0026#39;, \u0026#39;DZ\u0026#39;] [\u0026#39;American Samoa\u0026#39;, \u0026#39;AS\u0026#39;] [\u0026#39;Andorra\u0026#39;, \u0026#39;AD\u0026#39;] ## 만약 delimiter = \u0026#39;|\u0026#39; 를 입력하지 않는다면?? # name과 code가 하나의 값으로 인식된다. [\u0026#39;Afghanistan|AF\u0026#39;] [\u0026#39;횇land Islands|AX\u0026#39;] [\u0026#39;Albania|AL\u0026#39;] [\u0026#39;Algeria|DZ\u0026#39;] [\u0026#39;American Samoa|AS\u0026#39;] [\u0026#39;Andorra|AD\u0026#39;]  DictReader 를 사용하여 test2.csv의 내용을 dictionary 형태로 formatting한다.  \u0026gt; import csv \u0026gt; with open(\u0026#39;./resource/test1.csv\u0026#39;, \u0026#39;r\u0026#39;) as f: \u0026gt; reader = csv.DictReader(f) \u0026gt; print(reader) \u0026lt;csv.DictReader object at 0x000001DD1A8A2F70\u0026gt; \u0026gt; print(type(reader)) \u0026lt;class \u0026#39;csv.DictReader\u0026#39;\u0026gt; \u0026gt; print(dir(reader)) [\u0026#39;__class__\u0026#39;, \u0026#39;__delattr__\u0026#39;, \u0026#39;__dict__\u0026#39;, \u0026#39;__dir__\u0026#39;, \u0026#39;__doc__\u0026#39;, \u0026#39;__eq__\u0026#39;, \u0026#39;__format__\u0026#39;, \u0026#39;__ge__\u0026#39;, \u0026#39;__getattribute__\u0026#39;, \u0026#39;__gt__\u0026#39;, \u0026#39;__hash__\u0026#39;, \u0026#39;__init__\u0026#39;, \u0026#39;__init_subclass__\u0026#39;, \u0026#39;__iter__\u0026#39;, \u0026#39;__le__\u0026#39;, \u0026#39;__lt__\u0026#39;, \u0026#39;__module__\u0026#39;, \u0026#39;__ne__\u0026#39;, \u0026#39;__new__\u0026#39;, \u0026#39;__next__\u0026#39;, \u0026#39;__reduce__\u0026#39;, \u0026#39;__reduce_ex__\u0026#39;, \u0026#39;__repr__\u0026#39;, \u0026#39;__setattr__\u0026#39;, \u0026#39;__sizeof__\u0026#39;, \u0026#39;__str__\u0026#39;, \u0026#39;__subclasshook__\u0026#39;, \u0026#39;__weakref__\u0026#39;, \u0026#39;_fieldnames\u0026#39;, \u0026#39;dialect\u0026#39;, \u0026#39;fieldnames\u0026#39;, \u0026#39;line_num\u0026#39;, \u0026#39;reader\u0026#39;, \u0026#39;restkey\u0026#39;, \u0026#39;restval\u0026#39;] ## __iter__ 확인 완료 \u0026gt; for c in reader: \u0026gt; print(c) {\u0026#39;Name\u0026#39;: \u0026#39;Afghanistan\u0026#39;, \u0026#39;Code\u0026#39;: \u0026#39;AF\u0026#39;} {\u0026#39;Name\u0026#39;: \u0026#39;횇land Islands\u0026#39;, \u0026#39;Code\u0026#39;: \u0026#39;AX\u0026#39;} {\u0026#39;Name\u0026#39;: \u0026#39;Albania\u0026#39;, \u0026#39;Code\u0026#39;: \u0026#39;AL\u0026#39;} {\u0026#39;Name\u0026#39;: \u0026#39;Algeria\u0026#39;, \u0026#39;Code\u0026#39;: \u0026#39;DZ\u0026#39;} {\u0026#39;Name\u0026#39;: \u0026#39;American Samoa\u0026#39;, \u0026#39;Code\u0026#39;: \u0026#39;AS\u0026#39;} {\u0026#39;Name\u0026#39;: \u0026#39;Andorra\u0026#39;, \u0026#39;Code\u0026#39;: \u0026#39;AD\u0026#39;} ## 위 내용을 Name과 Code로 나누고 싶으면?? \u0026gt; for c in readers: \u0026gt; for k, v in c.items() \u0026gt; print(k) Name Code Name Code Name Code Name Code Name Code Name Code \u0026gt; print(v) Afghanistan AF 횇land Islands AX Albania AL Algeria DZ American Samoa AS Andorra AD \u0026gt; print(k,v) Name Afghanistan Code AF Name 횇land Islands Code AX Name Albania Code AL Name Algeria Code DZ Name American Samoa Code AS Name Andorra Code AD  2. Write csv file (csv 파일 쓰기) \u0026gt; import csv \u0026gt; w = [[1, 2, 3], [4, 5, 6], [7, 8, 9], [10, 11, 12], [13, 14, 15], [16, 17, 18], [19, 20, 21]] \u0026gt; with open(\u0026#39;./resoucre/write1.csv\u0026#39;, \u0026#39;w\u0026#39;, encoding = \u0026#39;utf-8\u0026#39;) as f: \u0026gt; wt = csv.writer(f) \u0026lt;class \u0026#39;_csv.writer\u0026#39;\u0026gt; \u0026gt; for v in w \u0026gt;  # v를 wt에 작성한다. 하나의 list가 하나의 record가 된다. \u0026gt; wt.writerow(v) 1,2,3 4,5,6 7,8,9 10,11,12 13,14,15 16,17,18 19,20,21  dict의 key 값을 field명으로 활용해서 써보기 .writeheader: Write a row with the field names (as specified in the constructor) to the writer’s file object .writerow: Write the row parameter to the writer’s file object, formatted according to the current Dialect.  \u0026gt; import csv \u0026gt; w = [[1, 2, 3], [4, 5, 6], [7, 8, 9], [10, 11, 12], [13, 14, 15], [16, 17, 18], [19, 20, 21]] \u0026gt; with open(\u0026#39;./resource/write2.csv\u0026#39;, \u0026#39;w\u0026#39;, encoding = \u0026#39;utf - 8\u0026#39;) as f: \u0026gt;  # w의 list 성분이 3개의 성분을 가지고 있으므로, 3개를 입력 \u0026gt; fields = [\u0026#39;one\u0026#39;, \u0026#39;two\u0026#39;, \u0026#39;three\u0026#39;] \u0026gt; wt = csv.DictWriter(f, fieldnames = fields) \u0026gt;  # header write \u0026gt;  # header로 one, two, three가 작성된 상태다. \u0026gt; wt.writeheader() \u0026gt; for v in w: \u0026gt; wt.writerow({\u0026#39;one\u0026#39;: v[0], \u0026#39;two\u0026#39;:v[1], \u0026#39;three\u0026#39;:v[2]}) one,two,three 1,2,3 4,5,6 7,8,9 10,11,12 13,14,15 16,17,18 19,20,21  Reference  CSV란??  ","permalink":"http://jeha00.github.io/post/python_basic_21_filereadwrite_2/","summary":"with open as 를 사용하여 외부 csv 파일을 읽고, 쓰는 방법을 알아보자.","title":"[TIL] Python basic 21: csv.read, write"},{"content":"Intro   이번 chapter에서는 외부에서 수집하거나 작성한 어떠한 text 파일, csv 파일, json 같은 다양한 형식의 외부 파일들을 읽고 쓰는 작업을 알아본다.\n  이번 chapter에서 중요한 것은\n 첫 번째, 외부 resource를 파이썬에 list type으로 읽어와서 저장하고, list type으로 원하는 파일을 쓴다는 것  readlines 함수와 writelines 함수   두 번째, 사용한 resource는 반드시 close를 해야 한다. 그래서 with문을 사용한다.  close를 하는 이유는 하지 않을 경우 다음 코드를 사용할 때 원활하지 않을 수 있다.      1. Read file (파일 읽기)  파일을 읽고 쓰는 작업을 하기 위해 open 이란 함수를 사용한다. 이 함수에서 사용하는 몇 가지 용어와 경로의 두 종류에 대해 알아보자.  r: 읽기모드 (read) w: 쓰기모드 (write) a: 추가모드 (append) t: text 모드 (기본모드라 생략 가능) b: binary 모드 경로의 종류: 상대 경로와 절대 경로  상대 경로(../, ./): 점 하나는 현재 위치를, 점 두 개는 상위 폴더를 의미한다. 절대 경로: C:\\Django\\example..' 다른 컴퓨터에 다운을 받을 때는 절대 경로보다 상대 경로가 맞다. 그 이유는 경로가 절대적으로 같지 않기 때문이다.       외부에 있는 파일을 읽을 때는 먼저 함수를 사용하여 연결한 후, 내용을 읽는다. Encoding 이란 사람의 언어를 컴퓨터 언어로 암호화하는 걸 의미한다.  Ecoding의 한 방식이 \u0026lsquo;UTF-8\u0026rsquo; 이다. 원문이 무엇으로 인코딩되었는지를 알아야 파이썬으로 불러왔을 때 깨지지 않는다.   먼저 원하는 경로에 파일을 만들어놓은 후, 실습을 진행했다.  ## open(\u0026#39;경로\u0026#39;, \u0026#39;rt\u0026#39; \u0026#39;rb\u0026#39; \u0026#39;w\u0026#39; \u0026#39;a\u0026#39; \u0026#39;a\u0026#39;, A) # 1) 현재 경로를 기준으로 상대 경로로 입력한다. # 2) rt이지만, t는 기본값이므로 r만 입력한다. # 3) encoding 방식으로 UTF-8 사용 \u0026gt; f = open(\u0026#39;./resource/it_news.txt\u0026#39;, \u0026#39;r\u0026#39;, encoding = \u0026#39;UTF-8\u0026#39;) ## 인코딩 방식 확인 \u0026gt; print(f.encoding) UTF - 8 ## 파일 이름 \u0026gt; print(f.name) ./resource/it_news.txt ## 모드 확인 \u0026gt; print(f.mode) r ## 외부 파일 읽은 후, 변수에 할당하기 \u0026gt; content = f.read() \u0026gt; print(content) Right now gamers can pay just $1 for access to hundreds of titles across PC and Xbox via Microsoft Xbox Game Pass Ultimate service?but dont activate that insanely cheap one-month trial just yet. You can lock in up to three years of Xbox Game Pass Ultimate with that same dollar if you play your cards right. ## 사용 후 반드시 close 한다. \u0026gt; f.close()  open하여 사용 후, 반드시 close를 해야한다. 하지만, with 문을 사용하면 close를 하지 않아도, 저절로 반환하기 때문에 with문을 사용하자.  \u0026gt; with open(\u0026#39;./resource/it_news.txt\u0026#39;, \u0026#39;r\u0026#39;, encoding = \u0026#39;UTF-8\u0026#39;) as f: \u0026gt; c = f.read() \u0026gt; print(c) # it_news.txt 파일의 내용이 문자 하나 하나로 쪼개져서 list로 출력된다. \u0026gt; print(list(c))  read() 함수에 intger type의 인자를 넣으면, 입력한 값만큼의 Byte를 읽는다. 그리고, 또 실행하면 이어서 읽는다. 왜냐하면 cursor가 움직이기 때문이다. seek() 함수를 사용하여 이 cursor의 위치를 초기화할 수 있다.   \u0026gt; with open(\u0026#39;./resource/it_news.txt\u0026#39;, \u0026#39;r\u0026#39;, encoding=\u0026#39;UTF-8\u0026#39;) as f: \u0026gt; c = f.read(20) \u0026gt; print(c) Right now gamers can # 다시 처음부터 20Byte를 읽어오는 것이 아니라, 전 마지막 읽은 부분부터 시작한다. \u0026gt; c = f.read(20) \u0026gt; print(c) pay just $1 for acc # seek은 커서의 이동 위치를 말해준다. 0,0으로 이동하고 다시 20byte 만큼 읽겠다. \u0026gt; f.seek(0,0) \u0026gt; c = f.read(20) \u0026gt; print(c) Right now gamers can  readline 함수를 사용하여 한 줄 씩 읽기  \u0026gt; with open(\u0026#39;./resource/it_news.txt\u0026#39;, \u0026#39;r\u0026#39;, encoding=\u0026#39;UTF-8\u0026#39;) as f: \u0026gt; line = f.readline() \u0026gt; print(line) Right now gamers can pay just $1 for access to hundreds of titles across PC \u0026gt; line = f.readline() \u0026gt; print(line) and Xbox via Microsoft Xbox Game Pass Ultimate service?but dont  처음부터 다시 읽는 것이 아닌, 이어서 읽기 때문에 반복문을 통해서 처리하자. readlines 함수를 사용한다. 전체를 읽은 후, 라인 단위 리스트로 저장한다. 즉, 파일을 list로 만든다. list로 만들어 원하는 부분만 가져와 텍스트 처리를 할 수 있기 때문에, 반드시 알고 있어야 하는 함수다.  \u0026gt; with open(\u0026#39;./resource/it_news.txt\u0026#39;, \u0026#39;r\u0026#39;, encoding=\u0026#39;UTF-8\u0026#39;) as f: \u0026gt; cts = f.readlines() \u0026gt; for c in cts: \u0026gt; print(c, end=\u0026#39;\u0026#39;) Right now gamers can pay just $1 for access to hundreds of titles across PC and Xbox via Microsoft Xbox Game Pass Ultimate service?but dont activate that insanely cheap one-month trial just yet. You can lock in up to three years of Xbox Game Pass Ultimate with that same dollar if you play your cards right.  2. Write file (파일 쓰기)  없는 파일을 쓰고자 할 때도 연결하기 위해 open함수를 사용한다. write이기 때문에 t 말고 w를 입력한다.  ## contents1.txt 라는 파일 만들기 \u0026gt; with open(\u0026#39;./resources/contents1.txt\u0026#39;, \u0026#39;w\u0026#39;) as f: \u0026gt; f.write(\u0026#39;I love python/n\u0026#39;) ## 위 ./resources 경로로 contents1.txt 파일이 생성된다. 그 파일 안에 내용은 I love python이 있다.  a(append) 를 사용하여 내용 추가하기  \u0026gt; with open(\u0026#39;./resources/contents1.txt\u0026#39;, \u0026#39;a\u0026#39;) as f: \u0026gt; f.write(\u0026#39;I love python2\\n\u0026#39;) ## contents1.txt 파일 내용을 보면 다음과 같이 되어 있다. I love python I love python2  writelines 함수를 사용하여 line list를 파일에 작성하기  \u0026gt; with open(\u0026#39;./resource/content2.txt\u0026#39;, \u0026#39;w\u0026#39;) as f: \u0026gt; list = [\u0026#39;Orange\\n\u0026#39;, \u0026#39;Apple\\n\u0026#39;, \u0026#39;Banana\\n\u0026#39;, \u0026#39;Melon\\n\u0026#39;] \u0026gt; f.writelines(list) Orange Apple Banana Melon  terminal이 아닌 파일로 출력을 해주는 방법  \u0026gt; with open(\u0026#39;./resource/contents3.txt\u0026#39;, \u0026#39;w\u0026#39;) as f: \u0026gt; print(\u0026#39;Test Text Write!\u0026#39;, file=f) \u0026gt; print(\u0026#39;Test Text Write!\u0026#39;, file=f) \u0026gt; print(\u0026#39;Test Text Write!\u0026#39;, file=f) # contents3.txt 파일을 보면 다음과 같다. Test Text Write! Test Text Write! Test Text Write! # 위에 file = f 를 없애면 terminal로 출력된다.  ","permalink":"http://jeha00.github.io/post/python_basic_20_filewriteread_1/","summary":"with open() as 함수를 사용해서 외부 파일을 읽고, 작성하는 방법을 알아보겠다.","title":"[TIL] Python basic 20: with open as"},{"content":" 여러 외장 함수들 중 sys, pickle, os, time, random, webbrowser 에 대해 예제 실습으로 알아보겠다. 특히 sys, os, time은 훨씬 자주 사용되므로 중요하다. 외장함수는 import를 하는 것부터 시작한다. 이 포스팅의 목적은 외장 함수에는 이런 것들이 있다는 기록하기 위해서다. 해당 포스팅으로는 각 외장 모듈에 대한 내용이 부족하니, 추가적인 학습을 반드시 해서 TIL에 올리자.  1. sys   sys 모듈은 파이썬 인터프리터가 제공하는 변수와 함수를 직접 제어할 수 있게 해주는 모듈이다.\n  sys.argv는 명령행에 인수를 전달하도록 하는 명령어다.\n  \u0026gt; import sys ## module 파일이 있는 위치들이 출력된다. \u0026gt; print(sys.path) ## 강제 종료 함수다. 함부로 사용하지 않는다. # visual studio code에서는 작동되지 않는다. 해당 언어 shell에서 작동한다. \u0026gt; sys.exit()  2. pickle  pickle 모듈은 텍스트 상태의 데이터가 아닌 객체의 형태를 그대로 유지하면서, 파일에 저장하고 불러올 수 있게 하는 파이썬이 제공하는 모듈이다. 파이썬 객체를 파일에 저장하는 과정을 피클링(pickling)이라 하고, 파일에서 객체를 읽어오는 과정을 언피클링(unpickling)이라 한다. test.obj라는 파일이 binary 형식으로 작성된다. 이 test.obj에 pickle.dump() 명령어로 obj 변수 내용을 저장한다. 그리고 나서, pickle.load() 명령어로 test.obj 파일을 읽는다.  \u0026gt; import pickle # w: write , b: binary, r: read \u0026gt; f = open(\u0026#39;test.obj\u0026#39;, \u0026#39;wb\u0026#39;) \u0026gt; obj = {1: \u0026#39;python\u0026#39;, 2: \u0026#39;study\u0026#39;, 3: \u0026#39;basic\u0026#39;} \u0026gt; pickle.dump(obj, f) # 열고 나서 반드시 닫아야 한다. # 쓴 resource는 컴퓨터한테 반드시 반환해야 한다. \u0026gt; f.close() ## binary file은 컴퓨터가 처리하는 파일 형식이다. ## 사람이 알아보기 힘든 상태로, txt 파일은 이 binary 파일을 사람이 읽기 쉽게 만든 파일 형식이다. ## 그러면 이걸 어떻게 열 수 있을까?? \u0026gt; f = open(\u0026#34;test.obj\u0026#34;, \u0026#39;rb\u0026#39;) \u0026gt; data = pickle.load(f) \u0026gt; print(data) \u0026gt; f.close()  3. os  OS 모듈은 환경 변수나 디렉터리, 파일 등의 OS 자원을 제어할 수 있게 해주는 모듈이다.  \u0026gt; import os # 사용자의 운영체제 정보를 파이썬에게 넘겨준다. \u0026gt; print(os.environ) environ({{\u0026#39;ALLUSERSPROFILE\u0026#39;: \u0026#39;C:\\\\ProgramData\u0026#39;, \u0026#39;APPDATA\u0026#39;: C:\\\\Users\\\\rudtl\\\\AppData\\\\Roaming\u0026#39;, ....}) \u0026gt; print(os.environ[\u0026#39;USERNAME\u0026#39;]) rudtl  4. time  time 모듈은 시간과 관련된 모듈이다.  \u0026gt; import time ## 1970년 1월 1일 0시 0분 0초를 기준으로 지난 시간을 초 단위로 반환한다. \u0026gt; print(time.time()) 1646220813.7009172 ## 하지만 위 방식은 알아보기가 힘들다. # time.time이 반환한 시간을 사용하여 연도,월,일,시,분,초의 형태로 바꿔주는 함수다. \u0026gt; print(time.localtime(time.time())) time.struct_time(tm_year=2022, tm_mon=3, tm_mday=2, tm_hour=20, tm_min=41, tm_sec=0, tm_wday=2, tm_yday=61, tm_isdst=0) ## local.time 보다 더 간단히 표현하는 모듈이다. \u0026gt; print(time.ctime()) Wed Mar 2 20:42:50 2022 ## 원하는 형식으로 시간을 출력해주는 모듈이다. # Year, Month, Day, hour , Minute, Second \u0026gt; print(time.strftime(\u0026#39;%Y-%m-%d %H:%M:%S\u0026#39;, time.localtime(time.time()))) 2022-03-02 20:42:50 ## 시간 간격 발생 # 출력 간 delay를 1초로 한다. \u0026gt; for i in range(5): \u0026gt; print(i) \u0026gt; time.sleep(1) 0 1 2 3 4  5. random  random은 난수(규칙이 없는 임의의 수)를 발생시키는 모듈  \u0026gt; import random ## 0에서 1 사이의 아무 난수를 반환한다. \u0026gt; print(random.random()) ## 1에서 45 사이의 정수값을 랜덤으로 갖고 온다. \u0026gt; print(random.randint(1, 45)) ## 1에서 44 사이의 정수값을 랜덤으로 갖고 온다. \u0026gt; print(random.randrange(1, 45)) ## Iterable object의 argument의 순서를 섞어서 출력한다. # 출력할 때마다 순서가 바뀐다. \u0026gt; d = [1, 2, 3, 4, 5] \u0026gt; random.shuffle(d) \u0026gt; print(d) [2, 5, 3, 4, 1] [2, 4, 1, 3, 5] ... ## Iterable object의 argument들 중 무작위로 선택하는 함수 \u0026gt; d = [1, 2, 3, 4, 5] \u0026gt; c = random.choice(d) \u0026gt; print(c) 1 4 3 2  6. webbrowser  webbrowser는 본인 OS의 web browser를 실행한다.  \u0026gt; import webbrowser ## 기본 웹 브라우저를 사용하여 아래 url로 자동으로 이동한다. 이미 실행된 상태라면 기존에 있던 tab이 이동된다. \u0026gt; webbrowser.open(\u0026#34;https://google.com\u0026#34;) ## 기본 웹 브라우저에 새로운 탭이 생기면서 아래 url로 이동한다. \u0026gt; webbrowser.open_new(\u0026#34;https://google.com\u0026#34;)  Reference  라이브러리 pickling  ","permalink":"http://jeha00.github.io/post/python_basic_19_external_functions/","summary":"외장 함수를 실행하는 방법과 외장 함수의 여러 종류들을 알아보겠다.","title":"[TIL] Python basic 19: external functions"},{"content":" 내장 함수란 프로그래밍 언어의 라이브러리에(파이썬의 인터프리터에) 이미 등록되어 있는 함수를 말한다. 그래서 별도의 정의나 설치가 필요없다. 외장 내장 구분하는 건 중요하지 않고, 필요한 곳에 이미 파이썬에 내장된 함수를 찾아서 프로그램을 개발할 때, 적합한 어떤 위치에서 사용하는 게 중요하다. 예시를 사용하여 내장함수에 대해 알아보겠다. 아래에 예시로 사용하는 내장함수는 반드시 알고 있자.   abs(): 입력된 숫자형 데이터를 절대값으로 반환해주는 함수  \u0026gt; print(abs(-3)) 3  all() , any: interable 요소를 검사하여 성분이 참인지 거짓인지 검사하는 함수 (True or False) all() 은 안에 있는 요소가 논리 연산자 and처럼 다 True여야 True를 반환한다. any() 는 논리 연산자 or처럼 안에 있는 요소들 중 하나라도 True가 있으면 True다.  \u0026gt; print(all([1, 2, 3])) True \u0026gt; print(all([False, True])) False \u0026gt; print(any([False, True])) True \u0026gt; print(any([False, False])) False  chr(): 아스키 코드를 문자로 반환하는 함수 ord(): 문자를 아스키 코드로 반환하는 함수  \u0026gt; print(chr(67)) C \u0026gt; print(ord(\u0026#39;c\u0026#39;)) 67  enumerate(): index + Iterable 객체(list, tuple, dictionary, set)을 생성한다.  \u0026gt; for i, name in enumerate([\u0026#39;abc\u0026#39;, \u0026#39;bcd\u0026#39;, \u0026#39;eft\u0026#39;]): \u0026gt; print(i, name) 0 abc 1 bcd 2 efg  filter(): Iterable 객체를 지정한 함수 조건에 맞는 값만 추출한다. filter(function or None, iterable) \u0026ndash;\u0026gt; filter object  \u0026gt; def conv_positive(x): \u0026gt; return abs(x) \u0026gt; 2 # 위에서 지정한 함수 조건은 \u0026#39;conv_posotive\u0026#39; 에 의해서 주어지고, interable 데이터가 입력된다. \u0026gt; print(filter(conv_positive, [1, -3, 2, 0, -5, 6])) \u0026lt;filter object at 0x0000025A0B362FA0\u0026gt; \u0026gt; print(list(filter(conv_pos, [1, -3, 2, 0, -5, 6]))) [-3, -5, 6] ## 단 한 번 쓸 함수를 위해 위에처럼 정의하면 분량이 늘어난다. 이럴 때, lamda 함수를 사용한다. \u0026gt; print(list(filter(lambda x: abs(x) \u0026gt; 2, [1, -3, 2, 0, -5, 6])))  id(): 객체의 주소값(reference)를 반환한다. id(): Return the identity of an object.  \u0026gt; print(id(5)) 2144671066544 \u0026gt; print(id(float(4))) 2144671700368  len: 요소의 길이를 반환한다. len: Return the number of items in a container.  \u0026gt; print(len(\u0026#39;123456789\u0026#39;)) 9 \u0026gt; print(len([1,2,3,4,5,6,7])) 7  max: 입력된 iterable 자료형 중에 가장 큰 값을 반환한다. max: With a single iterable argument, return its biggest item. With two or more arguments, return the largest argument. min: max와 반대로 가장 작은 값을 반환한다.  \u0026gt; print(max([1,2,3])) 3 ## 오름차순 시, y가 제일 크다. \u0026gt; print(max(\u0026#39;python study\u0026#39;)) y \u0026gt; print(min([1,2,3])) 1 # blank가 제일 작은 값이라, 아무것도 없어보인다. \u0026gt; print(min(\u0026#39;python study\u0026#39;))  map: iterable 객체 요소를 지정한 함수를 실행 후 추출 map: map(func, *iterables) \u0026ndash;\u0026gt; map object  Make an iterator that computes the function using arguments from each of the iterables.   데이터 전처리 과정에서 많이 사용한다.  \u0026gt; def conv_abs(x): \u0026gt; return abs(x) \u0026gt; print(list(map(conv_abs,[1,-3,2,0,-5,6]))) [1, 3, 2, 0, 5, 6] ## 또는 위에 함수 정의를 하지 않고, 람다 함수를 사용한다. \u0026gt; print(list(map(lambda x:abs(x),[1,-3,2,0,-5,6]))) [1, 3, 2, 0, 5, 6]  pow : 제곱값 반환  \u0026gt; print(pow(2,10)) 1024  range: 반복가능한 객체(Iterable) 반환  \u0026gt; print(range(1,10,2)) range(1, 10, 2) \u0026gt; print(list(range(1,10,2))) [1, 3, 5, 7, 9] \u0026gt; print(list(range(0,-15,-1)) [0, -1, -2, -3, -4, -5, -6, -7, -8, -9, -10, -11, -12, -13, -14]  round: 반올림  ## 소수점 둘쨰자리에서 반올림한다. \u0026gt; print(round(6.5781, 2)) 6.58 \u0026gt; print(round(5.6)) 6  sum: 반복가능한 객체(Iterable) 합 반환  \u0026gt; print(sum([6, 7, 8, 9, 10])) 40 \u0026gt; print(sum(range(1,101))) 5050  type: 자료형의 type을 확인  \u0026gt; print(type(3)) \u0026lt;class \u0026#39;int\u0026#39;\u0026gt; \u0026gt; print(type({})) \u0026lt;class \u0026#39;dict\u0026#39;\u0026gt; \u0026gt; print(type(())) \u0026lt;class \u0026#39;tuple\u0026#39;\u0026gt; \u0026gt; print(type([])) \u0026lt;class \u0026#39;list\u0026#39;\u0026gt;  zip: Iterable 객체의 요소를 묶어서 tuple type으로 반환 zip: A zip object yielding tuples until an input is exhausted.  \u0026gt; print(list(zip([10,20,30],[40,50,777]))) [(10, 40), (20, 50), (30, 777)] # 짝이 맞는 것만 반환한다. # list 안에 tuple type의 argument가 담겨져있다. \u0026gt; print(list(zip([10,20,],[40,50,777]))) [(10, 40), (20, 50)] \u0026gt; print(type(list(zip([10,20,30],[40,50,777]))[0])) \u0026lt;class \u0026#39;tuple\u0026#39;\u0026gt; ","permalink":"http://jeha00.github.io/post/python_basic_18_built_in_fuctions/","summary":"내장 함수란 무엇이고, 내장 함수에서 자주 사용된 것들로 실습을 해보겠다.","title":"[TIL] Python basic 18: built-in functions"},{"content":"1. Exception(예외) and Error(에러)의 차이점  Exception(예외) 와 Error(에러)에 대해 설명하겠다. 예외는 무엇이고 에러는 무엇이다라고 외우진 말자. 예외를 에러의 범주에 포함하기도 하기 때문이다. 다만, 예외와 에러에 대한 틀을 잡기 위해 설명한다.   Exception(예외)는 우리가 작성한 로직에서 비정상적으로 발생한 사건(event)이다.  예외에는 예측이 가능한 예외와 예측이 불가능한 예외로 나눠진다. 예측 가능한 예외의 경우는 id 입력을 생각해보자. 영어로 입력해야하는데, 한글을 입력했을 경우 예외가 발생한다. 예측 불가능한 예외의 경우는 메모리의 용량이 부족해서, OS에서 발생한 에러, 하드웨어적인 에러 등등이 해당된다.   이 예외와 에러를 잘 처리해야 내가 의도한대로 작동하는 어플리케이션을 만들 수 있다.   2. Error의 종류 2.1 SyntaxError: 문법 오류 # 조건문의 헤더에 콜론(:)을 하지 않아 발생했다. \u0026gt; print(\u0026#39;error\u0026#39;) \u0026gt; print(\u0026#39;error\u0026#39;) \u0026gt; if True \u0026gt; pass SyntaxError: invalid syntax 2.2 TypeError: 자료형에 맞지 않는 연산을 수행하여 발생하는 오류 \u0026gt; x = [1,2] \u0026gt; y = (1,2) \u0026gt; z = \u0026#39;test\u0026#39; # list와 tuple은 합칠 수 없다. \u0026gt; print(x + y) TypeError: can only concatenate list (not \u0026#34;tuple\u0026#34;) to list # string과 list는 합칠 수 없다. \u0026gt; print(x + z) TypeError: can only concatenate list (not \u0026#34;str\u0026#34;) to list # tuple과 string은 합칠 수 없다. \u0026gt; print(y + z) TypeError: can only concatenate list (not \u0026#34;str\u0026#34;) to list 2.3 NameError: 참조가 없을 때 발생하는 오류 \u0026gt; a = 10 \u0026gt; b = 15 \u0026gt; print(c) NameError: name \u0026#39;c\u0026#39; is not defined 2.4 IndexError: index가 존재하지 않아 발생하는 오류 \u0026gt; x = [50, 70, 90] \u0026gt; print(x[1]) 70 \u0026gt; print(x[4] IndexError: list index out of range # 알고리즘에서 op을 사용할 때 발생할 수 있는 에러 \u0026gt; print(x.pop()) 50 \u0026gt; print(x.pop()) 70 \u0026gt; print(x.pop()) 90 \u0026gt; print(x.pop()) IndexError: pop from empty list 2.5 ValueError: 참조값이 없을 때 발생하는 오류 \u0026gt; x = [10, 50, 90] \u0026gt; x.remove(50) \u0026gt; print(x) [10, 90] \u0026gt; x.remove(200) ValueError: list.remove(x): x not in list 2.6 KeyError: 해당되는 key가 없을 때 발생하는 오류 # `key` 값으로 `value` 값을 출력할 때는 `.get()` 함수를 사용한다. \u0026gt; x = {\u0026#39;A\u0026#39;: \u0026#39;apple\u0026#39;, \u0026#39;B\u0026#39;: \u0026#39;Banana\u0026#39;, \u0026#39;C\u0026#39;: \u0026#39;coffee\u0026#39;} \u0026gt; print(x[\u0026#39;D\u0026#39;]) KeyError: \u0026#39;D\u0026#39; \u0026gt; print(x.get(\u0026#39;D\u0026#39;)) None 2.7 AttributeError: 모듈, 클래스에 있는 잘못된 속성을 사용하여 발생한 오류 \u0026gt; import time \u0026gt; print(time.time2()) AttributeError: module \u0026#39;time\u0026#39; has no attribute \u0026#39;time2\u0026#39; 2.8 FileNotFoundError: 파일을 찾을 수 없을 때 발생하는 오류 \u0026gt; f = open(\u0026#39;test.txt\u0026#39;) FileNotFoundError: [Errno 2] No such file or directory: \u0026#39;test.txt\u0026#39; 2.9 ZeroDivisionError: 0으로 나눠서 발생하는 오류 \u0026gt; print(100 / 0) ZeroDivisionError: division by zero  3. 예외 처리 (try ~ exception)  try: 에러가 발생할 가능성이 있는 코드 실행  이 에러는 내 코드가 정확해도, 방문한 사이트 서버나 여러 프로그램이 외부와 연결될 때, 문제가 있을 수 있기 때문이다. 그래서 외부적으로 문제가 발생해도 try ~ except로 대비한다.   except 에러명 1~n:  error가 발생했을 때 잡아내어 다음 코드로 넘어가도록 해준다. 여러 개 가능하다. 어떤 Error만 잡을지 정할 수 있다. 모든 error 잡아내기  except Exception:은 모든 예외의 부모격이라 모든 error를 잡아낸다. except: 또한, 모든 error을 잡아낸다. 하지만, 정확히 어떤 error가 발생했는지 알 수 없다. 정확히 어떤 error가 발생했는지 알아야 로그를 남길 때 정확히 남길 수 있다.   예제 3에서처럼 예제 2에서 alias를 줘서 except Exception as e 와 print(e) 을 사용하여, 대략적인 error 내용을 확인하여 출력하도록 할 수 있다.   else: try block에 에러가 없을 경우 실행한다.  정상적으로 흘러갈 때 실행된다. for ~ else 에서도 for문에 break를 만나지 않으면 else가 실행했듯이, except를 만나지 않으면 실행된다.   finally: 에러발생 유무와 상관없이 무조건 실행된다.  error 발생 유무에 상관없이 항상 실행해줘야 하는 구문으로 finally를 사용한다. 예를 들어 error가 발생했을 경우, 연결된 메모리를 끊어줘야 메모리가 새지 않기 때문에 finally를 통해서 실행한다.    ## 예제 1 ## error 발생하지 않는 코드 \u0026gt; name = [\u0026#39;Kim\u0026#39;, \u0026#39;Lee\u0026#39;, \u0026#39;Park\u0026#39;] \u0026gt; print(name.index(\u0026#39;Kim\u0026#39;)) \u0026gt; try : \u0026gt; z = \u0026#39;Kim\u0026#39; \u0026gt; x = name.index(z) \u0026gt; print(\u0026#39;{} Found it! {} in name\u0026#39;.format(z, x + 1)) # error 중 ValueError 만 잡는다. # error 처리 시, 이렇게 error의 정확한 유형대로 잡아내느 것이 제일 좋은 case다. \u0026gt; except ValueError: \u0026gt; print(\u0026#39;Not found it! - Occurred ValueError!\u0026#39;) # error가 발생되지 않았으므로 else 구문이 작동된다. \u0026gt; else: \u0026gt; print(\u0026#39;Ok! else.\u0026#39;) \u0026gt; print(\u0026#39; \u0026#39; ) 0 Kim Found it! 1 in name Ok! else. ## 예제 2 # error 발생 코드 # error가 발생했어도 except로 잡아냈기 때문에 else 구문을 출력된다. # 그리고, 그 다음 코드를 계속해서 실행한다. print(\u0026#39;pass\u0026#39;)가 출력된 걸 확인할 수 있다. # 또한, 예제 1에서의 ValueError를 지웠기 때문에 모든 Error를 잡아낸다. # 하지만, 그래서 어떤 Error를 잡았는지 정확히 알 수 없다. \u0026gt; name = [\u0026#39;Kim\u0026#39;, \u0026#39;Lee\u0026#39;, \u0026#39;Park\u0026#39;] \u0026gt; try: \u0026gt; z = \u0026#39;Cho\u0026#39; \u0026gt; x = name.index(z) \u0026gt; print(\u0026#39;{} Found it! {} in name\u0026#39;.format(z, x + 1)) # except Exception: \u0026gt; except: \u0026gt; print(\u0026#39;Not found it! - Occurred Error!\u0026#39;) \u0026gt; else: \u0026gt; print(\u0026#39;Ok! else.\u0026#39;) \u0026gt; \u0026gt; print(\u0026#39;pass\u0026#39;) Not found it! - Occurred Error! pass ## 예제 3 # 예제 2를 보완한 코드 \u0026gt; name = [\u0026#39;Kim\u0026#39;, \u0026#39;Lee\u0026#39;, \u0026#39;Park\u0026#39;] \u0026gt; try: \u0026gt; z = \u0026#39;Cho\u0026#39; \u0026gt; x = name.index(z) \u0026gt; print(\u0026#39;{} Found it! {} in name\u0026#39;.format(z, x + 1)) # 예제 2와 달리 추가된 부분 \u0026gt; except Exception as e: \u0026gt; print(e) # \u0026gt; print(\u0026#39;Not found it! - Occurred Error!\u0026#39;) \u0026gt; else: \u0026gt; print(\u0026#39;Ok! else.\u0026#39;) # 예외 유무에 상관없이 finally는 실행된다. \u0026gt; finally: \u0026gt; print(\u0026#39;Ok! finally\u0026#39;) \u0026#39;Cho\u0026#39; is not in list Not found it! - Occurred Error! Ok! finally  error를 일부러 발생시킨 경우를 생각해보자. 언제 일부러 error를 발생시킬까?? 여기서 error란 Python에서 발생시킨 게 아니라, 설계자가 회사에서 요구하는 논리상 알기 위해서 일부러 발생시킨 error를 말한다. 아래 코드로 설명을 하자면 a가 Kim이 아니라면 이는 파이썬 내에 ValueError가 발생된 것이 아니다. 하지만 회사에서 Kim이 아닌 경우에 대해 알기 위해서 error를 발생시켰다. 이를 토대로 언제 Kim이 아닌지 역으로 분석할 수 있다.  ## error 발생 X \u0026gt; name = [\u0026#39;Kim\u0026#39;, \u0026#39;Lee\u0026#39;, \u0026#39;Park\u0026#39;] \u0026gt; try: \u0026gt; a = \u0026#39;Park\u0026#39; \u0026gt; if a == \u0026#39;Park\u0026#39;: \u0026gt; print(\u0026#39;OK! Pass!\u0026#39;) \u0026gt; else: \u0026gt; raise ValueError \u0026gt; except ValueError: \u0026gt; print(\u0026#39;Occurred! Exception!\u0026#39;) \u0026gt; else: \u0026gt; print(\u0026#39;Ok! else!\u0026#39;) OK! Pass! Ok! else! ## error 발생 O \u0026gt; name = [\u0026#39;Kim\u0026#39;, \u0026#39;Lee\u0026#39;, \u0026#39;Park\u0026#39;] \u0026gt; try: \u0026gt; a = \u0026#39;Park\u0026#39; \u0026gt; if a == \u0026#39;Kim\u0026#39;: \u0026gt; print(\u0026#39;OK! Pass!\u0026#39;) \u0026gt; else: \u0026gt; raise ValueError \u0026gt; except ValueError: \u0026gt; print(\u0026#39;Occurred! Exception!\u0026#39;) \u0026gt; else: \u0026gt; print(\u0026#39;Ok! else!\u0026#39;) Occurred! Exception!  a에는 \u0026lsquo;Park\u0026rsquo;가 할당되었다. \u0026lsquo;Kim\u0026rsquo;이 아니기 때문에, 일부러 ValueError를 발생시켰다. 그래서 except ValueError 문이 실행이 되어 print문이 출력되었다. 일부러 Error를 일으키고, ErrorType도 정할 수 있다는 걸 알고 있자.  ","permalink":"http://jeha00.github.io/post/python_basic_17_try_exception/","summary":"Error의 종류와 예외 처리문에 대해 알아보고, 일부러 에러를 일으키는 이유와 방법에 대해 알아보겠다.","title":"[TIL] Python basic 17: try ~ exception"},{"content":"1. Pacakge 구조  Package는 module의 묶음을 의미하며, 폴더에 담아 관리한다. 그러면 이 pacakge를 불러와서 사용하기 위해서는 2가지 방법이 있다.  첫 번째 방법: 현재 경로를 기준으로 상대 경로 개념을 사용하여, module 경로를 직접 입력하여 사용하는 방식 두 번째 방법: import와 from을 사용하는 방식   경로 이동: cd .. 을 하면 상위 directory로 이동된다. 다 같이 여러명과 project를 진행한다면 위 방법 2가지 보다는 컴퓨터 공용 위치에 package 파일들을 두고, sys.path 또는 환경설정에서 경로를 설정하는 방법을 사용하자.   2. 패키지 경로 및 패키지 함수 실행 2.1 패키지 경로 와 inspect.getfile 함수  예제를 설명하기에 앞서 module로 사용할 package인 module1.py 와 module2.py의 위치는 다음과 같다. __init__.py 파일도 기억해놓자.  sub ├─sub1 │ │─ module1.py │ │─ __init__.py │ └─ __pycache__ ├─sub2 │ │─ module2.py │ │─ __init__.py │ └─__pycache__ └─__pycache__  그리고 module 파일인 module1.py와 module2.py의 내부 코드는 다음과 같다. inspect 함수는 파이썬의 객체들로부터 유용한 정보를 얻고자 할 때 사용하는 함수다.  inspect: get useful imformation from live Python objects   inspect 에 의해 제공되는 함수가 .getfile 이다. .getfile은 object가 어느 위치에 있는지 알고자 할 때 사용한다. .currentframe 은 실행 중인 파일의 이름과 경로를 보여준다.  ## module1.py \u0026gt; import sys \u0026gt; import inspect # from ..sub2 import module2 \u0026gt; def mod1_test1(): \u0026gt; print (\u0026#34;Module1 -\u0026gt; Test1\u0026#34;) \u0026gt; print(\u0026#34;Path : \u0026#34;, inspect.getfile(inspect.currentframe())) \u0026gt; def mod1_test2(): \u0026gt; print (\u0026#34;Module1 -\u0026gt; Test2\u0026#34;) \u0026gt; print(\u0026#34;Path : \u0026#34;, inspect.getfile(inspect.currentframe())) # 만약 inspect.currentframe()만 입력하면 다음과 같이 뜬다. # \u0026lt;frame at 0x00000296CE1BB7C0, file c:\\\\Users ~~ \\module1.py, line 9, code mod1_test1\u0026gt; # 파일 경로와, 파일 내의 몇 번째 줄인지까지 확인할 수 있다. # 하지만, insepct.getfile(inspect.currentframe())) 을 입력하면 다음과 같이 뜬다. # c:\\Users\\ ~ sub\\sub1\\module1.py # 경로만 출력된다. # 코드 경로를 넘어서 더 상세한 위치를 알고 싶다면 `inspect.currentframe()`을 사용해야겠다. ## module2.py \u0026gt; import sys \u0026gt; import inspect \u0026gt; def mod2_test1(): \u0026gt; print (\u0026#34;Module2 -\u0026gt; Test1\u0026#34;) \u0026gt; print(\u0026#34;Path : \u0026#34;, inspect.getfile(inspect.currentframe())) \u0026gt; def mod2_test2(): \u0026gt; print (\u0026#34;Module2 -\u0026gt; Test2\u0026#34;) \u0026gt; print(\u0026#34;Path : \u0026#34;, inspect.getfile(inspect.currentframe())) 2.2 패키지 함수 실행하기: 2가지 방법   그러면 패키지를 불러오는 방법 2가지에 대해 알아보자.\n  폴더명을 입력하고 점.을 입력하면 입력했던 폴더명의 하위 object가 뜬다.\n 폴더, 파일, method 등등이 뜬다.     첫 번째 방법의 장단점  경로를 하나 하나 입력하는 방법이다. 단점:  경로가 너무 다르면 입력해야할 경로가 너무 길어진다. 그래서 현재 경로와 같을 경우에 사용한다. 경로가 길어질 경우를 대비해서 from을 사용한다. (두 번째 방법)   장점:  sys.path.append() 함수로 경로를 추가하지 않아도 불러올 수 있다.      ## 첫 번째 방법 \u0026gt; sub.sub1.module1.mod1_test1() \u0026gt; sub.sub2.module2.mod2_test1() # 또는 \u0026gt; import sub.sub1.module1 \u0026gt; import sub.sub2.module2  두 번째 방법: from ~ import ~ as 사용하기  첫 번째보다 경로를 짧게 입력할 수 있기 때문에, 깔끔하고 가독성이 좋다. from을 통해 패키지의 정확한 경로를 찾아서 사용하고 싶은 모듈만 import 하여 사용한다. as는 alias로 별명, 별칭이다. as를 설정하면 모듈 이름을 다 입력할 필요 없이, as만 입력하면 된다.    ## 두 번째 방법 \u0026gt; from sub.sub1 import module1 \u0026gt; from sub.sub1 import module2 as m2 # 호출하기 \u0026gt; module1.mod1_test1() Module1 -\u0026gt; Test1 Path : c:\\Users\\ ~ \\sub\\sub1\\module1.py \u0026gt; module1.mod1_test2() Module1 -\u0026gt; Test2 Path : c:\\Users\\ ~ \\sub\\sub1\\module1.py # 아래 2가지는 서로 같다. \u0026gt; module2.mod2_test1() \u0026gt; m2.mod2_test1() Module2 -\u0026gt; Test1 Path : c:\\Users\\ ~ \\sub\\sub2\\module2.py  from ~ import * 로 모든 module 파일을 가져올 수도 있다. * 이 모든 파일을 의미한다. 하지만 이런 경우 안쓰는 파일을 가져온다. 현재 HW의 발달로 눈에 띄는 성능 저하는 드러나지 않지만, 이런 것들이 쌓이면 run time에서 메모리를 잡아먹는다. 항상 메모리를 신경쓰는 습관을 가지자.  \u0026gt; from sub.sub1 import * \u0026gt; from sub.sub2 import * \u0026gt; module1.mod1_test1() Module1 -\u0026gt; Test1 Path : c:\\Users\\ ~ \\sub\\sub1\\module1.py \u0026gt; module1.mod1_test2() Module1 -\u0026gt; Test2 Path : c:\\Users\\ ~ \\sub\\sub1\\module1.py \u0026gt; module2.mod2_test1() Module2 -\u0026gt; Test1 Path : c:\\Users\\ ~ \\sub\\sub2\\module2.py \u0026gt; module2.mod2_test2() Module2 -\u0026gt; Test2 Path : c:\\Users\\ ~ \\sub\\sub2\\module2.py  3. __init__.py 가 존재하는 이유  __init__.py 파일은 파이썬에게 해당 폴더가 package로 인식하도록 해준다. __init__.py 이 없으면 파이썬은 그 폴더를 package로 인식하지 않는다. 하지만, Python 3.3 부터는 __init__.py 파일이 없어도 package로 인식한다. 그러면 __init__.py 을 작성할 필요가 없을까?? 아니다.  Python 3.3 이전 버전으로 의뢰가 들어올 경우가 있기 때문에, 그리고 하위 호환을 위해 작성한다. Python 3.3 이전 버전으로 작성하다가 새롭게 업데이트를 하면 거의 작동되겠지만, 예상치 못한 side effect가 있을 수 있기 때문에 작성한다.   package 폴더에 있는 pyecache 파일은 빠른 실행을 위해 파이썬 엔진이 만드는 것이기 때문에, 지워도 실행하면 다시 생긴다.   그러면 __init__.py 파일 내부를 살펴보자.  # sub1 폴더에는 module1.py 이 있다. # sub1 의 __init__.py 작성 명령어는 다음과 같다. \u0026gt; __all__ = [\u0026#39;module1\u0026#39;] # sub2 폴더에는 module2.py 이 있다. # sub2 의 __init__.py 작성 명령어는 다음과 같다. \u0026gt; __all__ = [\u0026#39;module2\u0026#39;]  아래 내용은 Python 3.3 이전 버전에 관한 내용이다. 이후부터는 필수가 아니다. __all__ = [ ] 에서 대괄호에 module 파일명이 적혀 있어야, 외부에서 import 할 때 해당 module 파일을 허가해준다. 이 list에 파일명이 다르면 작동할 수 없다. 파이썬이 import할 때, __init__을 먼저 검사하기 때문에, all에 없으면 error가 발생된다. Python 3.3부터는 __init__.py 가 필수가 아니어도, 아직도 많은 오픈 소스에는 __init__.py 가 존재한다.  ","permalink":"http://jeha00.github.io/post/python_basic_16/","summary":"package란 무엇인지, package의 경로와 함수를 어떻게 실행하는지, \u003cstrong\u003einit\u003c/strong\u003e.py가 존재하는 이유에 대해 알아보겠다.","title":"[TIL] Python basic 16: package"},{"content":"Module이란?? 그리고 Module 관련 함수  Module이란 하나의 파일 안에 함수, 변수, 클래스 등 파이썬 구성 요소 등을 모아놓아 공용적으로 쓸 수 있도록 만든 파일 타인으로부터 웹으로부터 가져다 사용한다. 이 Module 파일이 모여지면 Package가 된다. 외부 module을 사용하기 위해서는 import 를 사용한다. module 을 사용하기 위해서, 사용하기 전에 모듈파일이 있는 경로를 추가해야한다. sys.path는 영구적으로 경로를 등록하는 것이 아닌 일시적으로 등록하는 방법이다. 영구적으로 등록하고 싶으면 환경 변수에 있는 python path에 추가하기  \u0026gt; import math \u0026gt; print(math.pi) 3.1415926535 # random은 0부터 1 사이의 난수를 출력한다. \u0026gt; import random \u0026gt; random.random()) 0.71924824 ## import 된 module 파일의 module 타입을 알 수 있다. \u0026gt; import sys \u0026gt; print(sys) \u0026lt;module \u0026#39;sys\u0026#39; (built-in)\u0026gt; # built-in은 내장 파일을 말한다. # sys는 파이썬의 내장 모듈 파일임을 알 수 있다. ## Python 파일이 설치된 경로들이 출력된다. ## 이 경로들에 있는 파일을 파이썬이 가져다가 사용하는 것이 파이썬의 원리다. # 파이썬 모듈 파일들의 경로들이다. # 파이썬 내부에 있기 때문에 import로 가져다가 사용할 수 있다. \u0026gt; print(sys.path) [\u0026#39;c:\\\\Users\\\\rudtl\\\\Desktop\\\\Dev\\\\Python 강의\\\\Inflearn Original\\\\Level 1 입문_프로그래밍 시작하기\u0026#39;, \u0026#39;C:\\\\Users\\\\rudtl\\\\AppData\\\\Local\\\\Programs\\\\Python\\\\Python39\\\\python39.zip\u0026#39;, \u0026#39;C:\\\\Users\\\\rudtl\\\\AppData\\\\Local\\\\Programs\\\\Python\\\\Python39\\\\DLLs\u0026#39;, \u0026#39;C:\\\\Users\\\\rudtl\\\\AppData\\\\Local\\\\Programs\\\\Python\\\\Python39\\\\lib\u0026#39;, \u0026#39;C:\\\\Users\\\\rudtl\\\\AppData\\\\Local\\\\Programs\\\\Python\\\\Python39\u0026#39;, \u0026#39;C:\\\\Users\\\\rudtl\\\\AppData\\\\Local\\\\Programs\\\\Python\\\\Python39\\\\lib\\\\site-packages\u0026#39;] ## 모듈 경로 추가하기 # 추가하기 위해 모듈 경로의 데이터 타입을 확인한다. \u0026gt; print(type(sys.path)) \u0026lt;class \u0026#39;list\u0026#39;\u0026gt; # 경로를 추가하기 전에 밑에 경로로 동일한 명칭의 폴더를 만들어놔야 한다. # 끝에 경로가 추가된 걸 확인할 수 있다. \u0026gt; sys.path.append(\u0026#39;C:/math\u0026#39;) \u0026gt; print(sys.path) [\u0026#39;c:\\\\Users\\\\rudtl\\\\Desktop\\\\Dev\\\\Python 강의\\\\Inflearn Original\\\\Level 1 입문_프로그래밍 시작하기\u0026#39;, \u0026#39;C:\\\\Users\\\\rudtl\\\\AppData\\\\Local\\\\Programs\\\\Python\\\\Python39\\\\python39.zip\u0026#39;, \u0026#39;C:\\\\Users\\\\rudtl\\\\AppData\\\\Local\\\\Programs\\\\Python\\\\Python39\\\\DLLs\u0026#39;, \u0026#39;C:\\\\Users\\\\rudtl\\\\AppData\\\\Local\\\\Programs\\\\Python\\\\Python39\\\\lib\u0026#39;, \u0026#39;C:\\\\Users\\\\rudtl\\\\AppData\\\\Local\\\\Programs\\\\Python\\\\Python39\u0026#39;, \u0026#39;C:\\\\Users\\\\rudtl\\\\AppData\\\\Local\\\\Programs\\\\Python\\\\Python39\\\\lib\\\\site-packages\u0026#39;, \u0026#39;C:/math\u0026#39;] # 폴더를 만들었으면 module 파일을 이 폴더에 넣어놔야 한다. # \u0026#39;module_test` 란 이름으로 파이썬 파일을 만든다. # module 파일의 내용은 다음과 같다. \u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt; \u0026gt; def add(x, y): \u0026gt; return x + y \u0026gt; def subtract(x, y): \u0026gt; return x - y \u0026gt; def multiply(x, y): \u0026gt; return x * y \u0026gt; def divide(x , y): \u0026gt; return x / y \u0026gt; def power(x, y): \u0026gt; return x ** y \u0026gt; print(\u0026#39;-\u0026#39; * 15) \u0026gt; print(\u0026#39;called! inner!\u0026#39;) \u0026gt; print(add(5,5)) \u0026gt; print(subtract(15,5)) \u0026gt; print(multiply(5,5)) \u0026gt; print(divide(10,2)) \u0026gt; print(power(5,3)) \u0026gt; print(\u0026#39;-\u0026#39; * 15) \u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt; ## import를 실행할 파일로 돌아온 후, import 를 실행한다. \u0026gt; import module_test ## import가 되자마다 바로 명령어들이 실행된다. --------------- called! inner! 10 10 25 5.0 125 --------------- ## import된 module 내의 함수를 사용해보기 \u0026gt; import module_test \u0026gt; print(test_module.power(10, 3)) --------------- called! inner! 10 10 25 5.0 125 --------------- 1000  위와 같은 방식은 module을 외부에서 가져오는 사람들에게 편의성이 좋지 않다.    called! innter! 출력을 방지하기 위해서 print 문을 삭제하거나 주석처리를 하는 방법을 사용할 수도 있다.\n  하지만, python에서는 이에 대해 다른 방법을 만들어놨다. 예약어를 사용하여 아래 2가지로 나눠서 실행할 수 있다.\n 다른 곳에서 외부적으로 import를 할 경우 자기 자신을 스스로 실행할 경우    if __name__ == \u0026quot;__main__\u0026quot;: 을 추가한다.\n 이 명령어는 해당 모듈이 import 된 경우가 아니라, 인터프리터에서 직접 실행된 경우에만 if 문 이하의 코드를 돌리라를 명령이다.    module 파일에 아래 코드를 추가한다.\n  ## __name__ 사용 \u0026gt; if __name__ == \u0026#34;__main__\u0026#34;: \u0026gt; print(\u0026#39;-\u0026#39; * 15) \u0026gt; print(\u0026#39;called! __main__\u0026#39;) \u0026gt; print(add(5,5)) \u0026gt; print(subtract(15,5)) \u0026gt; print(multiply(5,5)) \u0026gt; print(divide(10,2)) \u0026gt; print(power(5,3)) \u0026gt; print(\u0026#39;-\u0026#39; * 15)  main은 실행되는 대상을 의미한다. import를 하면 바로 실행되지 않는다. 왜냐면 실행되는 대상이 아니기 때문이다. 하지만, module 파일에서 인터프리터로 직접 실행하면, 실행대상이기 때문에 출력된다. import 한 파일에서는 명령어를 입력하면 실행된다.  \u0026gt; import module_test \u0026gt; print(module_test.power(10,3)) 1000  그래서 바로 실행되지 않도록 if __name__ == \u0026quot;__main__\u0026quot;놔둔다.   ","permalink":"http://jeha00.github.io/post/python_basic_15/","summary":"Module이란 무엇인지, Module을 어떻게 사용하는지, Module 관련 함수에 대해 알아본다.","title":"[TIL] Python basic 15: module"},{"content":"Intro  OOP를 요약하여 간단히 핵심만 짚고, 이 이론을 바탕으로 python에서 class와 instance를 구현하겠다.  1. OOP란?  OOP : Object Oriented Programming으로, 객체 지향 프로그래밍이라 한다. Object(객체) : 소프트웨어로 구현할 대상 OOP의 특징  Encapsulation(캡슐화) : attribute 와 method를 하나로 묶어서 객체로 구성하는 것   OOP의 이점  눈에 보이는 사물들을 객체화할 수 있다 == 소프트웨어로 구현할 수 있다 Encapsulation(캡슐화)를 통해서 주변에 악영향 (side effect)을 최소화할 수 있다.  이를 Infomation hiding(정보 은폐)이라 한다.   class를 통해 만들기 때문에 코드의 재사용성이 용이하다. =\u0026gt; 경제적이다.  코드의 개선, 수정이 용이하다. 버그가 발생했을 때 유지보수 또한 용이하다.     하지만, OOP가 항상 빠르진 않다. 경우에 따라서는 객체 지향보다 절차 지향이 더 빠른 퍼포먼스를 가질 수 있으므로, 객체 지향과 절차 지향을 적절히 섞어 사용하자.  절차 지향 : 위에서부터 아래로 실행하는 것     2. Class와 instatnce의 차이  눈에 보이는 실체들 중에서 소프트웨어로 구현할 대상을 선정한다. 소프트웨어로 구현할 대상을 객체(Object)라 한다. 그리고, 이 객체(Object)를 class라는 틀을 통해서 소프트웨어적으로 묘사한 것을 instance라 한다. 그렇기 때문에 instance는 객체(Object)라는 개념에 포함된다.   Class variable(클래스 변수) 는  직접 접근이 가능하다. 클래스 변수는 공유된다. == 모든 인스턴스에서 동일하게 가지고 있는 것   instance variable(인스턴스 변수) 는  self가 붙은 것들이 instance varible(인스턴스 변수)다. 인스턴스화된 변수로 접근이 가능하다. 객체마다 별도로 존재한다. 위에 설명한대로 namespace라는 그 인스턴스만의 공간을 별도로 갖고 있어서, namespace를 통해 확인한다.    2.1 Class 만들기  class 만들기 위한 상황  애완견 용품에서 사용하는 소프트웨어를 개발한다고 가정하자. 개의 종은 매우 다양하기 때문에, 개의 종이 추가될 때마다 변수를 입력한다면 그 양이 매우 많아지고, 가독성도 떨어진다. 하지만, 클래스를 이용한다면 눈에 보이는 애완견 실체를 클래스 형태로 구성해서 instance로 만들 수 있다.     class를 만들어보자. __init__은 파이썬에서 클래스가 초기화될 때, 반드시 호출되는 함수다.  ## class 만들기 # class라는 예약어로 class를 만들기 시작한다. # Dog라는 class를 생성한다. # 파이썬의 모든 class는 object를 상속받기 때문에, 선언 방법은 자유롭다. \u0026gt; class Dog(): # class Dog 도 가능하다. \u0026gt;  ## 클래스 변수 지정 \u0026gt;  # 클래스 변수는 모든 인스턴스에서 동일하다. \u0026gt; species = \u0026#34;firstdog\u0026#34; \u0026gt; \u0026gt;  # 모든 class는 초기화 method 및 인스턴스 속성을 가질 수 있다. \u0026gt;  # self 후에, 인스턴스에 사용할 변수 속성들을 입력한다. \u0026gt; def __init__(self, name, age): \u0026gt;  # 초기화 method를 입력하고 나서, 입력한 인스턴스 속성들에 정확히 mapping 한다. \u0026gt; self.name = name \u0026gt; self.age = age 2.2 Class 호출하기  class 정보를 호출해보자.  ## class 정보 호출하기 \u0026gt; print(Dog) \u0026lt;class \u0026#39;__main__.Dog\u0026#39;\u0026gt; # 클래스가 코드로 구현된 걸 확인할 수 있다. 2.3 인스턴스화하기  인스턴스화 == class를 통해 구현된 instance를 변수에 할당하여 사용하도록 한다. 즉, instance는 변수에 할당하여 활용될 수 있다. 변수에 할당했기 때문에, 메모리에 올라가고 id값을 받는다. 각 instance는 동일한 속성값을 가져도, 파이썬에게는 전혀 다른 객체로 간주된다. 인스턴스화한 것은 모두 다 다른 id값을 가진다.  ## 인스턴스화 # 할당될 변수 = 클래스 이름(instance 속성들) \u0026gt; a = Dog(\u0026#34;mikky\u0026#34;, 2) \u0026gt; b = Dog(\u0026#34;baby\u0026#34;, 3) \u0026gt; c = Dog(\u0026#34;mikky\u0026#34;, 2) # 모두 다른 id값을 가진다. \u0026gt; print(a == c, id(a), id(b), id(c)) False 2542532857088 2542532856992 2542532856560 2.4 namespace 확인하기  namespace 확인하기 namespace 란  객체를 인스턴스화 할 때, instance의 속성들이 dictionary 형태로 저장되는 공간으로, instance들이 가지고 있는 속성들을 확인할 수 있다.   class는 하나지만, 서로 다른 속성들을 확인할 수 있다. instance만의 공간이다. instance의 namespace를 확인할 때는 __dict__ 를 사용한다.  ## namespace 확인하기 \u0026gt; print(\u0026#39;dog1\u0026#39;, a.__dict__) \u0026gt; print(\u0026#39;dog2\u0026#39;, b.__dict__) dog1 {\u0026#39;name\u0026#39;: \u0026#39;mikky\u0026#39;, \u0026#39;age\u0026#39;: 2} dog2 {\u0026#39;name\u0026#39;: \u0026#39;baby\u0026#39;, \u0026#39;age\u0026#39;: 3} 2.5 class 속성, instance 속성 확인하기  Class variable(클래스 변수) 는  직접 접근이 가능하다. 클래스 변수는 공유된다. == 모든 인스턴스에서 동일하게 가지고 있다.   instance variable(인스턴스 변수) 는  self가 붙은 것들이 instance varible(인스턴스 변수)다. 인스턴스화된 변수로 접근이 가능하다. 객체마다 별도로 존재한다. 위에 설명한대로 namespace라는 그 인스턴스만의 공간을 별도로 갖고 있어서, namespace를 통해 확인한다.     클래스 변수에 접근하기  ## 클래스로 직접 접근하기 \u0026gt; print(Dog.species) firstdog ## 인스턴스화된 변수를 통해서 접근하기 \u0026gt; print(a.species) firstdog \u0026gt; print(b.species) firstdog # 직접 접근이 가능하며, 하나의 값을 공유한다는 걸 알 수 있다.  instance 변수에 접근하기  ## 인스턴스화된 변수를 통해서 instance 속성에 접근하기 # a와 b를 인스턴스화했기 때문에 a와 b로 접근이 가능하다. \u0026gt; print(\u0026#39;{} is {} and {} is {}\u0026#39;.format(a.name, a.age, b.name, b.age)) mikky is 2 and baby is 3 \u0026gt; if a.species == \u0026#39;firstdog\u0026#39;: \u0026gt; print(\u0026#39;{0} is a {1}\u0026#39;.format(a.name, a.species)) mikky is a firstdog   위 예제들을 통해서 class의 장점을 다시 한 번 확인할 수 있다.\n  class의 장점\n class 하나를 만들어놓고 찍어내듯이 사용할 수 있다. instance만의 공간도 있고, 공유하는 공간이 있다. 그래서 코드의 재사용성이 좋다는 것이다. 코드의 재사용성이 좋다는 의미는 더 구체적으로 말하자면  객체지향에 입각하여 불필요한 중복을 방지한다. 깔끔한 코드를 통해 프로그램 개발을 할 수 있다. 생산성이 향상되고, 성능도 코드에 따라 좋아진다.       3. Self 의 이해: class method, instance method  __init__이 없으면 파이썬이 알아서 클래스를 만들 때 내부적으로 실행한다. instance 변수를 만들지 않고 사용할 것이기 때문에 __init__을 만들지 않는다. dir()로 변수 내부를 확인할 수 있다. 매개변수에 self 가 있으면 instance method다. 매개변수에 self가 없다면 class method 다. method 호출하기  class method 1가지 방법  주의 사항: 인스턴스화한 변수를 통해서 class method를 호출하면 error가 뜬다. class로 바로 호출하는 방법 (1-1 방법)   instance method 2가지 방법  첫 번째: 인스턴스화한 변수를 통해서 instance method를 호출하는 방법 (2-1 방법) 두 번째: 클래스로 접근하여 매개변수에 인스턴스를 넘겨주는 방법 (2-2 방법)      \u0026gt; class SelfTest: \u0026gt; def func1(): \u0026gt; print(\u0026#39;Func1 called\u0026#39;) \u0026gt; def func2(self): \u0026gt; print(id(self)) \u0026gt; print(\u0026#39;Func2 called\u0026#39;) ## 변수를 인스턴스화 한다. \u0026gt; f = SelfTest() ## dir로 변수 내부를 확인한다. \u0026gt; print(dir(f)) [\u0026#39;__class__\u0026#39;, \u0026#39;__delattr__\u0026#39;, \u0026#39;__dict__\u0026#39;, \u0026#39;__dir__\u0026#39;, \u0026#39;__doc__\u0026#39;, \u0026#39;__eq__\u0026#39;, \u0026#39;__format__\u0026#39;, \u0026#39;__ge__\u0026#39;, \u0026#39;__getattribute__\u0026#39;, \u0026#39;__gt__\u0026#39;, \u0026#39;__hash__\u0026#39;, \u0026#39;__init__\u0026#39;, \u0026#39;__init_subclass__\u0026#39;, \u0026#39;__le__\u0026#39;, \u0026#39;__lt__\u0026#39;, \u0026#39;__module__\u0026#39;, \u0026#39;__ne__\u0026#39;, \u0026#39;__new__\u0026#39;, \u0026#39;__reduce__\u0026#39;, \u0026#39;__reduce_ex__\u0026#39;, \u0026#39;__repr__\u0026#39;, \u0026#39;__setattr__\u0026#39;, \u0026#39;__sizeof__\u0026#39;, \u0026#39;__str__\u0026#39;, \u0026#39;__subclasshook__\u0026#39;, \u0026#39;__weakref__\u0026#39;, \u0026#39;func1\u0026#39;, \u0026#39;func2\u0026#39;] ## 인스턴스화된 f를 통해서 func1을 호출해보자. # func1에는 매개변수가 없는데, 1개가 넘어갔다는 걸 알 수 있다. \u0026gt; f.func1 TypeError: func1() takes 0 positional arguments but 1 was given ## 그러면 인스턴스화된 f를 통해서 func2를 호출해보자. (2-1 방법) \u0026gt; f.func2 2799723753424 Func2 called ## 그리고, f의 id 값을 호출해보자. \u0026gt; print(id(f)) 2799723753424 ## id(f.func2) 와 id(f) 가 같다는 걸 알 수 있다. ## 즉, self가 있는 method는 instance의 method인 걸 알 수 있다. ## f는 인스턴스화한 변수이기 때문에 func1로 넘어가는 것이 아닌, self가 있는 func2로 넘어간다. ## class method 호출하기 (1-1 방법) \u0026gt; SelfTest.func1() Func1 called ## 만약 역으로 클래스로 접근하여 func2를 호출한다면?? # func2가 요구하는 매개변수 1개를 놓쳐다는 error를 확인했다. \u0026gt; SelfTest.func2() Typeerror: func2() missing 1 required positional argument: \u0026#39;self\u0026#39; # 그러면 매개변수 1개를 입력해보자. (2-2 방법) \u0026gt; SelfTest.func2(f) 2332370018256 Func2 called  4. class, instance variable  class variable은 instance의 공통된 변수이기 때문에, instance의 namespace에 있을 것 같지만 없다. class variable은 class의 namespace에 있다. 하지만, 인스턴스화된 변수를 통해서 class variable에 접근한다면 namespace에서 찾을 수 없어도 class variable만 출력할 수 있다. instance attribute를 만들어서 사용할 것이기 때문에 __init__ 생성자를 사용한다. 그리고 생성자와는 반대로 소멸자를 사용했다. 소멸자: 객체가 소멸될 때 즉, 메모리에서 지워질 때 자동으로 호출되는 함수  \u0026gt; class Warehouse(): \u0026gt;  # class variable \u0026gt; stock_num = 0 \u0026gt; \u0026gt; def __init__(self, name): # 생성자 \u0026gt;  # instance variable \u0026gt;  # mapping \u0026gt; self.name = name \u0026gt; Warehouse.stock_num += 1 \u0026gt; \u0026gt; def __del__(self): # 소멸자 \u0026gt; Warehouse.stock_num -= 1 # user1 instance의 name을 Lee로 한다. \u0026gt; user1 = Warehouse(\u0026#39;Lee\u0026#39;) # user2 instance의 name을 Cho로 한다. \u0026gt; user2 = Warehouse(\u0026#39;Cho\u0026#39;) \u0026gt; print(Warehouse.stock_num) 2 \u0026gt; print(user1.name) Lee \u0026gt; print(user2.name) Cho ## instance의 namespace에서는 공통적으로 가지고 있는 클래스 변수를 찾을 수 없다. \u0026gt; print(user1.__dict__) {\u0026#39;name\u0026#39;: \u0026#39;Lee\u0026#39;} \u0026gt; print(user2.__dict__) {\u0026#39;name\u0026#39;: \u0026#39;Cho\u0026#39;} ## class의 namespace에서 찾을 수 있다. \u0026gt; print(Warehouse.__dict__) {\u0026#39;__module__\u0026#39;: \u0026#39;__main__\u0026#39;, \u0026#39;stock_num\u0026#39;: 2, \u0026#39;__init__\u0026#39;: \u0026lt;function Warehouse.__init__ at 0x000002DC6B59F8B0\u0026gt;, \u0026#39;__del__\u0026#39;: \u0026lt;function Warehouse.__del__ at 0x000002DC6B59F940\u0026gt;, \u0026#39;__dict__\u0026#39;: \u0026lt;attribute \u0026#39;__dict__\u0026#39; of \u0026#39;Warehouse\u0026#39; objects\u0026gt;, \u0026#39;__weakref__\u0026#39;: \u0026lt;attribute \u0026#39;__weakref__\u0026#39; of \u0026#39;Warehouse\u0026#39; objects\u0026gt;, \u0026#39;__doc__\u0026#39;: None} ## 그런데 \u0026lt;instance name\u0026gt;.\u0026lt;class variable name\u0026gt; 을 입력하면 `class variable`의 값이 출력된다. ## 이는 class의 namespace에서 python이 찾아서 출력한 것이다. \u0026gt; print(user1.stock_num) 2 ## 소멸자를 사용하여 instance를 삭제하면, stock_num이 1로 감소한 걸 확인할 수 있다. \u0026gt; del user1 \u0026gt; print(\u0026#39;after\u0026#39;, Warehouse.__dict__) {\u0026#39;__module__\u0026#39;: \u0026#39;__main__\u0026#39;, \u0026#39;stock_num\u0026#39;: 1, \u0026#39;__init__\u0026#39;: \u0026lt;function Warehouse.__init__ at 0x000002DC6B59F8B0\u0026gt;, \u0026#39;__del__\u0026#39;: \u0026lt;function Warehouse.__del__ at 0x000002DC6B59F940\u0026gt;, \u0026#39;__dict__\u0026#39;: \u0026lt;attribute \u0026#39;__dict__\u0026#39; of \u0026#39;Warehouse\u0026#39; objects\u0026gt;, \u0026#39;__weakref__\u0026#39;: \u0026lt;attribute \u0026#39;__weakref__\u0026#39; of \u0026#39;Warehouse\u0026#39; objects\u0026gt;, \u0026#39;__doc__\u0026#39;: None}  파이썬은 object의 이름을 다음 순서로 찾는다.  instance의 namespace -\u0026gt; class의 namespace -\u0026gt; super의 namespace super class: 해당 class의 상위 class를 의미     마지막 예제  ## Dog라는 class를 만든다. \u0026gt; class Dog(): \u0026gt;  # 클래스 변수 선언 \u0026gt; species = \u0026#39;Firstdog\u0026#39; \u0026gt;  # 생성자 및 인스턴스 속성 생성 그리고 mapping \u0026gt; def __init__(self, name, age): \u0026gt; self.name = name \u0026gt; self.age = age \u0026gt;  # 인스턴스 메소드 \u0026gt; def info(self): \u0026gt; return \u0026#39;{} is {} years old\u0026#39;.format(self.name, self.age) \u0026gt;  # 인스턴스 메소드 \u0026gt;  # sound는 호출 시에 입력한다. \u0026gt; def speak(self, sound): \u0026gt; return \u0026#39;{} says {}!\u0026#39;.format(self.name, sound) ## 인스턴스화 + 인스턴스 속성값 입력 \u0026gt; c = Dog(\u0026#39;july\u0026#39;, 4) \u0026gt; d = Dog(\u0026#39;Marry\u0026#39;, 10) ## 인스턴스 메소드 호출 \u0026gt; print(c.info()) july is 4 years old \u0026gt; print(d.info()) Marry is 10 years old ## 인스턴스 메소드 호출 + sound 매개변수 입력 \u0026gt; print(c.speak(\u0026#39;wal wal\u0026#39;)) july says wal wal! \u0026gt; print(d.speak(\u0026#39;Mung Mung\u0026#39;)) Marry says Mung Mung! ","permalink":"http://jeha00.github.io/post/python_basic_14/","summary":"OOP의 의미가 무엇인지, Class와 Instance의 차이가 무엇인지, self가 무엇을 의미하는지, class variable과 instance variable에 대해 알아본다.","title":"[TIL] Python basic 14: class"},{"content":"1. 사용자 입력 \u0026gt; name = input(\u0026#39;Enter Your Name : \u0026#39;) \u0026gt; grade = input(\u0026#39;Enter Your grade : \u0026#39;) \u0026gt; school = input(\u0026#39;Enter Your school : \u0026#39;) \u0026gt; print(name, grade, school) \u0026gt; print(type(name), type(grade), type(school)) Jeha A+ here \u0026lt;class \u0026#39;str\u0026#39;\u0026gt; \u0026lt;class \u0026#39;str\u0026#39;\u0026gt; \u0026lt;class \u0026#39;str\u0026#39;\u0026gt;  2. 형 변환 입력  input 함수는 기본 타입은 string 이다. string 외의 원하는 형태가 있다면 반드시 형 변환을 해야 한다.  \u0026gt; first_number = int(input(\u0026#34;Enter number1 : \u0026#34;)) Enter number1 : 20 \u0026gt; second_number = int(input(\u0026#34;Enter number2 : \u0026#34;)) Enter number2 : 15 \u0026gt; total = first_number + second_number \u0026gt; print(\u0026#34;fist_number + second_number : \u0026#34;, total) fist_number + second_number : 35 \u0026gt; float_number = float(input(\u0026#34;Enter a float number : \u0026#34;)) Enter a float number : 15 \u0026gt; print(\u0026#34;input float : \u0026#34;, float_number) input float : 15 \u0026gt; print(\u0026#34;input type : \u0026#34;, type(float_number)) \u0026lt;class \u0026#39;float\u0026#39;\u0026gt;  ","permalink":"http://jeha00.github.io/post/python_basic_13/","summary":"input을 통한 사용자 입력과 형 변환(type conversion) 입력을 알아본다.","title":"[TIL] Python basic 13: input"},{"content":"1. 함수 중요성  첫 번째 , 코드의 흐름을 원활히 할 수 있다.  요즘은 코드의 복잡도가 커지면서 코드 양이 매우 많아졌다. 그래서 이 코드를 일괄작성하기가 힘들다. 이에 대한 대책으로 단계별로 생각하여 각 단계마다 함수를 사용하여 개발을 원활하게 풀어갈 수 있다.   두 번째, 함수로 사용하면 코드의 재사용성이 향상된다.  하나의 기능을 각 소스마다 중복하여 집어 넣으면, 그 기능을 수정해야할 경우, 다 수정해야하는 번거로움이 있다. 이런 것들이 비효율적이기 때문에, 함수로 만들면 한 번의 수정으로 다 수정할 수 있다.   세 번째, 코드의 안정성이 좋아진다.  그 이유는 개발자가 자신이 담당하는 함수에만 집중할 수 있기 때문에, 함수 이외의 부분과 나눠서 생각할 수 있다.     2. 함수 선언 및 사용   함수에서 return 사용하지 않으면\n print로 출력할 수 없다. unpacking을 사용할 수 없다.    여러 값을 return 으로 반환하는 것을 다중 반환이라 한다.\n  ## return 명령어가 없을 경우 \u0026gt; def func_mul(x): \u0026gt; y1 = x * 10 \u0026gt; x1 = func_mul(10) \u0026gt; print(x1, type(x1)) None \u0026lt;class \u0026#39;NoneType\u0026#39;\u0026gt; # 출력할 수 없다. ## return 명령어가 있을 경우 \u0026gt; def func_mul(x): \u0026gt; y1 = x * 10 \u0026gt; return y1 \u0026gt; x1 = func_mul(10) \u0026gt; print(x1) 100 ## No return and unpacking \u0026gt; def func_mul1(x): \u0026gt; y1 = x * 10 \u0026gt; y2 = x * 20 \u0026gt; y3 = x * 30 # unpacking \u0026gt; x1, x2, x3 = func_mul1(10) \u0026gt; print(x1, x2, x3) TypeError: cannot unpack non-iterable NoneType object # 다중 반환 확인하기 \u0026gt; def func_mul1(x): \u0026gt; y1 = x * 10 \u0026gt; y2 = x * 20 \u0026gt; y3 = x * 30 \u0026gt; return y1, y2, y3 # unpacking \u0026gt; x1, x2, x3 = func_mul1(10) \u0026gt; print(x1, x2, x3) 100 200 300  원하는 data type으로 함수값을 출력하려면 어떻게 해야하는지 알아보자. return 할 data의 type이 출력할 data type이 된다.  ## tuple return \u0026gt; def func_mul1(x): \u0026gt; y1 = x * 10 \u0026gt; y2 = x * 20 \u0026gt; y3 = x * 30 \u0026gt; return (y1, y2, y3)  # tuple 형식 \u0026gt; t1 = func_mul1(10) \u0026gt; print(t1, type(t1)) (100, 200, 300) \u0026lt;class \u0026#39;tuple\u0026#39;\u0026gt; ## list return \u0026gt; def func_mul2(x): \u0026gt; y1 = x * 10 \u0026gt; y2 = x * 20 \u0026gt; y3 = x * 30 \u0026gt; return [y1, y2, y3]  # list 형식 \u0026gt; t1 = func_mul2(10) \u0026gt; print(t1, type(t1)) [100, 200, 300] \u0026lt;class \u0026#39;list\u0026#39;\u0026gt; ## dictionary return \u0026gt; def func_mul3(x): \u0026gt; y1 = x * 10 \u0026gt; y2 = x * 20 \u0026gt; y3 = x * 30 \u0026gt; return {\u0026#39;v1\u0026#39; : y1, \u0026#39;v2\u0026#39; : y2, \u0026#39;v3\u0026#39; : y3} # keyword 형식 \u0026gt; t1 = func_mul3(10) \u0026gt; print(t1, type(t1)) \u0026gt; print(t1.values()) {\u0026#39;v1\u0026#39;: 100, \u0026#39;v2\u0026#39;: 200, \u0026#39;v3\u0026#39;: 300} \u0026lt;class \u0026#39;dict\u0026#39;\u0026gt; dict_values([100, 200, 300]) \u0026gt; d = func_mul3(30) \u0026gt; print(type(d), d, d.get(\u0026#39;v2\u0026#39;), d.items(), d.keys()) \u0026lt;class \u0026#39;dict\u0026#39;\u0026gt; {\u0026#39;v1\u0026#39;: 300, \u0026#39;v2\u0026#39;: 600, \u0026#39;v3\u0026#39;: 900} 600 dict_items([(\u0026#39;v1\u0026#39;, 300), (\u0026#39;v2\u0026#39;, 600), (\u0026#39;v3\u0026#39;, 900)]) dict_keys([\u0026#39;v1\u0026#39;, \u0026#39;v2\u0026#39;, \u0026#39;v3\u0026#39;])  3. Packing, Unpacking 3.1 Positional argument, Keyword argument  함수 인자에는 Positional argument(위치인자)와 Keyword argument(키워드 인자)가 있다.  인자란 함수 기능에 필요한 값을 말한다. 기본값이 있다.  기본값이란 미리 기본으로 지정된 값을 말한다.   Positional argument는 인자값이 위치에 의해 결정되는 인자다.  순서가 중요하다.   Keyword argument는 key value가 key에 의해 결정되는 인자다.  순서 상관 없이 keyword가 중요하다.      # Positional argument(위치인자) # real number (실수)는 앞에, imaginary number(허수)는 뒤에 위치해야 된다. # 위치 즉, 순서가 중요하다. \u0026gt; complex(3, 5) (3 + 5j) # Keyword argument(키워드 인자) # key = value \u0026gt; complex (real = 3, imag = 5) (3 + 5j) 3.2 Packing  print 함수는 객체의 갯수에 제한 없이 출력한다.  # 1개 \u0026gt; print(\u0026#39;123 456 789\u0026#39;) 123 456 789 # 3개 \u0026gt; print(\u0026#39;123, \u0026#39;456, \u0026#39;789\u0026#39;) 123 456 789  print 함수처럼 함수가 받을 인자의 갯수를 유연하게 지정하기 위해 Python은 packing을 지원한다. packing 은  arguments를 하나의 객체로 합쳐서 받을 수 있도록 한다. positional argument packing 과 keyword argument packing이 있다.   positional argument packing은  * 한 개를 매개변수 앞에 붙여서 사용한다. 이 때는 tuple type 으로 하나의 객체가 된다.   keyword argument packing은  * 두 개 즉, **를 매개변수 앞에 붙여서 사용한다. keyword와 value로 구성된 dictionary type으로 하나의 객체가 된다.     positional argument packing을 사용하는 방법  parameter를 입력할 때, 입력되는 수만큼 (x, y, z, a, b)로 입력할 수 있다. 하지만, *args를 사용하여 하나의 객체로서 packing 하여 간단히 관리할 수 있다. args는 매개변수 명으로, 자유롭게 명명한다.     positional argument에 대해 앞서서 enumerate () 에 대해 알아보겠다.  # enumerate() # enumerate는 index 와 value 를 `tuple` 형식으로 하나의 성분으로서 맺어주고, return 해주는 함수다. \u0026gt; seasons = [\u0026#39;Spring\u0026#39;, \u0026#39;Summber\u0026#39;, \u0026#39;Fall\u0026#39;, \u0026#39;Winter\u0026#39;] # enumerate()를 하면 바로 id 값만 출력된다. \u0026gt; print(enumerate(seasons)) \u0026lt;enumerate object at 0x000002957E6DE640\u0026gt; \u0026gt; print(list(enumerate(seasons))) [(0, \u0026#39;Spring\u0026#39;), (1, \u0026#39;Summber\u0026#39;), (2, \u0026#39;Fall\u0026#39;), (3, \u0026#39;Winter\u0026#39;)] \u0026gt; print(tuple(enumerate(seasons))) ((0, \u0026#39;Spring\u0026#39;), (1, \u0026#39;Summber\u0026#39;), (2, \u0026#39;Fall\u0026#39;), (3, \u0026#39;Winter\u0026#39;))  enumerate () 를 사용하여 positional arguments packing을 설명하겠다. enumerate ()를 for ~ in문에 사용하겠다.  # args == arguments \u0026gt; def args_func(*args): \u0026gt; for i, v in enumerate(args): \u0026gt; print(\u0026#39;Result : {}\u0026#39;.format(i), v) # 인자의 수가 다양해도 다 받아지는 걸 알 수 있다. \u0026gt; args_func(\u0026#39;Lee\u0026#39;) Result : 0 Lee # 위치인자로 보낸 모든 객체들(\u0026#39;Lee\u0026#39;, \u0026#39;Park\u0026#39;)을 *args로 하나의 객체로서 관리해준다. \u0026gt; args_func(\u0026#39;Lee\u0026#39;, \u0026#39;Park\u0026#39;) Result : 0 Lee Result : 1 Park \u0026gt; args_func(\u0026#39;Lee\u0026#39;, \u0026#39;Park\u0026#39;, \u0026#39;Kim\u0026#39;) Result : 0 Lee Result : 1 Park Result : 2 Kim  keyword argument packing을 사용하는 방법  \u0026gt; def kwargs_func(**kwargs): \u0026gt; for v in kwargs.keys(): \u0026gt; print(\u0026#34;{}\u0026#34;.format(v), kwargs[v]) # keyword arguments를 packing 하여 dictionary로 관리한다. \u0026gt; kwargs_func(name1=\u0026#39;Apple\u0026#39;) name1 Apple \u0026gt; kwargs_func(name1=\u0026#39;Apple\u0026#39;, name2=\u0026#39;Window\u0026#39;) name1 Apple name2 Window \u0026gt; kwargs_func(name1=\u0026#39;Apple\u0026#39;, name2=\u0026#39;Window\u0026#39;, name3=\u0026#39;Choice\u0026#39;) name1 Apple name2 Window name3 Choice  positional argument 와 keyword argument를 같이 사용해보자.  \u0026gt; def example(args_1, args_2, *args, **kwargs): \u0026gt; print(args_1, args_2, args, kwargs) \u0026gt; example(10, 20, \u0026#39;Lee\u0026#39;, \u0026#39;Kim\u0026#39;, \u0026#39;Park\u0026#39;, \u0026#39;Cho\u0026#39;, age1=20, age2=30, age3=40) 10 20 (\u0026#39;Lee\u0026#39;, \u0026#39;Kim\u0026#39;, \u0026#39;Park\u0026#39;, \u0026#39;Cho\u0026#39;) {\u0026#39;age1\u0026#39;: 20, \u0026#39;age2\u0026#39;: 30, \u0026#39;age3\u0026#39;: 40} # args_1, args_2 로 총 2개이므로, print의 매개변수 앞에서 2개까지가 일반적인 positional argument이다. # 그 뒤에, *args 는 positional argument packing이므로 제한 없다. tuple 로 출력된 걸 확인할 수 있다. # 맨 마지막 인자는 ** 이므로, keyword argument packing이다. dictionary로 출력된 걸 확인할 수 있다. 3.3 Unpacking  Unpacking은 packing과는 반대로 여러개의 객체를 포함하고 있는 하나의 객체를 푼다. Unpacking 시 해체되는 인자의 수와 매칭되는 변수의 수가 동일해야 가능하다. packing 시에는 매개변수에 *을 붙였지만, unpacking 시에는 argument 앞에 *를 붙여서 사용한다.  \u0026gt; def sum(a, b, c): \u0026gt; return a + b + c \u0026gt; number = (1, 2, 3) \u0026gt; print(sum(*number)) 6  또는 다음과 같은 방식으로 unpacking 할 수 있다.  \u0026gt; def func_mul1(x): \u0026gt; y1 = x * 10 \u0026gt; y2 = x * 20 \u0026gt; y3 = x * 30 \u0026gt; return y1, y2, y3 # unpacking \u0026gt; x1, x2, x3 = func_mul1(10)  4. 중첩 함수 (Nested function)  중첩 함수란 함수 내부에 정의된 또 다른 함수 중첩 함수는 함수형 프로그래밍에서 많이 사용된다. 호출하는 함수는 부모 함수 이다. 부모 함수의 하위 함수를 호출할 수 없고,부모 함수의 매개변수를 받아서 사용한다.  # 중첩 함수 \u0026gt; def nested_func(num): # 부모 함수 \u0026gt; def func_in_func(num): # 부모 함수의 매개변수를 받아서 사용 가능 \u0026gt; print(num) \u0026gt; print(\u0026#34;In func\u0026#34;) \u0026gt; func_in_func(num + 100) \u0026gt; nested_func(100) 200 # 부모 함수의 하위 함수를 호출하여 사용할 수 없다. \u0026gt; func_in_func(100) NameError: name \u0026#39;func_in_func\u0026#39; is not defined  5. 람다(lambda) 함수 (익명함수)   람다식의 장점 from python 공식 사이트\n 메모리 절약 가독성 향상 코드 간결    람다식의 단점 (많은 실력자 분들이 람다식을 부정적으로 피력한다.)\n 과한 사용 시, 가독성 감소된다. 왜냐하면 익명 함수이기 때문이다. (빈번히 언급됨) (일반적인 함수는 함수명을 보고 그 기능을 추측할 수 있다.)    일반적인 함수와 람다식 함수의 차이\n  일반적인 함수는 함수명이 있기 때문에, 객체 생성 된다.\n  그 후, resource(memory)를 할당한다.\n  하지만, 람다식 함수는\n 즉시 실행 함수 라서, Heap 영역에 저장되고 (Heap 초기화), 메모리 초기화를 한다. 초기화로 메모리를 효율적으로 사용할 수 있다. 함수명이 존재하지 않아, 익명 함수라 한다. 그래서 별도의 변수에 할당해야 한다.    \u0026gt; def mul_func(x, y): \u0026gt; return x * y \u0026gt; print(mul_func(10, 50)) 500 # 첫 번째: 이미 변수에 할당해 놓은 일반적인 함수를 넣는 방법 \u0026gt; mul_func_var = mul_func \u0026gt; print(mul_func_var(10, 50)) 500 # 두 번째: 자주 쓰는 람다 함수이기 때문에, 정의를 해서 변수로 넘기는 방식 # 일시적으로 그 자리에서 함수가 필요할 때 사용한다. # def 와 return이 없어도 가능하다. # 람다식을 넣은 함수 \u0026gt; lambda_mul_func = lambda x,y : x * y \u0026gt; print(lambda_mul_func(10, 50)) 500 # 함수 안에서 함수를 인자로 받는 함수 \u0026gt; def func_final(x, y, func): \u0026gt; print(x * y * func(1,1)) # 첫 번째 방식 \u0026gt; func_final(10, 50, mul_func_var) 500 # 두 번째 방식 \u0026gt; func_final(10, 50, lambda_mul_func) 500 # 세 번째 방식: 바로 그 자리에서 람다식을 써서 넘기는 방법 \u0026gt; func_final(10, 50, lambda x,y : x * y)  위 방식대로 총 함수를 정의하는데 3가지 방식이 있다. 각 방식에 대해서 언제 무엇을 써야할지 생각해보자.   6. 함수 Type Hint  함수의 매개변수와 함수의 결과값의 데이터 타입을 알려주기 위해 python 3.5 부터 나온 기능이다. def \u0026lt;function-name\u0026gt;(parameter1: \u0026lt;data type\u0026gt;) -\u0026gt; \u0026lt;함수 결과값의 data type\u0026gt;  # 아래 예시처럼 각 매개변수의 데이터 타입이 무엇인지 알려준다. # 그리고, 함수의 결과값의 데이터 타입도 알려준다. \u0026gt; def tot_length1(word: str, num: int) -\u0026gt; int: \u0026gt; return len(word) * num # 아래 함수는 위 함수와 동일하다. \u0026gt; def tot_length1(word, num): \u0026gt; return len(word) * num \u0026gt; print(\u0026#39;hint exam1 : \u0026#39;, tot_length1(\u0026#34;i love you\u0026#34;, 10)) \u0026gt; print(type(tot_length1(\u0026#34;i love you\u0026#34;, 10))) hint exam1 : 100 \u0026lt;class \u0026#39;int\u0026#39;\u0026gt; \u0026gt; def tot_length2(word: str, num: int) -\u0026gt; None: \u0026gt; print(\u0026#39;hint exam2 : \u0026#39;, len(word) * num) \u0026gt; print(tot_length2(\u0026#34;niceman\u0026#34;, 10)) \u0026gt; print(type(tot_length2(\u0026#34;i love you\u0026#34;, 10))) hint exam2 : 70 \u0026lt;class \u0026#39;Nonetype\u0026#39;\u0026gt;  tot_length2의 data type이 Nonetype인 이유는 return 값이 없기 때문이다.   Reference  Positional argument, Keyword argument Packing, Unpacking enumerate lambda function  ","permalink":"http://jeha00.github.io/post/python_basic_12/","summary":"함수의 중요성 및 선언, Packing \u0026amp; Unpacking, 중첩 함수(Nested function), 람바 함사(익명 함수), 함수 Type hint 에 대해 알아본다.","title":"[TIL] Python basic 12: Method"},{"content":"Intro  for, if, while 문을 흐름 제어문 이라 한다. for문은 원하는 \u0026lt;collection\u0026gt;의 갯수만큼 반복한다면, while 문은 if처럼 조건을 만족할 때까지 계속 반복한다. While문은 if문처럼 조건이 들어간다. 그런데, 무한 반복될 수도 있기 때문에, 조건의 변화가 필요하다. 아니면 break 를 사용한다. 조건을 만족하면 while문을 빠져나온다. python 공식 사이트에서 while 의 구조는 다음과 같다. [expr]은 expression을 의미한다.  \u0026gt; while [expr]: \u0026gt; [statement(s)] 1. While 기본 사용법  whlie 문은 무한 반복문이 되지 않도록, 조건의 변화를 일으키는 코드를 넣어야 한다. 그래서 while문의 경우, 눈으로 중간 결과를 디버깅해서 무한 반복문인지 확인한다.  # 예제 1 \u0026gt; m = 3 \u0026gt; while m \u0026gt; 0: \u0026gt; print(m) # 여기까지 쓰면 계속해서 m \u0026gt; 0 이므로 `무한 반복문`이 된다. \u0026gt; m -= 1 3 2 1 # 예제 2 \u0026gt; z = [\u0026#39;foo\u0026#39;, \u0026#39;bar\u0026#39;, \u0026#39;baz\u0026#39;] \u0026gt; whlie z: # z 변수 안에 데이터가 존재하므로 True 상태이기 때문에 무한 반복문이다. # 위험한 코드이므로, 조건의 변화를 일으켜 무한 반복문을 방지한다. \u0026gt; print(a.pop()) # pop으로 성분의 갯수가 0이 되면 False가 되므로 중단된다.  2. Break, continue  조건의 변화를 일으키면서, 원하는 조건에서 중단하거나, 조건 판단문으로 되돌아가기 위해서 break와 continue를 사용한다. break 문과 continue문은 while문과 자주 사용된다. 중간에 if조건문이 껴져 있는 방식이 많다.  # 예제 3 \u0026gt; m = 5 \u0026gt; while m \u0026gt; 0: \u0026gt; m -= 1 \u0026gt; if m == 2: \u0026gt; break \u0026gt; print(m) \u0026gt; print(\u0026#39;Loop Ended\u0026#39;) 4 3 Loop Ended # 예제 4 \u0026gt; m = 5 \u0026gt; while m \u0026gt; 0: \u0026gt; m -= 1 \u0026gt; if m == 2: # 위에서 break를 continue로 바꿨다. \u0026gt; continue \u0026gt; print(m) \u0026gt; print(\u0026#39;Loop Ended\u0026#39;) 4 3 1 0 Loop Ended # 예제 5 \u0026gt; i = 1 \u0026gt; while i \u0026lt;= 10: \u0026gt; print(\u0026#39;i : \u0026#39;, i) \u0026gt; if i ==6: \u0026gt; break \u0026gt; i += 1 i : 1 i : 2 i : 3 i : 4 i : 5 i : 6  3. While ~ else 구문 # 예제 6 \u0026gt; n = 5 \u0026gt; while n \u0026gt; 0: \u0026gt; print(n) \u0026gt; n -= 1 \u0026gt; if n == 3: \u0026gt; break \u0026gt; else: \u0026gt; print(\u0026#39;else out.\u0026#39;) 5 4 # 예제 7 \u0026gt; g = [\u0026#39;red\u0026#39;, \u0026#39;blue\u0026#39;, \u0026#39;white\u0026#39;, \u0026#39;black\u0026#39;] \u0026gt; c = \u0026#39;black\u0026#39; \u0026gt; i = 0 \u0026gt; while i \u0026lt; len(g): \u0026gt; if g[i] == c: \u0026gt; print(\u0026#39;find {}\u0026#39;.format(c)) \u0026gt; break \u0026gt; i += 1 \u0026gt; else: \u0026gt; print(\u0026#39;not found in lise.\u0026#39;) find black  4. 무한 반복 구문  무한정 반복되는 구문을 말한다. 이 구문이 실행되면 다운되므로, break와 continue로 방지한다. 무한 반복문의 한 예가 다음과 같다.  \u0026gt; while True: \u0026gt; print(\u0026#39;Foo\u0026#39;)  무한 반복문을 방지하기 위해 다음과 같이 수정한다.  \u0026gt; a = [\u0026#39;foo\u0026#39;, \u0026#39;bar\u0026#39;, \u0026#39;baz\u0026#39;] \u0026gt; while True: \u0026gt; if not a: \u0026gt; break \u0026gt; print(a.pop()) baz bar foo  a의 원소가 존재하지 않으므로 if not a가 참이 되어 break가 실행된다.  ","permalink":"http://jeha00.github.io/post/python_basic_11/","summary":"While 반복문의 기본 사용법, break \u0026amp; continue 문, While ~ else 구문, 무한 반복 구문에 대해 알아본다.","title":"[TIL] Python basic 11: 흐름 제어문 (while 반복문)"},{"content":"Intro  코딩의 핵심 파이썬의 for 문은 다른 for 문과 달리 독자적인 특징이 있다. if else 처럼 for else도 가능하나, 자주 사용하지 않는다. for 문은 코딩에서 중요하다. 파이썬 공식 사이트에서는 다음과 같은 구조로 설명한다. \u0026lt;collection\u0026gt; 이란 반복 가능한 객체, iterable object (= interator)를 말한다. 그러면 어떤 게 iterator 인가?? dir() method를 사용했을 때 __iter__ 을 확인할 수 있으면 iterator다. 예를 들어서 string, list, tuple, dictionary, set을 말한다.  \u0026gt; for i in \u0026lt;collection\u0026gt;: \u0026gt; \u0026lt;loop body\u0026gt; 1. for ~ range pattern: 3가지  첫 번째 패턴  for n in range(j) : 변수 n이 0부터 j가 아닌 (j-1)까지 반복된다.    \u0026gt; for v in range(10): \u0026gt; pritn(\u0026#34;v is : \u0026#34;, v) v is : 0 v is : 1 v is : 2 v is : 3 v is : 4 v is : 5 v is : 6 v is : 7 v is : 8 v is : 9  두 번째 패턴  for n in range(i,j): n이 i부터 (j-1)까지 반복된다.    \u0026gt; for v in range(1, 11): \u0026gt; print(\u0026#34;v is : \u0026#34;, v) v is : 1 v is : 2 v is : 3 v is : 4 v is : 5 v is : 6 v is : 7 v is : 8 v is : 9 v is : 10  세 번째 패턴  for n in range(i,j,k): n이 i부터 k씩 증가하여 (j-1)까지 반복된다.    \u0026gt; for v in range(1, 11, 2): \u0026gt; print(\u0026#34;v is :\u0026#34;, v) v is : 1 v is : 3 v is : 5 v is : 7 v is : 9 \u0026gt; for v in range(1, 11, 3): \u0026gt; print(\u0026#34;v is :\u0026#34;, v) v is : 1 v is : 4 v is : 7 v is : 10  1 ~ 1000까지 합 구하기  # 첫 번째 방법 \u0026gt; sum = 0 \u0026gt; for v in range(1, 1001): \u0026gt; sum += v \u0026gt; print(\u0026#39;1 ~ 1000 Sum : \u0026#39;, sum) 1 ~ 1000 sum : 500500 # 두 번째 방법 \u0026gt; print(\u0026#39;1 ~ 1000 Sum : \u0026#39;, sum(range(1, 1001))) 1 ~ 1000 Sum : 500500 \u0026gt; print(\u0026#39;1 ~ 1000 안에 4의 배수의 합 : \u0026#39;, sum(range(1, 1001, 4))) 1 ~ 1000 안에 4의 배수의 합 : 124750 \u0026gt; print(type(range(1,11))) \u0026lt;class \u0026#39;range\u0026#39;\u0026gt;  2. Iterator 자료형 활용과 Iterable 함수 # iterable 리턴 함수 : range, reversed, enumerate, filter, map, zip (이런 것들 다 for 문에서 사용할 수 있다.) # 예제1 # Iterator: string으로 구성된 list \u0026gt; names = [\u0026#34;Kim\u0026#34;, \u0026#34;Park\u0026#34;, \u0026#34;Cho\u0026#34;, \u0026#34;Lee\u0026#34;, \u0026#34;Choi\u0026#34;, \u0026#34;Yoo\u0026#34;] \u0026gt; for name in names: \u0026gt; print(\u0026#34;You are\u0026#34;, name) You are Kim You are Park You are Cho You are Lee You are Choi You are Yoo # 예제2 # Iterator: interger 로 구성된 list \u0026gt; lotto_numbers = [11, 19, 21, 28, 36, 37] \u0026gt; for number in lotto_numbers: \u0026gt; print(\u0026#34;Current number : \u0026#34;, number) Current number : 11 Current number : 19 Current number : 21 Current number : 28 Current number : 36 Current number : 37 # 예제3 # Iterator : string \u0026gt; word = \u0026#39;Beautiful\u0026#39; \u0026gt; for s in word: \u0026gt; print(\u0026#39;word : \u0026#39;, s) word : B word : e word : a word : u word : t word : i word : f word : u word : l # 예제4 # Iterator: dictionary \u0026gt; my_info = { \u0026gt; \u0026#34;name\u0026#34;: \u0026#34;Lee\u0026#34;, \u0026gt; \u0026#34;Age\u0026#34;: 33, \u0026gt; \u0026#34;City\u0026#34;: \u0026#34;Seoul\u0026#34; \u0026gt; } \u0026gt; for key in my_info: \u0026gt; print(\u0026#34;value :\u0026#34;, my_info[key]) value : Lee value : 33 value: Seoul # 또는 아래 방법으로 value만 순차적으로 출력할 수 있다. \u0026gt; for val in my_info.values(): \u0026gt; print(val) Lee 33 Seoul  Iterable에 사용되는 함수를 사용하여 대문자로 출력해보자. \u0026lt;string iterator\u0026gt;.isupper : 문자가 대문자인지 확인하는 함수 \u0026lt;string iterator\u0026gt;.islower : 문자가 소문자인지 확인하는 함수 \u0026lt;string iterator\u0026gt;.upper : 문자열을 대문자로 변경하는 함수 \u0026lt;string iterator\u0026gt;.lower : 문자열을 소문자로 변경하는 함수  # Iterator : string \u0026gt; name = \u0026#39;FineApplE\u0026#39; # 지난 시간에 배운 중첩 조건문을 의미 \u0026gt; for n in name: \u0026gt; if n.isupper(): \u0026gt; print(n) \u0026gt; else: \u0026gt; print(n.upper()) F I N E A P P L E  3. break, continue 문  break 문: 가장 가까운 반복문을 강제로 탈출한다.  내가 원하는 특정 조건에서, 멈추기 원할 때 사용된다. 현업에서는 수집하는 데이터량이 매우 많기 때문에, break로 반복문을 조절하는 게 중요하다.   continue 문: break문과 달리 특정 조건이 되면 탈출하는 것이 아니라, continue 문 아래의 코드가 실행되지 않고, 조건을 판단하는 곳으로 점프한다.  많은 데이터 중에 내가 보기 싫은 또는 불필요하게 출력되거나 계산되지 말아야 하는 것이 list에 있을 때, 스킵할 수 있다.    # break \u0026gt; numbers = [14, 3, 4, 7, 10, 24, 17, 2, 33, 15, 34, 36, 38] \u0026gt; for num in numbers: \u0026gt; if num == 34: \u0026gt; print(\u0026#34;Found : 34!\u0026#34;) \u0026gt; break \u0026gt; else: \u0026gt; print(\u0026#34;Not found : \u0026#34;, num) Not found : 14 Not found : 3 Not found : 4 Not found : 7 Not found : 10 Not found : 24 Not found : 17 Not found : 2 Not found : 33 Not found : 15 Found : 34! # continue \u0026gt; lt = [2, 5, True, 4.3, complex(4)] \u0026gt; for v in lt: \u0026gt; if type(v) is bool: \u0026gt; continue \u0026gt; print(\u0026#34;current type : \u0026#34;, type(v)) \u0026gt; print(\u0026#34;multiply by 2:\u0026#34;, v * 2) \u0026gt; print(True * 3) current type : \u0026lt;class \u0026#39;int\u0026#39;\u0026gt; multiply by 2: 4 3 current type : \u0026lt;class \u0026#39;int\u0026#39;\u0026gt; multiply by 2: 10 3 current type : \u0026lt;class \u0026#39;float\u0026#39;\u0026gt; multiply by 2: 8.6 3 current type : \u0026lt;class \u0026#39;complex\u0026#39;\u0026gt; multiply by 2: (8+0j) 3 # true가 1이기 때문에 3이 나온다. 5. for ~ else 구문  for ~ else 구문: python에만 있는 for-else 구문으로, 자주 사용하지는 않지만, 알고 있자.  \u0026gt; numbers = [14, 3, 4, 7, 10, 24, 17, 2, 33, 15, 34, 36, 38] \u0026gt; for num in numbers: \u0026gt; if num == 34: \u0026gt; print(\u0026#34;Found : 34!\u0026#34;) \u0026gt; break \u0026gt; else: \u0026gt; print(\u0026#34;Not Found 45...\u0026#34;) ","permalink":"http://jeha00.github.io/post/python_basic_10/","summary":"for ~ range의 3가지 pattern, for문에 interable 자료형 활용하기, break 문과 continue 문 사용하기, for ~ else 구문에 대해 알아본다.","title":"[TIL] Python basic 10: 흐름 제어문 (for 반복문)"},{"content":"1. 조건문 기본 형식  콜론(:)으로 끝나는 부분을 헤더(Header)라고 한다. 헤더의 마지막 콜론은 바로 뒤에 스위트가 이어진다. 스위트는 헤더와 한 세트로 따라다니는 실행문을 의미한다. if - elif - else  if 식: 스위트 =\u0026gt; if 문으로, 반드시 1개 필요하다.\nelif 식: 스위트 =\u0026gt; elif 문으로, 없어도 되며 있으면 n개 가능 (여러개 가능)\nelse 식: 스위트 =\u0026gt; else 문으로, 없어도 되며 있으면 1개만 가능\n    반드시 True 여야 제어문이 실행된다.  \u0026gt; print(type(True)) \u0026gt; print(type(False)) \u0026lt;class \u0026#39;bool\u0026#39;\u0026gt; \u0026gt; if True: \u0026gt; print(\u0026#34;Good\u0026#34;) Good \u0026gt; if False: \u0026gt; print(\u0026#34;Bad\u0026#34;) 실행 X  2. 연산자  연산자에는 지난 번에 봤던 산술 연산자 그리고, 관계 연산자, 논리 연산자가 있다. 관계 연산자에는 \u0026gt;, \u0026gt;=, \u0026lt;, \u0026lt;=, ==, != 가 있다.  \u0026gt; x = 15 \u0026gt; y = 10 # == 양 변이 같을 때 참 \u0026gt; print(x == y) False # != 양변이 다를 때 참 \u0026gt; print(x != y) True # \u0026gt; 왼쪽이 클 때 참 \u0026gt; print(x \u0026gt; y) True # \u0026gt;= 왼쪽이 크거나 같을 때 참 \u0026gt; print(x \u0026gt;= y) True # \u0026lt; 오른쪽이 클 때 참 \u0026gt; print(x \u0026lt; y) False # \u0026lt;= 오른쪽이 크거나 같을 때 참 \u0026gt; print(x \u0026lt;= y) False  논리 연산자에는 and, or, not이 있다.  \u0026gt; a = 75 \u0026gt; b = 40 \u0026gt; c = 10 \u0026gt; print(\u0026#39;and : \u0026#39;, a \u0026gt; b and b \u0026gt; c) and : True \u0026gt; print(\u0026#39;or : \u0026#39;, a \u0026gt; b or b \u0026gt; c) or : True \u0026gt; print(\u0026#39;not : \u0026#39;, not a \u0026gt; b) not : False \u0026gt; print(\u0026#39;not : \u0026#39;, not b \u0026gt; c) not : False  산술, 관계, 논리 우선순위  산술 \u0026gt; 관계 \u0026gt; 논리 순서로 적용한다.    \u0026gt; print(\u0026#39;e1 : \u0026#39;, 3 + 12 \u0026gt; 7 + 3) e1 : True \u0026gt; print(\u0026#39;e2 : \u0026#39;, 5 + 10 * 3 \u0026gt; 7 + 3 * 20) e2 : False \u0026gt; print(\u0026#39;e3 : \u0026#39;, 5 + 10 \u0026gt; 3 and 7 + 3 == 10) e3 : True \u0026gt; print(\u0026#39;e4 : \u0026#39;, 5 + 10 \u0026gt; 0 and not 7 + 3 == 10) e4 : False  3. 참거짓 판별 종류  참 : \u0026ldquo;values\u0026rdquo;, [values], (values), {values}, 1 거짓 : \u0026ldquo;\u0026rdquo;, [], (), {}, 0, None  # city가 공란이르모 False를 의미한다. # 그래서 else 문을 출력한다. \u0026gt; city = \u0026#34;\u0026#34; \u0026gt; \u0026gt; if city: \u0026gt; print(\u0026#34;You are in:\u0026#34;, city) \u0026gt; else: \u0026gt; print(\u0026#34;Please enter your city\u0026#34;) Please enter your city # city에 값이 value가 있으므로 True를 의미한다. # 그래서 if 문을 출력한다. \u0026gt; city = \u0026#34;Seoul\u0026#34; \u0026gt; \u0026gt; if city: \u0026gt; print(\u0026#34;You are in:\u0026#34;, city) \u0026gt; else: \u0026gt; print(\u0026#34;Please enter your city\u0026#34;) You are in: Seoul  4. 다중 조건문, 중첩 조건문, in \u0026amp; not in 4.1 다중 조건문  동일한 syntax의 조건문이 여러 개일 조건문을 다중 조건문이라 한다.  \u0026gt; nume = 90 \u0026gt; if num \u0026gt;= 90: \u0026gt; print(\u0026#39;Grade : A\u0026#39;) \u0026gt; elif num \u0026gt;= 80: \u0026gt; print(\u0026#39;Grade : B\u0026#39;) \u0026gt; elif num \u0026gt;= 70: \u0026gt; print(\u0026#39;Grade : C\u0026#39;) \u0026gt; else: \u0026gt; print(\u0026#39;과락\u0026#39;) Grade : A 4.2 중첩 조건문  한 syntax 조건문 하에 여러 개의 조건문을 중첩 조건문이라 한다.  \u0026gt; grade = \u0026#39;A\u0026#39; \u0026gt; total = 80 \u0026gt; if grade == \u0026#39;A\u0026#39;: \u0026gt; if total \u0026gt;= 90: \u0026gt; print(\u0026#34;장학금 100%\u0026#34;) \u0026gt; elif total \u0026gt;= 80: \u0026gt; print(\u0026#34;장학금 80%\u0026#34;) \u0026gt; else: \u0026gt; print(\u0026#34;장학금 70%\u0026#34;) \u0026gt; else: \u0026gt; print(\u0026#34;장학금 50%\u0026#34;) 장학금 80% 4.3 in \u0026amp; not in  A in B : B 안에 A가 있으면 참 A not in B : B 안에 A가 없으면 참  # list \u0026gt; q = [10, 20, 30] # sets \u0026gt; w = {70, 80, 90, 90} # dictionary \u0026gt; e = {\u0026#34;name\u0026#34;: \u0026#39;Lee\u0026#39;, \u0026#34;city\u0026#34;: \u0026#34;Seoul\u0026#34;, \u0026#34;grade\u0026#34;: \u0026#34;A\u0026#34;} # tuple \u0026gt; r = (10, 12, 14) \u0026gt; print(15 in q) False \u0026gt; print(90 in w) True \u0026gt; print(12 not in r) False # key 검색. dictionary를 in 사용하여 검색할 때 default는 keys 다. \u0026gt; print(\u0026#34;name\u0026#34; in e) True # value 검색 \u0026gt; print(\u0026#34;seoul\u0026#34; in e.values()) False  ","permalink":"http://jeha00.github.io/post/python_basic_9/","summary":"조건문의 기본 형식, 연산자를 통해서 제어하는 방법, 참거짓을 의미하는 값들, 다중 및 중첩 조건문, in \u0026amp; not in 으로 제어하는 방법을 알아본다.","title":"[TIL] Python basic 9: 흐름 제어문 (if 조건문)"},{"content":"Intro  Sets은 한국어로 집합을 의미한다. 수학의 집합을 생각해보자. sequence X, 중복 X  순서가 없기 때문에, 출력할 때마다 달라진다.   mutable 자료형 =\u0026gt; 수정 O, 삭제 O 집합 자료형 활용에 핵심이다.   1. Sets 선언  dictionary 처럼 sets 도 다양한 선언 방식이 있다. 빈집합, list 형식으로도, 중괄호로도 가능하다.  \u0026gt; a = set() \u0026gt; b = set([1,2,3,4,4]) \u0026gt; c = set([1, 4, 5, 6]) # 서로 다른 자료형을 저장할 수 있다. \u0026gt; d = set([1, 2, \u0026#39;Pen\u0026#39;, \u0026#39;Cap\u0026#39;, \u0026#39;Plate\u0026#39;]) \u0026gt; e = {\u0026#39;foo\u0026#39;, \u0026#39;bar\u0026#39;, \u0026#39;bz\u0026#39;, \u0026#39;foo\u0026#39;, \u0026#39;qux\u0026#39;} # 튜플도, 실수형도 넣을 수 있다. \u0026gt; f = {42, \u0026#39;foo\u0026#39;, (1,2,3), 3.14159} \u0026gt; print(\u0026#39;a\u0026#39;, type(a), a, 2 in a) a \u0026lt;class \u0026#39;set\u0026#39;\u0026gt; set() False # b에 4를 중복으로 입력했지만, 출력은 하나만 나온다. \u0026gt; print(\u0026#39;b\u0026#39;, type(b), b) b \u0026lt;class \u0026#39;set\u0026#39;\u0026gt; {1, 2, 3, 4} \u0026gt; print(\u0026#39;c\u0026#39;, type(c), c) c \u0026lt;class \u0026#39;set\u0026#39;\u0026gt; {1, 4, 5, 6} \u0026gt; print(\u0026#39;d\u0026#39;, type(d), d) d \u0026lt;class \u0026#39;set\u0026#39;\u0026gt; {1, 2, \u0026#39;Pen\u0026#39;, \u0026#39;Cap\u0026#39;, \u0026#39;Plate\u0026#39;} # foo를 중복으로 입력했지만, 출력은 하나만 나온다. \u0026gt; print(\u0026#39;e\u0026#39;, type(e), e) e \u0026lt;class \u0026#39;set\u0026#39;\u0026gt; {\u0026#39;qux\u0026#39;, \u0026#39;bz\u0026#39;, \u0026#39;foo\u0026#39;, \u0026#39;bar\u0026#39;} \u0026gt; print(\u0026#39;f\u0026#39;, type(f), f) f \u0026lt;class \u0026#39;set\u0026#39;\u0026gt; {42, 3.14159, \u0026#39;foo\u0026#39;, (1, 2, 3)}  2. Sets type converison  파이썬의 장점 중 하나: 간단한 형 변환 sets에 중복으로 값을 입력해도, 중복을 허락하지 않기 때문에 type conversion 시에도 중복된 값들은 하나만 있는 걸 확인할 수 있다. tuple로 변환  \u0026gt; t = tuple(b) \u0026gt; print(\u0026#39;t - \u0026#39;, type(t), t) t - \u0026lt;class \u0026#39;tuple\u0026#39;\u0026gt; (1, 2, 3, 4) \u0026gt; print(\u0026#39;t - \u0026#39;, t[0], t[1:3]) t - 1 (2, 3)  list로 변환  \u0026gt; l = list(c) \u0026gt; print(\u0026#39;l - \u0026#39;, type(l), l) l - \u0026lt;class \u0026#39;list\u0026#39;\u0026gt; [1, 4, 5, 6] \u0026gt; print(\u0026#39;l - \u0026#39;, l[0], l[1:3]) l - 1 [4, 5] \u0026gt; le = list(e) \u0026gt; print(\u0026#39;le - \u0026#39;, type(le), le) le - \u0026lt;class \u0026#39;list\u0026#39;\u0026gt; [\u0026#39;bz\u0026#39;, \u0026#39;foo\u0026#39;, \u0026#39;qux\u0026#39;, \u0026#39;bar\u0026#39;] # reversed() 함수와 함께 해보자. \u0026gt; name = \u0026#39;Aceman\u0026#39; # id 값이 나오므로, 뒤집어진 값을 원하면 형 변환을 해야 한다. \u0026gt; print(\u0026#39;Reversed : \u0026#39;, reversed(name)) \u0026gt; print(\u0026#39;List : \u0026#39;, list(reversed(name))) \u0026gt; print(\u0026#39;Tuple : \u0026#39;, tuple(reversed(name))) \u0026gt; print(\u0026#39;Set : \u0026#39;, set(reversed(name))) Reversed : \u0026lt;reversed object at 0x000001F1E690AFA0\u0026gt; List : [\u0026#39;n\u0026#39;, \u0026#39;a\u0026#39;, \u0026#39;m\u0026#39;, \u0026#39;e\u0026#39;, \u0026#39;c\u0026#39;, \u0026#39;A\u0026#39;] Tuple : (\u0026#39;n\u0026#39;, \u0026#39;a\u0026#39;, \u0026#39;m\u0026#39;, \u0026#39;e\u0026#39;, \u0026#39;c\u0026#39;, \u0026#39;A\u0026#39;) Set : {\u0026#39;m\u0026#39;, \u0026#39;a\u0026#39;, \u0026#39;c\u0026#39;, \u0026#39;e\u0026#39;, \u0026#39;n\u0026#39;, \u0026#39;A\u0026#39;} # set은 출력할 떄마다 순서가 달라진다.  또한 len 함수로 길이를 구할 수 있다.  \u0026gt; print(len(a)) 0 \u0026gt; print(len(b)) 4 \u0026gt; print(len(c)) 4 \u0026gt; print(len(d)) 5 \u0026gt; print(len(e)) 4  3. 집합 자료형 함수: Sets 함수 \u0026gt; s1 = set([1, 2, 3, 4, 5, 6]) \u0026gt; s2 = set([4, 5, 6, 7, 8, 9]) # 교집합 \u0026gt; print(\u0026#39;l - \u0026#39;, s1 \u0026amp; s2) \u0026gt; print(\u0026#39;l - \u0026#39;, s1.intersection(s2)) l - {4, 5, 6} # 합집합 \u0026gt; print(\u0026#39;l - \u0026#39;, s1 | s2) \u0026gt; print(\u0026#39;l - \u0026#39;, s1.union(s2)) l - {1, 2, 3, 4, 5, 6, 7, 8, 9} # 차집합 \u0026gt; print(\u0026#39;l - \u0026#39;, s1 - s2) \u0026gt; print(\u0026#39;l - \u0026#39;, s1.difference(s2)) l - {1, 2, 3} \u0026gt; print(\u0026#39;l - \u0026#39;, s2 - s1) \u0026gt; print(\u0026#39;l - \u0026#39;, s2.difference(s1)) l - {8, 9, 7} # 중복 원소 확인 # 겹치는 원소가 없는지에 대해 알려주는 함수 # 겹치는 원소가 없으면 True, 있으면 False 다. \u0026gt; print(s1.isdisjoint(s2)) False # 부분집합 확인 # s1은 s2의 부분 집합인가요?? # 아니면 False, 맞으면 True \u0026gt; print(s1.issubset(s2)) False # 상위 집합 확인 # s1은 s2의 상위 집합인가요? # 아니면 False, 맞으면 True \u0026gt; print(s1.issuperset(s2)) False  4. Sets 수정, 추가, 제거   추가하는 건 .add(추가하려는 원소) 를 사용한다.\n  삭제하는 건 .remove(삭제하려는 원소) 또는 .discard(삭제하려는 원소)를 사용한다.\n 전자는 error가 뜨지만, 후자는 error를 발생시키지 않는다.    모두 제거하는 건 .clear() 함수를 사용한다.\n  \u0026gt; s1 = set([1,2,3,4]) \u0026gt; s1.add(5) \u0026gt; print(sl) {1, 2, 3, 4, 5} \u0026gt; s1.remove(5) \u0026gt; print(sl) {1, 2, 3, 4} \u0026gt; s1.discard(4) \u0026gt; print(sl) {1, 2, 3} \u0026gt; s1.clear() \u0026gt; print(s1) set() ","permalink":"http://jeha00.github.io/post/python_basic_8/","summary":"set 선언법, set type conversion, 집합 자료형 활용을 위한 함수, set type의 수정하기를 알아본다.","title":"[TIL] Python basic 8: set"},{"content":"Intro  범용적으로 가장 많이 사용되는 기초 자료형 sequence X key: value로 구성된다. key 중복 X \u0026lt;= key 값으로 index 하기 때문에 key 값은 중복되면 안된다.  key는 숫자, 문자 다 가능하다. key만 존재하면 value는 어떤 자료 형태든 가능하다.   value 중복 O mutable 자료형 =\u0026gt; 수정 O, 삭제 O 중괄호 {} 를 사용한다.   1. dictionary 선언  dictionary 선언에는 매우 다양한 방법이 있다. 이 다양한 방법들의 공통점은 { }, key, value 로 기본적으로 구성된다.  # key와 value 모두 string \u0026gt; a = {\u0026#39;name\u0026#39; : \u0026#39;Kim\u0026#39;, \u0026#39;phone\u0026#39;: \u0026#39;01012345678\u0026#39;, \u0026#39;birth\u0026#39;: \u0026#39;870124\u0026#39;} # key는 integer 자료형, value는 string \u0026gt; b = {0 : \u0026#39;Hello Python!\u0026#39;} # key는 string, value는 list \u0026gt; c = {\u0026#39;arr\u0026#39;: [1, 2, 3, 4]} \u0026gt; d = { \u0026#39;Name\u0026#39; : \u0026#39;Niceman\u0026#39;, \u0026#39;City\u0026#39; : \u0026#39;Seoul\u0026#39;, \u0026#39;Age\u0026#39; : 33, \u0026#39;Grade\u0026#39; : \u0026#39;A\u0026#39;, \u0026#39;Status\u0026#39; : True } # 하나 하나 튜플 형식으로 입력한다. 가독성이 좋지 않은 단점이 있다. # 그래서 개선된 방법이 f 다. \u0026gt; e = dict([ ( \u0026#39;Name\u0026#39;, \u0026#39;Niceman\u0026#39;), (\u0026#39;City\u0026#39;, \u0026#39;Seoul\u0026#39;), (\u0026#39;Age\u0026#39;, \u0026#39;33\u0026#39;), (\u0026#39;Grade\u0026#39;, \u0026#39;A\u0026#39;), (\u0026#39;Status\u0026#39;, True) \u0026gt; ]) # 이 형태로 DB에 저장하거나, 엑셀이 쓰거나, 웹 서비스 형태에 사용된다. # java에서는 map 이라고 한다. # JSON 형태도 이런 방식으로 되어 있다. \u0026gt; f = dict( Name = \u0026#39;Niceman\u0026#39;, City = \u0026#39;Seoul\u0026#39;, Age = \u0026#39;33\u0026#39;, Grade = \u0026#39;A\u0026#39;, Status = True \u0026gt; ) \u0026gt; print(\u0026#39;a - \u0026#39;, type(a),a) a - \u0026lt;class \u0026#39;dict\u0026#39;\u0026gt; {\u0026#39;name\u0026#39;: \u0026#39;Kim\u0026#39;, \u0026#39;phone\u0026#39;: \u0026#39;01012345678\u0026#39;, \u0026#39;birth\u0026#39;: \u0026#39;870124\u0026#39;} \u0026gt; print(\u0026#39;b - \u0026#39;, type(b),b) b - \u0026lt;class \u0026#39;dict\u0026#39;\u0026gt; {0: \u0026#39;Hello Python!\u0026#39;} \u0026gt; print(\u0026#39;c - \u0026#39;, type(c),c) c - \u0026lt;class \u0026#39;dict\u0026#39;\u0026gt; {\u0026#39;arr\u0026#39;: [1, 2, 3, 4]} \u0026gt; print(\u0026#39;d - \u0026#39;, type(d),d) d - \u0026lt;class \u0026#39;dict\u0026#39;\u0026gt; {\u0026#39;Name\u0026#39;: \u0026#39;Niceman\u0026#39;, \u0026#39;City\u0026#39;: \u0026#39;Seoul\u0026#39;, \u0026#39;Age\u0026#39;: 33, \u0026#39;Grade\u0026#39;: \u0026#39;A\u0026#39;, \u0026#39;Status\u0026#39;: True} \u0026gt; print(\u0026#39;e - \u0026#39;, type(e),e) e - \u0026lt;class \u0026#39;dict\u0026#39;\u0026gt; {\u0026#39;Name\u0026#39;: \u0026#39;Niceman\u0026#39;, \u0026#39;City\u0026#39;: \u0026#39;Seoul\u0026#39;, \u0026#39;Age\u0026#39;: \u0026#39;33\u0026#39;, \u0026#39;Grade\u0026#39;: \u0026#39;A\u0026#39;, \u0026#39;Status\u0026#39;: True} \u0026gt; print(\u0026#39;f - \u0026#39;, type(f),f) f - \u0026lt;class \u0026#39;dict\u0026#39;\u0026gt; {\u0026#39;Name\u0026#39;: \u0026#39;Niceman\u0026#39;, \u0026#39;City\u0026#39;: \u0026#39;Seoul\u0026#39;, \u0026#39;Age\u0026#39;: \u0026#39;33\u0026#39;, \u0026#39;Grade\u0026#39;: \u0026#39;A\u0026#39;, \u0026#39;Status\u0026#39;: True}  2. dictionary value 출력과 수정 2.1 dictionary value 출력  value 출력에는 2가지 방법이 있다.  print(a[key]) 로 출력하는 방법 print(a.get(key))로 출력하는 방법     첫 번째 방법은 key에 해당하는 value 값이 존재하지 않으면 error가 발생한다. 두 번째 방법은 key에 해당하는 value 값이 존재하지 않으면 none처리를 한다. error가 발생하면 중단되기 때문에, 실무에서는 두 번째 방법을 많이 사용한다.\n결론: Key에 해당하는 값을 사용할 때는 함수 .get(key) 를 사용하자.  \u0026gt; print(\u0026#39;a - \u0026#39;, a.get(\u0026#39;name1\u0026#39;)) None \u0026gt; print(\u0026#39;a - \u0026#39;, a[\u0026#39;name1\u0026#39;]) # error 발생으로 중단 \u0026gt; print(\u0026#39;b - \u0026#39;, b[0]) \u0026gt; print(\u0026#39;b - \u0026#39;, b.get(0)) Hello Python! \u0026gt; print(\u0026#39;c - \u0026#39;, c[\u0026#39;arr\u0026#39;]) \u0026gt; print(\u0026#39;c - \u0026#39;, c.get(\u0026#39;arr\u0026#39;)) [1, 2, 3, 4] # value 값이 여러 원소를 가지고 있을 경우, index를 사용하여 출력할 수 있다. \u0026gt; print(\u0026#39;c - \u0026#39;, c[\u0026#39;arr\u0026#39;][3]) \u0026gt; print(\u0026#39;c - \u0026#39;, c.get(\u0026#39;arr\u0026#39;)[3]) 4 \u0026gt; print(\u0026#39;d - \u0026#39;, d.get(\u0026#39;Age\u0026#39;)) 33 \u0026gt; print(\u0026#39;e - \u0026#39;, e.get(\u0026#39;Status\u0026#39;)) True \u0026gt; print(\u0026#39;f - \u0026#39;, f.get(\u0026#39;City\u0026#39;)) Seoul 2.2 dictionary 수정  index에 key 값을 입력했을 때, 기존에 있던 key 면 수정이 되고, 없는 key면 추가된다.  # 수정 \u0026gt; b = {0 : \u0026#39;Hello Python!\u0026#39;} \u0026gt; b[0] = \u0026#39;Good backend developer\u0026#39; \u0026gt; print(b) {0: \u0026#39;Good backend developer\u0026#39;} # 추가 \u0026gt; b[2] = \u0026#39;Python Python\u0026#39; \u0026gt; print(b) {0: \u0026#39;Good backend developer\u0026#39;, 2: \u0026#39;Python Python\u0026#39;}  3. dictionary 함수  len : key의 갯수 구하기 .keys(): key 값만 출력 .values(): value 값만 출력 .items(): key, value 다 출력 .pop(): list에서 배운 것과 동일하다. .popitem(): key와 value 중 아무거나 하나를 임의로 도출하여 없앤다. .update(): 다른 리스트를 넣어서, 키가 똑같은 것을 수정할 수 있다. in 연산자를 사용해서 해당하는 키 값이 있는지 알 수 있다.  \u0026gt; a = {\u0026#39;name\u0026#39; : \u0026#39;Kim\u0026#39;, \u0026#39;phone\u0026#39;: \u0026#39;01012345678\u0026#39;, \u0026#39;birth\u0026#39;: \u0026#39;870124\u0026#39;} \u0026gt; d = { \u0026#39;Name\u0026#39; : \u0026#39;Niceman\u0026#39;, \u0026#39;City\u0026#39; : \u0026#39;Seoul\u0026#39;, \u0026#39;Age\u0026#39; : 33, \u0026#39;Grade\u0026#39; : \u0026#39;A\u0026#39;, \u0026#39;Status\u0026#39; : True } # len \u0026gt; print(len(a)) 3 \u0026gt; print(len(d)) 5 # .keys() \u0026gt; print(a.keys()) dict_keys([\u0026#39;name\u0026#39;, \u0026#39;phone\u0026#39;, \u0026#39;birth\u0026#39;]) \u0026gt; print(d.keys()) dict_keys([\u0026#39;Name\u0026#39;, \u0026#39;City\u0026#39;, \u0026#39;Age\u0026#39;, \u0026#39;Grade\u0026#39;, \u0026#39;Status\u0026#39;]) # .values() \u0026gt; print(a.values()) dict_values([\u0026#39;Kim\u0026#39;, \u0026#39;01012345678\u0026#39;, \u0026#39;870124\u0026#39;]) \u0026gt; print(d.values()) dict_values([\u0026#39;Niceman\u0026#39;, \u0026#39;Seoul\u0026#39;, 33, \u0026#39;A\u0026#39;, True]) # .items() \u0026gt; print(a.items()) dict_items([(\u0026#39;name\u0026#39;, \u0026#39;Kim\u0026#39;), (\u0026#39;phone\u0026#39;, \u0026#39;01012345678\u0026#39;), (\u0026#39;birth\u0026#39;, \u0026#39;870124\u0026#39;)]) \u0026gt; print(d.items()) dict_items([(\u0026#39;Name\u0026#39;, \u0026#39;Niceman\u0026#39;), (\u0026#39;City\u0026#39;, \u0026#39;Seoul\u0026#39;), (\u0026#39;Age\u0026#39;, 33), (\u0026#39;Grade\u0026#39;, \u0026#39;A\u0026#39;), (\u0026#39;Status\u0026#39;, True)]) # list 안에 넣으면 key 값들만, value 값들만, item 값들만으로 list를 만든다. \u0026gt; print(list(a.keys()) [\u0026#39;name\u0026#39;, \u0026#39;phone\u0026#39;, \u0026#39;birth\u0026#39;] \u0026gt; print(list(a.values()) [\u0026#39;Kim\u0026#39;, \u0026#39;01012345678\u0026#39;, \u0026#39;870124\u0026#39;] \u0026gt; print(list(a.items()) [(\u0026#39;name\u0026#39;, \u0026#39;Kim\u0026#39;), (\u0026#39;phone\u0026#39;, \u0026#39;01012345678\u0026#39;), (\u0026#39;birth\u0026#39;, \u0026#39;870124\u0026#39;)] # .pop() \u0026gt; print(a.pop(\u0026#39;birth\u0026#39;)) 870124 \u0026gt; print(a) {\u0026#39;name\u0026#39;: \u0026#39;Kim\u0026#39;, \u0026#39;phone\u0026#39;: \u0026#39;01012345678\u0026#39;} \u0026gt; print(d.pop(\u0026#39;Age\u0026#39;)) 33 \u0026gt; print(d) {\u0026#39;Name\u0026#39;: \u0026#39;Niceman\u0026#39;, \u0026#39;City\u0026#39;: \u0026#39;Seoul\u0026#39;, \u0026#39;Grade\u0026#39;: \u0026#39;A\u0026#39;, \u0026#39;Status\u0026#39;: True} # .popitem(): 추첨기에 사용할 수 있다. \u0026gt; print(d.popitem()) (\u0026#39;Status\u0026#39;, True) \u0026gt; print(d) {\u0026#39;Name\u0026#39;: \u0026#39;Niceman\u0026#39;, \u0026#39;City\u0026#39;: \u0026#39;Seoul\u0026#39;, \u0026#39;Grade\u0026#39;: \u0026#39;A\u0026#39;} \u0026gt; print(d.popitem()) (\u0026#39;Grade\u0026#39;, \u0026#39;A\u0026#39;) \u0026gt; print(d) {\u0026#39;Name\u0026#39;: \u0026#39;Niceman\u0026#39;, \u0026#39;City\u0026#39;: \u0026#39;Seoul\u0026#39;, \u0026#39;Grade\u0026#39;: \u0026#39;A\u0026#39;}  in 연산자 사용하여 key 값 존재유무 확인  \u0026gt; a = {\u0026#39;name\u0026#39; : \u0026#39;Kim\u0026#39;, \u0026#39;phone\u0026#39;: \u0026#39;01012345678\u0026#39;, \u0026#39;birth\u0026#39;: \u0026#39;870124\u0026#39;} \u0026gt; print(\u0026#39;name\u0026#39; in a) True \u0026gt; print(\u0026#39;addr\u0026#39; in a) False ","permalink":"http://jeha00.github.io/post/python_basic_7/","summary":"dictionary type의 선언, 출력과 수정 그리고, dictionary에 사용되는 함수에 대해 알아본다.","title":"[TIL] Python basic 7: dictionary "},{"content":"Intro  list와 tuple의 차이를 알아야 비교해서 무엇을 쓸 지 결정한다. tuple은 sequence형, immutable이기 때문에  순서가 있다.  하지만, list의 순서는 변할 수 있고, tuple의 순서는 불변이다. tuple의 순서는 한 번 생성되면 변경할 수 없다.   중복이 가능하다. =\u0026gt; list와 동일 수정이 안된다. =\u0026gt; del, remove, slicing, insert 로 값 변경이 안된다. list 와 마찬가지로 다양한 타입이 함께 포함될 수 있다.     1. tuple 선언  list는 대괄호다. tuple은 소괄호 또는 무괄호다. 소괄호는 괄호만 해도 tuple로 인식된다. 무괄호는 최소 원소 하나 이상이어야 하며, 쉼표가 있어야 한다. 소괄호 또한 최소 원소 하나 이상 입력할 때, 쉼표가 있어야 한다.  # tuple 선언 \u0026gt; a = () \u0026gt; b = (1,) \u0026gt; b = 1, \u0026gt; print(type(a)) # 위 방식 다 tuple 선언법이다. \u0026lt;class \u0026#39;tuple\u0026#39;\u0026gt; \u0026gt; c = (11, 12, 13, 14) \u0026gt; d = (100, 1000, \u0026#39;Ace\u0026#39;, \u0026#39;Base\u0026#39;, \u0026#39;Captine\u0026#39;) \u0026gt; e = (100, 1000, (\u0026#39;Ace\u0026#39;, \u0026#39;Base\u0026#39;, \u0026#39;Captine\u0026#39;))  2. tuple indexing, slicing, 연산  tuple에 indexing 사용하기  \u0026gt; c = (11, 12, 13, 14) \u0026gt; d = (100, 1000, \u0026#39;Ace\u0026#39;, \u0026#39;Base\u0026#39;, \u0026#39;Captine\u0026#39;) \u0026gt; e = (100, 1000, (\u0026#39;Ace\u0026#39;, \u0026#39;Base\u0026#39;, \u0026#39;Captine\u0026#39;)) \u0026gt; print(\u0026#39;d - \u0026#39;, type(d), d) d - \u0026lt;class \u0026#39;tuple\u0026#39;\u0026gt;, (100, 1000, \u0026#39;Ace\u0026#39;, \u0026#39;Base\u0026#39;, \u0026#39;Captine\u0026#39;) \u0026gt; print(\u0026#39;d - \u0026#39;, d[1]) d - 1000 \u0026gt; print(\u0026#39;d - \u0026#39;, d[0] + d[1] * 2) d - 2100 \u0026gt; print(\u0026#39;d - \u0026#39;, d[-1]) d - Captine \u0026gt; print(\u0026#39;e - \u0026#39;, e[-1]) e - (\u0026#39;Ace\u0026#39;, \u0026#39;Base\u0026#39;, \u0026#39;Captine\u0026#39;) \u0026gt; print(\u0026#39;e - \u0026#39;, e[-1][1]) e - Base \u0026gt; print(\u0026#39;e - \u0026#39;, list(e[-1][1])) e - [\u0026#39;B\u0026#39;, \u0026#39;a\u0026#39;, \u0026#39;s\u0026#39;, \u0026#39;e\u0026#39;]  tuple에 slicing 사용하기  \u0026gt; print(\u0026#39;d - \u0026#39;, d[0:3]) d - (100, 1000, \u0026#39;Ace\u0026#39;) \u0026gt; print(\u0026#39;d - \u0026#39;, d[2:]) d - (\u0026#39;Ace\u0026#39;, \u0026#39;Base\u0026#39;, \u0026#39;Captine\u0026#39;) \u0026gt; print(\u0026#39;e - \u0026#39;, e[2][1:3]) e - (\u0026#39;Ace\u0026#39;, \u0026#39;Base\u0026#39;)  tuple로 연산하기  \u0026gt; print(\u0026#39;c + d - \u0026#39;, c + d) c + d - (11, 12, 13, 14, 100, 1000, \u0026#39;Ace\u0026#39;, \u0026#39;Base\u0026#39;, \u0026#39;Captine\u0026#39;) \u0026gt; print(\u0026#39;c * 3 - \u0026#39;, c * 3) c * 3 -(11, 12, 13, 14, 11, 12, 13, 14, 11, 12, 13, 14) \u0026gt; print(\u0026#34;\u0026#39;Test\u0026#39; + c[0] - \u0026#34;, \u0026#39;Test\u0026#39; + c[0]) \u0026#39;Test\u0026#39; + c[0] - Test11  3. tuple 함수: index, count  index(): 함수는 원하는 성분 값의 index를 구하는 함수다. count(): 원하는 성분의 수량을 구하는 함수다.  \u0026gt; a = (5, 2, 3, 1, 4) \u0026gt; print(\u0026#39;a - \u0026#39;, a) a - (5, 2, 3, 1, 4) \u0026gt; print(\u0026#39;a - \u0026#39;, a.index(5)) a - 0 \u0026gt; print(\u0026#39;a - \u0026#39;, a.count(4)) a - 1 4. tuple의 중요한 특징: packing \u0026amp; unpacking  packing이란 단어 그대로의 의미로, 하나로 묶는 것을 말한다. unpacking은 하나로 묶여있던 tuple을 풀어서 각각 할당하는 것을 말한다.  # packing \u0026gt; t = (\u0026#39;foo\u0026#39;, \u0026#39;bar\u0026#39;, \u0026#39;baz\u0026#39;, \u0026#39;qux\u0026#39;) #출력 확인 \u0026gt; print(t) (\u0026#39;foo\u0026#39;, \u0026#39;bar\u0026#39;, \u0026#39;baz\u0026#39;, \u0026#39;qux\u0026#39;) \u0026gt; print(t[0]) foo \u0026gt; print(t[-1]) qux # unpacking 1 \u0026gt; (x1, x2, x3, x4) = t # 출력 확인 \u0026gt; print(x1, x2, x3, x4) foo bar baz qux # unpacking 2 \u0026gt; (x1, x2, x3, x4) = (\u0026#39;foo\u0026#39;, \u0026#39;bar\u0026#39;, \u0026#39;baz\u0026#39;, \u0026#39;qux\u0026#39;) \u0026gt; print(x1, x2, x3, x4) foo bar baz qux # unpacking 3 \u0026gt; t2 = 2, 3, 4 \u0026gt; t3 = 4, \u0026gt; x1, x2, x3 = t2 \u0026gt; x4, x5, x6 = 4, 5, 6 # tuple을 출력하는 것이므로 괄호가 존재한다. \u0026gt; print(t2) (2, 3, 4) \u0026gt; print(t3) (4, ) # 각 원소 값을 출력하는 것이므로 괄호가 없다. \u0026gt; print(x1, x2, x3) 2 3 4 \u0026gt; print(x4, x5, x6) 4 5 6 ","permalink":"http://jeha00.github.io/post/python_basic_6/","summary":"list와 tuple의 차이. tuple의 indexing, slicing, 연산. 그리고, tuple의 중요한 특징 중 하나인 packing \u0026amp; unpacking에 대해 알아본다.","title":"[TIL] Python basic 6: tuple"},{"content":"Intro   List 자료형은 sequence형이고, mutable이기 때문에\n 순서 존재한다. =\u0026gt; len, index, slicing 이 가능 중복이 가능하다. 수정, 삭제가 가능하다.    다른 언어에서는 배열이라 하는데 알고리즘을 풀기 위해서 굉장히 중요한 자료 형태다.\n   1. List 선언 # 빈 리스트 선언 \u0026gt; a = [] \u0026gt; print(type(a)) \u0026lt;class \u0026#39;list\u0026#39;\u0026gt; \u0026gt; b = list() \u0026gt; print(type(b)) \u0026lt;class \u0026#39;list\u0026#39;\u0026gt; # 값은 동일하지만, id 값이 다르다. \u0026gt; print(id(a), id(b)) # 정수만 list 구성 \u0026gt; c = [70, 75, 80 ,85] # 문자열, 정수, 실수형으로 list 구성 \u0026gt; d = [1000, 1000.5, \u0026#39;Ace\u0026#39;, \u0026#39;Base\u0026#39;, \u0026#39;Captine\u0026#39;] # list 안에 list를 넣을 수 있다. \u0026gt; e = [1000, 1000.5, [\u0026#39;Ace\u0026#39;, \u0026#39;Base\u0026#39;, \u0026#39;Captine\u0026#39;]] \u0026gt; f = [21.42, \u0026#39;foobar\u0026#39;, 3, 4, \u0026#39;bark\u0026#39;, False, 3.14159]  2. List indexing, slicing  list도 string처럼 sequence 형이기 때문에, len, index, slicing을 사용할 수 있다.\n  indexing: 원하는 데이터를 꺼내는 과정  \u0026gt; print(\u0026#39;d - \u0026#39;, type(d), d) d - \u0026lt;class \u0026#39;list\u0026#39;\u0026gt; [1000, 10000.1, \u0026#39;Ace\u0026#39;, \u0026#39;Base\u0026#39;, \u0026#39;Captine\u0026#39;] # index의 시작은 0부터이기 때문 \u0026gt; print(\u0026#39;d - \u0026#39;, d[1]) d - 1000.5 \u0026gt; print(\u0026#39;d - \u0026#39;, d[0] + d[1] + d[1]) d - 3001 \u0026gt; print(\u0026#39;d - \u0026#39;, d[-1]) d - Captine # list의 성분이 list이기 때문에, 성분 list의 [1] 성분을 말한다. \u0026gt; print(\u0026#39;e - \u0026#39;, e[-1][1]) e - Base # 문자열을 문자행 단위로 쪼개서 list로 만든다. \u0026gt; print(\u0026#39;e - \u0026#39;, list(e[-1][1])) e - [\u0026#39;B\u0026#39;, \u0026#39;a\u0026#39;, \u0026#39;s\u0026#39;, \u0026#39;e\u0026#39;]  slicing: 같은 데이터 타입으로, 원하는 부분의 데이터를 뽑아내는 것  \u0026gt; d = [1000, 1000.5, \u0026#39;Ace\u0026#39;, \u0026#39;Base\u0026#39;, \u0026#39;Captine\u0026#39;] \u0026gt; e = [1000, 1000.5, [\u0026#39;Ace\u0026#39;, \u0026#39;Base\u0026#39;, \u0026#39;Captine\u0026#39;]] \u0026gt; print(\u0026#39;d - \u0026#39;, d[0:3]) d - [1000, 1000.5, \u0026#39;Ace\u0026#39;] \u0026gt; print(\u0026#39;d - \u0026#39;, d[2:]) d - [\u0026#39;Ace\u0026#39;, \u0026#39;Base\u0026#39;, \u0026#39;Captine\u0026#39;] \u0026gt; print(\u0026#39;e - \u0026#39;, e[2][1:3]) e - [\u0026#39;Ace\u0026#39;, \u0026#39;Base\u0026#39;] \u0026gt; print(\u0026#39;e - \u0026#39;, e[-1][1:3]) e - [\u0026#39;Ace\u0026#39;, \u0026#39;Base\u0026#39;]  3. List 연산 \u0026gt; c = [70, 75, 80 ,85] \u0026gt; print(\u0026#39;c + d -\u0026#39;, c + d) [70, 75, 80 ,85, 1000, 1000.5, \u0026#39;Ace\u0026#39;, \u0026#39;Base\u0026#39;, \u0026#39;Captine\u0026#39;] \u0026gt; print(\u0026#39;c * 3 -\u0026#39;, c * 3) [70, 75, 80 ,85, 70, 75, 80 ,85, 70, 75, 80 ,85] \u0026gt; print(\u0026#39;Test + c[0] - \u0026#39;, \u0026#39;Test\u0026#39; + str(c[0])) Test + c[0] - Test70 # 값 비교 \u0026gt; print(c == c[:3] + c[3:]) True # 동일한 id 값 \u0026gt; python = c \u0026gt; print (python == c) True # 동일한 id가 출력된다. \u0026gt; print(id(c), id(python))  4. List 함수 a = [5, 3, 4, 7, 8 ] # 끝에 데이터를 삽입할 때 사용 # append가 매달다 라는 의미이므로 \u0026gt; a.append(6) \u0026gt; print(a) [5, 3, 4, 7, 8, 6] # 정렬 \u0026gt; a.sort() \u0026gt; print(a) [3, 4, 5, 7, 8] # 뒤집음 \u0026gt; a.reverse() \u0026gt; print(a) [8, 7, 5, 4, 3] # sort와 reverse는 데이터가 많으면 오랜 시간이 걸린다. # index(x) 는 x 값의 첫 번째 index를 출력한다. \u0026gt; print(\u0026#39;a - \u0026#39;, a.index(3), a[3]) a - 4 4 # insert(추가할 위치, 추가할 값) \u0026gt; a.insert(2,7) \u0026gt; print(a) [8, 7, 7, 5, 4, 3] # count(): 원하는 값의 갯수를 새는 method다. # a list에 7이 2개가 있으므로 출력값 2가 나온다. \u0026gt; print(\u0026#39;a - \u0026#39;, a.count(7)) a - 2 # extend(): 괄호 안에 값을 list에 연장한다. \u0026gt; ad = [2, 1] \u0026gt; a.extend(ad) \u0026gt; print(a) [8, 7, 7, 5, 4, 3, 2, 1] 결론\n a.append(): 끝에 데이터를 삽입한다. 매달은다 a.sort(): 데이터를 정렬한다. a.reverse(): 데이터 방향을 뒤집는다. a.index(): 괄호 값의 첫 번째 index를 알려준다. a.insert(x,y): index x 번째 있는 자리에 y 값을 삽입한다. a.count(): 원하는 값의 갯수를 세는 method a.extend(): 괄호 안의 값을 list에 연장한다.   5. List 수정, 삭제 5.1 slicing과 index를 사용하여 수정, 삭제하는 방법  수정하기  \u0026gt; c = [70, 75, 80 ,85] ## 수정하기 # index 번호로 접근하여 수정 \u0026gt; c[0] = 4 \u0026gt; print(c) [4, 75, 80, 85] # insert 되는 결과 \u0026gt; c[1:2] = [\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;] \u0026gt; print(c) [4, \u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;, 80, 85] # 하지만 slicing이 아닌 index로 명령하면 선언한 value 그대로 원소가 된다. \u0026gt; c[1] = [\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;] \u0026gt; print(c) [70, [\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;], 80, 85] # list 자체가 하나의 원소로 list에 들어갔다. # slicing으로 list를 원소로 넣고 싶으면 다음과 같이 한다. \u0026gt; c[1:2] = [[\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;]] \u0026gt; print(c) [70, [\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;], 80, 85] ## list 안에 list가 들어간 걸 `중첩`이라 한다.  삭제하기  # 빈 값을 선언하는 것이 삭제하는 걸 의미한다. \u0026gt; c = [70, 75, 80 ,85] \u0026gt; c[1:3] = [] \u0026gt; print(c) [70, 85] # c[1], c[2] 원소가 삭제된다. 5.2 함수를 사용하여 삭제하는 방법: remove, pop, del \u0026gt; c = [70, 75, 80 ,85] # remove(삭제할 데이터값) # remove는 삭제할 데이터값을 직접 지정한다. \u0026gt; c.remove(70) \u0026gt; print(c) [75, 80, 85] # pop() : 마지막 원소를 뽑아내고, 나머지로 만든다. \u0026gt; print(\u0026#39;c - \u0026#39;, c.pop()) c - 85 # del은 지울려는 데이터가 몇 번째인지 알아야 한다. # 하지만, list의 데이터는 많아질 경우, 세기가 어렵다. # 그럴 때는 위에 remove를 사용한다. \u0026gt; del c[1] \u0026gt; print(c) 75   pop( )\n stack 자료 구조에서 마지막에 들어온 애가 가장 먼저 나갑니다: last in, first out로 LIFO라 한다.\n예1) 음식을 접시에 담을 때, 마지막에 쌓은 접시를 꺼내서 사용한다. 예2) 웹 브라우저를 뒤로 가기 버튼을 누르면, 마지막 페이지가 먼저 나온다.\n이런 자료 구조에서 많이 사용되는 method가 pop 입니다.\n   Queue 는 stack과 반대로 가장 처음에 들어온 것을 빼는 구조로, first in, first out로 FIFO라 한다.\n   반복문을 활용하여 제거하는 방법도 있다. 따로 break 를 사용하지 않아도, a가 비워지면 끝난다.  \u0026gt; a = [8, 7, 7, 5, 4, 3] \u0026gt; while a: \u0026gt; data = a.pop() \u0026gt; print(data) ","permalink":"http://jeha00.github.io/post/python_basic_5/","summary":"list의 생성, indexing, slicing, 연산, list에 쓰이는 함수 그리고, list를 수정하고 삭제하는 방법에 대해 알아보겠다.","title":"[TIL] Python basic 5: list"},{"content":"1. 문자열 생성, 출력 그리고, 길이  문자열 생성하기(선언하기) 및 출력하기  # 문자열 생성 \u0026gt; str1 = \u0026#34;I am Python\u0026#34; \u0026gt; str2 = \u0026#39;Python\u0026#39; # 빈 문자열 생성 \u0026gt; str_t1 = \u0026#39;\u0026#39; \u0026gt; str_t2 = str() # 문자열 출력 \u0026gt; print(str1, type(str1)) I am Python \u0026lt;class \u0026#39;str\u0026#39;\u0026gt; \u0026gt; print(str2, type(str2)) Pyton \u0026lt;class \u0026#39;str\u0026#39;\u0026gt; \u0026gt; print(str_t1, type(str_t1)) \u0026lt;class \u0026#39;str\u0026#39;\u0026gt; \u0026gt; print(str_t2, type(str_t2)) \u0026lt;class \u0026#39;str\u0026#39;\u0026gt;  문자열 길이 측정: **len()**을 많이 사용한다. 길이에는 공백을 포함한다.  \u0026gt; print(len(str1)) 11 \u0026gt; print(len(str2)) 6 결론\n 문자열 선언에는 \u0026ldquo;\u0026rdquo;, \u0026lsquo;\u0026rsquo;, \u0026ldquo;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026rdquo;, '''''' 을 사용한다. 문자열 출력에는 다른 출력과 동일하게 print를 사용한다. 문자열 길이 측정에는 len() 함수를 사용한다. 길이에는 공백을 포함한다.\n  2. Escape, raw string and multi line 2.1 Escape code \\n: 개행(줄바꿈) \\t: 탭키를 누른 만큼 벌어짐 \\\\: 문자 삽입 \\\u0026#39;: 문자 삽입 \\\u0026#34;: 문자 삽입  위에 escape code 예시를 작성해보자.  ## 문자 삽입 escape code \u0026gt; escape_str1 = \u0026#34;do you have a \\\u0026#34;retro games\\\u0026#34;?\u0026#34; \u0026gt; print(escape_str1) do you have a \u0026#34;retro games?\u0026#34; # 홀따옴표 사용 \u0026gt; escape_str2 = \u0026#39;What\\\u0026#39;s on TV??\u0026#39; # 쌍따옴표 사용 \u0026gt; escape_Str3 = \u0026#34;what\u0026#39;s one TV??\u0026#34; \u0026gt; print(escape_str2) \u0026gt; print(escape_str3) What\u0026#39;s on TV?? ## 개행, 탭 # tab 누른 만큼 떨어져서 출력 \u0026gt; t_s1 = \u0026#34;Click \\t Start!\u0026#34; \u0026gt; print(t_s1) Click Start! # 줄 바껴서 출력 \u0026gt; t_s2 = \u0026#34;New Line\\n Check!\u0026#34; \u0026gt; print(t_s2) New Line Check! 2.2 Raw String  소문자 r을 붙이면 Escape 표현을 무시하고 그대로 다 출력한다. Escape 표현을 사용하지 않기 위해 선언! 이런 게 있다는 정도만 알고 있기  # raw string 미포함 \u0026gt; raw_s1 = \u0026#34;\\\\x\\y\\z\\q\u0026#34; \u0026gt; print(raw_s1) \\x\\y\\z\\q # raw string 포함 \u0026gt; raw_s1 = r\u0026#34;\\\\x\\y\\z\\q\u0026#34; \u0026gt; print(raw_s1) \\\\x\\y\\z\\q 2.3 Multi Line  여러 줄 출력하는 방법으로 \\(역슬러쉬) 를 사용한다. 역슬러쉬를 사용하여 파이썬에게 어떤 변수를 binding 한다는 걸 의미한다. 그래서 다음 줄에 변수를 선언한다는 걸 의미한다. 콤마는 ```,\u0026quot;\u0026quot;\u0026quot; 처럼 3개 이상을 사용한다.  \u0026gt; multi_str1 \\ \u0026#34;\u0026#34;\u0026#34; 문자열 멀티라인 입력 테스트 \u0026#34;\u0026#34;\u0026#34; \u0026gt; print(multi_str1) 문자열 멀티라인 입력 테스트 결말\n  이스케이프 코드를 사용하여 개행, 탭만큼 띄우기, 따옴표 문자 삽입이 가능하다. 이스케이프 코드를 사용하고 싶지 않을 때는 string code를 사용한다. 한 줄로는 너무 길어서 여러 줄로 표현하고 싶을 때, 백슬러쉬와 따옴표 3개를 사용하여 멀티라인으로 출력한다.    3. 문자형 연산 \u0026gt; str_o1 = \u0026#34;python\u0026#34; \u0026gt; str_o2 = \u0026#34;Apple\u0026#34; \u0026gt; str_o3 = \u0026#34;How are you doing\u0026#34; \u0026gt; str_o4 = \u0026#34;Korea Japan America\u0026#34; \u0026gt; print(3 * str_o1) pythonpythonpython \u0026gt; print(str_o1 + str_o2) pythonApple \u0026gt; print(\u0026#39;y\u0026#39; in str_o1) True \u0026gt; print(\u0026#39;n\u0026#39; in str_o1) True \u0026gt; print(\u0026#39;P\u0026#39; not in str_o1) False  4. 문자형 형 변환(Type conversion), 문자형 함수 4.1 Type Conversion  파이썬에서 type conversion은 자유롭게 가능하다고 생각하자.  # 정수 -\u0026gt; 문자열 \u0026gt; print(str(66)) # 실수 -\u0026gt; 문자열 \u0026gt; print(str(10.1)) # boolean -\u0026gt; string \u0026gt; print(str(True), type(str)) True \u0026lt;class \u0026#39;str\u0026#39;\u0026gt; # complex -\u0026gt; string \u0026gt; print(str(complex(12))) 12 + 0j 4.2 문자열 함수  print(dir()) 함수에 변수를 입력하면 그 변수가 사용할 수 있는 함수를 보여준다. string type의 data를 넣으면 string이 사용할 수 있는 함수를 보여준다. list면 list가 사용할 수 있는 함수를 보여준다.\n \u0026gt; im_str = \u0026#34;Good Boy\u0026#34; \u0026gt; print(dir(im_str)) [\u0026#39;capitalize\u0026#39;, \u0026#39;encode\u0026#39;, \u0026#39;endswith\u0026#39;, \u0026#39;expandtabs\u0026#39;, \u0026#39;find\u0026#39;, \u0026#39;format\u0026#39;, \u0026#39;lower\u0026#39;, \u0026#39;lstrip\u0026#39;, \u0026#39;maketrans\u0026#39;, \u0026#39;partition\u0026#39;, \u0026#39;removeprefix\u0026#39;, \u0026#39;removesuffix\u0026#39;, \u0026#39;replace\u0026#39;, \u0026#39;rfind\u0026#39;, \u0026#39;rindex\u0026#39;, \u0026#39;rjust\u0026#39;, \u0026#39;rpartition\u0026#39;, \u0026#39;rsplit\u0026#39;, \u0026#39;rstrip\u0026#39;, \u0026#39;split\u0026#39;, \u0026#39;splitlines\u0026#39;, \u0026#39;startswith\u0026#39;, \u0026#39;strip\u0026#39;, \u0026#39;swapcase\u0026#39;, \u0026#39;title\u0026#39;, \u0026#39;translate\u0026#39;, \u0026#39;upper\u0026#39;, \u0026#39;zfill\u0026#39;.....]  위 함수들에서 일부만 출력해보겠다.  \u0026gt; str_o1 = \u0026#34;python\u0026#34; \u0026gt; str_o2 = \u0026#34;Apple\u0026#34; \u0026gt; str_o3 = \u0026#34;How are you doing\u0026#34; \u0026gt; str_o4 = \u0026#34;Korea Japan America\u0026#34; # 첫 글자를 대문자로 바꿔주는 함수 \u0026gt; print(\u0026#34;Capitalize : \u0026#34;, str_o1.capitalize()) Capitalize : Python # 모든 문자를 대문자로 바꿔주는 함수 \u0026gt; print(\u0026#34;upper : \u0026#34;, str_o1.upper()) upper : PYTHON # 모든 문자를 소문자로 바꿔주는 함수 \u0026gt; print(\u0026#34;lower : \u0026#34;, str_o2.lower()) lower : apple # 마지막 글자가 s로 끝나는가? \u0026gt; print(\u0026#34;endswith? : \u0026#34;, str_o1.endswith(\u0026#39;s\u0026#39;)) endswith : False # 해당 문자열 앞 뒤로 join하는 함수 \u0026gt; print(\u0026#34;join str : \u0026#34;, str_o1.join([\u0026#34;I\u0026#39;m\u0026#34;, \u0026#34;!\u0026#34;])) join str : I\u0026#39;m python! # 해당 문자열을 입력한 다른 문자열로 바꿔주는 함수 \u0026gt; print(\u0026#34;replace : \u0026#34;, str_o1.replace(\u0026#39;thon\u0026#39;, \u0026#39;Good\u0026#39;)) replace : pyGood # 해당 문자열을 입력한 문자열을 기준으로 쪼개어 list로 만드는 함수 \u0026gt; print(\u0026#34;split : \u0026#34;, str_o4.split(\u0026#39; \u0026#39;)) split : Korea Japan America # 최소 단위까지 쪼개어 알파벳 순으로 list로 만드는 함수 \u0026gt; print(\u0026#39;sorted : \u0026#39;, sorted(str_o3)) sorted : [\u0026#39; \u0026#39;, \u0026#39; \u0026#39;, \u0026#39; \u0026#39;, \u0026#39;?\u0026#39;, \u0026#39;H\u0026#39;, \u0026#39;a\u0026#39;, \u0026#39;d\u0026#39;, \u0026#39;e\u0026#39;, \u0026#39;g\u0026#39;, \u0026#39;i\u0026#39;, \u0026#39;n\u0026#39;, \u0026#39;o\u0026#39;, \u0026#39;o\u0026#39;, \u0026#39;o\u0026#39;, \u0026#39;r\u0026#39;, \u0026#39;u\u0026#39;, \u0026#39;w\u0026#39;, \u0026#39;y\u0026#39;] \u0026gt; print(\u0026#39;reversed1: \u0026#39;, reversed(str_o2)) reversed1: \u0026lt;reversed object at 0x000001ECEA15CFD0\u0026gt; # reversed는 return 값이 존재하기에 list로 출력이 가능하다. \u0026gt; print(\u0026#39;reversed2: \u0026#39;, list(reversed(str_o2)) reversed2: [\u0026#39;e\u0026#39;, \u0026#39;l\u0026#39;, \u0026#39;p\u0026#39;, \u0026#39;p\u0026#39;, \u0026#39;A\u0026#39;]  reverse 와 reversed 의 차이\n reverse 는 list 함수를 단순히 뒤집어서 저장해주는 역할로, 리턴값이 없어서 for문 같은 조건문 반복문에 사용하지 못 한다. reversed는 id 값으로 나온다. 그래서 reverse 값을 원하면 형 변환을 해야 한다. 또한, 기존 리스트의 값을 변경하지 않으면서 return 값만을 원할 때 reversed 함수를 사용한다.    5. Slicing  문자열의 일부분을 원하는 대로 잘라오는 것을 말한다.\n \u0026gt; sl = \u0026#39;Nice Python\u0026#39; \u0026gt; print(sl[0:3]) Nic # index[0] 부터 [3]까지가 아닌, [2]까지이기 때문이다. \u0026gt; print(sl[5:]) Python # 아무런 값이 없으면 끝까지 또는 처음부터라는 의미다. \u0026gt; print(sl[:len(sl)]) Nice Python # 끝부분의 index를 모를 때, len 함수를 사용한다. 끝까지 출력된다. # 위에 [0:3] 처럼 끝에가 -1 이 되지 않는다. \u0026gt; print(sl[:len(sl)-1]) Nice Pytho # 처음과 끝을 의미한다. \u0026gt; print(sl[:]) Nice Python # index[1]부터 시작하여 2씩 증가하며, index[4] 미만까지 한다. \u0026gt; print(sl[1:4:2]) ie # index[-4]부터 시작하여 [-3] 미만까지 한다. \u0026gt; print(sl[-4:-2]) th # index를 역으로 해도 가능하다. \u0026gt; print(sl[-5:]) Python # index를 역으로 하는 것과 정방향으로 하는 것을 같이 해도 가능하다. \u0026gt; print(sl[1:-2]) ice Pyth # 역으로 출력된다. \u0026gt; print(sl[::-1]) nohtyP eciN 결론: slicing을 사용하여 원하는 정보를 추출해야한다. 그렇기 떄문에 slicing은 중요하다.\n","permalink":"http://jeha00.github.io/post/python_basic_4/","summary":"string type의 생성부터 연산, len 함수 사용, type conversion, 문자형 함수 그리고 slicing을 알아보겠다.","title":"[TIL] Python basic 4: string"},{"content":"1. 파이썬의 모든 자료형  파이썬이 지원하는 자료형은 다음과 같다.  int: 정수 float: 실수 complex: 복소수 bool: 불린 (True or False) str: 문자열(시퀀스) list: 리스트(시퀀스) tuple: 튜플(시퀀스) set: 집합 dict: 사전  그러면 각 자료형의 구체적인 예를 알아보자.  # str : string 의 약어로, 문자열 자료형을 의미한다. \u0026gt; str1 = \u0026#34;Jeha\u0026#34; \u0026gt; str2 = \u0026#34;Anacondacong\u0026#34; # bool: boolean 의 약어로, True or False 자료형을 의미한다. \u0026gt; bool1 = True # float: 실수형 자료형을 의미한다. 소수점이 존재한다. # 소수점 아래가 0이어도, 소수점이 존재하므로 실수형 데이터다. \u0026gt; float1 = 10.0 # int : integer의 약어로, 정수형 데이터를 말한다. \u0026gt; int1 = 7 # list : 리스트형으로 대괄호 안에 열거된 데이터 타입을 말합니다. \u0026gt; list1 = [str1, str2] # tuple: 튜플이라 하며, 소괄호 또는 괄호 없이 , 마로만 열거된 형태를 말합니다. # dict : dictionary의 약어로, 중괄호 안에 key : value 로 구성된 데이터 형태입니다. \u0026gt; dict1 = { \u0026#34;name : \u0026#34;Machine Learning\u0026#34;, \u0026#34;version\u0026#34; : 2.0 } # set : 집합형 데이터 타입으로, dict 와 마찬가지로 중괄호 형태의 데이터입니다. \u0026gt; set1 = {7, 8, 9}  각 데이터 타입 출력은 다음과 같이 한다.  \u0026gt; print(type(str1)) \u0026lt;class \u0026#39;str\u0026#39;\u0026gt; \u0026gt; print(type(bool1)) \u0026lt;class \u0026#39;bool\u0026#39;\u0026gt; \u0026gt; print(type(str2)) \u0026lt;class \u0026#39;str\u0026#39;\u0026gt; \u0026gt; print(type(float1)) \u0026lt;class \u0026#39;float\u0026#39;\u0026gt; \u0026gt; print(type(int1)) \u0026lt;class \u0026#39;int\u0026#39;\u0026gt; \u0026gt; print(type(dict1)) \u0026lt;class \u0026#39;dict\u0026#39;\u0026gt; \u0026gt; print(type(tuple1)) \u0026lt;class \u0026#39;tuple\u0026#39;\u0026gt; \u0026gt; print(type(set1)) \u0026lt;class \u0026#39;set\u0026#39;\u0026gt; - 결론: 데이터 타입의 종류에는 숫자형, 문자형, 리스트, 튜플, 딕셔너리가 있다.\n 2. 숫자형 데이터 선언 # 정수 선언 \u0026gt; i = 77 \u0026gt; i2 = -14 \u0026gt; big_int = 888888888888888 #정수 출력 \u0026gt; print(i) 77 \u0026gt; print(i2) -14 \u0026gt; print(big_int) 888888888888888 # 실수 선언 \u0026gt; f = 0.9999 \u0026gt; f2 = 3.141592358 \u0026gt; f3 = - 4.2 # 실수 출력 \u0026gt; print(f) 0.9999 \u0026gt; print(f2) 3.141592358 \u0026gt; print(f3) -4.2 - 결론: 변수명 = 할당할 value값\n 3. 연산자 활용  숫자형 연산자 종류에는 다음과 같다.  + : 덧셈 - : 뺼셈 * : 곱셈 / = 나누기를 의마하며, 몫과 나머지로 구성된다. // : 나누기의 몫 부분을 출력한다. % : 나누기의 나머지 부분을 출력한다. x ** y : 제곱으로, x의 y제곱 을 의미한다.  그러면 연산 실습을 해보겠다.  # 변수 선언 \u0026gt; i1 = 39 \u0026gt; i2 = 939 \u0026gt; big_int1 = 123456789123456789012345678901234567890 \u0026gt; big_int2 = 999999999999999999999999999999999999999 \u0026gt; f1 = 1.234 \u0026gt; f2 = 3.939 # + \u0026gt; print(\u0026#34;i1 + i2 : \u0026#34;, i1 + i2) i1 + i2 : 978 \u0026gt; print(\u0026#34;f1 + f2 : \u0026#34;, f1 + f2) f1 + f2 : 5.173 \u0026gt; print(\u0026#34;big_int1 + big_int2 : \u0026#34;, big_int1 + big_int2) big_int1 + big_int2 : 1123456789123456789012345678901234567889 # 큰 값들도 연산이 가능하다. \u0026gt; a = 3 + 1.0 \u0026gt; print(a, type(a)) 4.1 \u0026lt;class \u0026#39;float\u0026#39; \u0026gt; # 정수형과 실수형을 같이 연산할 때, 정수형을 자동적으로 실수형으로 변환하여 계산한다. # - \u0026gt; print(\u0026#34;i1 - i2: \u0026#34;, i1 - i2) i1 - i2: -900 \u0026gt; print(\u0026#34;f1 - f2: \u0026#34;, f1 - f2) f1 - f2: -2.705 \u0026gt; print(\u0026#34;big_int1 - big_int2: \u0026#34;, big_int1 - big_int2) big_int1 - big_int2: -876543210876543210987654321098765432109 # * \u0026gt; print(\u0026#34;i1 * i2: \u0026#34;, i1 * i2) i1 * i2: 36621 \u0026gt; print(\u0026#34;f1 * f2: \u0026#34;, f1 * f2) f1 * f2: 4.860726 \u0026gt; print(\u0026#34;big_int1 * big_int2: \u0026#34;, big_int1 * big_int2) big_int1 * big_int2: 123456789123456789012345678901234567889876543210876543210987654321098765432110 # / \u0026gt; print(\u0026#34;i2 / i1: \u0026#34;, i2 / i1) i2 / i1: 24.076923076923077 \u0026gt; print(\u0026#34;f2 / f1: \u0026#34;, f2 / f1) f2 / f1: 3.1920583468395463 \u0026gt; print(\u0026#34;big_int2 / big_int1: \u0026#34;, big_int2 / big_int1) big_int2 / big_int1: 8.10000006561 # // \u0026gt; print(\u0026#34;i2 // i1: \u0026#34;, i2 // i1) i2 // i1: 24 # i2 / i1 의 연산값의 몫 부분임을 알 수 있다. \u0026gt; print(\u0026#34;f2 // f1: \u0026#34;, f2 // f1) f2 // f1: 3.0 # f2 / f1 의 연산값의 몫 부분임을 알 수 있다. \u0026gt; print(\u0026#34;big_int2 // big_int1: \u0026#34;, big_int2 // big_int1) big_int2 // big_int1: 8 # big_int2 / big_int1 의 연산값의 몫 부분임을 알 수 있다. # % \u0026gt; print(\u0026#34;i2 % i1 :\u0026#34;, i2 % i1) i2 % i1 : 3 # i1 * (i2 // i1) 으로 i2를 나누고 나온 나머지값 \u0026gt; print(\u0026#34;f2 % f1 :\u0026#34;, f2 % f1) f2 % f1 : 0.2370000000000001 \u0026gt; print(\u0026#34;big_int1 % big_int2 :\u0026#34;, big_int1 % big_int2) big_int1 % big_int2 : 123456789123456789012345678901234567890 # ** 와 pow(x,y) \u0026gt; print(\u0026#34;2 ** 3: \u0026#34;, 2 ** 3) \u0026gt; print(\u0026#34;2 ** 3: \u0026#34;, pow(2,3)) 2 ** 3: 8 2 ** 3: 8 \u0026gt; print(\u0026#34;i1 ** i2: \u0026#34;, i1 ** i2) \u0026gt; print(\u0026#34;i1 ** i2: \u0026#34;, pow(i1,i2)) i1 ** i2: 102250631262663558380..... i1 ** i2: 102250631262663558380..... # 너무 길어서 생략 \u0026gt; print(\u0026#34;f1 ** f2: \u0026#34;, f1 ** f2) \u0026gt; print(\u0026#34;f1 ** f2: \u0026#34;, pow(f1,f2)) f1 ** f2: 2.289235194260789 f1 ** f2: 2.289235194260789 4. 형 변환  형 변환 함수는 다음과 같다.  abs(x): absolute의 약어로, 절대값으로 변환한다. int(x): 정수형으로 만듭니다. 실수를 입력했다면 실수의 정수 부분을 출력한다. float(x): 실수형으로 만듭니다. 정수를 입력했다면 소수점 .0 으로 나온다. complex(x): 복소수로 허수까지 포함해서 a+bi 형태로 변환한다. pow(x, y): x의 y승 제곱으로 출력된다. a = 3. b = 9 c = .65 d = 13.55 # type 출력 \u0026gt; print(type(a), type(b), type(c), type(d)) \u0026lt;class \u0026#39;float\u0026#39;\u0026gt; \u0026lt;class \u0026#39;int\u0026#39;\u0026gt; \u0026lt;class \u0026#39;float\u0026#39;\u0026gt; \u0026lt;class \u0026#39;float\u0026#39;\u0026gt; # 형 변환 \u0026gt; print(float(b))  #정수 -\u0026gt; 실수 9.0 \u0026gt; print(int(c)) # 실수 -\u0026gt; 정수 0 \u0026gt; print(ind(D)) # 실수 -\u0026gt; 정수 13 \u0026gt; print(int(True)) # Bool -\u0026gt; 정수 1 \u0026gt; print(float(True)) # Bool -\u0026gt; 실수 1.0 \u0026gt; print(int(False)) 0 \u0026gt; print(float(False)) 0.0 \u0026gt; print(complex(3)) # 정수 -\u0026gt; 복소수 3 +0j \u0026gt; print(complex(\u0026#39;3\u0026#39;)) # 문자형 -\u0026gt; 복소수 3 + 0j # string data type을 숫자형으로 바꾸고 나서 복소수를 처리해야 하는데, 바로 처리된다. \u0026gt; print(complex(False)) # Bool -\u0026gt; 복소수 0j # 수치 연산 함수 \u0026gt; print(abs(-7)) 7 # divmod(x,y) : x를 y로 나눴을 때, 몫과 나머지를 반환한다. 많이 사용되는 함수로 중요하다. \u0026gt; x, y = divmod(100, 8) #몫 과 나머지 \u0026gt; print(x, y) 12 4 \u0026gt; print(pow(5, 3)) \u0026gt; print(5**3) 125 125 - 결론: 다른 data type으로 형 변환이 가능하다.\n5. 외부 모듈 사용  import 를 사용한다.  # 외부 모듈을 불러오는 함수 \u0026gt; import math # math 모듈에서 ceil 이란 함수를 사용하겠다. # ceil(x) : x 이상의 수중에서 가장 작은 정수를 반환한다. \u0026gt; print(math.ceil(5.2)) 6 \u0026gt; print(math.pi) 3.1415926535 - 결론: import를 사용하여 외부 module을 가져온다.\nReference  Python tutorial  ","permalink":"http://jeha00.github.io/post/python_basic_3/","summary":"첫 번째, python의 자료형 종류에는 무엇이 있는지 알아본다. 두 번째, 숫자형 데이터 타입의 선언, 연산, 그리고 형 변환에 대해 중점적으로 알아보겠다.","title":"[TIL] Python basic 3: numeric data"},{"content":"1. 기본 출력 1.1 Escape 코드 \\n: 개행 \\t: 탭 \\\\: 문자 \\\u0026#39;: 문자 \\\u0026#34;: 문자 \\000: 널 문자 1.2 기본 출력  '' 또는 \u0026quot;\u0026quot; 를 자주 사용한다.  \u0026gt; print(\u0026#39;JeHa start!\u0026#39;) \u0026gt; print(\u0026#34;JeHa start!\u0026#34;) \u0026gt; print() \u0026gt; print(\u0026#39;\u0026#39;\u0026#39;JeHa start!\u0026#39;\u0026#39;\u0026#39;) \u0026gt; print(\u0026#39;\u0026#39;) \u0026gt; print(\u0026#34;\u0026#34;\u0026#34;JeHa start!\u0026#34;\u0026#34;\u0026#34;) # 아무것도 출력되지 않는다. \u0026gt; print(\u0026#39;\u0026#39;) \u0026gt; print()  결과는 다음과 같다.  JeHa start! JeHa start! JeHa start! JeHa start! 1.3 Separator 옵션  여러 data를 열거하여 출력할 때, 각 data 사이 사이를 분리할 string을 입력할 수 있다.  \u0026gt; print(\u0026#39;python\u0026#39;, \u0026#39;start!\u0026#39;, sep=\u0026#39;@\u0026#39;) python @ start! \u0026gt; print(\u0026#39;p\u0026#39;,\u0026#39;y\u0026#39;,\u0026#39;t\u0026#39;,\u0026#39;h\u0026#39;,\u0026#39;o\u0026#39;,\u0026#39;n\u0026#39;) p y t h o n \u0026gt; print(\u0026#39;p\u0026#39;,\u0026#39;y\u0026#39;,\u0026#39;t\u0026#39;,\u0026#39;h\u0026#39;,\u0026#39;o\u0026#39;,\u0026#39;n\u0026#39;, sep = \u0026#39;\u0026#39;) python \u0026gt; print(\u0026#39;010\u0026#39;, \u0026#39;6677\u0026#39;, \u0026#39;6677\u0026#39;, sep = \u0026#39;-\u0026#39; ) 010-6677-6677 \u0026gt; print(\u0026#39;python\u0026#39;, \u0026#39;google.com\u0026#39;, sep = \u0026#39;@\u0026#39;) python@google.com 1.4 End 옵션  print에는 자동적으로 행간을 나누는 기능이 있다. 이를 end를 통해서 합칠 수 있다.  \u0026gt; print(\u0026#39;I\u0026#39;) \u0026gt; print(\u0026#39;love\u0026#39;) \u0026gt; print(\u0026#39;u\u0026#39;) I Love u \u0026gt; print(\u0026#39;I\u0026#39;, end = \u0026#39; \u0026#39;) \u0026gt; print(\u0026#39;love\u0026#39;, end = \u0026#39; \u0026#39;) \u0026gt; print(\u0026#39;u\u0026#39;) I love u 2. String 문자열 출력 (s)  d는 정수, s는 string, f는 실수를 의미한다. % 로 formatting 하는 방법과 .format 을 사용해서 formatting하는 방법이 있다. 다 익숙해져야 하지만, 후자를 더 빈번히 사용한다. formatting을 하면 특정 케이스에 원하는 형식대로 출력할 수 있고, 가독성이 높아진다.  # 순서에 맞게 자동적으로 mapping 해준다. \u0026gt; print(\u0026#39;%s %s\u0026#39; % (\u0026#39;one\u0026#39;,\u0026#39;two)) \u0026gt; print(\u0026#39;{} {}\u0026#39;.format(\u0026#39;one\u0026#39;,\u0026#39;two\u0026#39;)) # 순서를 지정해서도 할 수 있다. # index[1] 은 two, index[0]은 one 이므로, 교차해서 mapping 된다. \u0026gt; print(\u0026#39;{1} {0}\u0026#39;.format(\u0026#39;one\u0026#39;,\u0026#39;two\u0026#39;)) one two one two two one  전체 자릿수를 지정하는 방법과 정렬 방향을 바꾸는 방법을 알아보겠다.  # 문자열 총 자리 수는 10자리를 의미한다. # 오른쪽 정렬 # 즉, blank 시작은 왼쪽부터다. \u0026gt; print(\u0026#39;%10s\u0026#39; % (likelike)) # 왼쪽 blank는 2칸이다. likelike # 방향을 반대로 하기 위해서는 (-)를 붙힌다: 왼쪽정렬 \u0026gt; print(\u0026#39;%-10s\u0026#39; % (likelike)) likelike  위 내용을 .format으로 표현해보자. .format은 string을 입력할 때 \u0026rsquo;s\u0026rsquo;를 입력하지 않아도 된다.  # 오른쪽 정렬 \u0026gt; print(\u0026#39;{:\u0026gt;10}\u0026#39;.format(\u0026#39;likelike\u0026#39;)) likelike # 왼쪽 정렬 \u0026gt; print(\u0026#39;{:\u0026lt;10}\u0026#39;.format(\u0026#39;likelike\u0026#39;)) likelike \u0026gt; print(\u0026#39;{:10}\u0026#39;.format(\u0026#39;likelike\u0026#39;)) likelike # 가운데 정렬 \u0026gt; print(\u0026#39;{:^10}\u0026#39;.format(\u0026#39;likelike\u0026#39;)) likelike # blank에는 언더바가 있도록 하는 것 \u0026gt; print(\u0026#39;{:_\u0026gt;10}\u0026#39;.format(\u0026#39;like\u0026#39;)) ______like  그러면 지정한 자릿수보다 문자열이 더 길다면??  \u0026gt; print(\u0026#39;%5s\u0026#39; % (\u0026#39;likelike\u0026#39;)) likelike # 다 출력된다.  지정한 자릿수를 넘는 문자열 부분들을 절삭하고 싶다면??  # . 점을 아래와 같이 표시한다. \u0026gt; print(\u0026#39;%.5s\u0026#39; % \u0026#39;likelike\u0026#39;) likel # 이것은 어떻게 출력될까?? \u0026gt; print(\u0026#39;%10.5s\u0026#39; % (\u0026#39;likelike\u0026#39;)) # 지정한 문자열 총 자리수는 10자리고, 5자리를 넘으면 절삭한다. # blank가 5자리고, 왼쪽에서부터 오른쪽 방향으로 채워진다. # 나머지 5자리에 문자가 채워진다. _____likel # format으로 표현해보자 \u0026gt; print(\u0026#39;{:\u0026gt;10.5}\u0026#39;.format(\u0026#39;likelike\u0026#39;)) 결론\n print('-%n1.n2s' % (\u0026lsquo;출력하기 원하는 문자열\u0026rsquo;))   n1은 전체 자릿수 n2는 출력되길 원하는 문자열의 총 자리수를 의미 \u0026lsquo;-\u0026lsquo;는 정렬 방향을 역으로 한다. 정렬 방향 default는 오른쪽, (-)는 왼쪽 정렬을 의미    print('{:^ \u0026gt; \u0026lt; n1.n2}'.format(\u0026lsquo;string\u0026rsquo;))   n1은 전체 자릿수 n2는 출력되길 원하는 문자열의 총 자리수를 의미 \u0026lsquo;^\u0026rsquo; 는 가운데 정렬 \u0026lsquo;\u0026gt;\u0026lsquo;은 오른쪽 정렬, \u0026lsquo;\u0026lt;\u0026rsquo; 는 왼쪽 정렬을 의미 .format은 s를 입력하지 않는다.      3. Integer 정수형 출력 (d)  .format 은 문자열 s는 입력하지 않는다. 정수형 d or i, 실수형 f 은 입력한다.  \u0026gt; print(\u0026#39;%d %d\u0026#39; % (1, 2)) 1,2 \u0026gt; print(\u0026#39;{} {}\u0026#39;.format(1,2)) 1,2 \u0026gt; print(\u0026#39;{1} {0}.format(1,2)\u0026#39;) 2,1 \u0026gt; print(\u0026#39;%4d\u0026#39; % (24)) \u0026gt; print(\u0026#39;{:\u0026gt;4d}\u0026#39;.format(24)) \u0026gt; print(\u0026#39;{:4d}\u0026#39;.format(24)) 24 \u0026gt; print(\u0026#39;%-4d\u0026#39; % (24)) \u0026gt; print(\u0026#39;{:\u0026lt;4d}\u0026#39;.format(24)) 24 \u0026gt; print(\u0026#39;{:^4d}\u0026#39;.format(24)) 24 \u0026gt; print(\u0026#39;{:_\u0026gt;4d}\u0026#39;.format(24)) __24 \u0026gt; print(\u0026#39;{:_\u0026lt;4d}\u0026#39;.format(24)) 24__ \u0026gt; print(\u0026#39;{:_^4d}\u0026#39;.format(24)) _24_ 결론\n print('-%n1d\u0026rsquo; % (integer))   n1은 전체 자릿수 \u0026lsquo;-\u0026lsquo;는 정렬 방향을 역으로 한다. 정렬 방향 default는 오른쪽, (-)는 왼쪽 정렬을 의미    print('{:^ \u0026gt; \u0026lt; n1d}'.format(integer))   n1은 전체 자릿수 \u0026lsquo;^\u0026rsquo; 는 가운데 정렬 default와 \u0026lsquo;\u0026gt;\u0026lsquo;은 오른쪽 정렬, \u0026lsquo;\u0026lt;\u0026rsquo; 는 왼쪽 정렬을 의미      3. Float 실수형 출력 (f) # 전체 실수자리를 따로 지정하지 않으면 8자리까지 출력된다. \u0026gt; print(\u0026#39;%f\u0026#39; % (3.1415926535)) \u0026gt; print(\u0026#39;{:f}\u0026#39;.format(3.1415926535)) 3.141593 # 3.141592가 아니고, 반올림되어 3.141593 이다. # 소수 부분 8자리 \u0026gt; print(\u0026#39;%.8f\u0026#39; % (3.1415926535)) 3.14159265 # 반올림 되어 맨 마지막 자리 수가 5다. # 소수 부분 12자리 \u0026gt; print(\u0026#39;%.12f\u0026#39; % (3.1415926535)) 3.1415926535 # 소수점(.)까지 포함하여 6자리고, 소수 부분은 2자리, 빈 부분은 0으로 표시한다. \u0026gt; print(\u0026#39;%06.2f\u0026#39; % (3.1415926535)) \u0026gt; print(\u0026#39;{:06.2f}\u0026#39;.format(3.1415926535)) 003.14 # 소수점(.)까지 포함하여 6자리고, 소수 부분은 2자리, 빈 부분은 blank로 둔다. # blank가 있기 때문에 정렬 개념이 적용된다. 그래서 오른쪽 정렬된 상태 \u0026gt; print(\u0026#39;%6.2f\u0026#39; % (3.1415926535)) 3.14 # 왼쪽 정렬 상태 \u0026gt; print(\u0026#39;%-6.2f\u0026#39; % (3.1415926535)) 3.14 결론\nprint('%n1.n2f\u0026rsquo; % ())\nprint('{:n1.n2f}'.format())\n n1 은 전체 자릿수로서, 소수점을 포함한다. n2는 소수점 자리를 말한다. n1 앞에 0이 붙으면 정수 부분에서 비어있는 자리수는 0으로 표기된다.   Reference  Python tutorial  ","permalink":"http://jeha00.github.io/post/python_basic_2/","summary":"첫 번째 print 함수를 사용할 때, separator와 end를 사용하여 다양하게 사용하는 것과 두 번째, stirng type, numeric type을 다양하게 출력을 해봄으로서 print 함수에 대해 이해해보겠다.","title":"[TIL] Python basic 2: print 사용법"},{"content":"1. 변수 할당 설명 1.1 기본 선언  다른 프로그래밍 언어는 변수 타입을 정하고 나서 값을 할당한다. 반면에, Python은 값을 정하고 나서 변수 타입을 알아서 할당해준다. 이 변수를 할당한다는 건 물리적으로 즉, 컴퓨터 내부적으로 컴퓨터 메모리의 일부를 할당하는 의미로, \u0026lsquo;고유 주소\u0026rsquo;가 지정된다는 걸 의미한다. 이 \u0026lsquo;고유 주소\u0026rsquo;는 id 라는 명령어로 확인할 수 있다. 함수 id: 객체(object)의 고유값 id(identity) 을 확인  # 700이라는 int type의 data를 n에 할당한다. \u0026gt; n = 700 # \u0026#39;n\u0026#39;이라는 변수의 data type을 확인해보자. \u0026gt; print(type(n)) # \u0026#39;n\u0026#39; 이라는 변수에 할당된 메모리 고유주소를 확인해보자. \u0026gt; print(id(n)) - 결론 : 선언을 한다는 건 메모리 값을 할당하는 걸 의미한다. 이는 id 값을 통해 고유주소를 확인하여 알 수 있다.\n1.2 동시 선언  만약 명칭만 다른 세 변수에 동일한 value가 할당된 경우, id는 어떻게 나올까?  # x, y, z에 동일한 값을 할당한다. # 동일한 object 참조 \u0026gt; x = y = z = 700 \u0026gt; print(x, y, z) # x의 id 와 y의 id는 같은가? \u0026gt; print(id(x) == id(y)) \u0026gt; print(id(x), id(y)) # y의 id 와 z의 id는 같은가? \u0026gt; print(id(y) == id(z)) \u0026gt; print(id(z))  위 두 질문의 결과는 True가 나온다. 동일한 값과 type을 가지고 있기 때문에 메모리 주소가 동일하다는 걸 알 수 있다. 즉, 3개를 선언했지만 실제로 존재하는 건 1개라는 의미다. 파이썬이 하나의 오브젝트로 생성해버린다. 이러한 걸 동시선언 이라고 하며, 파이썬에서는 가능하다. 이처럼 하나 하나 최적화를 시키면 원활하고 빠른 프로그램 실행 흐름이 가능하다.  - 결론: 여러 변수에 똑같은 값을 할당하면 파이썬은 내부에서 하나만 만들어진다.\n1.3 재선언  변수의 명칭은 동일하나 다른 value를 할당해보겠다.  # 동일 명칭의 변수가 다른 object를 참조 # var이란 변수에 75라는 정수형 데이터를 할당되었다. \u0026gt; var = 75 \u0026gt; print(var) \u0026gt; print(id(var)) # int. 형이 아닌 string 형 데이터를 재할당한다. \u0026gt; var = \u0026#34;Change Value\u0026#34; \u0026gt; print(var) \u0026gt; print(id(var))  결과는 다음과 같다.  \u0026lt;class \u0026#39;int\u0026#39;\u0026gt; 2298218369712 Change Value \u0026lt;class \u0026#39;str\u0026#39;\u0026gt; 2298224531568  data type과 value가 변하자 id값이 달라진 걸 알 수 있다. 이것이 가능한 이유가 파이썬에는 garbage collector 가 있기 때문이다. 실제로 재선언할 때는 프로그램의 흐름이 끝날 떄까지 잘 추적하는 게 중요하다. 재선언을 통해서 프로그램의 흐름이 꼬여질 수도 있기 때문이다. 그래서 큰 project에서는 변수의 사전이 엑셀이나 기타 문서로 존재한다고 한다.  - 결론: 동일한 명칭의 변수여도 할당된 값이 변하면 파이썬이 알아서 id 값을 바꾼다.\n 2. Object References 변수가 할당 상태일 때, 아래와 같은 상태가 일어나는 걸 의미한다. (예 : n = 700이라 선언했을 때)\n첫 번째, type에 맞는 object를 생성: type을 통해서 class \u0026lsquo;int\u0026rsquo;라는 오브제트가 생성됨을 알 수 있다. 두 번쨰, 값 생성: 700을 안에서 생성 세 번째, 콘솔 출력 : 700이 출력된다.\n 더 다양한 예제를 살펴보자.  #예1) 아래 출력은 동일하다. 즉, int() 를 하지 않아도 내부적으로 처리된다. \u0026gt; print(300) \u0026gt; print(int(300)) #예2) \u0026gt; n = 800 \u0026gt; print(n, type(n)) # int형의 오브젝트임로 생성되었다. 그리고 출력된다. \u0026gt; m = n \u0026gt; print(m, n) \u0026gt; print(type(m), type(n)) \u0026gt; m = 400 \u0026gt; print(m, n) \u0026gt; print(type(m), type(n)) \u0026gt; m = 800 \u0026gt; n = 600 #m과 n의 고유값이 다르다. \u0026gt; print(id(m), id(n)) \u0026gt; print(id(m)==id(n)) 3. 다양한 변수 선언방법과 예약어  이 규칙들을 가지고 변수를 선언하면 세련되고, 코드를 재활용할 때 가독성이 좋은 소스 코드로 만들 수 있다.   Camel Case : method를 선언할 때 사용. ex) numberOfCollegeGraduates Pascal Case : 언어 상관 없이 class를 주로 선언할 때 사용. ex) umberOfCollegeGraduates snake case: 파이썬에서 변수를 선언 시 사용. ex) number_of_college_graduates\n Camel과 Pascal의 차이는 첫 문자가 소문자냐 대문자냐의 차이다.\n 이외에 허용하는 변수 선언 법은 다음과 같다.  숫자로 시작하지 않는다. 변수는 되도록 snake case로 선언한다. 예약어 같이 문법에 사용되는 단어는 변수명으로 불가능하다.\n   \u0026gt; age = 1 \u0026gt; Age = 2 \u0026gt; aGe = 3 \u0026gt; AGE = 4 \u0026gt; a_g_e = 5 \u0026gt; _age = 6 \u0026gt; age_ = 7 \u0026gt; _AGE_ = 8  예약어는 python reserved words로 검색하면 나온다. 예약어의 종류는 다음과 같다.  False\tdef\tif\traise None\tdel\timport\treturn True\telif\tin\ttry and\telse\tis\twhile as\texcept\tlambda\twith assert\tfinally\tnonlocal\tyield break\tfor\tnot class\tfrom\tor continue\tglobal\tpass  Reference  Python tutorial  ","permalink":"http://jeha00.github.io/post/python_basic_1/","summary":"첫 번째, 기본적인 선언 방법과 동시 선언, 재선언을 알아본다. 두 번째, 각 선언에 따른 id 값을 확인하여 파이썬 내부 원리를 이해한다. 세 번째, 선언 방법의 종류인 Camel case, Pascal case, Snake case가 무엇인지 알아본다.","title":"[TIL] Python basic 1: 변수 선언"},{"content":"\nMonthly Memoirs 월별 회고  \u0026lsquo;성찰 없는 발전\u0026rsquo;은 존재하지 않는다. 성찰이 발전으로 확실히 가기 위해 \u0026lsquo;기록\u0026rsquo;이 필요하다. 또한, 기록을 통해 \u0026lsquo;나\u0026rsquo;를 알고, 사람을 이해하여 \u0026lsquo;선한 마음\u0026rsquo; 을 이루자. 선한 마음과 꾸준함이 \u0026lsquo;비범함\u0026rsquo;을 만든다.  작성 규칙  M.M (Monthly Memoirs)은 새로 온 달의 첫 주말에 시간을 내어 작성한다. 작성하기 전 충분한 시간을 가지고 한달을 회고한다. 목표한 공부 계획에 맞춰 얼마나 성취했는지 각 목표 계획을 소제목으로 하여 회고를 작성한다. 부끄러움과 후회를 두려워하지 말라. 점차 줄여가자. 제목 형식: 2022-mm.md 3개월을 시도한 후, M.M 에 추가하여 W.M (Weekly Moemoirs)를 실행할지 말지 판단한다.   ","permalink":"http://jeha00.github.io/post/monthly-memoirs/","summary":"Monthly Memoirs 작성하는 이유를 설명하고, 앞으로의 규칙을 지키자는 다짐을 하기 위해 작성한다.","title":"Monthly Memoirs 작성 이유와 규칙"},{"content":"Intro window 10 환경에서 Hugo 라는 SSG의 한 종류를 사용해서 \u0026lt;user-id\u0026gt;.github.io 주소의 github page를 만들고 배포한 후, contents를 업로드하는 것까지 내용을 다룬다. 이를 위해 총 5단계를 거쳐서 진행한다.\n위 과정들에서 필요한 개념들, 부딪혔던 error 및 해결책도 각 단계 마지막 부분에 작성했다.\n 동일한 주제로 다룬 블로그들을 보면 3단계와 4단계의 순서를 바꿔서 진행한다. 4단계 진행 후, 3단계를 진행해도 무방하다. 다만, 나는 그 과정에서 헷갈린 부분이 있어서 마지막에 theme 적용을 하기로 선택했다.\n  1. Static Site Generator 로 Hugo를 선택한 이유 Github page를 만들 때 SSG의 종류들로 Jekyll, Hexo, Hugo 가 많이 언급된다. 그러면 SSG란 무엇인가?? 정적 페이지(Static Site)란 HTML,CSS,JS를 미리 올려서 서버가 바뀌지 않는 HTML page를 보여주는 것을 말한다. 이 정적 페이지를 보다 간편하게 만들어주는 것이 SSG(Static Site Generator)다. 이와 반대로 동적 페이지는 client에 반응하여 HTML page를 동적으로 만들어진 페이지를 말한다. 더 상세한 정보를 원하시는 분은 정적 웹은 뭐고 동적 웹은 뭔가요? 이 영상을 참고하시길 바란다.\nhugo를 선택하기에 앞서 각 SSG의 특징들에 대해 알아야 하기 때문에, Jekyll, Hexo, Hugo의 각 특징들은 다음과 같다.\n Jekyll -루비 기반 -현재 가장 인기 있음(깃헙 별 수 제일 많음) -한글 레퍼런스도 제일 많음 -느리다는 제보가 많음(몇 십개의 포스팅 뿐인데도 빌드 하는데 5분씩 걸린다고) -윈도우 공식 지원 안됨 Hexo -자바스크립트(Node.js) 기반 -한글 레퍼런스 꽤 많음 -메인 개발자가 손을 놓은 듯 -개발자가 중국인? 이라 구글링하면 중국어 글이 많이 나옴 Hugo -Golang 기반 -빌드 빠름 -문서화 잘돼있음 -깃헙 별 수가 헥소보다 많음 -한글 레퍼런스가 거의 없음 출처: http://tadakichi.tistory.com/188 그래서 4가지 이유로 Hugo를 선택했다.\n 남들이 안해본 걸 해보자. 한글 레퍼런스가 거의 없기 때문에, 내가 기여할 수 있는 부분이 다른 것보다 있을 것이다. 내가 원하는 디자인 대부분이 Hugo였다. 앞으로 계속해서 기술 블로그를 작성할 것이기 때문에, 빠른 빌드를 원했다.  두 번째 이유의 경우, 맨 처음에 Hugo의 존재를 모른 상태에서 jekyll이 많이 사용된다고 하여, 처음에 jekyll로 github page를 만들었다. 그래서 Hugo와 비교했을 때, 훨씬 Jekyll이 한글 레퍼런스가 많다는 걸 알았다.\n 2. Github page 만들기 위한 local 환경 조성   git을 설치한다. 그리고, github 에 가입한다. Visual Studio Code (VSC), Atom 같은 에디터를 설치한다. window 환경에 Hugo를 설치한다.   첫 번째, github 가입은 Github 에 들어가서 오른쪽 상단에 있는 Sign up을 클릭하여 진행한다. 그러면 최종적으로 https://github.com/user-name/ 을 가진다. 이것이 github blog다. github page는 [user-name].github.io 로 가진다.\n두 번째, 나는 visual studio code를 사용한다. visual studio code 여기에 들어가 설치한다.\n세 번째, window 환경에 hugo를 설치한다. window에서 Hugo 설치하기 이 영상 하나 따라하면 쉽다. 하지만, 글로 보고 싶은 분들을 위해 작성한다.\n hugo 다운로드 로 들어가서 아래로 scroll을 내리면 window 버전을 다운받아 C:\\Hugo\\bin 디렉토리를 생성해서 다운받은 압축 파일을 해제 어느 위치에서나 Hugo가 실행할 수 있도록 윈도우 검색으로 시스템 환경 변수 편집을 검색하여 들어간다. 고급 탭의 환경 변수 로 들어간다. 사용자 변수 란의 path를 클릭 후, 편집 을 클릭한다. 새로 만들기를 클릭하여 C:\\Hugo\\bin 경로를 추가한다. cmd에 echo %PATH% 를 입력하여 추가한 경로가 있는지 확인한다. 해제한 압축 파일에서 hugo 실행하여 설치 후, cmd에 hugo version 으로 동작 확인한다.   3. 새로운 2개 github repo 와 local 연결하기 3.1 Submodule 개념 이해하기 이 단계를 진행하기 전에 submodule 개념을 알아야 한다. 영어 독해가 가능하신 분들은 How to Set Up a Hugo Site on Github Pages - with Git Submodules! 이 링크에 들어가 보시기 바란다. submodule에 대해 그림과 함께 잘 설명되어있다. 아래 내용은 위 블로그에서 submodule에 대한 부분을 번역한 내용이다. 오역이 있다면 댓글로 알려주시면 감사하겠다.\n public folder는 [3.4 B repo를 public 폴더에 submodule로 연결하기] 파트에서 아래 명령어로 만들어진다.\n지금 이 명령어를 입력하지 않고, 이런 개념이 있구나 정도만 이해하기.\n# blog 폴더의 submodule로 branch main에 B repo를 add 한다. # sample: git submodule add https://github.com/JeHa00/JeHa00.github.io.git public \u0026gt; git submodule add -b main https://github.com/\u0026lt;user-name\u0026gt;/\u0026lt;B repo 명칭\u0026gt;.git public  출처: How to Set Up a Hugo Site on Github Pages - with Git Submodules!\n왜 Git submodule인가?? 모든 git project는 repository에 저장된다. 이 git submodule은 한 레포 안에서 다른 레포를 참조하도록 해준다. 그래서 프로젝트 안에 프로젝트를 효과적으로 운영할 수 있다. 중요한 건 submodule은 main project와 달리 자신만의 commit과 branch histroy를 가진다. 그래서 프로젝트들을 분리시킬 수 있다. 이는 매우 강력한 도구다. 아래 그림에서는 git project에서 submodule을 사용할 시, 어떻게 코드가 포함되는지를 보여준다. .... 메인 repository의 submodule로 `public` folder를 하위 폴더로 설정하여, 독립된 branch history를 갖는 개체로 대할 수 있다. 출처: https://www.adamormsby.com/posts/000/how-to-set-up-a-hugo-site-on-github-pages-with-submodules/  A repo가 blog 에 remote origin으로 연결된다. B repo가 public 폴더 형태로, blog의 submodule로 들어간다.  출처: How to Set Up a Hugo Site on Github Pages - with Git Submodules!\n3.2 New repository 2개 만들기  자신의 github에 2개의 repository를 만든다.\n   2개의 repository를 각각 A,B라고 하자.\n  2개의 repository는 public과 private 중 public으로 만든다. private 으로 하면 site에 배포가 안될 수도 있다.\n**주의: 두 repo를 만들 때 주의사항 **\n A repo에는 README.md 만들지 말기: README.md가 있다면 나중에 git push 시에 충돌이 일어난다. B repo에 README.md를 만들기: repo가 비어있으면 submodule로 연결이 안된다.    A는 user-name/blog 로, B는 user-name/user-name.github.io 로 명칭을 만든다.\nex) A의 url은 github.com/JeHa00/blog / B의 url은 github/JeHa00/JeHa00.github.io\n  B repo의 이름이 github page로 쓰일 url.\n  3.3 Hugo new site 생성및 remote add origin A repo 실행  Visual Studio Code의 terminal 또는 Window의 cmd에 입력한다.\n 경로 C:\\Hugo # 새로운 Hugo project 생성 # sample: Hugo new site blog \u0026gt; Hugo new site \u0026lt;project 명칭\u0026gt; # project folder인 blog로 이동 # sample: cd blog \u0026gt; cd \u0026lt;project 명칭\u0026gt; #3. local git 초기화 \u0026gt; git init # blog의 remote origin으로 A repo 추가하기 # sample: git remote add origin https://github.com/Jeha00/blog.git \u0026gt; git remote add origin https://github.com/\u0026lt;user-name\u0026gt;/\u0026lt;A repo 명칭\u0026gt;.git # commit 하기 위해 모든 파일을 stage에 올리기 \u0026gt; git add . # commit \u0026gt; git commit -m \u0026#34;add origin\u0026#34; # the remote origin 에 push 하겠다. branch는 master로 하겠다. \u0026gt; git push origin master   remote origin이 잘 되었는지 확인하기 위해서는 git remote -v를 입력하면 뜬다.\n  error: src refspec master does not match any 가 뜬다면 이는 stage에 오른 파일이 없다는 의미이므로, git add . 를 했는지 확인하기\n  hugo new site \u0026lt;project 명칭\u0026gt; 명령으로 local에서 컨텐츠를 관리하기 위한 장소 생성\n  이 때 경로는 C:\\Hugo 인 상태에서 terminal에 입력한다.\n  \u0026lt;project 명칭\u0026gt;을 A repo 이름과 똑같이 한다.\n  project를 새로 생성해서 project 파일 경로는 C:\\Hugo\\\u0026lt;project 명칭\u0026gt; 일 것이다.\n  위 명령어로 생긴 tree는 다음과 같다.\n  Hugo/project 명칭 ├─archetypes ├─content ├─data ├─layouts ├─static ├─themes └─config.toml   git remote add origin https://github.com/\u0026lt;user-name\u0026gt;/\u0026lt;A repo 명칭\u0026gt;.git Hugo new site로 만든 project 에 대한 remote origin으로 A repo를 추가하겠다는 의미다.\n  C:\\Hugo\\\u0026lt;project 명칭\u0026gt; 경로에서 git push를 하면 앞으로 A repo에 저장된다.\n  그 결과, A repo안에 구성은 다음과 같다.\n  \u0026lt;user-name\u0026gt;/A repo 이름 ├─archetypes └─config.toml 3.4 B repo를 public 폴더에 submodule로 연결하기 # blog 폴더의 submodule로 branch main에 B repo를 add 한다. # sample: git submodule add https://github.com/JeHa00/JeHa00.github.io.git public \u0026gt; git submodule add -b main https://github.com/\u0026lt;user-name\u0026gt;/\u0026lt;B repo 명칭\u0026gt;.git public  이 명령어로 public 폴더가 생성되고, 이 폴더의 remote origin이 B repo가 된다. public 폴더가 생긴 걸 알 수 있다.  Hugo/project 명칭 ├─archetypes ├─content ├─data ├─layouts ├─public ├─static ├─themes ├─.gitmodules └─config.toml  하지만 public 폴더가 생긴다고 연결된 게 아니다. 확실하게 연결이 되었다면 .gitmodules 파일이 생기고, 이 안에 아래와 같은 코드가 생겨야 한다.  [submodule \u0026quot;public\u0026quot;] path = public url = https://github.com/JeHa00/jeha0.github.io.git branch = main   만약 public folder는 생겼지만, .gitmodules와 위 코드가 없다면 다음 조치를 취한다.\n  첫 번째, public folder를 삭제한다.\n  두 번째, local 문서에서 C:\\Hugo\\\u0026lt;new project 명칭\u0026gt; folder로 들어가 숨긴 파일 보이기를 하여, .git 폴더의 modules 폴더를 삭제한다.\n  세 번째, terminal에 C:\\Hugo\\\u0026lt;new project 명칭\u0026gt; 경로에서 git rm --cached public 을 입력한다.\n  첫 번째, 두 번째만 실행한다면 다음과 같은 error 종류들이 뜰 수 있다.\nerror: 'public' does not have a commit checked out\nerror: 'public' already exists in the index\nerror: a git directory for 'public' is found locally with remote(s)\n  이렇게 뜨는 이유는 cach에 public이 아직 남아있기 때문이다. 그래서 이를 제거하고자 git rm --cached public 을 입력한다.\n  그리고, 다시 submodule 명령어를 실행하여, .gitmodules 에 위 코드가 생기는지 확인한다.\n  다시 https://github.com/\u0026lt;user-name\u0026gt;/blog.git 에 public @ 폴더가 생겼는지 확인한다. 이 폴더가 생겼다면 submodule 등록이 확실하게 완료되었다.\n  만약, Permission denied (publickey) 오류가 뜬다면 SSH 보안키를 등록해야한다.\n  위 방법대로 했지만 public 폴더와 B repo가 submodule 연결이 되지 않는다면, B repo에 아무런 file이 존재하지 않아서다.\n  3.2 New repository 2개 만들기 내용처럼 B repo에 README.md를 추가하여 empty repo로 만들지 말자.\n  3.5 public directory와 project root directoy git push 단계 # public directory에 site build 수행하기 \u0026gt; hugo # public dicrectory로 이동 \u0026gt; cd public \u0026gt; git add . \u0026gt; git commit -m \u0026#39;first build\u0026#39; \u0026gt; git push origin main # the project root 로 되돌아가기 \u0026gt; cd .. \u0026gt; git add . \u0026gt; git commit -m \u0026#39;first build - update submodule reference\u0026#39; \u0026gt; git push origin master  위 명령어로 생긴 tree는 다음과 같다.  Hugo/\u0026lt;project 명칭\u0026gt; ├─archetypes ├─content ├─data ├─layouts ├─public │ ├─categories │ └─tags ├─resources │ │─_gen │ ├─assets │ └─images ├─static │─themes ├─.gitmodules └─config.toml  A repo의 directory 내부 구성은 아래와 같다. 아래 image처럼 public@가 떠야 한다. submodule이 잘 연결되었다는 의미다.    4. Github page에 theme 적용  원하는 테마 찾기\n   Hugo Theme Star Ranking, jamstackthemes 그리고, Hugo Themes: Complete List 이 3가지 사이트 정도라면 충분히 찾을 수 있다.\n  처음에 테마 찾는 데 많은 시간을 썼는데, 지금 생각해보면 기본 테마를 찾은 다음에 customizing 하는 방법이 더 빠른 방향이었다.\n   submodule을 사용하여 테마 적용하기\n   submodule로 테마를 적용한 이유는 업데이트된 테마를 쉽게 가져올 수 있기 때문에, clone보다 submodule로 만드는 게 더 낫다고 한다. (by submodule이 나은 이유)\n  테마 또한 submodule로 적용한다. 구조는 아래와 같다.   출처: How to Set Up a Hugo Site on Github Pages - with Git Submodules!\n경로 C:\\Hugo\\\u0026lt;New Project 명칭\u0026gt; # root project folder에 submodule로 테마를 적용한다 # git submodule add .git themes/Paper-Mod \u0026gt; git submodule add \u0026lt;theme 경로\u0026gt;.git themes/\u0026lt;테마명\u0026gt;   원하는 theme을 fork 한다.\n  fork를 하는 이유는 테마를 직접 수정할 수 없고, 수정한 버전을 유지하기 어렵기 때문에, fork하여 자신의 github으로 가져온다.\n  fork한 테마의 경로를 복사하는 방법은 다음과 같다.   위 이미지에서 url 옆에 있는 버튼을 클릭하면 복사된다.\n  git submodule add \u0026lt;theme 경로\u0026gt;.git themes/\u0026lt;테마명\u0026gt; 에서 themes란 밑에 이미지의 themes folder를 말한다. 이 folder 밑에 \u0026lt;테마명\u0026gt; folder를 만들어, 테마 자료들을 다운받는다는 의미다.\n  Hugo/\u0026lt;project 명칭\u0026gt; ├─archetypes ├─content ├─data ├─layouts ├─public │ ├─categories │ └─tags ├─resources │ │─_gen │ ├─assets │ └─images ├─static │─themes │ └─\u0026lt;테마명\u0026gt; ├─.gitmodules └─config.toml  다음으로 config.toml 에 theme = 이 없으면 추가하여, theme = \u0026lt;테마명\u0026gt; 을 적는다. BaseURL을 B repo의 끝 부분인 https://\u0026lt;user-name\u0026gt;.github.io/ 로 수정한다. 이 경로가 앞으로 github page의 URL이 된다. theme 적용 또한 submodule이므로 .gitmodules 파일에 다음과 같이 2개가 등록되었다.  #example [submodule \u0026#34;public\u0026#34;] path = public url = https://github.com/\u0026lt;user-name\u0026gt;/\u0026lt;B repo 명칭\u0026gt;.git branch = main [submodule \u0026#34;\u0026lt;테마명\u0026gt;\u0026#34;] path = themes/\u0026lt;테마명\u0026gt; url = 테마 url  theme 적용 후, theme 폴더 안에 examplesite 란 의미의 폴더가 있다면, 그 폴더 안에 있는 config.toml을 복사하여 C:\\Hugo\\\u0026lt;New Project 명칭\u0026gt; 경로에 있는 config.toml에 복사 붙여 넣는다. BaseURL만 다시 수정한다.   테마 적용되었는지 테스트하기\n 경로 C:\\Hugo\\\u0026lt;New Project 명칭\u0026gt; # D 란 draft 문서까지 포함해서 보겠다는 의미다. \u0026gt; hugo server -D  그러면 https://localhost:1313/ 이 뜬다. 이를 클릭하면 테마가 적용되었는지 알 수 있다. terminal 작업을 다시 할려면 Ctrl + C를 눌러 중단한다. hugo server -D 가 돌아가는 동안에는 글의 수정을 바로 확인할 수 있다.   5. Contents 생성과 업로드, utterances로 댓글 기능 추가, 업로드 자동화 5.1 Contents 생성과 업로드  Contents 생성과 public folder에 반영하기\n 경로 C:\\Hugo\\\u0026lt;New Project 명칭\u0026gt; # contents 생성 \u0026gt; hugo new post/test1.md # 생성된 글 public 폴더에 반영하기 \u0026gt; hugo -t \u0026lt;테마이름\u0026gt;   hugo new post/test1.md는 \\content\\post\\test1.md 경로로 생성된다.\n  contents 생성 후, hugo server -D로 localhost에는 생성한 contents가 보이는데, github page에는 안보인다면 hugo -t \u0026lt;테마이름\u0026gt;명령을 하지 않았기 때문이다.\n  여기서 \u0026lt;테마이름\u0026gt;은 git submodule add \u0026lt;theme 경로\u0026gt;.git themes/\u0026lt;테마명\u0026gt; 에서 테마명과 동일해야 한다.\n   컨텐츠 업로드\n # public dicrectory로 이동 \u0026gt; cd public \u0026gt; git add . \u0026gt; git commit -m \u0026#39;commit message\u0026#39; \u0026gt; git push origin main # the project root 로 되돌아가기 \u0026gt; cd .. \u0026gt; git add . \u0026gt; git commit -m \u0026#39;commit message\u0026#39; \u0026gt; git push origin master 5.2 Utterances로 댓글 기능 추가  사용 방법\n Github에 \u0026lt;user-name\u0026gt;/blog-comments 같이 private이 아닌 public 저장소를 만든다. Utterance에서 1번에서 만든 repository를 입력한다. Utterance에서 Mapping 방식 6가지 중 한 가지를 선택한다. 2번 3번에 따라 Utterance에서 생성된 script를 복사하여 각자의 적절한 템플릿 위치가 추가한다. 추가 위치는 각 theme의 README.md 를 꼼꼼히 읽어본다.   아웃사이더님의 블로그 글에서 보고 가져온다.\n5.3 deploy.sh로 자동화  deploy.sh 파일명으로 아래 코드를 저장한 후, C:\\Hugo\\\u0026lt;프로젝트 명칭\u0026gt; 경로에 저장한다. 이후 Git Bash 프로그램을 사용하여 C:\\Hugo\\\u0026lt;프로젝트 명칭\u0026gt; 경로로 이동 후, bash deploy.sh를 입력하면 the project root와 submodule 모두 순차적으로 push가 실행된다. 나는 submodule은 main default branch에, the project root는 master default branch로 설정했다.\n #!/bin/bash echo -e \u0026#34;\\033[0;32mDeploying updates to GitHub...\\033[0m\u0026#34; # Build the project. hugo -t \u0026lt;테마명\u0026gt; # Go To Public folder cd public # Add changes to git. git add . # Commit changes. msg=\u0026#34;rebuilding site `date`\u0026#34; if [ $# -eq 1 ] then msg=\u0026#34;$1\u0026#34; fi git commit -m \u0026#34;$msg\u0026#34; # Push source and build repos. ## master 대신 각자 연결한 branch 명으로 수정하면 된다. git push origin main # Come Back up to the Project Root cd .. # blog 저장소 Commit \u0026amp; Push git add . msg=\u0026#34;rebuilding site `date`\u0026#34; if [ $# -eq 1 ] then msg=\u0026#34;$1\u0026#34; fi git commit -m \u0026#34;$msg\u0026#34; ## master 대신 각자 연결한 branch 명으로 수정하면 된다. git push origin master  6. To customize blog theme   커스텀마이징을 위한 제일 좋은 방법은 각자 선택한 테마 템플릿의 README.md를 꼼꼼히 읽어보는 게 제일 빠른 지름길이라 생각한다. 사용자가 원하는 기능들을 어떻게 추가하면 되는지 설명해논 템플릿이 많기 때문에, 반드시 README.md 를 꼼꼼히 읽기 바란다.   7. 후기   git에 대해 더 숙지를 하고 나서 git page를 만들기 시작했다면 시간 소모를 줄일 수 있었을 것이다. 급한 마음에 github page를 시작하여 생각보다 많은 시행착오와 error들을 격었다. 이 error들은 대체로 git을 정확히 이해하지 못해서 발생하는 문제점들이다. 이번 일을 통해서 git이 개발자에게 사람의 숨쉬기와 같다는 걸 느껴서 Pro git 이란 책을 사서 꾸준히 공부하기로 결정했다. gith page를 만들었으니, TIL부터 시작하여 꾸준히 공부하자. Hugo를 선택한 것이 처음 시도할 때는 매우 힘들었지만, 지금 와서는 잘한 선택임을 느낀다. 진행하다가 부딪힌 error들에 대해서는 바로 바로 기록을 하자. 이는 반복적인 똑같은 삽질을 예방할 수 있다.   Reference   정적 웹은 뭐고 동적 웹은 뭔가요?\n  Jekyll, Hexo, Hugo 차이점 설명\n  Hugo로 Github.io 블로그 만들기\n  How to Set Up a Hugo Site on Github Pages - with Git Submodules!\n  theme 적용에 submodule이 나은 이유\n  아웃사이더님의 블로그 글\n  ","permalink":"http://jeha00.github.io/post/hugo%EB%A1%9C-github-page-%EB%A7%8C%EB%93%A4%EA%B3%A0-%EB%B0%B0%ED%8F%AC%ED%95%98%EA%B8%B0/","summary":"SSG의 한 종류 \u0026lsquo;Hugo\u0026rsquo;와 \u0026lsquo;git remote, git submodule\u0026rsquo;로 Github page를 만든다. 그 후, 컨텐츠 생성과 업로드를 한다. 마지막으로 utterances로 댓글 기능 추가, deploy.sh를 사용하여 업로드하는 방법을 다룬다.","title":"Window에서 Hugo로 Github page 만들고 배포하기"}]