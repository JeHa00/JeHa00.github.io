<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>[TIL] Alogorithum Chapter 04: Stack and Queue | Jeha00 DevLog</title><meta name=keywords content="TIL,Algorithum"><meta name=description content="stack과 queue에 대해 알아보고, 직접 구현하여 해당 자료 구조에 대해 알아보고, 이 두 자료구조의 차이점에 대해 이해해보자."><meta name=author content><link rel=canonical href=http://jeha00.github.io/post/algorithum/chapter04_%EC%8A%A4%ED%83%9D%EA%B3%BC%ED%81%90/><meta name=google-site-verification content="XYZabc"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.min.1e44d58192cbf6d7a4eb649bc43dbc3d4cc432677e5d8adc69b08c34cbe461ac.css integrity="sha256-HkTVgZLL9tek62SbxD28PUzEMmd+XYrcabCMNMvkYaw=" rel="preload stylesheet" as=style><link rel=icon href=http://jeha00.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=http://jeha00.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=http://jeha00.github.io/favicon-32x32.png><link rel=apple-touch-icon href=http://jeha00.github.io/apple-touch-icon.png><link rel=mask-icon href=http://jeha00.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><meta name=generator content="Hugo 0.101.0"><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><script type=application/javascript>var doNotTrack=!1;doNotTrack||(function(e,t,n,s,o,i,a){e.GoogleAnalyticsObject=o,e[o]=e[o]||function(){(e[o].q=e[o].q||[]).push(arguments)},e[o].l=1*new Date,i=t.createElement(n),a=t.getElementsByTagName(n)[0],i.async=1,i.src=s,a.parentNode.insertBefore(i,a)}(window,document,"script","https://www.google-analytics.com/analytics.js","ga"),ga("create","UA-123-45","auto"),ga("send","pageview"))</script><meta property="og:title" content="[TIL] Alogorithum Chapter 04: Stack and Queue"><meta property="og:description" content="stack과 queue에 대해 알아보고, 직접 구현하여 해당 자료 구조에 대해 알아보고, 이 두 자료구조의 차이점에 대해 이해해보자."><meta property="og:type" content="article"><meta property="og:url" content="http://jeha00.github.io/post/algorithum/chapter04_%EC%8A%A4%ED%83%9D%EA%B3%BC%ED%81%90/"><meta property="og:image" content="http://jeha00.github.io/47"><meta property="article:section" content="post"><meta property="article:published_time" content="2022-06-07T20:47:33+09:00"><meta property="article:modified_time" content="2022-06-07T20:47:33+09:00"><meta property="og:site_name" content="JeHa00 DevLog"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="http://jeha00.github.io/47"><meta name=twitter:title content="[TIL] Alogorithum Chapter 04: Stack and Queue"><meta name=twitter:description content="stack과 queue에 대해 알아보고, 직접 구현하여 해당 자료 구조에 대해 알아보고, 이 두 자료구조의 차이점에 대해 이해해보자."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"http://jeha00.github.io/post/"},{"@type":"ListItem","position":2,"name":"[TIL] Alogorithum Chapter 04: Stack and Queue","item":"http://jeha00.github.io/post/algorithum/chapter04_%EC%8A%A4%ED%83%9D%EA%B3%BC%ED%81%90/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"[TIL] Alogorithum Chapter 04: Stack and Queue","name":"[TIL] Alogorithum Chapter 04: Stack and Queue","description":"stack과 queue에 대해 알아보고, 직접 구현하여 해당 자료 구조에 대해 알아보고, 이 두 자료구조의 차이점에 대해 이해해보자.","keywords":["TIL","Algorithum"],"articleBody":"0. Introduction 이번 chapter의 학습은 Do it! 자료구조와 함께 배우는 알고리즘 입문로부터 학습했습니다. 더 자세한 내용과 관련 내용의 코드는 위 서적의 출판사 사이트에서 확인하실 수 있습니다. 1. 스택(Stack) 데이터를 임시 저장할 때 사용하는 자료 구조로, 데이터의 입력과 출력 순서는 후입선출(LIFO: Last In, First Out) 방식이다.\n이 스택에 데이터를 넣는 작업을 푸시(push) 라 하며, 스택에서 데이터를 꺼내는 작업을 팝(pop) 이라 한다.\n회전 초밥 집에서 먹은 후, 쌓인 접시를 생각해보자. 마지막에 먹는 초밥 접시가 맨 위에 있고, 이 접시들을 꺼낸다고 하면 마지막에 먹은 초밥 접시가 제일 먼저 꺼내진다.\n이렇게 쌓인 스택 자료 구조에서 쌓인 데이터의 윗 부분, 아랫 부분을 별도로 부르는 명칭이 있다.\n윗 부분은 꼭대기(top), 아랫 부분은 바닥(bottom) 이라 한다.\n1.1 스택: list형 배열 이 스택(stack, stk)은 list형 배열이다.\nlist의 index가 0으로 갈수록 위의 바닥(bottom) 과 가까워지고, 바깥쪽으로 갈수록 꼭대기(top) 에 가까워진다고 생각하자.\n또한, 이 스택의 크기는 capacity 단어가 의미하며, 스택에 쌓여 있는 데이터의 개수를 나타내는 정수값을 스택 포인터(stack pointer, ptr) 라 한다.\n그래서, stk가 비어 있으면 ptr은 0이 되고, stk가 가득 차면 capacity와 동일한 값이 된다.\n1.2 고정 길이 스택을 구현하기 위한 클래스와 메서드 종류 그러면 고정 길이 스택을 구현하기 위한 클래스와 메서드를 알아보자.\n아래와 같이 정리하는 이유는 이 스택을 구현하기 위한 기본 틀을 정립하기 위함이다.\n메서드 명이 정확히 일치하지 않을지라도 다음과 같은 기능을 구현할 필요가 있다는 걸 알기 위함이다.\n초기화 __init__ method\n스택 배열을 생성하는 준비 작업을 수행하는 함수로서, capacity 만큼으로 스택 크기가 결정된다. 첫 모든 원소는 None이 list가 생성된다. 데이터 갯수를 알 수 있는 __len__ method\nstack에 쌓여 있는 데이터 개수를 반환한다. stack이 비어 있는지 판단하는 is_empty() method\nstack이 비어 있는지 판단하여, 비어있으면 True, 그렇지 않으면 False를 반환한다. stack이 가득 차 있는지를 판단하는 is_full method\nstack이 가득 차 있는지 판단하여, 가득차면 True, 그렇지 않으면 False를 반환한다. 예외 처리 클래스 Empty와 Full\nEmpty class는 pop() 함수를 호출할 때, 비어있으면 내보내는 예외처리 class다. Full class는 push() 함수를 호출할 때, 가득 차 있으면 내보내는 예외처리 class다. 데이터를 푸시하는 push() method\nstack에 데이터를 추가한다. 데이터를 팝하는 pop() method\nstack의 top에서 데이터를 꺼내어 그 값을 반환한다. 데이터를 들여보는 peek() method\nstack의 꼭대기 data를 들여다본다. 스택의 모든 데이터를 삭제하는 clear() method\nstack에 쌓여 있는 데이터를 모두 삭제하여 빈 스택을 만든다. 스택의 데이터를 검색하는 find() method\n스택 본체의 배열 stk 안에 value와 값이 같은 데이터가 포함되어 있는지 확인 데이터 갯수를 세는 count() method\nstack에 쌓여 있는 데이터의 갯수를 구한다. 데이터가 포함되어 있는지 판단하는 __contains__ method\n2. 큐(Queue) 데이터를 임시 저장할 때 사용하는 자료 구조로, 데이터의 입력과 출력 순서는 선입선출(FIFO: First In, First Out) 방식이다.\n스택과 동일하게 list형 배열이며, 은행 창구에서 차례를 기다리거나, 마트에서 계산을 기다리는 줄을 생각하면 된다.\n데이터를 꺼내는 쪽을 프런트(Front) 라고 하며, 맨 앞 원소를 가리킨다.\n데이터를 넣는 쪽을 리어(rear) 라고 하며, 맨 끝 원소를 가리킨다.\n리어 에 데이터를 추가하는 작업을 인큐(enqueue) 라고 하며, 프런트 에서 데이터를 꺼내는 작업을 디큐(dequeue) 라고 한다.\n스택과는 달리 데이터를 추가하고 꺼내는 작업의 방향이 다르다는 걸 아래 이미지로 볼 수 있다.\n이미지 상의 차이로 큐는 디큐를 하면 전체 배열을 위로 하나씩 올려야 하는 비용이 들고 복잡도로 판단하자면 O(n) 이다.\n그래서 이를 해결하는 방법이 링 버퍼(ring buffer) 다. 이 방식은 인큐와 디큐에 따라 시작 원소와 끝 원소가 달라지는 상황에 맞춰서 전체 원소를 옮기는 것이 아닌 프런트(Front) 와 리어(Rear)의 각 인덱스를 계속해서 바꾸는 것이다. 이런 경우 복잡도는 O(1) 이다. 아래 이미지를 참조하자.\nfrom: RingBuffer aka Circular Queue\n그러면, 이 큐를 구현하기 위한 클래스와 메서드에는 무엇이 필요할까???\n고정 길이 큐를 구현하기 위한 클래스와 메서드 종류는 위에 스택과 동일하므로, 스택을 참고하자.\nReference Do it! 자료구조와 함께 배우는 알고리즘 입문 RingBuffer aka Circular Queue ","wordCount":"561","inLanguage":"en","datePublished":"2022-06-07T20:47:33+09:00","dateModified":"2022-06-07T20:47:33+09:00","mainEntityOfPage":{"@type":"WebPage","@id":"http://jeha00.github.io/post/algorithum/chapter04_%EC%8A%A4%ED%83%9D%EA%B3%BC%ED%81%90/"},"publisher":{"@type":"Organization","name":"Jeha00 DevLog","logo":{"@type":"ImageObject","url":"http://jeha00.github.io/favicon.ico"}}}</script></head><body class=dark id=top><script>localStorage.getItem("pref-theme")==="light"&&document.body.classList.remove("dark")</script><header class=header><nav class=nav><div class=logo><a href=http://jeha00.github.io/ accesskey=h title="Jeha00 (Alt + H)">Jeha00</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></span></div><ul id=menu><li><a href=http://jeha00.github.io/about/ title=About><span>About</span></a></li><li><a href=http://jeha00.github.io/archives/ title=Archive><span>Archive</span></a></li><li><a href=http://jeha00.github.io/categories/ title=Categories><span>Categories</span></a></li><li><a href=http://jeha00.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=http://jeha00.github.io/>Home</a>&nbsp;»&nbsp;<a href=http://jeha00.github.io/post/>Posts</a></div><h1 class=post-title>[TIL] Alogorithum Chapter 04: Stack and Queue</h1><div class=post-meta><span title='2022-06-07 20:47:33 +0900 KST'>June 7, 2022</span>&nbsp;|&nbsp;<a href=https://github.com/JeHa00/blog/content/post/Algorithum/Chapter04_%ec%8a%a4%ed%83%9d%ea%b3%bc%ed%81%90.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#0-introduction aria-label="0. Introduction">0. Introduction</a></li><li><a href=#1-%ec%8a%a4%ed%83%9dstack aria-label="1. 스택(Stack)">1. 스택(Stack)</a><ul><li><a href=#11-%ec%8a%a4%ed%83%9d-list%ed%98%95-%eb%b0%b0%ec%97%b4 aria-label="1.1 스택: list형 배열">1.1 스택: list형 배열</a></li><li><a href=#12-%ea%b3%a0%ec%a0%95-%ea%b8%b8%ec%9d%b4-%ec%8a%a4%ed%83%9d%ec%9d%84-%ea%b5%ac%ed%98%84%ed%95%98%ea%b8%b0-%ec%9c%84%ed%95%9c-%ed%81%b4%eb%9e%98%ec%8a%a4%ec%99%80-%eb%a9%94%ec%84%9c%eb%93%9c-%ec%a2%85%eb%a5%98 aria-label="1.2 고정 길이 스택을 구현하기 위한 클래스와 메서드 종류">1.2 고정 길이 스택을 구현하기 위한 클래스와 메서드 종류</a></li></ul></li><li><a href=#2-%ed%81%90queue aria-label="2. 큐(Queue)">2. 큐(Queue)</a></li><li><a href=#reference aria-label=Reference>Reference</a></li></ul></div></details></div><div class=post-content><h1 id=0-introduction>0. Introduction<a hidden class=anchor aria-hidden=true href=#0-introduction>#</a></h1><ul><li>이번 chapter의 학습은 <a href="http://www.kyobobook.co.kr/product/detailViewKor.laf?barcode=9791163031727">Do it! 자료구조와 함께 배우는 알고리즘 입문</a>로부터 학습했습니다.</li><li>더 자세한 내용과 관련 내용의 코드는 위 서적의 출판사 사이트에서 확인하실 수 있습니다.</li></ul><hr><h1 id=1-스택stack>1. 스택(Stack)<a hidden class=anchor aria-hidden=true href=#1-스택stack>#</a></h1><blockquote><p><strong><em>데이터를 임시 저장할 때 사용하는 자료 구조로, 데이터의 입력과 출력 순서는 후입선출(LIFO: Last In, First Out) 방식이다.</em></strong></p></blockquote><p>이 스택에 데이터를 넣는 작업을 <strong><em>푸시(push)</em></strong> 라 하며, 스택에서 데이터를 꺼내는 작업을 <strong><em>팝(pop)</em></strong> 이라 한다.</p><p>회전 초밥 집에서 먹은 후, 쌓인 접시를 생각해보자. 마지막에 먹는 초밥 접시가 맨 위에 있고, 이 접시들을 꺼낸다고 하면 마지막에 먹은 초밥 접시가 제일 먼저 꺼내진다.</p><p>이렇게 쌓인 스택 자료 구조에서 쌓인 데이터의 윗 부분, 아랫 부분을 별도로 부르는 명칭이 있다.</p><p>윗 부분은 <strong><em>꼭대기(top)</em></strong>, 아랫 부분은 <strong><em>바닥(bottom)</em></strong> 이라 한다.</p><h2 id=11-스택-list형-배열>1.1 스택: list형 배열<a hidden class=anchor aria-hidden=true href=#11-스택-list형-배열>#</a></h2><p>이 스택(stack, stk)은 list형 배열이다.</p><p>list의 index가 0으로 갈수록 위의 <strong><em>바닥(bottom)</em></strong> 과 가까워지고, 바깥쪽으로 갈수록 <strong><em>꼭대기(top)</em></strong> 에 가까워진다고 생각하자.</p><p>또한, 이 스택의 크기는 <strong><em>capacity</em></strong> 단어가 의미하며, 스택에 쌓여 있는 데이터의 개수를 나타내는 정수값을 <strong><em>스택 포인터(stack pointer, ptr)</em></strong> 라 한다.</p><p>그래서, stk가 비어 있으면 ptr은 0이 되고, stk가 가득 차면 capacity와 동일한 값이 된다.</p><p><img loading=lazy src=https://user-images.githubusercontent.com/78094972/172626905-1855bada-f74e-4bbd-af2b-e9133dec2d61.jpg alt=image></p><h2 id=12-고정-길이-스택을-구현하기-위한-클래스와-메서드-종류>1.2 고정 길이 스택을 구현하기 위한 클래스와 메서드 종류<a hidden class=anchor aria-hidden=true href=#12-고정-길이-스택을-구현하기-위한-클래스와-메서드-종류>#</a></h2><p>그러면 고정 길이 스택을 구현하기 위한 클래스와 메서드를 알아보자.</p><p>아래와 같이 정리하는 이유는 이 스택을 구현하기 위한 기본 틀을 정립하기 위함이다.</p><p>메서드 명이 정확히 일치하지 않을지라도 다음과 같은 기능을 구현할 필요가 있다는 걸 알기 위함이다.</p><ul><li><p>초기화 __init__ method</p><ul><li>스택 배열을 생성하는 준비 작업을 수행하는 함수로서, capacity 만큼으로 스택 크기가 결정된다. 첫 모든 원소는 None이 list가 생성된다.</li></ul></li><li><p>데이터 갯수를 알 수 있는 __len__ method</p><ul><li>stack에 쌓여 있는 데이터 개수를 반환한다.</li></ul></li><li><p>stack이 비어 있는지 판단하는 is_empty() method</p><ul><li>stack이 비어 있는지 판단하여, 비어있으면 True, 그렇지 않으면 False를 반환한다.</li></ul></li><li><p>stack이 가득 차 있는지를 판단하는 is_full method</p><ul><li>stack이 가득 차 있는지 판단하여, 가득차면 True, 그렇지 않으면 False를 반환한다.</li></ul></li><li><p>예외 처리 클래스 Empty와 Full</p><ul><li>Empty class는 pop() 함수를 호출할 때, 비어있으면 내보내는 예외처리 class다.</li><li>Full class는 push() 함수를 호출할 때, 가득 차 있으면 내보내는 예외처리 class다.</li></ul></li><li><p>데이터를 푸시하는 push() method</p><ul><li>stack에 데이터를 추가한다.</li></ul></li><li><p>데이터를 팝하는 pop() method</p><ul><li>stack의 top에서 데이터를 꺼내어 그 값을 반환한다.</li></ul></li><li><p>데이터를 들여보는 peek() method</p><ul><li>stack의 꼭대기 data를 들여다본다.</li></ul></li><li><p>스택의 모든 데이터를 삭제하는 clear() method</p><ul><li>stack에 쌓여 있는 데이터를 모두 삭제하여 빈 스택을 만든다.</li></ul></li><li><p>스택의 데이터를 검색하는 find() method</p><ul><li>스택 본체의 배열 stk 안에 value와 값이 같은 데이터가 포함되어 있는지 확인</li></ul></li><li><p>데이터 갯수를 세는 count() method</p><ul><li>stack에 쌓여 있는 데이터의 갯수를 구한다.</li></ul></li><li><p>데이터가 포함되어 있는지 판단하는 __contains__ method</p></li></ul><hr><h1 id=2-큐queue>2. 큐(Queue)<a hidden class=anchor aria-hidden=true href=#2-큐queue>#</a></h1><blockquote><p><strong><em>데이터를 임시 저장할 때 사용하는 자료 구조로, 데이터의 입력과 출력 순서는 선입선출(FIFO: First In, First Out) 방식이다.</em></strong></p></blockquote><p>스택과 동일하게 list형 배열이며, 은행 창구에서 차례를 기다리거나, 마트에서 계산을 기다리는 줄을 생각하면 된다.</p><p>데이터를 꺼내는 쪽을 <strong><em>프런트(Front)</em></strong> 라고 하며, 맨 앞 원소를 가리킨다.</p><p>데이터를 넣는 쪽을 <strong><em>리어(rear)</em></strong> 라고 하며, 맨 끝 원소를 가리킨다.</p><p><strong><em>리어</em></strong> 에 데이터를 추가하는 작업을 <strong><em>인큐(enqueue)</em></strong> 라고 하며, <strong><em>프런트</em></strong> 에서 데이터를 꺼내는 작업을 <strong><em>디큐(dequeue)</em></strong> 라고 한다.</p><p>스택과는 달리 데이터를 추가하고 꺼내는 작업의 방향이 다르다는 걸 아래 이미지로 볼 수 있다.</p><p><img loading=lazy src=https://user-images.githubusercontent.com/78094972/172626927-58936a8d-c0bf-4f3b-bc5c-27b71a330eb4.jpg alt=image></p><p>이미지 상의 차이로 큐는 디큐를 하면 전체 배열을 위로 하나씩 올려야 하는 비용이 들고 복잡도로 판단하자면 O(n) 이다.</p><p>그래서 이를 해결하는 방법이 <strong><em>링 버퍼(ring buffer)</em></strong> 다. 이 방식은 인큐와 디큐에 따라 시작 원소와 끝 원소가 달라지는 상황에 맞춰서 <strong><em>전체 원소를 옮기는 것이 아닌 프런트(Front) 와 리어(Rear)의 각 인덱스를 계속해서 바꾸는 것이다.</em></strong> 이런 경우 복잡도는 O(1) 이다. 아래 이미지를 참조하자.</p><p><img loading=lazy src=https://user-images.githubusercontent.com/78094972/172816375-639e69a6-a57a-4ac2-8982-8a38d86979fe.jpg alt=image></p><p>from: <a href=https://iosexample.com/ringbuffer-aka-circular-queue/>RingBuffer aka Circular Queue</a></p><p>그러면, 이 큐를 구현하기 위한 클래스와 메서드에는 무엇이 필요할까???</p><p>고정 길이 큐를 구현하기 위한 클래스와 메서드 종류는 위에 스택과 동일하므로, 스택을 참고하자.</p><hr><h1 id=reference>Reference<a hidden class=anchor aria-hidden=true href=#reference>#</a></h1><ul><li><a href="http://www.kyobobook.co.kr/product/detailViewKor.laf?barcode=9791163031727">Do it! 자료구조와 함께 배우는 알고리즘 입문</a></li><li><a href=https://iosexample.com/ringbuffer-aka-circular-queue/>RingBuffer aka Circular Queue</a></li></ul></div><footer class=post-footer><ul class=post-tags><li><a href=http://jeha00.github.io/tags/til/>TIL</a></li><li><a href=http://jeha00.github.io/tags/algorithum/>Algorithum</a></li></ul><nav class=paginav><a class=prev href=http://jeha00.github.io/post/algorithum/chapter05_%EC%9E%AC%EA%B7%80%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/><span class=title>« Prev Page</span><br><span>[TIL] Alogorithum Chapter 05: Recursive algorithum</span></a>
<a class=next href=http://jeha00.github.io/post/algorithum/chapter03_%EA%B2%80%EC%83%89%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/><span class=title>Next Page »</span><br><span>[TIL] Alogorithum Chapter 03: Search algorithum</span></a></nav><div class=share-buttons><a target=_blank rel="noopener noreferrer" aria-label="share [TIL] Alogorithum Chapter 04: Stack and Queue on twitter" href="https://twitter.com/intent/tweet/?text=%5bTIL%5d%20Alogorithum%20Chapter%2004%3a%20Stack%20and%20Queue&url=http%3a%2f%2fjeha00.github.io%2fpost%2falgorithum%2fchapter04_%25EC%258A%25A4%25ED%2583%259D%25EA%25B3%25BC%25ED%2581%2590%2f&hashtags=TIL%2cAlgorithum"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM195.519 424.544c135.939.0 210.268-112.643 210.268-210.268.0-3.218.0-6.437-.153-9.502 14.406-10.421 26.973-23.448 36.935-38.314-13.18 5.824-27.433 9.809-42.452 11.648 15.326-9.196 26.973-23.602 32.49-40.92-14.252 8.429-30.038 14.56-46.896 17.931-13.487-14.406-32.644-23.295-53.946-23.295-40.767.0-73.87 33.104-73.87 73.87.0 5.824.613 11.494 1.992 16.858-61.456-3.065-115.862-32.49-152.337-77.241-6.284 10.881-9.962 23.601-9.962 37.088.0 25.594 13.027 48.276 32.95 61.456-12.107-.307-23.448-3.678-33.41-9.196v.92c0 35.862 25.441 65.594 59.311 72.49-6.13 1.686-12.72 2.606-19.464 2.606-4.751.0-9.348-.46-13.946-1.38 9.349 29.426 36.628 50.728 68.965 51.341-25.287 19.771-57.164 31.571-91.8 31.571-5.977.0-11.801-.306-17.625-1.073 32.337 21.15 71.264 33.41 112.95 33.41z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share [TIL] Alogorithum Chapter 04: Stack and Queue on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&url=http%3a%2f%2fjeha00.github.io%2fpost%2falgorithum%2fchapter04_%25EC%258A%25A4%25ED%2583%259D%25EA%25B3%25BC%25ED%2581%2590%2f&title=%5bTIL%5d%20Alogorithum%20Chapter%2004%3a%20Stack%20and%20Queue&summary=%5bTIL%5d%20Alogorithum%20Chapter%2004%3a%20Stack%20and%20Queue&source=http%3a%2f%2fjeha00.github.io%2fpost%2falgorithum%2fchapter04_%25EC%258A%25A4%25ED%2583%259D%25EA%25B3%25BC%25ED%2581%2590%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share [TIL] Alogorithum Chapter 04: Stack and Queue on reddit" href="https://reddit.com/submit?url=http%3a%2f%2fjeha00.github.io%2fpost%2falgorithum%2fchapter04_%25EC%258A%25A4%25ED%2583%259D%25EA%25B3%25BC%25ED%2581%2590%2f&title=%5bTIL%5d%20Alogorithum%20Chapter%2004%3a%20Stack%20and%20Queue"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share [TIL] Alogorithum Chapter 04: Stack and Queue on facebook" href="https://facebook.com/sharer/sharer.php?u=http%3a%2f%2fjeha00.github.io%2fpost%2falgorithum%2fchapter04_%25EC%258A%25A4%25ED%2583%259D%25EA%25B3%25BC%25ED%2581%2590%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share [TIL] Alogorithum Chapter 04: Stack and Queue on whatsapp" href="https://api.whatsapp.com/send?text=%5bTIL%5d%20Alogorithum%20Chapter%2004%3a%20Stack%20and%20Queue%20-%20http%3a%2f%2fjeha00.github.io%2fpost%2falgorithum%2fchapter04_%25EC%258A%25A4%25ED%2583%259D%25EA%25B3%25BC%25ED%2581%2590%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share [TIL] Alogorithum Chapter 04: Stack and Queue on telegram" href="https://telegram.me/share/url?text=%5bTIL%5d%20Alogorithum%20Chapter%2004%3a%20Stack%20and%20Queue&url=http%3a%2f%2fjeha00.github.io%2fpost%2falgorithum%2fchapter04_%25EC%258A%25A4%25ED%2583%259D%25EA%25B3%25BC%25ED%2581%2590%2f"><svg viewBox="2 2 28 28"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></div></footer></article></main><footer class=footer><span>&copy; 2022 <a href=http://jeha00.github.io/>Jeha00 DevLog</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerText="copy";function s(){t.innerText="copied!",setTimeout(()=>{t.innerText="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>