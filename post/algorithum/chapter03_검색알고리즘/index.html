<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>[TIL] Alogorithum Chapter 03: Search algorithum | Jeha00 DevLog</title><meta name=keywords content="TIL,Algorithum"><meta name=description content="검색 알고리즘의 종류인 선형 검색, 이진검색, 해쉬법에 대해 알아본다."><meta name=author content="Jeha00"><link rel=canonical href=http://jeha00.github.io/post/algorithum/chapter03_%EA%B2%80%EC%83%89%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/><meta name=google-site-verification content="XYZabc"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.min.1e44d58192cbf6d7a4eb649bc43dbc3d4cc432677e5d8adc69b08c34cbe461ac.css integrity="sha256-HkTVgZLL9tek62SbxD28PUzEMmd+XYrcabCMNMvkYaw=" rel="preload stylesheet" as=style><link rel=icon href=http://jeha00.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=http://jeha00.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=http://jeha00.github.io/favicon-32x32.png><link rel=apple-touch-icon href=http://jeha00.github.io/apple-touch-icon.png><link rel=mask-icon href=http://jeha00.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><meta name=generator content="Hugo 0.98.0"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script type=application/javascript>var doNotTrack=!1;doNotTrack||(function(e,o,i,a,t,n,s){e.GoogleAnalyticsObject=t,e[t]=e[t]||function(){(e[t].q=e[t].q||[]).push(arguments)},e[t].l=1*new Date,n=o.createElement(i),s=o.getElementsByTagName(i)[0],n.async=1,n.src=a,s.parentNode.insertBefore(n,s)}(window,document,"script","https://www.google-analytics.com/analytics.js","ga"),ga("create","UA-123-45","auto"),ga("send","pageview"))</script><meta property="og:title" content="[TIL] Alogorithum Chapter 03: Search algorithum"><meta property="og:description" content="검색 알고리즘의 종류인 선형 검색, 이진검색, 해쉬법에 대해 알아본다."><meta property="og:type" content="article"><meta property="og:url" content="http://jeha00.github.io/post/algorithum/chapter03_%EA%B2%80%EC%83%89%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/"><meta property="og:image" content="http://jeha00.github.io/47"><meta property="article:section" content="post"><meta property="article:published_time" content="2022-06-03T20:47:08+09:00"><meta property="article:modified_time" content="2022-06-03T20:47:08+09:00"><meta property="og:site_name" content="JeHa00 DevLog"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="http://jeha00.github.io/47"><meta name=twitter:title content="[TIL] Alogorithum Chapter 03: Search algorithum"><meta name=twitter:description content="검색 알고리즘의 종류인 선형 검색, 이진검색, 해쉬법에 대해 알아본다."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"http://jeha00.github.io/post/"},{"@type":"ListItem","position":2,"name":"[TIL] Alogorithum Chapter 03: Search algorithum","item":"http://jeha00.github.io/post/algorithum/chapter03_%EA%B2%80%EC%83%89%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"[TIL] Alogorithum Chapter 03: Search algorithum","name":"[TIL] Alogorithum Chapter 03: Search algorithum","description":"검색 알고리즘의 종류인 선형 검색, 이진검색, 해쉬법에 대해 알아본다.","keywords":["TIL","Algorithum"],"articleBody":"0. Introduction  이번 chapter의 학습은 Do it! 자료구조와 함께 배우는 알고리즘 입문로부터 학습했습니다. 더 자세한 내용과 관련 내용의 코드는 위 서적의 출판사 사이트에서 확인하실 수 있습니다.   1. 검색 알고리즘이란? 알고리즘이란 어떠한 문제를 해결하기 위해 정해 놓은 일련의 절차를 말하며, 올바른 알고리즘은 어떠한 경우에도 실행 결과가 똑같이 나오는 알고리즘을 말한다.\n검색이란 어떤 특정 조건을 만족하는 데이터를 찾아내는 것이다.\n그렇다면 검색 알고리즘이란 어떤 특정 조건을 만족하는 데이터를 찾아내기 위한 일련의 정해놓은 절차를 말한다는 걸 알 수 있다.\n이 검색 알고리즘의 종류에는 다음과 같이 3가지가 있다.\n 배열 검색 연결 리스트 검색 이진 검색 트리 검색  이 중에서 배열 검색에 대해 먼저 알아볼 것이고, 이 배열 검색 또한 3가지 검색법이 있다.\n 배열 검색  선형 검색: 무작위로 늘어놓은 데이터 집합에서 검색을 수행한다. 이진 검색: 일정한 규칙으로 늘어놓은 데이터 집합에서 아주 빠른 검색을 수행한다. 해시법: 추가 삭제가 자주 일어나는 데이터 집합에서 아주 빠른 검색을 수행한다.  체인법: 같은 해시값 데이터를 연결 리스트로 연결하는 방법 오픈 주소법: 데이터를 위한 ㅐ시값이 충돌할 때, 재해시하는 방법      그러면 검색은 무조건 빠르게 수행하면 좋은 걸까??\n그렇지 않다.\n용도, 목적, 실행 속도, 자료 구조 등 여러 사항을 고려해서 선택해야 한다.\n이제 배열 검색부터 알아보자.\n 2. 선형 검색(Linear search)  선형으로 늘어선 배열에서 원하는 키값을 찾을 때까지 맨 앞부터 스캔하여 순서대로 검색하는 알고리즘\n 이 선형 검색이 종료가 될라면 검색이 실패하든가 성공해야 한다.\n검색할 값을 찾지 못하고, 배열의 맨 끝을 지나가면 실패한 경우다.\n검색할 값과 같은 원소를 찾았다면 당연히 성공한 경우다.\n그러면 이 성공한 경우와 실패한 경우를 간단히 코드로 구현해보자.\n# 배열 a에서 검색하는 프로그램  i = 0  while True:  if i == len(a): # 검색 실패  if a[i] == key: # 검색 성공 하지만 이 검색 종료를 판단하기 위한 횟수도 줄일 수록 오버헤드가 줄어드는 것이다.\n이 오버헤드 비용을 반으로 줄이는 방법이 보초법(sentinel) 이다.\n원래의 배열 맨 끝에 찾으려는 key 값을 추가한다. 그러면 위 코드에서 검색 실패에 해당하는 과정을 수행할 필요 없이, 검색 성공에 해당하는 경우만 판단하면 된다.\n 3. 이진 검색(Binary search)  배열을 내림차순 또는 오름차순으로 정렬한 후, 검색 범위의 중간 위치에 있는 값이 key 값보다 작거나 크거나에 따라서 검색 범위를 점차 좁혀가는 검색하는 알고리즘으로, 선형 검색(순차 검색)보다 빠르다.\n [코들리] 알고리즘 - 이진검색 을 참고하자.\n글로 더 자세히 설명하자면 다음과 같다.\n배열 검색 범위의 맨 앞, 맨 끝, 중앙의 인덱스를 각각 pl, pr, pc 라고 하면, pl은 0, pr은 (n-1), pc는 (n-1) // 2로 초기화한다.\n중앙 값을 기준으로 key값보다 크고 작냐에 따라서 범위가 점점 줄어들기 때문에, 선형 검색보다 탐색 횟수가 적어서 빠르다.\n a[pc] a[pc]  key: 중앙에서 왼쪽으로 한 칸 이동하며, 새로운 오른쪽 끝 pc로 지정하고, 검색 범위로 앞쪽 절반으로 좁힌다.  그래서 이진 검색은 다음과 같은 두 가지 조건일 때, 검색이 종료된다.\n a[pc] 와 key가 일치하는 경우 검색 범위가 더 이상 없는 경우  복잡도(Complexity)  알고리즘의 성능을 객관적으로 평가하는 기준\n 복잡도의 종류에는 다음 두 가지가 있다.\n 시간 복잡도(time complexity): 실행하는데 필요한 시간을 평가한다. 공간 복잡도(space complexity): 메모리(기억 공간)와 파일 공간이 얼마나 필요한지 평가한다.  복잡도는 _Order의 첫 글자 O로 표시한다. _\n실행 횟수가 1이면 복잡도를 O(1)로 표시한다. 하지만, 실행 횟수가 n에 비례하는 경우 복잡도는 O(n)으로 표시한다.\n그리고, 2가지 계산으로 구성된 알고리즘의 복잡도는 차원이 더 높은 쪽의 복잡도를 우선으로 하기 때문에, O(1)과 O(n)으로 구성되었다면 O(n)으로 여긴다.\n복잡도 O에 대한 더 자세한 설명은 이 블로그 알고리즘의 시간 복잡도와 Big-O 쉽게 이해하기를 보자.\n 4. 해시법(Hasing)  데이터의 추가, 삭제도 효율적으로 수행할 수 있는 검색법으로, 해시 함수(hash function)를 통해서 key를 해시값(hash value, key를 원소 갯수로 나눈 나머지)으로 데이터에 접근하는 방식\n 해시 테이블(hash table)에서 만들어진 원소를 버킷(bucket) 이라 한다.\n그리고, key와 hash value는 일반적으로 다 대 1 (n:1) 이라서, 저장할 버킷이 중복되는 현상을 충돌(collision) 이라 한다.\n이 충돌을 발생 시 대처 방법에는 아래와 같이 2가지가 있다.\n 체인법: 해시값이 같은 데이터 원소를 체인 모양의 연결 리스트롤 연결하는 방법을 말하며, 오픈 해시법(open hashing) 이라 한다. 오픈 주소법: 빈 버킷을 찾을 때까지 해시를 반복한다.   Reference  Do it! 자료구조와 함께 배우는 알고리즘 입문 [코들리] 알고리즘 - 이진검색 알고리즘의 시간 복잡도와 Big-O 쉽게 이해하기  ","wordCount":"636","inLanguage":"en","datePublished":"2022-06-03T20:47:08+09:00","dateModified":"2022-06-03T20:47:08+09:00","author":{"@type":"Person","name":"Jeha00"},"mainEntityOfPage":{"@type":"WebPage","@id":"http://jeha00.github.io/post/algorithum/chapter03_%EA%B2%80%EC%83%89%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/"},"publisher":{"@type":"Organization","name":"Jeha00 DevLog","logo":{"@type":"ImageObject","url":"http://jeha00.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=http://jeha00.github.io/ accesskey=h title="Jeha00 (Alt + H)">Jeha00</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></span></div><ul id=menu><li><a href=http://jeha00.github.io/archives/ title=Archive><span>Archive</span></a></li><li><a href=http://jeha00.github.io/categories/ title=Categories><span>Categories</span></a></li><li><a href=http://jeha00.github.io/tags/ title=Tags><span>Tags</span></a></li><li><a href=http://jeha00.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=http://jeha00.github.io/>Home</a>&nbsp;»&nbsp;<a href=http://jeha00.github.io/post/>Posts</a></div><h1 class=post-title>[TIL] Alogorithum Chapter 03: Search algorithum</h1><div class=post-meta><span title="2022-06-03 20:47:08 +0900 KST">June 3, 2022</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;Jeha00&nbsp;|&nbsp;<a href=https://github.com/JeHa00/blog/content/post/Algorithum/Chapter03_%ea%b2%80%ec%83%89%ec%95%8c%ea%b3%a0%eb%a6%ac%ec%a6%98.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#0-introduction aria-label="0. Introduction">0. Introduction</a></li><li><a href=#1-%ea%b2%80%ec%83%89-%ec%95%8c%ea%b3%a0%eb%a6%ac%ec%a6%98%ec%9d%b4%eb%9e%80 aria-label="1. 검색 알고리즘이란?">1. 검색 알고리즘이란?</a></li><li><a href=#2-%ec%84%a0%ed%98%95-%ea%b2%80%ec%83%89linear-search aria-label="2. 선형 검색(Linear search)">2. 선형 검색(Linear search)</a></li><li><a href=#3-%ec%9d%b4%ec%a7%84-%ea%b2%80%ec%83%89binary-search aria-label="3. 이진 검색(Binary search)">3. 이진 검색(Binary search)</a><ul><ul><li><a href=#%eb%b3%b5%ec%9e%a1%eb%8f%84complexity aria-label=복잡도(Complexity)>복잡도(Complexity)</a></li></ul></ul></li><li><a href=#4-%ed%95%b4%ec%8b%9c%eb%b2%95hasing aria-label="4. 해시법(Hasing)">4. 해시법(Hasing)</a></li><li><a href=#reference aria-label=Reference>Reference</a></li></ul></div></details></div><div class=post-content><h1 id=0-introduction>0. Introduction<a hidden class=anchor aria-hidden=true href=#0-introduction>#</a></h1><ul><li>이번 chapter의 학습은 <a href="http://www.kyobobook.co.kr/product/detailViewKor.laf?barcode=9791163031727">Do it! 자료구조와 함께 배우는 알고리즘 입문</a>로부터 학습했습니다.</li><li>더 자세한 내용과 관련 내용의 코드는 위 서적의 출판사 사이트에서 확인하실 수 있습니다.</li></ul><hr><h1 id=1-검색-알고리즘이란>1. 검색 알고리즘이란?<a hidden class=anchor aria-hidden=true href=#1-검색-알고리즘이란>#</a></h1><p><strong><em>알고리즘이란 어떠한 문제를 해결하기 위해 정해 놓은 일련의 절차를 말하며, 올바른 알고리즘은 어떠한 경우에도 실행 결과가 똑같이 나오는 알고리즘을 말한다.</em></strong></p><p><strong><em>검색이란 어떤 특정 조건을 만족하는 데이터를 찾아내는 것이다.</em></strong></p><p>그렇다면 검색 알고리즘이란 어떤 특정 조건을 만족하는 데이터를 찾아내기 위한 일련의 정해놓은 절차를 말한다는 걸 알 수 있다.</p><p>이 검색 알고리즘의 종류에는 다음과 같이 3가지가 있다.</p><ul><li>배열 검색</li><li>연결 리스트 검색</li><li>이진 검색 트리 검색</li></ul><p>이 중에서 배열 검색에 대해 먼저 알아볼 것이고, 이 배열 검색 또한 3가지 검색법이 있다.</p><ul><li><strong><em>배열 검색</em></strong><ul><li>선형 검색: 무작위로 늘어놓은 데이터 집합에서 검색을 수행한다.</li><li>이진 검색: 일정한 규칙으로 늘어놓은 데이터 집합에서 아주 빠른 검색을 수행한다.</li><li>해시법: 추가 삭제가 자주 일어나는 데이터 집합에서 아주 빠른 검색을 수행한다.<ul><li>체인법: 같은 해시값 데이터를 연결 리스트로 연결하는 방법</li><li>오픈 주소법: 데이터를 위한 ㅐ시값이 충돌할 때, 재해시하는 방법</li></ul></li></ul></li></ul><p>그러면 검색은 무조건 빠르게 수행하면 좋은 걸까??</p><p>그렇지 않다.</p><p>용도, 목적, 실행 속도, 자료 구조 등 여러 사항을 고려해서 선택해야 한다.</p><p>이제 배열 검색부터 알아보자.</p><hr><h1 id=2-선형-검색linear-search>2. 선형 검색(Linear search)<a hidden class=anchor aria-hidden=true href=#2-선형-검색linear-search>#</a></h1><blockquote><p><strong><em>선형으로 늘어선 배열에서 원하는 키값을 찾을 때까지 맨 앞부터 스캔하여 순서대로 검색하는 알고리즘</em></strong></p></blockquote><p>이 선형 검색이 종료가 될라면 검색이 실패하든가 성공해야 한다.</p><p>검색할 값을 찾지 못하고, 배열의 맨 끝을 지나가면 실패한 경우다.</p><p>검색할 값과 같은 원소를 찾았다면 당연히 성공한 경우다.</p><p>그러면 이 성공한 경우와 실패한 경우를 간단히 코드로 구현해보자.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yml data-lang=yml><span style=display:flex><span><span style=color:#6272a4># 배열 a에서 검색하는 프로그램</span>
</span></span><span style=display:flex><span>&gt; i = 0
</span></span><span style=display:flex><span><span style=color:#ff79c6>&gt; while True</span>:
</span></span><span style=display:flex><span><span style=color:#ff79c6>&gt;     if i == len(a)</span>: <span style=color:#6272a4># 검색 실패</span>
</span></span><span style=display:flex><span><span style=color:#ff79c6>&gt;     if a[i] == key</span>: <span style=color:#6272a4># 검색 성공</span>
</span></span></code></pre></div><p>하지만 이 검색 종료를 판단하기 위한 횟수도 줄일 수록 오버헤드가 줄어드는 것이다.</p><p>이 오버헤드 비용을 반으로 줄이는 방법이 <strong><em>보초법(sentinel)</em></strong> 이다.</p><p>원래의 배열 맨 끝에 찾으려는 key 값을 추가한다. 그러면 위 코드에서 검색 실패에 해당하는 과정을 수행할 필요 없이, 검색 성공에 해당하는 경우만 판단하면 된다.</p><hr><h1 id=3-이진-검색binary-search>3. 이진 검색(Binary search)<a hidden class=anchor aria-hidden=true href=#3-이진-검색binary-search>#</a></h1><blockquote><p><strong><em>배열을 내림차순 또는 오름차순으로 정렬한 후, 검색 범위의 중간 위치에 있는 값이 key 값보다 작거나 크거나에 따라서 검색 범위를 점차 좁혀가는 검색하는 알고리즘으로, 선형 검색(순차 검색)보다 빠르다.</em></strong></p></blockquote><p><a href="https://www.youtube.com/watch?v=IfIuG95RH0o">[코들리] 알고리즘 - 이진검색</a> 을 참고하자.</p><p>글로 더 자세히 설명하자면 다음과 같다.</p><p>배열 검색 범위의 맨 앞, 맨 끝, 중앙의 인덱스를 각각 pl, pr, pc 라고 하면, pl은 0, pr은 (n-1), pc는 (n-1) // 2로 초기화한다.</p><p>중앙 값을 기준으로 key값보다 크고 작냐에 따라서 범위가 점점 줄어들기 때문에, 선형 검색보다 탐색 횟수가 적어서 빠르다.</p><ul><li>a[pc] &lt; key: 중앙에서 오른쪽으로 한 칸 이동하여, 새로운 왼쪽 끝 pl로 지정하고, 검색 범위를 뒤쪽 절반으로 좁힌다.</li><li>a[pc] > key: 중앙에서 왼쪽으로 한 칸 이동하며, 새로운 오른쪽 끝 pc로 지정하고, 검색 범위로 앞쪽 절반으로 좁힌다.</li></ul><p>그래서 이진 검색은 다음과 같은 두 가지 조건일 때, 검색이 종료된다.</p><ul><li>a[pc] 와 key가 일치하는 경우</li><li>검색 범위가 더 이상 없는 경우</li></ul><h3 id=복잡도complexity>복잡도(Complexity)<a hidden class=anchor aria-hidden=true href=#복잡도complexity>#</a></h3><blockquote><p><strong><em>알고리즘의 성능을 객관적으로 평가하는 기준</em></strong></p></blockquote><p>복잡도의 종류에는 다음 두 가지가 있다.</p><ul><li>시간 복잡도(time complexity): 실행하는데 필요한 시간을 평가한다.</li><li>공간 복잡도(space complexity): 메모리(기억 공간)와 파일 공간이 얼마나 필요한지 평가한다.</li></ul><p>복잡도는 <strong>_Order의 첫 글자 O로 표시한다. _</strong></p><p>실행 횟수가 1이면 복잡도를 O(1)로 표시한다. 하지만, 실행 횟수가 n에 비례하는 경우 복잡도는 O(n)으로 표시한다.</p><p>그리고, 2가지 계산으로 구성된 알고리즘의 복잡도는 차원이 더 높은 쪽의 복잡도를 우선으로 하기 때문에, O(1)과 O(n)으로 구성되었다면 O(n)으로 여긴다.</p><p>복잡도 O에 대한 더 자세한 설명은 이 블로그 <a href=https://blog.chulgil.me/algorithm/>알고리즘의 시간 복잡도와 Big-O 쉽게 이해하기</a>를 보자.</p><hr><h1 id=4-해시법hasing>4. 해시법(Hasing)<a hidden class=anchor aria-hidden=true href=#4-해시법hasing>#</a></h1><blockquote><p><strong><em>데이터의 추가, 삭제도 효율적으로 수행할 수 있는 검색법으로, 해시 함수(hash function)를 통해서 key를 해시값(hash value, key를 원소 갯수로 나눈 나머지)으로 데이터에 접근하는 방식</em></strong></p></blockquote><p>해시 테이블(hash table)에서 만들어진 원소를 <strong><em>버킷(bucket)</em></strong> 이라 한다.</p><p>그리고, key와 hash value는 일반적으로 다 대 1 (n:1) 이라서, 저장할 버킷이 중복되는 현상을 <strong><em>충돌(collision)</em></strong> 이라 한다.</p><p>이 충돌을 발생 시 대처 방법에는 아래와 같이 2가지가 있다.</p><ul><li>체인법: 해시값이 같은 데이터 원소를 체인 모양의 연결 리스트롤 연결하는 방법을 말하며, 오픈 해시법(open hashing) 이라 한다.</li><li>오픈 주소법: 빈 버킷을 찾을 때까지 해시를 반복한다.</li></ul><hr><h1 id=reference>Reference<a hidden class=anchor aria-hidden=true href=#reference>#</a></h1><ul><li><a href="http://www.kyobobook.co.kr/product/detailViewKor.laf?barcode=9791163031727">Do it! 자료구조와 함께 배우는 알고리즘 입문</a></li><li><a href="https://www.youtube.com/watch?v=IfIuG95RH0o">[코들리] 알고리즘 - 이진검색</a></li><li><a href=https://blog.chulgil.me/algorithm/>알고리즘의 시간 복잡도와 Big-O 쉽게 이해하기</a></li></ul></div><footer class=post-footer><ul class=post-tags><li><a href=http://jeha00.github.io/tags/til/>TIL</a></li><li><a href=http://jeha00.github.io/tags/algorithum/>Algorithum</a></li></ul><nav class=paginav><a class=prev href=http://jeha00.github.io/post/algorithum/chapter04_%EC%8A%A4%ED%83%9D%EA%B3%BC%ED%81%90/><span class=title>« Prev Page</span><br><span>[TIL] Alogorithum Chapter 04: Stack and Queue</span></a>
<a class=next href=http://jeha00.github.io/post/os/os_chapter_13_%EC%9B%B9%EC%BA%90%EC%8B%B1/><span class=title>Next Page »</span><br><span>[TIL] OS Chapter 13: 웹캐싱 기법</span></a></nav><div class=share-buttons><a target=_blank rel="noopener noreferrer" aria-label="share [TIL] Alogorithum Chapter 03: Search algorithum on twitter" href="https://twitter.com/intent/tweet/?text=%5bTIL%5d%20Alogorithum%20Chapter%2003%3a%20Search%20algorithum&url=http%3a%2f%2fjeha00.github.io%2fpost%2falgorithum%2fchapter03_%25EA%25B2%2580%25EC%2583%2589%25EC%2595%258C%25EA%25B3%25A0%25EB%25A6%25AC%25EC%25A6%2598%2f&hashtags=TIL%2cAlgorithum"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM195.519 424.544c135.939.0 210.268-112.643 210.268-210.268.0-3.218.0-6.437-.153-9.502 14.406-10.421 26.973-23.448 36.935-38.314-13.18 5.824-27.433 9.809-42.452 11.648 15.326-9.196 26.973-23.602 32.49-40.92-14.252 8.429-30.038 14.56-46.896 17.931-13.487-14.406-32.644-23.295-53.946-23.295-40.767.0-73.87 33.104-73.87 73.87.0 5.824.613 11.494 1.992 16.858-61.456-3.065-115.862-32.49-152.337-77.241-6.284 10.881-9.962 23.601-9.962 37.088.0 25.594 13.027 48.276 32.95 61.456-12.107-.307-23.448-3.678-33.41-9.196v.92c0 35.862 25.441 65.594 59.311 72.49-6.13 1.686-12.72 2.606-19.464 2.606-4.751.0-9.348-.46-13.946-1.38 9.349 29.426 36.628 50.728 68.965 51.341-25.287 19.771-57.164 31.571-91.8 31.571-5.977.0-11.801-.306-17.625-1.073 32.337 21.15 71.264 33.41 112.95 33.41z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share [TIL] Alogorithum Chapter 03: Search algorithum on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&url=http%3a%2f%2fjeha00.github.io%2fpost%2falgorithum%2fchapter03_%25EA%25B2%2580%25EC%2583%2589%25EC%2595%258C%25EA%25B3%25A0%25EB%25A6%25AC%25EC%25A6%2598%2f&title=%5bTIL%5d%20Alogorithum%20Chapter%2003%3a%20Search%20algorithum&summary=%5bTIL%5d%20Alogorithum%20Chapter%2003%3a%20Search%20algorithum&source=http%3a%2f%2fjeha00.github.io%2fpost%2falgorithum%2fchapter03_%25EA%25B2%2580%25EC%2583%2589%25EC%2595%258C%25EA%25B3%25A0%25EB%25A6%25AC%25EC%25A6%2598%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share [TIL] Alogorithum Chapter 03: Search algorithum on reddit" href="https://reddit.com/submit?url=http%3a%2f%2fjeha00.github.io%2fpost%2falgorithum%2fchapter03_%25EA%25B2%2580%25EC%2583%2589%25EC%2595%258C%25EA%25B3%25A0%25EB%25A6%25AC%25EC%25A6%2598%2f&title=%5bTIL%5d%20Alogorithum%20Chapter%2003%3a%20Search%20algorithum"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share [TIL] Alogorithum Chapter 03: Search algorithum on facebook" href="https://facebook.com/sharer/sharer.php?u=http%3a%2f%2fjeha00.github.io%2fpost%2falgorithum%2fchapter03_%25EA%25B2%2580%25EC%2583%2589%25EC%2595%258C%25EA%25B3%25A0%25EB%25A6%25AC%25EC%25A6%2598%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share [TIL] Alogorithum Chapter 03: Search algorithum on whatsapp" href="https://api.whatsapp.com/send?text=%5bTIL%5d%20Alogorithum%20Chapter%2003%3a%20Search%20algorithum%20-%20http%3a%2f%2fjeha00.github.io%2fpost%2falgorithum%2fchapter03_%25EA%25B2%2580%25EC%2583%2589%25EC%2595%258C%25EA%25B3%25A0%25EB%25A6%25AC%25EC%25A6%2598%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share [TIL] Alogorithum Chapter 03: Search algorithum on telegram" href="https://telegram.me/share/url?text=%5bTIL%5d%20Alogorithum%20Chapter%2003%3a%20Search%20algorithum&url=http%3a%2f%2fjeha00.github.io%2fpost%2falgorithum%2fchapter03_%25EA%25B2%2580%25EC%2583%2589%25EC%2595%258C%25EA%25B3%25A0%25EB%25A6%25AC%25EC%25A6%2598%2f"><svg viewBox="2 2 28 28"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></div></footer><script src=https://utteranc.es/client.js repo=JeHa00/blog-comments issue-term=pathname theme=github-dark crossorigin=anonymous async></script></article></main><footer class=footer><span>&copy; 2022 <a href=http://jeha00.github.io/>Jeha00 DevLog</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(t){t.preventDefault();var e=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(e)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(e)}']`).scrollIntoView({behavior:"smooth"}),e==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${e}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>