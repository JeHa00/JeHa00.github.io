<!doctype html><html lang=en dir=auto>
<head><meta charset=utf-8>
<meta http-equiv=x-ua-compatible content="IE=edge">
<meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no">
<meta name=robots content="index, follow">
<title>[TIL] Python basic 32: LEGB rules and Memory structures | Jeha00 DevLog</title>
<meta name=keywords content="TIL,python">
<meta name=description content="LEGB rules 즉 Local, Enclosing, global(or module), built-in varialbe의 scope에 대해 알아본다. 그리고, Python Memory structure가 어떤지 개괄적으로 알아본다.">
<meta name=author content="Jeha00">
<link rel=canonical href=http://jeha00.github.io/post/python_basic/python_basic_32_legb_rules/>
<meta name=google-site-verification content="XYZabc">
<meta name=yandex-verification content="XYZabc">
<meta name=msvalidate.01 content="XYZabc">
<link crossorigin=anonymous href=/assets/css/stylesheet.min.1e44d58192cbf6d7a4eb649bc43dbc3d4cc432677e5d8adc69b08c34cbe461ac.css integrity="sha256-HkTVgZLL9tek62SbxD28PUzEMmd+XYrcabCMNMvkYaw=" rel="preload stylesheet" as=style>
<link rel=icon href=http://jeha00.github.io/favicon.ico>
<link rel=icon type=image/png sizes=16x16 href=http://jeha00.github.io/favicon-16x16.png>
<link rel=icon type=image/png sizes=32x32 href=http://jeha00.github.io/favicon-32x32.png>
<link rel=apple-touch-icon href=http://jeha00.github.io/apple-touch-icon.png>
<link rel=mask-icon href=http://jeha00.github.io/safari-pinned-tab.svg>
<meta name=theme-color content="#2e2e33">
<meta name=msapplication-TileColor content="#2e2e33">
<meta name=generator content="Hugo 0.92.1">
<noscript>
<style>#theme-toggle,.top-link{display:none}</style>
<style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style>
</noscript>
<script type=application/javascript>var doNotTrack=!1;doNotTrack||(function(a,e,f,g,b,c,d){a.GoogleAnalyticsObject=b,a[b]=a[b]||function(){(a[b].q=a[b].q||[]).push(arguments)},a[b].l=1*new Date,c=e.createElement(f),d=e.getElementsByTagName(f)[0],c.async=1,c.src=g,d.parentNode.insertBefore(c,d)}(window,document,'script','https://www.google-analytics.com/analytics.js','ga'),ga('create','UA-123-45','auto'),ga('send','pageview'))</script><meta property="og:title" content="[TIL] Python basic 32: LEGB rules and Memory structures">
<meta property="og:description" content="LEGB rules 즉 Local, Enclosing, global(or module), built-in varialbe의 scope에 대해 알아본다. 그리고, Python Memory structure가 어떤지 개괄적으로 알아본다.">
<meta property="og:type" content="article">
<meta property="og:url" content="http://jeha00.github.io/post/python_basic/python_basic_32_legb_rules/"><meta property="og:image" content="http://jeha00.github.io/47"><meta property="article:section" content="post">
<meta property="article:published_time" content="2022-03-27T23:53:06+09:00">
<meta property="article:modified_time" content="2022-03-27T23:53:06+09:00"><meta property="og:site_name" content="JeHa00 DevLog">
<meta name=twitter:card content="summary_large_image">
<meta name=twitter:image content="http://jeha00.github.io/47">
<meta name=twitter:title content="[TIL] Python basic 32: LEGB rules and Memory structures">
<meta name=twitter:description content="LEGB rules 즉 Local, Enclosing, global(or module), built-in varialbe의 scope에 대해 알아본다. 그리고, Python Memory structure가 어떤지 개괄적으로 알아본다.">
<script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"http://jeha00.github.io/post/"},{"@type":"ListItem","position":2,"name":"[TIL] Python basic 32: LEGB rules and Memory structures","item":"http://jeha00.github.io/post/python_basic/python_basic_32_legb_rules/"}]}</script>
<script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"[TIL] Python basic 32: LEGB rules and Memory structures","name":"[TIL] Python basic 32: LEGB rules and Memory structures","description":"LEGB rules 즉 Local, Enclosing, global(or module), built-in varialbe의 scope에 대해 알아본다. 그리고, Python Memory structure가 어떤지 개괄적으로 알아본다.","keywords":["TIL","python"],"articleBody":"Intro  coroutin을 공부하면서 global variable과 local variable에 대해서 기본적인 의미만 알았지만, 이것이 Scoping Rule과 연관이 되어있다는 것과,stack과 heap이라는 데이터 임시 저장 자료 구조와 연관된 걸 몰랐다. 그래서 Scoping Rule, Stack 그리고, Heap에 대해 알아보겠다.   1.LEGB rules(Scoping rules)  변수(variable)의 생존 범위(lifetime)에 관련된 규칙\n  Python scope 개념을 알아야 하는 이유:  신뢰성 있고, 유지보수성이 좋은 프로그램을 작성할 수 있다. name 충돌을 방지할 수 있고, 버그를 줄일 수 있다. 이와 관련된 tool인 Closure에 대해 알 수 있다.    1.1 Scope의 일반적인 종류 : 2가지  global scope  이 scope에서 정의한 name은 모든 코드에서 사용할 수 있다.   local scope  이 scope에서 정의한 name은 범위 내의 코드에서만 사용할 수 있거나 볼 수 있다.      name: 변수, 상수, 함수, 클래스 등등의 식별자(identifier)를 참조하는 것으로, 구분하기 위해 존재한다.   1.2 초기 Scope의 부재로 인한 문제  초기 프로그래밍은 global만 있었기 때문에, 변수를 수정해야할 때 모든 코드를 동시에 염두에 둬야했다. 그래서 이런 문제를 피하기 위해 scope을 사용했다. scope을 사용한 후, 프로그램의 어디에서든지 그 scope에 있는 변수들에 함부로 접근할 수 없다. (out of scope) name들의 scope은 이 name들을 정의한 코드의 block scope과 동일하다. (in scope)  1.3 파이썬의 이름(name)과 범위(scope)들  파이썬에서의 변수들에 값이 할당될 때, 즉 파이썬 names을 다음과 같은 방법들로 만들 때 변수들은 존재하게 된다.  변수(variable): 변수에 값을 할당하면, 변수는 만들어진다. function , classes: 예약어 def, classes를 사용하여 정의하면 이용할 수 있다. modules: import하여 사용할 수 있다.    1.4 assignment operations와 reference operations의 차이  reference operations  name을 ‘참조’ 한다는 건, name에 담겨진 content or value를 ‘단지 가져온다’   assignment operations  name을 ‘할당’ 한다는 건, name을 ‘새롭게’ 만들거나, ‘수정’ 한다   할당한다는 건 특정 scope이 결정된다는 걸 말한다.  1.5 Python scope와 namespace의 관계  Namespace : python의 name이 dictionary data type으로 구현된 것\n   dictionary가 Python이 name을 저장하는 구체적인 원리다.\n  Namespace는 또한 __dir__ 명령어에 저장되어 있다.\n  namespace는 각각 다른 수명 시간(life time)을 가지고 있다.\n  왜냐하면 각각 다른 지점에서 만들어지기 때문이다.\n  from Python-course.eu: Namespaces\n    즉, __dir__은 Namespace를 확인할 수 있는 명령어이고, 할당된 name이 가지는 scope을 보여준다.\n  .__dict__.keys() 로 key value로 indexing하여 확인할 수 있다.\n  python은 name의 존재유무를 확인하기 위해서, 여러 scope levels(or namespace)를 찾아본다.\n  찾는 순서는 다음과 같다.\n local namespace - global namespace - global or module namespace - built-in namespace      1.6 Python이 name을 찾는 규칙: LEGB rules   local namespace - enclosing namespace - global(or module) namespace- built-in scope namespace 순서로 주어진 name을 파이썬이 찾는다.\n  Local(or function) scope: Python function의 body 또는 code block 부분이 local scope\n   지역 함수 내에 로직을 해결하는 값을 사용한다.\n   fuction 내에서 정의한 name들만 포함한다.\n  이 function의 코드에서만 local scope에 있는 name을 확인할 수 있다.\n  lifetime of a local namespace: 할당된 function이 종료되면 끝난다.\n  Enclosing(or nonlocal) scope: 중첩함수(nested functions)를 위해서만 존재하는 scope\n enclosing function 안에서 정의된 names만 포함한다. 이 enclosing function의 코드에서만 enclosing scope에 있는 name을 확인할 수 있다.    Global(or module) scope: Python program, script, module 안에서 Top level의 scope\n   이 scope에는 주로 변하지 않는 고정값을 사용한다.\n   프로그램 또는 모듈에서 최고 수준으로(Top level) 정의한 이름들을 포함한다.\n  어느 코드에서든지 Global scope에 있는 name을 확인할 수 있다.\n Top level이란??    lifetime of a module namespace: 일반적으로 script가 끝날 때까지만 지속된다.\n  Built-in scope: script를 run할 때마다 만들어지는 특별한 scope\n Python 안에 내장된 예약어들, functions들 등등의 name을 포함한다. 이 scope 또한 Global scope처럼 어느 코드에서든지 name을 확인한다. Built-in namespace는 interpreter가 시작되면 만들어지고, 절대로 삭제되지 않는다.    1.7 LEGB rules: The Local Scope  그러면 code를 보면 이해해보자.   def square(base):  result = base ** 2  print(f'The square of {base} is : {result}')  square(10) The square of 10 is : 100  result NameError: name 'result' is not defined  base NameError: name 'base' is not defined   위 코드에 대해 알아보자.\n square fuction을 호출할 때, 파이썬은 base와 result를 포함하는 local scope을 만든다. square(10)으로 호출할 때, base에는 10을 result에는 100을 취한다. 또 다시 호출할 때는 첫 번째 호출 시 취한 값들은 기억하지 않는다. result와 base는 square() 호출에 의해 만들어진 local scope에만 존재한다. 그래서 square fuction 호출 후, 접근한다면 NameError을 얻는 것이다.    그러면 추가로 local scope에 동일한 변수 이름을 가진 fuction을 정의해보자.\n   def cube(base):  result = base ** 3  print(f'The cube of {base} is : {result}')  cube(30) The cube of 30 is : 27000  local scope에 동일한 변수이름을 사용했지만, 프로그램 충돌이 일어나지 않았다. 왜냐하면 local scope을 사용했기 때문이다. local scope에만 살아있는 변수를 local variable이라 한다. 함수 실행이 끝나면 local scope에서 벗어나기 때문에 local variable의 생명력은 끝난다. 이러한 장점 때문에, 디버깅과 수정이 쉽고 가독성이 좋아진다.  1.8 LEGB rules: The Enclosing Scope (Nested Functions)  def outer_func():   # 이 block은 외부 함수(outer_func)의 local scope이면서   # 내부 함수(inner_func)의 enclosing scope이기도 하다.  var = 100  def inner_func():  print(f'Printing var from inner_func() : {var}')  inner_func()  print(f'Printing var from outer_func() : {var}')  outer_func() Printing var from inner_func(): 100 Printing var from outer_func(): 100  inner_func() NameError: name 'inner_func' is not defined  outer_func()을 호출할 때, outer_func()의 local scope이 만들어진다. 이 scope은 동시에 inner_func()의 enclosing scope이라고도 한다.  global scope과 local scope 둘 다 아니고, 이 사이에 놓여있는 특별한 scope을 의미.   또한, inner_func()은 enclosing function인 outer_func이 실행되는 동안에만 유지되는 일시적인 함수다. 즉, outer_func()의 code에서만 inner_func()을 찾을 수 있다.  1.9 LEGB rules: Modules - The Global Scope    프로그램을 실행한 순간부터 global scope에 있는 것이다.    이 global scope은 module file과 깊은 연관이 있기 때문에, module scope이라 한다.    그리고 현재 실행되는 script 또는 module이 entry point 역할을 한다면, 이 시점부터 scope of __main__이 된다.    namespace를 확인하기 위해서 dir()을 사용할 때, 아무런 인자 없이 사용하면 main global Python scope에서 이용가능한 name list를 얻는다.    프로그램 실행할 때 단 하나의 global Python scope만이 존재한다. 그리고, 프로그램 실행이 끝나야 scope이 종료된다.    local scope에 있는 global 변수를 참조하거나 접근할 수 있다.   하지만, local scope에서 global variable에 값을 할당할려고 하면 Error가 발생된다.    # a global variable  var = 100  def increment():  var += 1 # global variable 업데이트 시도하기  increment() UnboundLocalError: local variable 'var' referenced before assignment   global variable을 업데이트하려고 시도했지만, local scope 내에서는 global variable을 선언할 수 없기 때문에, 파이썬에서는 var 이라는 동일한 이름으로 local variable을 새롭게 만들었다.\n  그리고, 이 과정에서 첫 번째 할당 var + 1 전에 local var을 사용하려고 시도한 걸 알았기 때문에 Error가 발생된다.\n  그러면 이렇게 코드를 다시 짜보자.\n  # a gloabl variable  var = 100  def func(): # the global varaible 참조한다.  print(var) 'var' # 동일한 이름으로 새로운 local variable을 정의한다.  var = 200  func() UnboundLocalError: local variable 'var' referenced before assignment   global variable을 출력한 후에 var을 업데이트 할 수 있다고 생각했겠지만, 다시 동일한 Error가 발생된다.\n  global variable을 업데이트한 것이 아닌 function의 body 부분에 있기 때문에 local variable를 새로 만든 것이다.\n   Python은 global variable과 동일한 이름으로 function body에 선언해도, local variable로 인식한다.\n 1.10 LEGB rules: summary # This area is the global or module scope  number = 100  def outer_func():   # This block is the local scope of outer_func()   # It's also the enclosing scope of inner_func()  def inner_func():   # This block is the local scope of inner_func()  print(number)   inner_func()  outer_func() 100  Inside inner_func(): local scope 이지만, number variable는 존재하지 않는다. Inside outer_func(): the enclosing scope 이다. number variable이 정의되지 않았다. In the module scope: the global scope 이다. number variable을 찾을 수 있어서 출력할 수 있다. 만약 number variable이 the global scope에서 정의되지 않는다면, 파이썬은 built-in scope에서 찾을 것이다.  1.11 Local variable 또는 global variable 찾아보기  locals() method를 통해서, globals() method를 통해서 지역 변수만, 또는 전역 변수만 출력할 수 있다. 먼저 locals()에 대해 알아보자.   def func(var):  x = 10  def printer():  print('Ex  5', \"Printer Func Inner\")  print('Func Inner', locals())  func('Hi') Func Inner {'var': 'Hi', 'x': 10, 'printer': .printer at 0x000001D53343FDC0}  func() 함수를 호출하기 위해 인자로 넘겼던 ‘Hi’ 또한 지역변수임을 알 수 있다. enclosing scope에 있는 것 또한 local variable로 확인할 수 있다. outer function의 local scope에 정의했기 때문에 printer 또한 지역 변수로 확인할 수 있다.   그러면 다음으로 globals()에 대해 알아보자. globals는 이 코드를 실행할 때 입력한 모든 전역 변수가 입력되기 때문에, 다음과 같이 하여 알아본다. globals()는 global 영역에 변수를 입력할 때 호출된다.   print('Ex ', globals()) Ex7  {.....}  globals()['text_variable'] = 100  print('Ex ', globals()) Ex7  {'test_variable': 100}  globals()를 사용한 변수 자동화 생성: 지역 - 전역 변수로 작성한다.   for i in range(1, 6):  for k in range(1, 6):  globals()['plus_{}_{}'.format(i, k)] = i + k  print(globals()) {'plus_1_1': 2, 'plus_1_2': 3, 'plus_1_3': 4, 'plus_1_4': 5, 'plus_1_5': 6, 'plus_2_1': 3, 'plus_2_2': 4, 'plus_2_3': 5, 'plus_2_4': 6, 'plus_2_5': 7, 'plus_3_1': 4, 'plus_3_2': 5, 'plus_3_3': 6, 'plus_3_4': 7, 'plus_3_5': 8, 'plus_4_1': 5, 'plus_4_2': 6, 'plus_4_3': 7, 'plus_4_4': 8, 'plus_4_5': 9, 'plus_5_1': 6, 'plus_5_2': 7, 'plus_5_3': 8, 'plus_5_4': 9, 'plus_5_5': 10}  rint(plus_3_5) 8  print(plus_5_5) 10 1.12 LEGB rules: Built-in scope  Built-in scope은 builtins 라 불리는 표준 라이브러리 모듈로서 실행되는 특별한 파이썬 scope이다. 파이썬은 LEGB 에서 마지막으로 built-in을 찾는다. 이 scope에서는 어느 모듈이든지 import할 필요 없이 names을 사용할 수 있다. builtins 안에 있는 name들은 언제나 Python의 global scope에, __builtins__로 담겨진다. 밑에 예제를 보자.   dir() ['__annotations__', '__builtins__',..., '__package__', '__spec__']  dir(__builtins__) ['ArithmeticError', 'AssertionError',..., 'tuple', 'type', 'vars', 'zip']  dir()의 첫 호출에서 __builtins__을 확인할 수 있다. 그리고 __builtins__를 dir로 내부를 들여다보면, 파이썬의 built-in names의 전체 목록을 얻을 수 있다.   또 한 가지 특징은 global scope에서 어떠한 built-in names이든 오버라이드할 수 있다. 하지만 우연히 또는 부주의하게 이렇게 오버라이드가 된다면 위험하며, bugs를 찾기 어렵다. 그래서 이런 종류의 실행은 최대한 피하는 게 낫다.  # a built-in fuction의 표준 사용  abs(-15) 15 # global scope에서 built-in name을 재정의한다.  abs = 20  abs(-15) TypeError: 'int' object is not callable  del abs  abs(-15) 15 1.13 LEGB rules: final summary  From: Python Scope \u0026 the LEGB rule: Resolving Names in Your code   2. Python memory structure 2.1 코드 영역  실행할 프로그램의 코드가 저장되는 영역 (text 영역이라고도 한다)\n  lifetime: 프로그램이 시작하고, 끝날 때까지 메모리에 계속 남아 있는다.  2.2 데이터 영역  프로그램의 global variable과 정적(static) variable가 저장되는 영역\n  프로그램이 시작하고, 끝날 때까지 메모리에 계속 남아 있는다.  2.3 Stack   데이터를 임시 저장할 때 사용하는 자료구조로, 데이터의 입력과 출력 순서는 후입선출(Last In First Out, LIFO) 방식 loca var. 와 parameter var.가 저장된다.    push(푸쉬): stack에 데이터를 넣는 작업 pop(팝):stack에서 데이터를 꺼내는 작업 데이터를 넣고 꺼내는 작업에서 윗 부분을 top, 아랫 부분을 bottom 이라 한다.   stack 영역은 함수의 호출과 함께 생성되고, 함수의 호출이 완료되면 소멸한다. 스택 프레임(stack frame): 스택 영역에 저장되는 함수의 호출 정보 메모리의 높은 주소에서 낮은 주소의 방향으로 할당된다. 한계가 있어서, 한계를 초과하도록 삽입할 수 없다. Stack overflow: 함수는 변수를 저장하기 위해 stack을 만드는데, 만들어진 stack이 메모리 용량을 넘어서면 Stack overflow가 발생한다.  2.2 Heap  사용자가 직접 관리할수 잇는 영역으로, 객체가 생성된다.\n  사용자에 의해 메모리 공간이 동적으로 할당되고, 해제된다. heap 영역은 런타임 시에 크기가 결정된다 (메모리가 할당된다) 메모리의 낮은 주소에서 높은 주소로 할당된다.   Reference  파이썬 프로그래밍 기초 - 지역 변수와 전역 변수 Python-course.eu: Namespaces 스코핑 룰(Scoping rule) 자료구조와 함께 배우는 알고리즘 입문 파이썬편 Python Scope \u0026 the LEGB rule: Resolving Names in Your code  ","wordCount":"1749","inLanguage":"en","datePublished":"2022-03-27T23:53:06+09:00","dateModified":"2022-03-27T23:53:06+09:00","author":{"@type":"Person","name":"Jeha00"},"mainEntityOfPage":{"@type":"WebPage","@id":"http://jeha00.github.io/post/python_basic/python_basic_32_legb_rules/"},"publisher":{"@type":"Organization","name":"Jeha00 DevLog","logo":{"@type":"ImageObject","url":"http://jeha00.github.io/favicon.ico"}}}</script>
</head>
<body id=top>
<script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add('dark'):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove('dark'):window.matchMedia('(prefers-color-scheme: dark)').matches&&document.body.classList.add('dark')</script>
<header class=header>
<nav class=nav>
<div class=logo>
<a href=http://jeha00.github.io/ accesskey=h title="Jeha00 (Alt + H)">Jeha00</a>
<span class=logo-switches>
<button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg>
</button>
</span>
</div>
<ul id=menu>
<li>
<a href=http://jeha00.github.io/archives/ title=Archive>
<span>Archive</span>
</a>
</li>
<li>
<a href=http://jeha00.github.io/categories/ title=Categories>
<span>Categories</span>
</a>
</li>
<li>
<a href=http://jeha00.github.io/tags/ title=Tags>
<span>Tags</span>
</a>
</li>
<li>
<a href=http://jeha00.github.io/search/ title="Search (Alt + /)" accesskey=/>
<span>Search</span>
</a>
</li>
</ul>
</nav>
</header>
<main class=main>
<article class=post-single>
<header class=post-header>
<div class=breadcrumbs><a href=http://jeha00.github.io/>Home</a>&nbsp;»&nbsp;<a href=http://jeha00.github.io/post/>Posts</a></div>
<h1 class=post-title>
[TIL] Python basic 32: LEGB rules and Memory structures
</h1>
<div class=post-meta><span title="2022-03-27 23:53:06 +0900 KST">March 27, 2022</span>&nbsp;·&nbsp;9 min&nbsp;·&nbsp;Jeha00&nbsp;|&nbsp;<a href=https://github.com/JeHa00/blog/content/post/Python_basic/Python_basic_32_LEGB_rules.md rel="noopener noreferrer" target=_blank>Suggest Changes</a>
</div>
</header> <div class=toc>
<details>
<summary accesskey=c title="(Alt + C)">
<span class=details>Table of Contents</span>
</summary>
<div class=inner><ul>
<li>
<a href=#intro aria-label=Intro>Intro</a></li>
<li>
<a href=#1legb-rulesscoping-rules aria-label="1.LEGB rules(Scoping rules)">1.LEGB rules(Scoping rules)</a><ul>
<li>
<a href=#11-scope%ec%9d%98-%ec%9d%bc%eb%b0%98%ec%a0%81%ec%9d%b8-%ec%a2%85%eb%a5%98--2%ea%b0%80%ec%a7%80 aria-label="1.1 Scope의 일반적인 종류 : 2가지">1.1 Scope의 일반적인 종류 : 2가지</a></li>
<li>
<a href=#12-%ec%b4%88%ea%b8%b0-scope%ec%9d%98-%eb%b6%80%ec%9e%ac%eb%a1%9c-%ec%9d%b8%ed%95%9c-%eb%ac%b8%ec%a0%9c aria-label="1.2 초기 Scope의 부재로 인한 문제">1.2 초기 Scope의 부재로 인한 문제</a></li>
<li>
<a href=#13-%ed%8c%8c%ec%9d%b4%ec%8d%ac%ec%9d%98-%ec%9d%b4%eb%a6%84name%ea%b3%bc-%eb%b2%94%ec%9c%84scope%eb%93%a4 aria-label="1.3 파이썬의 이름(name)과 범위(scope)들">1.3 파이썬의 이름(name)과 범위(scope)들</a></li>
<li>
<a href=#14-assignment-operations%ec%99%80-reference-operations%ec%9d%98-%ec%b0%a8%ec%9d%b4 aria-label="1.4 assignment operations와 reference operations의 차이">1.4 assignment operations와 reference operations의 차이</a></li>
<li>
<a href=#15-python-scope%ec%99%80-namespace%ec%9d%98-%ea%b4%80%ea%b3%84 aria-label="1.5 Python scope와 namespace의 관계">1.5 Python scope와 namespace의 관계</a></li>
<li>
<a href=#16-python%ec%9d%b4-name%ec%9d%84-%ec%b0%be%eb%8a%94-%ea%b7%9c%ec%b9%99-legb-rules aria-label="1.6 Python이 name을 찾는 규칙: LEGB rules">1.6 Python이 name을 찾는 규칙: LEGB rules</a></li>
<li>
<a href=#17-legb-rules-the-local-scope aria-label="1.7 LEGB rules: The Local Scope">1.7 LEGB rules: The Local Scope</a></li>
<li>
<a href=#18-legb-rules-the-enclosing-scope-nested-functions aria-label="1.8 LEGB rules: The Enclosing Scope (Nested Functions)">1.8 LEGB rules: The Enclosing Scope (Nested Functions)</a></li>
<li>
<a href=#19-legb-rules-modules---the-global-scope aria-label="1.9 LEGB rules: Modules - The Global Scope">1.9 LEGB rules: Modules - The Global Scope</a></li>
<li>
<a href=#110-legb-rules-summary aria-label="1.10 LEGB rules: summary">1.10 LEGB rules: summary</a></li>
<li>
<a href=#111-local-variable-%eb%98%90%eb%8a%94-global-variable-%ec%b0%be%ec%95%84%eb%b3%b4%ea%b8%b0 aria-label="1.11 Local variable 또는 global variable 찾아보기">1.11 Local variable 또는 global variable 찾아보기</a></li>
<li>
<a href=#112-legb-rules-built-in-scope aria-label="1.12 LEGB rules: Built-in scope">1.12 LEGB rules: Built-in scope</a></li>
<li>
<a href=#113-legb-rules-final-summary aria-label="1.13 LEGB rules: final summary">1.13 LEGB rules: final summary</a></li></ul>
</li>
<li>
<a href=#2-python-memory-structure aria-label="2. Python memory structure">2. Python memory structure</a><ul>
<li>
<a href=#21-%ec%bd%94%eb%93%9c-%ec%98%81%ec%97%ad aria-label="2.1 코드 영역">2.1 코드 영역</a></li>
<li>
<a href=#22-%eb%8d%b0%ec%9d%b4%ed%84%b0-%ec%98%81%ec%97%ad aria-label="2.2 데이터 영역">2.2 데이터 영역</a></li>
<li>
<a href=#23-stack aria-label="2.3 Stack">2.3 Stack</a></li>
<li>
<a href=#22-heap aria-label="2.2 Heap">2.2 Heap</a></li></ul>
</li>
<li>
<a href=#reference aria-label=Reference>Reference</a>
</li>
</ul>
</div>
</details>
</div>
<div class=post-content><h1 id=intro>Intro<a hidden class=anchor aria-hidden=true href=#intro>#</a></h1>
<ul>
<li><code>coroutin</code>을 공부하면서 global variable과 local variable에 대해서 기본적인 의미만 알았지만,</li>
<li>이것이 Scoping Rule과 연관이 되어있다는 것과,stack과 heap이라는 데이터 임시 저장 자료 구조와 연관된 걸 몰랐다.</li>
<li>그래서 <code>Scoping Rule</code>, <code>Stack</code> 그리고, <code>Heap</code>에 대해 알아보겠다.</li>
</ul>
<hr>
<h1 id=1legb-rulesscoping-rules>1.LEGB rules(Scoping rules)<a hidden class=anchor aria-hidden=true href=#1legb-rulesscoping-rules>#</a></h1>
<blockquote>
<p>변수(variable)의 생존 범위(lifetime)에 관련된 규칙</p>
</blockquote>
<ul>
<li>Python scope 개념을 알아야 하는 이유:
<ul>
<li>신뢰성 있고, 유지보수성이 좋은 프로그램을 작성할 수 있다.</li>
<li>name 충돌을 방지할 수 있고, 버그를 줄일 수 있다.</li>
<li>이와 관련된 tool인 <code>Closure</code>에 대해 알 수 있다.</li>
</ul>
</li>
</ul>
<h2 id=11-scope의-일반적인-종류--2가지>1.1 Scope의 일반적인 종류 : 2가지<a hidden class=anchor aria-hidden=true href=#11-scope의-일반적인-종류--2가지>#</a></h2>
<ul>
<li><strong>global</strong> scope
<ul>
<li>이 scope에서 정의한 name은 모든 코드에서 사용할 수 있다.</li>
</ul>
</li>
<li><strong>local</strong> scope
<ul>
<li>이 scope에서 정의한 name은 범위 내의 코드에서만 사용할 수 있거나 볼 수 있다.</li>
</ul>
</li>
</ul>
<blockquote>
<ul>
<li>name: 변수, 상수, 함수, 클래스 등등의 식별자(identifier)를 참조하는 것으로, 구분하기 위해 존재한다.</li>
</ul>
</blockquote>
<h2 id=12-초기-scope의-부재로-인한-문제>1.2 초기 Scope의 부재로 인한 문제<a hidden class=anchor aria-hidden=true href=#12-초기-scope의-부재로-인한-문제>#</a></h2>
<ul>
<li>초기 프로그래밍은 <strong>global</strong>만 있었기 때문에,</li>
<li>변수를 수정해야할 때 모든 코드를 동시에 염두에 둬야했다.</li>
<li>그래서 이런 문제를 피하기 위해 <strong>scope</strong>을 사용했다.</li>
<li>scope을 사용한 후, 프로그램의 어디에서든지 그 scope에 있는 변수들에 함부로 접근할 수 없다. (<em>out of scope</em>)</li>
<li>name들의 scope은 이 name들을 정의한 코드의 block scope과 동일하다. (<em>in scope</em>)</li>
</ul>
<h2 id=13-파이썬의-이름name과-범위scope들>1.3 파이썬의 이름(name)과 범위(scope)들<a hidden class=anchor aria-hidden=true href=#13-파이썬의-이름name과-범위scope들>#</a></h2>
<ul>
<li>파이썬에서의 변수들에 값이 할당될 때, 즉 파이썬 names을 다음과 같은 방법들로 만들 때 변수들은 존재하게 된다.
<ul>
<li>변수(variable): 변수에 값을 할당하면, 변수는 만들어진다.</li>
<li>function , classes: 예약어 <code>def</code>, <code>classes</code>를 사용하여 정의하면 이용할 수 있다.</li>
<li>modules: <code>import</code>하여 사용할 수 있다.</li>
</ul>
</li>
</ul>
<h2 id=14-assignment-operations와-reference-operations의-차이>1.4 assignment operations와 reference operations의 차이<a hidden class=anchor aria-hidden=true href=#14-assignment-operations와-reference-operations의-차이>#</a></h2>
<ul>
<li>reference operations
<ul>
<li>name을 <strong><em>&lsquo;참조&rsquo;</em></strong> 한다는 건, name에 담겨진 content or value를 <strong><em>&lsquo;단지 가져온다&rsquo;</em></strong></li>
</ul>
</li>
<li>assignment operations
<ul>
<li>name을 <strong><em>&lsquo;할당&rsquo;</em></strong> 한다는 건, name을 <strong><em>&lsquo;새롭게&rsquo;</em></strong> 만들거나, <strong><em>&lsquo;수정&rsquo;</em></strong> 한다</li>
</ul>
</li>
<li>할당한다는 건 특정 scope이 결정된다는 걸 말한다.</li>
</ul>
<h2 id=15-python-scope와-namespace의-관계>1.5 Python scope와 namespace의 관계<a hidden class=anchor aria-hidden=true href=#15-python-scope와-namespace의-관계>#</a></h2>
<blockquote>
<p><strong>Namespace</strong> : python의 name이 dictionary data type으로 구현된 것</p>
</blockquote>
<ul>
<li>
<p>dictionary가 Python이 name을 저장하는 구체적인 원리다.</p>
</li>
<li>
<p>Namespace는 또한 <code>__dir__</code> 명령어에 저장되어 있다.</p>
</li>
<li>
<p>namespace는 각각 다른 <code>수명 시간(life time)</code>을 가지고 있다.</p>
<ul>
<li>
<p>왜냐하면 각각 다른 지점에서 만들어지기 때문이다.</p>
</li>
<li>
<p>from <a href=https://python-course.eu/python-tutorial/namespaces.php>Python-course.eu: Namespaces</a></p>
</li>
</ul>
</li>
<li>
<p>즉, <strong><code>__dir__</code>은 Namespace를 확인할 수 있는 명령어이고, 할당된 name이 가지는 scope을 보여준다.</strong></p>
<ul>
<li>
<p><code>.__dict__.keys()</code> 로 key value로 indexing하여 확인할 수 있다.</p>
</li>
<li>
<p>python은 name의 존재유무를 확인하기 위해서, 여러 scope levels(or namespace)를 찾아본다.</p>
</li>
<li>
<p>찾는 순서는 다음과 같다.</p>
<ul>
<li>local namespace -> global namespace -> global or module namespace -> built-in namespace</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id=16-python이-name을-찾는-규칙-legb-rules>1.6 Python이 name을 찾는 규칙: LEGB rules<a hidden class=anchor aria-hidden=true href=#16-python이-name을-찾는-규칙-legb-rules>#</a></h2>
<ul>
<li>
<p>local namespace -> enclosing namespace -> global(or module) namespace-> built-in scope namespace 순서로 주어진 name을 파이썬이 찾는다.</p>
</li>
<li>
<p><strong>Local(or function) scope</strong>: Python function의 body 또는 code block 부분이 local scope</p>
</li>
</ul>
<blockquote>
<p>지역 함수 내에 로직을 해결하는 값을 사용한다.</p>
</blockquote>
<ul>
<li>
<p>fuction 내에서 정의한 name들만 포함한다.</p>
</li>
<li>
<p>이 <code>function의 코드에서만</code> local scope에 있는 name을 확인할 수 있다.</p>
</li>
<li>
<p>lifetime of a local namespace: 할당된 function이 종료되면 끝난다.</p>
</li>
<li>
<p><strong>Enclosing(or nonlocal) scope</strong>: 중첩함수(nested functions)를 위해서만 존재하는 scope</p>
<ul>
<li>enclosing function 안에서 정의된 names만 포함한다.</li>
<li>이 <code>enclosing function의 코드에서만</code> enclosing scope에 있는 name을 확인할 수 있다.</li>
</ul>
</li>
<li>
<p><strong>Global(or module) scope</strong>: Python program, script, module 안에서 Top level의 scope</p>
</li>
</ul>
<blockquote>
<p>이 scope에는 주로 변하지 않는 고정값을 사용한다.</p>
</blockquote>
<ul>
<li>
<p>프로그램 또는 모듈에서 <code>최고 수준으로(Top level)</code> 정의한 이름들을 포함한다.</p>
</li>
<li>
<p><code>어느 코드에서든지</code> Global scope에 있는 name을 확인할 수 있다.</p>
<ul>
<li><a href=https://jeha00.github.io/post/python_basic/python_basic_23_ifnamemain/#22-top-level-%EC%9D%B4%EB%9E%80>Top level이란??</a></li>
</ul>
</li>
<li>
<p>lifetime of a module namespace: 일반적으로 script가 끝날 때까지만 지속된다.</p>
</li>
<li>
<p><strong>Built-in scope</strong>: script를 run할 때마다 만들어지는 특별한 scope</p>
<ul>
<li><code>Python 안에 내장된</code> 예약어들, functions들 등등의 name을 포함한다.</li>
<li>이 scope 또한 Global scope처럼 <code>어느 코드에서든지</code> name을 확인한다.</li>
<li>Built-in namespace는 interpreter가 시작되면 만들어지고, 절대로 삭제되지 않는다.</li>
</ul>
</li>
</ul>
<h2 id=17-legb-rules-the-local-scope>1.7 LEGB rules: The Local Scope<a hidden class=anchor aria-hidden=true href=#17-legb-rules-the-local-scope>#</a></h2>
<ul>
<li>그러면 code를 보면 이해해보자.</li>
</ul>
<div class=highlight><pre tabindex=0 style=color:#272822;background-color:#fafafa;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yml data-lang=yml><span style=color:#f92672>&gt; def square(base)</span><span style=color:#111>:</span>
<span style=color:#ae81ff>&gt;   result = base ** 2</span>
<span style=color:#ae81ff>&gt;   print(f&#39;The square of {base} is : {result}&#39;)</span>

<span style=color:#ae81ff>&gt; square(10)</span>
<span style=color:#f92672>The square of 10 is </span><span style=color:#111>:</span> <span style=color:#ae81ff>100</span>

<span style=color:#ae81ff>&gt; result</span>
<span style=color:#f92672>NameError</span><span style=color:#111>:</span> <span style=color:#ae81ff>name &#39;result&#39; is not defined</span>

<span style=color:#ae81ff>&gt; base</span>
<span style=color:#f92672>NameError</span><span style=color:#111>:</span> <span style=color:#ae81ff>name &#39;base&#39; is not defined</span>
</code></pre></div><ul>
<li>
<p>위 코드에 대해 알아보자.</p>
<ul>
<li>square fuction을 호출할 때, 파이썬은 base와 result를 포함하는 local scope을 만든다.</li>
<li><code>square(10)</code>으로 호출할 때, base에는 10을 result에는 100을 취한다.</li>
<li>또 다시 호출할 때는 첫 번째 호출 시 취한 값들은 기억하지 않는다.</li>
<li><code>result</code>와 <code>base</code>는 <code>square()</code> 호출에 의해 만들어진 <code>local scope</code>에만 존재한다.</li>
<li>그래서 <code>square</code> fuction 호출 후, 접근한다면 <code>NameError</code>을 얻는 것이다.</li>
</ul>
</li>
<li>
<p>그러면 추가로 local scope에 동일한 변수 이름을 가진 fuction을 정의해보자.</p>
</li>
</ul>
<div class=highlight><pre tabindex=0 style=color:#272822;background-color:#fafafa;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yml data-lang=yml><span style=color:#f92672>&gt; def cube(base)</span><span style=color:#111>:</span>
<span style=color:#ae81ff>&gt;        result = base ** 3</span>
<span style=color:#ae81ff>&gt;        print(f&#39;The cube of {base} is : {result}&#39;)</span>

<span style=color:#ae81ff>&gt; cube(30)</span>
<span style=color:#f92672>The cube of 30 is </span><span style=color:#111>:</span> <span style=color:#ae81ff>27000</span>
</code></pre></div><ul>
<li>local scope에 동일한 변수이름을 사용했지만, 프로그램 충돌이 일어나지 않았다.</li>
<li>왜냐하면 <code>local scope</code>을 사용했기 때문이다.</li>
<li><code>local scope</code>에만 살아있는 변수를 <code>local variable</code>이라 한다.</li>
<li>함수 실행이 끝나면 local scope에서 벗어나기 때문에 <code>local variable</code>의 생명력은 끝난다.</li>
<li>이러한 장점 때문에, 디버깅과 수정이 쉽고 가독성이 좋아진다.</li>
</ul>
<h2 id=18-legb-rules-the-enclosing-scope-nested-functions>1.8 LEGB rules: The Enclosing Scope (Nested Functions)<a hidden class=anchor aria-hidden=true href=#18-legb-rules-the-enclosing-scope-nested-functions>#</a></h2>
<div class=highlight><pre tabindex=0 style=color:#272822;background-color:#fafafa;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yml data-lang=yml><span style=color:#f92672>&gt;  def outer_func()</span><span style=color:#111>:</span>
<span style=color:#ae81ff>&gt;    </span> <span style=color:#75715e># 이 block은 외부 함수(outer_func)의 local scope이면서</span>
<span style=color:#ae81ff>&gt;    </span> <span style=color:#75715e># 내부 함수(inner_func)의 enclosing scope이기도 하다.</span>
<span style=color:#ae81ff>&gt;     var = 100</span>
<span style=color:#f92672>&gt;     def inner_func()</span><span style=color:#111>:</span>
<span style=color:#f92672>&gt;         print(f&#39;Printing var from inner_func() </span><span style=color:#111>:</span> {<span style=color:#ae81ff>var}&#39;)</span>
<span style=color:#ae81ff>&gt;     inner_func()</span>
<span style=color:#f92672>&gt;     print(f&#39;Printing var from outer_func() </span><span style=color:#111>:</span> {<span style=color:#ae81ff>var}&#39;)</span>

<span style=color:#ae81ff>&gt; outer_func()</span>
<span style=color:#f92672>Printing var from inner_func()</span><span style=color:#111>:</span> <span style=color:#ae81ff>100</span>
<span style=color:#f92672>Printing var from outer_func()</span><span style=color:#111>:</span> <span style=color:#ae81ff>100</span>

<span style=color:#ae81ff>&gt; inner_func()</span>
<span style=color:#f92672>NameError</span><span style=color:#111>:</span> <span style=color:#ae81ff>name &#39;inner_func&#39; is not defined</span>
</code></pre></div><ul>
<li><code>outer_func()</code>을 호출할 때, <code>outer_func()</code>의 local scope이 만들어진다.</li>
<li>이 scope은 동시에 <code>inner_func()</code>의 <code>enclosing scope</code>이라고도 한다.
<ul>
<li><code>global scope</code>과 <code>local scope</code> 둘 다 아니고, 이 사이에 놓여있는 특별한 scope을 의미.</li>
</ul>
</li>
<li>또한, <code>inner_func()</code>은 enclosing function인 outer_func이 실행되는 동안에만 유지되는 일시적인 함수다. 즉, <code>outer_func()</code>의 code에서만 <code>inner_func()</code>을 찾을 수 있다.</li>
</ul>
<h2 id=19-legb-rules-modules---the-global-scope>1.9 LEGB rules: Modules - The Global Scope<a hidden class=anchor aria-hidden=true href=#19-legb-rules-modules---the-global-scope>#</a></h2>
<ul>
<li>
<ol>
<li>프로그램을 실행한 순간부터 <code>global scope</code>에 있는 것이다.</li>
</ol>
</li>
<li>
<ol start=2>
<li>이 <code>global scope</code>은 module file과 깊은 연관이 있기 때문에, <code>module scope</code>이라 한다.</li>
</ol>
</li>
<li>
<ol start=3>
<li>그리고 현재 실행되는 script 또는 module이 entry point 역할을 한다면, 이 시점부터 scope of <code>__main__</code>이 된다.</li>
</ol>
</li>
<li>
<ol start=4>
<li>namespace를 확인하기 위해서 <code>dir()</code>을 사용할 때, 아무런 인자 없이 사용하면 <code>main global Python scope</code>에서 이용가능한 name list를 얻는다.</li>
</ol>
</li>
<li>
<ol start=5>
<li>프로그램 실행할 때 단 하나의 <code>global Python scope</code>만이 존재한다. 그리고, 프로그램 실행이 끝나야 scope이 종료된다.</li>
</ol>
</li>
<li>
<ol start=6>
<li>local scope에 있는 global 변수를 참조하거나 접근할 수 있다.</li>
</ol>
<ul>
<li>하지만, local scope에서 global variable에 값을 할당할려고 하면 Error가 발생된다.</li>
</ul>
</li>
</ul>
<div class=highlight><pre tabindex=0 style=color:#272822;background-color:#fafafa;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yml data-lang=yml><span style=color:#75715e># a global variable</span>
<span style=color:#ae81ff>&gt; var = 100</span>

<span style=color:#f92672>&gt; def increment()</span><span style=color:#111>:</span>
<span style=color:#ae81ff>&gt;   var += 1</span> <span style=color:#75715e># global variable 업데이트 시도하기</span>

<span style=color:#ae81ff>&gt; increment()</span>
<span style=color:#f92672>UnboundLocalError</span><span style=color:#111>:</span> <span style=color:#ae81ff>local variable &#39;var&#39; referenced before assignment</span>
</code></pre></div><ul>
<li>
<p>global variable을 업데이트하려고 시도했지만, local scope 내에서는 global variable을 선언할 수 없기 때문에, 파이썬에서는 <code>var</code> 이라는 동일한 이름으로 local variable을 새롭게 만들었다.</p>
</li>
<li>
<p>그리고, 이 과정에서 첫 번째 할당 <code>var + 1</code> 전에 local var을 사용하려고 시도한 걸 알았기 때문에 Error가 발생된다.</p>
</li>
<li>
<p>그러면 이렇게 코드를 다시 짜보자.</p>
</li>
</ul>
<div class=highlight><pre tabindex=0 style=color:#272822;background-color:#fafafa;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yml data-lang=yml><span style=color:#75715e># a gloabl variable</span>
<span style=color:#ae81ff>&gt; var = 100</span>

<span style=color:#f92672>&gt; def func()</span><span style=color:#111>:</span>

<span style=color:#75715e># the global varaible 참조한다.</span>
<span style=color:#ae81ff>&gt;   print(var) &#39;var&#39;</span>

<span style=color:#75715e># 동일한 이름으로 새로운 local variable을 정의한다.</span>
<span style=color:#ae81ff>&gt;   var = 200</span>

<span style=color:#ae81ff>&gt;&gt; func()</span>
<span style=color:#f92672>UnboundLocalError</span><span style=color:#111>:</span> <span style=color:#ae81ff>local variable &#39;var&#39; referenced before assignment</span>
</code></pre></div><ul>
<li>
<p>global variable을 출력한 후에 <code>var</code>을 업데이트 할 수 있다고 생각했겠지만, 다시 동일한 Error가 발생된다.</p>
</li>
<li>
<p>global variable을 업데이트한 것이 아닌 function의 body 부분에 있기 때문에 local variable를 새로 만든 것이다.</p>
</li>
</ul>
<blockquote>
<p>Python은 global variable과 동일한 이름으로 function body에 선언해도, local variable로 인식한다.</p>
</blockquote>
<h2 id=110-legb-rules-summary>1.10 LEGB rules: summary<a hidden class=anchor aria-hidden=true href=#110-legb-rules-summary>#</a></h2>
<div class=highlight><pre tabindex=0 style=color:#272822;background-color:#fafafa;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yml data-lang=yml><span style=color:#75715e># This area is the global or module scope</span>
<span style=color:#ae81ff>&gt; number = 100</span>
<span style=color:#f92672>&gt; def outer_func()</span><span style=color:#111>:</span>
<span style=color:#ae81ff>&gt;     </span> <span style=color:#75715e># This block is the local scope of outer_func()</span>
<span style=color:#ae81ff>&gt;     </span> <span style=color:#75715e># It&#39;s also the enclosing scope of inner_func()</span>
<span style=color:#f92672>&gt;     def inner_func()</span><span style=color:#111>:</span>
<span style=color:#ae81ff>&gt;        </span> <span style=color:#75715e># This block is the local scope of inner_func()</span>
<span style=color:#ae81ff>&gt;         print(number)</span>
<span style=color:#ae81ff>&gt;</span>
<span style=color:#ae81ff>&gt;     inner_func()</span>

<span style=color:#ae81ff>&gt; outer_func()</span>
<span style=color:#ae81ff>100</span>
</code></pre></div><ul>
<li>Inside inner_func(): local scope 이지만, number variable는 존재하지 않는다.</li>
<li>Inside outer_func(): the enclosing scope 이다. number variable이 정의되지 않았다.</li>
<li>In the module scope: the global scope 이다. number variable을 찾을 수 있어서 출력할 수 있다.</li>
<li>만약 number variable이 the global scope에서 정의되지 않는다면, 파이썬은 built-in scope에서 찾을 것이다.</li>
</ul>
<h2 id=111-local-variable-또는-global-variable-찾아보기>1.11 Local variable 또는 global variable 찾아보기<a hidden class=anchor aria-hidden=true href=#111-local-variable-또는-global-variable-찾아보기>#</a></h2>
<ul>
<li><code>locals()</code> method를 통해서, <code>globals()</code> method를 통해서 지역 변수만, 또는 전역 변수만 출력할 수 있다.</li>
<li>먼저 <code>locals()</code>에 대해 알아보자.</li>
</ul>
<div class=highlight><pre tabindex=0 style=color:#272822;background-color:#fafafa;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yml data-lang=yml><span style=color:#f92672>&gt; def func(var)</span><span style=color:#111>:</span>
<span style=color:#ae81ff>&gt;   x = 10</span>
<span style=color:#f92672>&gt;   def printer()</span><span style=color:#111>:</span>
<span style=color:#ae81ff>&gt;       print(&#39;Ex &gt; 5&#39;, &#34;Printer Func Inner&#34;)</span>
<span style=color:#ae81ff>&gt;   print(&#39;Func Inner&#39;, locals())</span>

<span style=color:#ae81ff>&gt; func(&#39;Hi&#39;)</span>
<span style=color:#ae81ff>Func Inner {&#39;var&#39;: &#39;Hi&#39;, &#39;x&#39;: 10, &#39;printer&#39;: &lt;function func.&lt;locals&gt;.printer at 0x000001D53343FDC0&gt;}</span>
</code></pre></div><ul>
<li><code>func()</code> 함수를 호출하기 위해 인자로 넘겼던 &lsquo;Hi&rsquo; 또한 지역변수임을 알 수 있다.</li>
<li>enclosing scope에 있는 것 또한 local variable로 확인할 수 있다.</li>
<li>outer function의 local scope에 정의했기 때문에 printer 또한 지역 변수로 확인할 수 있다.</li>
</ul>
<ul>
<li>그러면 다음으로 <code>globals()</code>에 대해 알아보자.</li>
<li>globals는 이 코드를 실행할 때 입력한 모든 전역 변수가 입력되기 때문에, 다음과 같이 하여 알아본다.</li>
<li><code>globals()</code>는 global 영역에 변수를 입력할 때 호출된다.</li>
</ul>
<div class=highlight><pre tabindex=0 style=color:#272822;background-color:#fafafa;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yml data-lang=yml><span style=color:#ae81ff>&gt; print(&#39;Ex &gt;&#39;, globals())</span>
<span style=color:#ae81ff>Ex7 &gt; {.....}</span>

<span style=color:#ae81ff>&gt; globals()[&#39;text_variable&#39;] = 100</span>
<span style=color:#ae81ff>&gt; print(&#39;Ex &gt;&#39;, globals())</span>
<span style=color:#ae81ff>Ex7 &gt; {&#39;test_variable&#39;: 100}</span>
</code></pre></div>
<ul>
<li><code>globals()</code>를 사용한 변수 자동화 생성: 지역 -> 전역 변수로 작성한다.</li>
</ul>
<div class=highlight><pre tabindex=0 style=color:#272822;background-color:#fafafa;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yml data-lang=yml><span style=color:#f92672>&gt; for i in range(1, 6)</span><span style=color:#111>:</span>
<span style=color:#f92672>&gt;   for k in range(1, 6)</span><span style=color:#111>:</span>
<span style=color:#ae81ff>&gt;       globals()[&#39;plus_{}_{}&#39;.format(i, k)] = i + k</span>

<span style=color:#ae81ff>&gt; print(globals())</span>
{<span style=color:#f92672>&#39;plus_1_1&#39;: 2, &#39;plus_1_2&#39;: 3, &#39;plus_1_3&#39;: 4, &#39;plus_1_4&#39;: 5, &#39;plus_1_5&#39;</span><span style=color:#111>:</span> <span style=color:#ae81ff>6</span><span style=color:#111>,</span>
<span style=color:#f92672>&#39;plus_2_1&#39;: 3, &#39;plus_2_2&#39;: 4, &#39;plus_2_3&#39;: 5, &#39;plus_2_4&#39;: 6, &#39;plus_2_5&#39;</span><span style=color:#111>:</span> <span style=color:#ae81ff>7</span><span style=color:#111>,</span>
<span style=color:#f92672>&#39;plus_3_1&#39;: 4, &#39;plus_3_2&#39;: 5, &#39;plus_3_3&#39;: 6, &#39;plus_3_4&#39;: 7, &#39;plus_3_5&#39;</span><span style=color:#111>:</span> <span style=color:#ae81ff>8</span><span style=color:#111>,</span>
<span style=color:#f92672>&#39;plus_4_1&#39;: 5, &#39;plus_4_2&#39;: 6, &#39;plus_4_3&#39;: 7, &#39;plus_4_4&#39;: 8, &#39;plus_4_5&#39;</span><span style=color:#111>:</span> <span style=color:#ae81ff>9</span><span style=color:#111>,</span>
<span style=color:#f92672>&#39;plus_5_1&#39;: 6, &#39;plus_5_2&#39;: 7, &#39;plus_5_3&#39;: 8, &#39;plus_5_4&#39;: 9, &#39;plus_5_5&#39;</span><span style=color:#111>:</span> <span style=color:#ae81ff>10</span>}

<span style=color:#ae81ff>&gt; rint(plus_3_5)</span>
<span style=color:#ae81ff>8</span>
<span style=color:#ae81ff>&gt; print(plus_5_5)</span>
<span style=color:#ae81ff>10</span>
</code></pre></div><h2 id=112-legb-rules-built-in-scope>1.12 LEGB rules: Built-in scope<a hidden class=anchor aria-hidden=true href=#112-legb-rules-built-in-scope>#</a></h2>
<ul>
<li>Built-in scope은 <code>builtins</code> 라 불리는 표준 라이브러리 모듈로서 실행되는 특별한 파이썬 scope이다.</li>
<li>파이썬은 LEGB 에서 마지막으로 built-in을 찾는다.</li>
<li>이 scope에서는 어느 모듈이든지 import할 필요 없이 names을 사용할 수 있다.</li>
<li><code>builtins</code> 안에 있는 name들은 언제나 Python의 global scope에, <code>__builtins__</code>로 담겨진다. 밑에 예제를 보자.</li>
</ul>
<div class=highlight><pre tabindex=0 style=color:#272822;background-color:#fafafa;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yml data-lang=yml><span style=color:#ae81ff>&gt; dir()</span>
<span style=color:#111>[</span><span style=color:#d88200>&#39;__annotations__&#39;</span><span style=color:#111>,</span> <span style=color:#d88200>&#39;__builtins__&#39;</span><span style=color:#111>,</span><span style=color:#ae81ff>..., &#39;__package__&#39;, &#39;__spec__&#39;]</span>

<span style=color:#ae81ff>&gt; dir(__builtins__)</span>
<span style=color:#111>[</span><span style=color:#d88200>&#39;ArithmeticError&#39;</span><span style=color:#111>,</span> <span style=color:#d88200>&#39;AssertionError&#39;</span><span style=color:#111>,</span><span style=color:#ae81ff>..., &#39;tuple&#39;, &#39;type&#39;, &#39;vars&#39;, &#39;zip&#39;]</span>
</code></pre></div><ul>
<li><code>dir()</code>의 첫 호출에서 <code>__builtins__</code>을 확인할 수 있다.</li>
<li>그리고 <code>__builtins__</code>를 dir로 내부를 들여다보면, 파이썬의 built-in names의 전체 목록을 얻을 수 있다.</li>
</ul>
<ul>
<li>또 한 가지 특징은 global scope에서 어떠한 built-in names이든 오버라이드할 수 있다.</li>
<li>하지만 우연히 또는 부주의하게 이렇게 오버라이드가 된다면 위험하며, bugs를 찾기 어렵다. 그래서 이런 종류의 실행은 최대한 피하는 게 낫다.</li>
</ul>
<div class=highlight><pre tabindex=0 style=color:#272822;background-color:#fafafa;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yml data-lang=yml><span style=color:#75715e># a built-in fuction의 표준 사용</span>
<span style=color:#ae81ff>&gt; abs(-15)</span>
<span style=color:#ae81ff>15</span>

<span style=color:#75715e># global scope에서 built-in name을 재정의한다.</span>
<span style=color:#ae81ff>&gt; abs = 20</span>

<span style=color:#ae81ff>&gt; abs(-15)</span>
<span style=color:#f92672>TypeError</span><span style=color:#111>:</span> <span style=color:#d88200>&#39;int&#39;</span> <span style=color:#ae81ff>object is not callable</span>

<span style=color:#ae81ff>&gt; del abs</span>
<span style=color:#ae81ff>&gt; abs(-15)</span>
<span style=color:#ae81ff>15</span>
</code></pre></div>
<h2 id=113-legb-rules-final-summary>1.13 LEGB rules: final summary<a hidden class=anchor aria-hidden=true href=#113-legb-rules-final-summary>#</a></h2>
<ul>
<li>From: <a href=https://realpython.com/python-scope-legb-rule/>Python Scope & the LEGB rule: Resolving Names in Your code</a></li>
</ul>
<hr>
<h1 id=2-python-memory-structure>2. Python memory structure<a hidden class=anchor aria-hidden=true href=#2-python-memory-structure>#</a></h1>
<h2 id=21-코드-영역>2.1 코드 영역<a hidden class=anchor aria-hidden=true href=#21-코드-영역>#</a></h2>
<blockquote>
<p><strong>실행할 프로그램의 코드가 저장</strong>되는 영역 (text 영역이라고도 한다)</p>
</blockquote>
<ul>
<li>lifetime: 프로그램이 시작하고, 끝날 때까지 메모리에 계속 남아 있는다.</li>
</ul>
<h2 id=22-데이터-영역>2.2 데이터 영역<a hidden class=anchor aria-hidden=true href=#22-데이터-영역>#</a></h2>
<blockquote>
<p>프로그램의 <strong>global variable과 정적(static) variable</strong>가 저장되는 영역</p>
</blockquote>
<ul>
<li>프로그램이 시작하고, 끝날 때까지 메모리에 계속 남아 있는다.</li>
</ul>
<h2 id=23-stack>2.3 Stack<a hidden class=anchor aria-hidden=true href=#23-stack>#</a></h2>
<blockquote>
<ul>
<li>데이터를 임시 저장할 때 사용하는 자료구조로, 데이터의 입력과 출력 순서는 <strong><em>후입선출(Last In First Out, LIFO)</em></strong> 방식</li>
<li>loca var. 와 parameter var.가 저장된다.</li>
</ul>
</blockquote>
<ul>
<li><strong><code>push(푸쉬)</code></strong>: stack에 데이터를 넣는 작업</li>
<li><strong><code>pop(팝)</code></strong>:stack에서 데이터를 꺼내는 작업</li>
<li>데이터를 넣고 꺼내는 작업에서 윗 부분을 <code>top</code>, 아랫 부분을 <code>bottom</code> 이라 한다.</li>
</ul>
<ul>
<li>stack 영역은 <code>함수의 호출과 함께 생성</code>되고, 함수의 호출이 완료되면 소멸한다.</li>
<li><code>스택 프레임(stack frame)</code>: 스택 영역에 저장되는 함수의 호출 정보</li>
<li>메모리의 높은 주소에서 낮은 주소의 방향으로 할당된다.</li>
<li>한계가 있어서, 한계를 초과하도록 삽입할 수 없다.</li>
<li>Stack overflow: 함수는 변수를 저장하기 위해 stack을 만드는데, 만들어진 stack이 메모리 용량을 넘어서면 <code>Stack overflow</code>가 발생한다.</li>
</ul>
<h2 id=22-heap>2.2 Heap<a hidden class=anchor aria-hidden=true href=#22-heap>#</a></h2>
<blockquote>
<p>사용자가 직접 관리할수 잇는 영역으로, 객체가 생성된다.</p>
</blockquote>
<ul>
<li>사용자에 의해 메모리 공간이 동적으로 할당되고, 해제된다.</li>
<li>heap 영역은 <code>런타임 시</code>에 크기가 결정된다 (메모리가 할당된다)</li>
<li>메모리의 낮은 주소에서 높은 주소로 할당된다.</li>
</ul>
<hr>
<h1 id=reference>Reference<a hidden class=anchor aria-hidden=true href=#reference>#</a></h1>
<ul>
<li><a href="https://www.youtube.com/watch?v=xNaBCSnm3Hg&list=PLUWNXmQtLdmDCRVur4eHjKhLZtipVexCE&index=13">파이썬 프로그래밍 기초 - 지역 변수와 전역 변수</a></li>
<li><a href=https://python-course.eu/python-tutorial/namespaces.php>Python-course.eu: Namespaces</a></li>
<li><a href=https://blog.hexabrain.net/283>스코핑 룰(Scoping rule)</a></li>
<li><a href=http://www.yes24.com/Product/Goods/91219874>자료구조와 함께 배우는 알고리즘 입문 파이썬편</a></li>
<li><a href=https://realpython.com/python-scope-legb-rule/>Python Scope & the LEGB rule: Resolving Names in Your code</a></li>
</ul>
</div>
<footer class=post-footer>
<ul class=post-tags>
<li><a href=http://jeha00.github.io/tags/til/>TIL</a></li>
<li><a href=http://jeha00.github.io/tags/python/>python</a></li>
</ul>
<nav class=paginav>
<a class=prev href=http://jeha00.github.io/post/python_basic/python_basic_33_closure/>
<span class=title>« Prev Page</span>
<br>
<span>[TIL] Python basic 33: Closure</span>
</a>
<a class=next href=http://jeha00.github.io/post/python_basic/python_basic_31_firstclass/>
<span class=title>Next Page »</span>
<br>
<span>[TIL] Python basic 31: First-class</span>
</a>
</nav>
<div class=share-buttons>
<a target=_blank rel="noopener noreferrer" aria-label="share [TIL] Python basic 32: LEGB rules and Memory structures on twitter" href="https://twitter.com/intent/tweet/?text=%5bTIL%5d%20Python%20basic%2032%3a%20LEGB%20rules%20and%20Memory%20structures&url=http%3a%2f%2fjeha00.github.io%2fpost%2fpython_basic%2fpython_basic_32_legb_rules%2f&hashtags=TIL%2cpython"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM195.519 424.544c135.939.0 210.268-112.643 210.268-210.268.0-3.218.0-6.437-.153-9.502 14.406-10.421 26.973-23.448 36.935-38.314-13.18 5.824-27.433 9.809-42.452 11.648 15.326-9.196 26.973-23.602 32.49-40.92-14.252 8.429-30.038 14.56-46.896 17.931-13.487-14.406-32.644-23.295-53.946-23.295-40.767.0-73.87 33.104-73.87 73.87.0 5.824.613 11.494 1.992 16.858-61.456-3.065-115.862-32.49-152.337-77.241-6.284 10.881-9.962 23.601-9.962 37.088.0 25.594 13.027 48.276 32.95 61.456-12.107-.307-23.448-3.678-33.41-9.196v.92c0 35.862 25.441 65.594 59.311 72.49-6.13 1.686-12.72 2.606-19.464 2.606-4.751.0-9.348-.46-13.946-1.38 9.349 29.426 36.628 50.728 68.965 51.341-25.287 19.771-57.164 31.571-91.8 31.571-5.977.0-11.801-.306-17.625-1.073 32.337 21.15 71.264 33.41 112.95 33.41z"/></svg>
</a>
<a target=_blank rel="noopener noreferrer" aria-label="share [TIL] Python basic 32: LEGB rules and Memory structures on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&url=http%3a%2f%2fjeha00.github.io%2fpost%2fpython_basic%2fpython_basic_32_legb_rules%2f&title=%5bTIL%5d%20Python%20basic%2032%3a%20LEGB%20rules%20and%20Memory%20structures&summary=%5bTIL%5d%20Python%20basic%2032%3a%20LEGB%20rules%20and%20Memory%20structures&source=http%3a%2f%2fjeha00.github.io%2fpost%2fpython_basic%2fpython_basic_32_legb_rules%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg>
</a>
<a target=_blank rel="noopener noreferrer" aria-label="share [TIL] Python basic 32: LEGB rules and Memory structures on reddit" href="https://reddit.com/submit?url=http%3a%2f%2fjeha00.github.io%2fpost%2fpython_basic%2fpython_basic_32_legb_rules%2f&title=%5bTIL%5d%20Python%20basic%2032%3a%20LEGB%20rules%20and%20Memory%20structures"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg>
</a>
<a target=_blank rel="noopener noreferrer" aria-label="share [TIL] Python basic 32: LEGB rules and Memory structures on facebook" href="https://facebook.com/sharer/sharer.php?u=http%3a%2f%2fjeha00.github.io%2fpost%2fpython_basic%2fpython_basic_32_legb_rules%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg>
</a>
<a target=_blank rel="noopener noreferrer" aria-label="share [TIL] Python basic 32: LEGB rules and Memory structures on whatsapp" href="https://api.whatsapp.com/send?text=%5bTIL%5d%20Python%20basic%2032%3a%20LEGB%20rules%20and%20Memory%20structures%20-%20http%3a%2f%2fjeha00.github.io%2fpost%2fpython_basic%2fpython_basic_32_legb_rules%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg>
</a>
<a target=_blank rel="noopener noreferrer" aria-label="share [TIL] Python basic 32: LEGB rules and Memory structures on telegram" href="https://telegram.me/share/url?text=%5bTIL%5d%20Python%20basic%2032%3a%20LEGB%20rules%20and%20Memory%20structures&url=http%3a%2f%2fjeha00.github.io%2fpost%2fpython_basic%2fpython_basic_32_legb_rules%2f"><svg viewBox="2 2 28 28"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg>
</a>
</div>
</footer><script src=https://utteranc.es/client.js repo=JeHa00/blog-comments issue-term=pathname theme=github-dark crossorigin=anonymous async></script>
</article>
</main>
<footer class=footer>
<span>&copy; 2022 <a href=http://jeha00.github.io/>Jeha00 DevLog</a></span>
<span>
Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a>
</span>
</footer>
<a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a>
<script>let menu=document.getElementById('menu');menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(a=>{a.addEventListener("click",function(b){b.preventDefault();var a=this.getAttribute("href").substr(1);window.matchMedia('(prefers-reduced-motion: reduce)').matches?document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView({behavior:"smooth"}),a==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${a}`)})})</script>
<script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script>
<script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove('dark'),localStorage.setItem("pref-theme",'light')):(document.body.classList.add('dark'),localStorage.setItem("pref-theme",'dark'))})</script>
</body>
</html>