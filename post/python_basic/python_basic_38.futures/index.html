<!doctype html><html lang=en dir=auto>
<head><meta charset=utf-8>
<meta http-equiv=x-ua-compatible content="IE=edge">
<meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no">
<meta name=robots content="index, follow">
<title>[TIL] Python basic 38: Futures | Jeha00 DevLog</title>
<meta name=keywords content="TIL,python">
<meta name=description content="인프런 파이썬 level 4 과정의 기반으로 대략적으로 학습하는 내용이다. 구체적으로 Synchro와 Asynchro가 각각 무엇을 의미하는지, threadpool이란 무엇인지, concurrent.futures package에서 wait과 as_completed module에 대해 학습해본다.">
<meta name=author content="Jeha00">
<link rel=canonical href=http://jeha00.github.io/post/python_basic/python_basic_38.futures/>
<meta name=google-site-verification content="XYZabc">
<meta name=yandex-verification content="XYZabc">
<meta name=msvalidate.01 content="XYZabc">
<link crossorigin=anonymous href=/assets/css/stylesheet.min.1e44d58192cbf6d7a4eb649bc43dbc3d4cc432677e5d8adc69b08c34cbe461ac.css integrity="sha256-HkTVgZLL9tek62SbxD28PUzEMmd+XYrcabCMNMvkYaw=" rel="preload stylesheet" as=style>
<link rel=icon href=http://jeha00.github.io/favicon.ico>
<link rel=icon type=image/png sizes=16x16 href=http://jeha00.github.io/favicon-16x16.png>
<link rel=icon type=image/png sizes=32x32 href=http://jeha00.github.io/favicon-32x32.png>
<link rel=apple-touch-icon href=http://jeha00.github.io/apple-touch-icon.png>
<link rel=mask-icon href=http://jeha00.github.io/safari-pinned-tab.svg>
<meta name=theme-color content="#2e2e33">
<meta name=msapplication-TileColor content="#2e2e33">
<meta name=generator content="Hugo 0.92.1">
<noscript>
<style>#theme-toggle,.top-link{display:none}</style>
<style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style>
</noscript>
<script type=application/javascript>var doNotTrack=!1;doNotTrack||(function(a,e,f,g,b,c,d){a.GoogleAnalyticsObject=b,a[b]=a[b]||function(){(a[b].q=a[b].q||[]).push(arguments)},a[b].l=1*new Date,c=e.createElement(f),d=e.getElementsByTagName(f)[0],c.async=1,c.src=g,d.parentNode.insertBefore(c,d)}(window,document,'script','https://www.google-analytics.com/analytics.js','ga'),ga('create','UA-123-45','auto'),ga('send','pageview'))</script><meta property="og:title" content="[TIL] Python basic 38: Futures">
<meta property="og:description" content="인프런 파이썬 level 4 과정의 기반으로 대략적으로 학습하는 내용이다. 구체적으로 Synchro와 Asynchro가 각각 무엇을 의미하는지, threadpool이란 무엇인지, concurrent.futures package에서 wait과 as_completed module에 대해 학습해본다.">
<meta property="og:type" content="article">
<meta property="og:url" content="http://jeha00.github.io/post/python_basic/python_basic_38.futures/"><meta property="og:image" content="http://jeha00.github.io/47"><meta property="article:section" content="post">
<meta property="article:published_time" content="2022-04-06T21:34:38+09:00">
<meta property="article:modified_time" content="2022-04-06T21:34:38+09:00"><meta property="og:site_name" content="JeHa00 DevLog">
<meta name=twitter:card content="summary_large_image">
<meta name=twitter:image content="http://jeha00.github.io/47">
<meta name=twitter:title content="[TIL] Python basic 38: Futures">
<meta name=twitter:description content="인프런 파이썬 level 4 과정의 기반으로 대략적으로 학습하는 내용이다. 구체적으로 Synchro와 Asynchro가 각각 무엇을 의미하는지, threadpool이란 무엇인지, concurrent.futures package에서 wait과 as_completed module에 대해 학습해본다.">
<script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"http://jeha00.github.io/post/"},{"@type":"ListItem","position":2,"name":"[TIL] Python basic 38: Futures","item":"http://jeha00.github.io/post/python_basic/python_basic_38.futures/"}]}</script>
<script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"[TIL] Python basic 38: Futures","name":"[TIL] Python basic 38: Futures","description":"인프런 파이썬 level 4 과정의 기반으로 대략적으로 학습하는 내용이다. 구체적으로 Synchro와 Asynchro가 각각 무엇을 의미하는지, threadpool이란 무엇인지, concurrent.futures package에서 wait과 as_completed module에 대해 학습해본다.","keywords":["TIL","python"],"articleBody":"Intro  이번 내용은 파이썬 고급 과정 고수가 되는 파이썬 : 동시성과 병렬성 문법 배우기 Feat. 멀티스레딩 vs 멀티프로세싱 (Inflearn Original) 에서 자세히 배운다고 하여 깊이 있게 들어가진 않았다. 이런 게 있구나 정도로만 파악하자.   1. Synchronous VS Asynchronous   소제목에 있는 두 영단어는 접두어와 어원으로 분석하여 접근하면 쉽다.\n  syn는 ‘together’를, chrono는 ‘time’을 의미한다.\n  하지만 Asynchronous 는 접두어로 ‘a’가 붙었는데, 이는 부정의 의미를 가진다.\n  시간을 함께 맞추는 것 vs 시간을 함께 맞추지 않는 것의 의미로 해석할 수 있다.\n  Synchronous는 단어적 의미를 기반으로 바라보면 2가지 이상의 대상이 서로 시간을 맞춰 해동하는 걸 의미한다.\n A 작업이 끝난 후에야 B 작업이 시작되는 걸 말한다. 끝나고 나서 시작되는 것처럼 시간을 맞춘다.    Asynchronous는 서로 시간을 맞추지 않는 걸 의미한다.\n A에 작업을 조금 걸어넣고, B에도 조금 시작하여 동시성이 실행되는 걸 의미한다.     2. Blocking vs Non-Blocking   Blocking이란 직접 제어할 수 없는 대상의 작업이 끝날 때까지 제어권을 넘겨주지 않는 걸 말한다.\n 예) 호출 함수가 I/O 을 요청했을 때, 이 요청이 완료될까지 아무 일도 하지 못한 채 기다리는 걸 말한다.    Non-blocking이란 non이 붙여졌듯이 blocking의 반대 의미다.\n  요청이 완료될 때까지 기다릴 필요 없이 바로 자신의 작업을 할 수 있는 상태를 말한다.\n  blocking 현상으로 CPU 및 resource 낭비를 하고 있을 때, 동시성 활용 작업으로 낭비를 방지한다.\n  파이썬은 단일 쓰레드로 해도 충분히 빠르다.\n  특히, 비동기 작업과 적합한 프로그램일 경우, 압도적으로 성능이 향상된다.\n   3. GIL(Global Interface Lock)   GIL은 Python에만 존재하는 것으로, Global Interface Lock in CPython을 의미한다.\n  GIL은 두 개 이상의 thread가 동시에 실행될 때(context switching 상황) 하나의 자원에 액세스하는 경우, 문제점을 방지하기 위해 GIL을 실행하여 resource 전체에 lock을 건다.\n  그래서 multi-thread할 때, GIL 때문에 single-thread보다 느린 경우가 많다.\n  GIL을 우회하기 위해서는 반드시 multi-processing을 사용하거나 CPython을 사용하면 GIL이 걸리지 않는다.\n  하지만 이 때는 동기화를 직접해야 한다.\n   4. Concurrent.futures 4.1 Thread Pool이란??   server 요청 model에 Thread per request model 이다.\n 즉, 요청마다 새로운 thread를 할당하여 처리한다면, 요청이 들어올 때마다 thread를 생성하고 요청이 완료되면 thread를 삭제해야 한다.    이 방식의 문제는 요청마다 스레드 생성에 소요되는 시간 때문에, 요청 처리가 더 오래 걸린다.\n  만약 처리 속도 thread가 계속 생성되어, thread 수는 증가한다. 이에 따라 context switching이 더 자주 발생한다. CPU overhead 증가로 CPU time이 낭비된다. 결국, 어느 순간 서버 전체가 응답 불가능 한 상태에 빠진다. 또한, 메모리가 점점 고갈 된다.    그래서 미리 최대 몇 개의 thread 묶음을 만들어놓는다. 이를 thread pool이라 한다.\n API 요청이 들어오면 thread pool 안에 일이 없는 thread를 할당한다. 요청이 완료되면 thread는 삭제하지 않고, 이 pool에 다시 들어온다. 미리 thread를 여러 개 만들어 놓고 재사용하여 thread 생성 시간을 절약한다. 또한, 제한된 개수의 thread를 응용 하기 때문에, 무제한으로 생성되는 걸 방지한다.    Thread pool 사례: 여러 작업을 동시 처리해야할 때\n task를 subtask로 나뉘어서 동시에 처리할 때 순서 상관없이 동시실행이 가능한 task 처리할 때    Thread pool 사용 시, Tip\n thread pool에 몇 개의 thread를 만들어 두는 게 적절한가???  CPU의 core 개수와 task의 성향에 따라 다르다. CPU-bound task라면 코어 개수 만큼 혹은 그보다 몇 개 더 많은 정도 I/O-bound task라면 경험적으로 찾아야 한다.   thread pool에서 실행될 task 개수에 제한이 없다면, thread pool의 큐가 사이즈 제한이 있는지 반드시 확인할 것   큐에 요청이 무한정 쌓인다면??? 잠재적으로 메모리를 고갈시킬 수 있는 원인이 된다. 그래서 큐에 제한이 없다면 제한을 걸어야 한다.    process pool 또한, process를 미리 만들어두는 방식을 말한다.\n  python에서는 GIL 때문에 CPU-bound task를 실행할려면, 동시에 CPU에서 여러 프로세스가 실행될 수 없으므로 thread pool을 사용해야 한다.\n  4.2 concurrent.futures package   concurrent.futures package\n 비동기 실행을 위한 API를 고수준으로 작성하고, ‘사용하기 쉽도록 개선’하여 나온 것  전에는 ‘import processing’, ‘import thread’ 으로 따로 호출해서 사용했었지만, 지금은 multi-threading / multi-processing API가 통일되어 매우 사용하기 쉽다. 또한, low level로 하지 않아도 가능하다.   실행 중인 작업 취소, 완료 여부 체크, 타임아웃 옵션, 콜백 추가, 동기화 코드를 매우 쉽게 작성할 수 있다.    concurrent.futures.ProcessPoolExecutor 는 multiprocessing.Process와 동일한 역할을 한다.\n  하지만, concurrent.futures.ProcessPoolExecutor는 max_workers를 지정하여 fork할 process의 최대 갯수를 지정하는 게 가능하다.\n  process pool을 사용하여 호출을 비동기적으로 실행하는 method\n  ThreadPoolExecutor는 process pool이 아닌, thread pool을 사용한다.\n thread pool이란 미리 만들어 놓은 thread 집단을 말한다.     5. Exercise - PoolExecutor  concurrent.futures 사용법  ThreadPoolExecutor의 max_work 기본 값은 min(32, os.cpu_count() + 4)다.  이 기본값은 I/O 병목 작업을 위해 최소 5개의 작업자를 유지한다.   ProcessPoolExecutor의 max_work 기본 값은 기계의 프로세서 수를 기본값으로 사용한다. 아래 코드의 pattern을 외우자. map은 작업 순서를 유지하고, 즉시 실행한다.  4개를 동시에 시작해서 그 결과값을 받아온다. 그런데 4개 중 한 작업이 1시간이 걸린다면 이 한 시간을 계속 기다린다.       import os  import time # threading, multi-processing이 저수준으로 만들어져 있는 걸 사용한다.  from concurrent import futures # 1부터 각 성분값까지 합을 계산할 것이기 때문에, 4가지 작업을 동시에 실행한다. # 실무에서는 각 값에 자신이 만든 함수를 넣어 사용해도 된다.  WORK_LIST = [100000, 1000000, 10000000, 100000000] # 인자 n에 위 WORK_LIST의 성분 값들이 하나씩 넘어와서 합이 계산된다. # 그래서 총 동시에 4개가 실행된다. # 누적 합계 함수(generator)  def sum_generator(n):  return sum(n for n in range(1, n+1)) # worker의 수는 두 인수 중 작은 수로 한다. # worker를 몇 개 할지 모르면 운영체제한테 맡긴다.  def main1():  worker= min(10, len(WORK_LIST)) ## 시작시간 # time.time은 현재 시간을 나타낸다.  start_tm = time.time() ## 결과 건수 # with문으로 해야 열고 닫는 게 자동적으로 이뤄진다. # def main1 과의 차이점 (ThreadPoolExecutor)  with futures.ThreadPoolExecutor() as excutor:  result = excutor.map(sum_generator, WORK_LIST) ## 종료시간 # 현재 시간을 나타낸 거에, 시작 시간을 빼서 총 걸린 시간을 나타낸다.  end_tm = time.time() - start_tm ## 출력 포맷 # float 형 데이터 출력에 소수점 둘째짜리까지 출력한다.  msg = '\\n Result - {} Time : {:.2f}s'  print(msg.format(list(result), end_tm))  def main2():  worker= min(10, len(WORK_LIST))  start_tm = time.time() # def main2 와의 차이점 (ProcessPoolExcutor)  with futures.ProcessPoolExecutor() as excutor:  result = excutor.map(sum_generator, WORK_LIST)  end_tm = time.time() - start_tm  msg = '\\n Result - {} Time : {:.2f}s'  print(msg.format(list(result), end_tm)) ## 실행 # 진입점을 알려줘야, multi-processing이 실행될 때 작업을 할 수 있다.  if __name__ == '__main__':  main1()  main2() Result - [5000050000, 500000500000, 50000005000000, 5000000050000000] Time : 7.61s Result - [5000050000, 500000500000, 50000005000000, 5000000050000000] Time : 7.14s  ProcessPool로 실행했을 때의 결과가 더 빠르다는 걸 확인했다.   그러면 동기적으로 진행했을 때의 시간을 측정해보자.   WORK_LIST = [100000, 1000000, 10000000, 100000000] # 시작 시간  stm = time.time()  for i in WORK_LIST:  sum(n for n in range(1, i+1)) # 종료 시간  etm = time.time() - stm  print('total time - {:0.2f}s'.format(etm)) 8.43s  thread pool과 process pool을 사용하는 방법이 더 빠르다는 걸 알 수 있다.   6. Exercise - wait, as_completed  Exercise - PoolExecutor에서 한 예제는 총 4가지에 대한 합계를 구하는 동시성을 구현해보는 예제였다. 그러면 동시적으로 수행되는 각 작업이 성공했는지, 확인할 수도 있어야 하지 않을까?? 이를 확인하기 위해, wait과 as_completed module에 대해 먼저 알아보자.  6.1 wait  작업의 양이 작아서 금방 끝나서, 한 번에 다 끝난 다음에 작업을 하기 원할 때 wait을 사용한다.\n  각 작업이 정해진 시간(timeout)을 벗어나면 실패로 간주하고 중단시킨다. 완료된 작업들만 추출하고 싶으면 .done method를 사용한다. 완료되지 않은 작업들, 실패한 작업들을만 추출하고 싶으면 .not_done method를 사용한다. 결과값을 원할 때는 .result를 사용한다.  6.2 as_completed  하나라도 끝난 다음에 바로 일을 시작할려고 할 때, 즉 real time 작업을 하려고 할 때, as_completed를 사용한다.\n  먼저 끝나는 대로 순서를 반환한다. (yield) 결과값만 추출하기 원하면 .result를 사용한다. 완료된 작업들만 추출하고 싶으면 .done method를 사용한다. 완료되지 않은 작업들, 실패한 작업들을만 추출하고 싶으면 .cancelled method를 사용한다.   그러면 예시 코드로 적용해보자.   import os  import time # 이번에는 쓸만큼만 호출한다.  from concurrent.futures import ThreadPoolExecutor, ProcessPoolExecutor, wait, as_completed  WORK_LIST = [100000, 1000000, 10000000, 100000000]  def sum_generator(n):  return sum(n for n in range(1, n+1))  def main():  worker= min(10, len(WORK_LIST)) ## 시작시간  start_tm = time.time()  future_list = [] ## 결과 건수 # ThreadPoolExecutor로도 해보자.  with ProcessPoolExecutor() as excutor:  for work in WORK_LIST:  furture = excutor.submit(sum_generator, work)  futures_list.append(future)  print('Scheduled for {} : {}'.format(work, future))  print() ## wait 결과 출력 # 스케쥴된 list를 인자로 받는다. # timeout으로 정한 시간만큼 list를 기다린다. # 이 정해진 시간 안에 일을 못 끝내면 실패로 간주하고 중단시킨다. # sum_generator로 인한 연산 작업으로 future_list에 append될 때까지 7초를 넘으면 실패로 간주한다.  result = wait(futures_list, timeout = 7) ## 성공한 것들  print('Completed Tasks : ' + str(result.done))  print() ## 실패한 것들  print('Pending ones after waiting for 7seconds : ' + str(result.not_done))  print() ## 결과 값 출력  print([future.result() for future in result.done])  print() ## as_completed 결과 출력  for future in as_completed(futures_list):  result = future.result()  done = future.done()  cancelled = future.cancelled ## future 결과 확인  print('Future Result : {}, Done: {}'.format(result, done))  print('Future Cancelled : {}'.format(cancelled)) ## 종료시간  end_tm = time.time() - start_tm ## 출력 포맷  msg = '\\n Time : {:.2f}s'  print(msg.format(end_tm)) ## 실행  if __name__ == '__main__':  main() ## 결과 건수에서 예약된 작업들 Scheduled for 100000 : Scheduled for 1000000 : Scheduled for 10000000 : Scheduled for 100000000 : ## 성공한 것들 Completed Tasks : {, , } ## 실패한 것들 Pending ones after waiting for 7seconds : {} ## 결과값 출력 [5000050000, 500000500000, 50000005000000] ## 종료시간 Time : 8.47s   submit(func, *args)는 func에 *args 를 넘겨주어 그 결과값을 return하는 함수다.\n  Futures chapter는 더 공부를 해야할 필요를 다른 단원보다 많이 느낀다.\n  파이썬에 대해 더 공부한 후, 파이썬 과정 level 4인 고수가 되는 파이썬 : 동시성과 병렬성 문법 배우기 Feat. 멀티스레딩 vs 멀티프로세싱 (Inflearn Original) 을 공부하면서 깊이 있게 학습해야겠다.\n   Reference  인프런 파이썬 중급 Sync VS Async, Blocking VS Non-Blocking thread pool  ","wordCount":"1540","inLanguage":"en","datePublished":"2022-04-06T21:34:38+09:00","dateModified":"2022-04-06T21:34:38+09:00","author":{"@type":"Person","name":"Jeha00"},"mainEntityOfPage":{"@type":"WebPage","@id":"http://jeha00.github.io/post/python_basic/python_basic_38.futures/"},"publisher":{"@type":"Organization","name":"Jeha00 DevLog","logo":{"@type":"ImageObject","url":"http://jeha00.github.io/favicon.ico"}}}</script>
</head>
<body id=top>
<script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add('dark'):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove('dark'):window.matchMedia('(prefers-color-scheme: dark)').matches&&document.body.classList.add('dark')</script>
<header class=header>
<nav class=nav>
<div class=logo>
<a href=http://jeha00.github.io/ accesskey=h title="Jeha00 (Alt + H)">Jeha00</a>
<span class=logo-switches>
<button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg>
</button>
</span>
</div>
<ul id=menu>
<li>
<a href=http://jeha00.github.io/archives/ title=Archive>
<span>Archive</span>
</a>
</li>
<li>
<a href=http://jeha00.github.io/categories/ title=Categories>
<span>Categories</span>
</a>
</li>
<li>
<a href=http://jeha00.github.io/tags/ title=Tags>
<span>Tags</span>
</a>
</li>
<li>
<a href=http://jeha00.github.io/search/ title="Search (Alt + /)" accesskey=/>
<span>Search</span>
</a>
</li>
</ul>
</nav>
</header>
<main class=main>
<article class=post-single>
<header class=post-header>
<div class=breadcrumbs><a href=http://jeha00.github.io/>Home</a>&nbsp;»&nbsp;<a href=http://jeha00.github.io/post/>Posts</a></div>
<h1 class=post-title>
[TIL] Python basic 38: Futures
</h1>
<div class=post-meta><span title="2022-04-06 21:34:38 +0900 KST">April 6, 2022</span>&nbsp;·&nbsp;8 min&nbsp;·&nbsp;Jeha00&nbsp;|&nbsp;<a href=https://github.com/JeHa00/blog/content/post/Python_basic/Python_basic_38.Futures.md rel="noopener noreferrer" target=_blank>Suggest Changes</a>
</div>
</header> <div class=toc>
<details>
<summary accesskey=c title="(Alt + C)">
<span class=details>Table of Contents</span>
</summary>
<div class=inner><ul>
<li>
<a href=#intro aria-label=Intro>Intro</a></li>
<li>
<a href=#1-synchronous-vs-asynchronous aria-label="1. Synchronous VS Asynchronous">1. Synchronous VS Asynchronous</a></li>
<li>
<a href=#2-blocking-vs-non-blocking aria-label="2. Blocking vs Non-Blocking">2. Blocking vs Non-Blocking</a></li>
<li>
<a href=#3-gilglobal-interface-lock aria-label="3. GIL(Global Interface Lock)">3. GIL(Global Interface Lock)</a></li>
<li>
<a href=#4-concurrentfutures aria-label="4. Concurrent.futures">4. Concurrent.futures</a><ul>
<li>
<a href=#41-thread-pool%ec%9d%b4%eb%9e%80 aria-label="4.1 Thread Pool이란??">4.1 Thread Pool이란??</a></li>
<li>
<a href=#42-concurrentfutures-package aria-label="4.2 concurrent.futures package">4.2 concurrent.futures package</a></li></ul>
</li>
<li>
<a href=#5-exercise---poolexecutor aria-label="5. Exercise - PoolExecutor">5. Exercise - PoolExecutor</a></li>
<li>
<a href=#6-exercise---wait-as_completed aria-label="6. Exercise - wait, as_completed">6. Exercise - wait, as_completed</a><ul>
<li>
<a href=#61-wait aria-label="6.1 wait">6.1 wait</a></li>
<li>
<a href=#62-as_completed aria-label="6.2 as_completed">6.2 as_completed</a></li></ul>
</li>
<li>
<a href=#reference aria-label=Reference>Reference</a>
</li>
</ul>
</div>
</details>
</div>
<div class=post-content><h1 id=intro>Intro<a hidden class=anchor aria-hidden=true href=#intro>#</a></h1>
<ul>
<li>이번 내용은 파이썬 고급 과정 <a href=https://www.inflearn.com/course/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D-%ED%8C%8C%EC%9D%B4%EC%8D%AC-%EC%99%84%EC%84%B1-%EC%9D%B8%ED%94%84%EB%9F%B0-%EC%98%A4%EB%A6%AC%EC%A7%80%EB%84%90/dashboard>고수가 되는 파이썬 : 동시성과 병렬성 문법 배우기 Feat. 멀티스레딩 vs 멀티프로세싱 (Inflearn Original)</a> 에서 자세히 배운다고 하여 깊이 있게 들어가진 않았다.</li>
<li>이런 게 있구나 정도로만 파악하자.</li>
</ul>
<hr>
<h1 id=1-synchronous-vs-asynchronous>1. Synchronous VS Asynchronous<a hidden class=anchor aria-hidden=true href=#1-synchronous-vs-asynchronous>#</a></h1>
<ul>
<li>
<p>소제목에 있는 두 영단어는 접두어와 어원으로 분석하여 접근하면 쉽다.</p>
</li>
<li>
<p>syn는 &lsquo;together&rsquo;를, chrono는 &lsquo;time&rsquo;을 의미한다.</p>
</li>
<li>
<p>하지만 Asynchronous 는 접두어로 &lsquo;a&rsquo;가 붙었는데, 이는 부정의 의미를 가진다.</p>
</li>
<li>
<p>시간을 함께 맞추는 것 vs 시간을 함께 맞추지 않는 것의 의미로 해석할 수 있다.</p>
</li>
<li>
<p><code>Synchronous</code>는 단어적 의미를 기반으로 바라보면 2가지 이상의 대상이 서로 시간을 맞춰 해동하는 걸 의미한다.</p>
<ul>
<li>A 작업이 끝난 후에야 B 작업이 시작되는 걸 말한다.</li>
<li>끝나고 나서 시작되는 것처럼 시간을 맞춘다.</li>
</ul>
</li>
<li>
<p><code>Asynchronous</code>는 서로 시간을 맞추지 않는 걸 의미한다.</p>
<ul>
<li>A에 작업을 조금 걸어넣고, B에도 조금 시작하여 <code>동시성</code>이 실행되는 걸 의미한다.</li>
</ul>
</li>
</ul>
<hr>
<h1 id=2-blocking-vs-non-blocking>2. Blocking vs Non-Blocking<a hidden class=anchor aria-hidden=true href=#2-blocking-vs-non-blocking>#</a></h1>
<ul>
<li>
<p>Blocking이란 직접 제어할 수 없는 대상의 작업이 끝날 때까지 제어권을 넘겨주지 않는 걸 말한다.</p>
<ul>
<li>예) 호출 함수가 I/O 을 요청했을 때, 이 요청이 완료될까지 아무 일도 하지 못한 채 기다리는 걸 말한다.</li>
</ul>
</li>
<li>
<p>Non-blocking이란 non이 붙여졌듯이 blocking의 반대 의미다.</p>
</li>
<li>
<p>요청이 완료될 때까지 기다릴 필요 없이 바로 자신의 작업을 할 수 있는 상태를 말한다.</p>
</li>
<li>
<p>blocking 현상으로 CPU 및 resource 낭비를 하고 있을 때, <code>동시성</code> 활용 작업으로 낭비를 방지한다.</p>
</li>
<li>
<p>파이썬은 단일 쓰레드로 해도 충분히 빠르다.</p>
</li>
<li>
<p>특히, 비동기 작업과 적합한 프로그램일 경우, 압도적으로 성능이 향상된다.</p>
</li>
</ul>
<hr>
<h1 id=3-gilglobal-interface-lock>3. GIL(Global Interface Lock)<a hidden class=anchor aria-hidden=true href=#3-gilglobal-interface-lock>#</a></h1>
<ul>
<li>
<p>GIL은 Python에만 존재하는 것으로, Global Interface Lock in CPython을 의미한다.</p>
</li>
<li>
<p>GIL은 두 개 이상의 thread가 동시에 실행될 때(context switching 상황) 하나의 자원에 액세스하는 경우, 문제점을 방지하기 위해 GIL을 실행하여 resource 전체에 lock을 건다.</p>
</li>
<li>
<p>그래서 multi-thread할 때, GIL 때문에 single-thread보다 느린 경우가 많다.</p>
</li>
<li>
<p>GIL을 우회하기 위해서는 반드시 multi-processing을 사용하거나 CPython을 사용하면 GIL이 걸리지 않는다.</p>
</li>
<li>
<p>하지만 이 때는 동기화를 직접해야 한다.</p>
</li>
</ul>
<hr>
<h1 id=4-concurrentfutures>4. Concurrent.futures<a hidden class=anchor aria-hidden=true href=#4-concurrentfutures>#</a></h1>
<h2 id=41-thread-pool이란>4.1 Thread Pool이란??<a hidden class=anchor aria-hidden=true href=#41-thread-pool이란>#</a></h2>
<ul>
<li>
<p>server 요청 model에 <code>Thread per request model</code> 이다.</p>
<ul>
<li>즉, 요청마다 새로운 thread를 할당하여 처리한다면, 요청이 들어올 때마다 thread를 생성하고 요청이 완료되면 thread를 삭제해야 한다.</li>
</ul>
</li>
<li>
<p>이 방식의 문제는 요청마다 스레드 생성에 소요되는 시간 때문에, 요청 처리가 더 오래 걸린다.</p>
</li>
<li>
<p>만약 처리 속도 &lt; 요청 속도이면??</p>
<ul>
<li><strong>thread가 계속 생성되어, thread 수는 증가한다.</strong></li>
<li>이에 따라 context switching이 더 자주 발생한다.</li>
<li>CPU overhead 증가로 CPU time이 낭비된다.</li>
<li>결국, 어느 순간 <em>서버 전체가 응답 불가능</em> 한 상태에 빠진다.</li>
<li>또한, <em>메모리가 점점 고갈</em> 된다.</li>
</ul>
</li>
<li>
<p>그래서 미리 최대 몇 개의 thread 묶음을 만들어놓는다. 이를 <code>thread pool</code>이라 한다.</p>
<ul>
<li>API 요청이 들어오면 thread pool 안에 일이 없는 thread를 할당한다.</li>
<li>요청이 완료되면 thread는 삭제하지 않고, 이 pool에 다시 들어온다.</li>
<li><strong>미리 thread를 여러 개 만들어 놓고 재사용하여 thread 생성 시간을 절약한다.</strong></li>
<li><strong>또한, 제한된 개수의 thread를 응용</strong> 하기 때문에, 무제한으로 생성되는 걸 방지한다.</li>
</ul>
</li>
<li>
<p>Thread pool 사례: <strong>여러 작업을 동시 처리해야할 때</strong></p>
<ul>
<li>task를 subtask로 나뉘어서 동시에 처리할 때</li>
<li>순서 상관없이 동시실행이 가능한 task 처리할 때</li>
</ul>
</li>
<li>
<p>Thread pool 사용 시, <strong>Tip</strong></p>
<ol>
<li>thread pool에 몇 개의 thread를 만들어 두는 게 적절한가???
<ul>
<li>CPU의 core 개수와 task의 성향에 따라 다르다.</li>
<li>CPU-bound task라면 코어 개수 만큼 혹은 그보다 몇 개 더 많은 정도</li>
<li>I/O-bound task라면 경험적으로 찾아야 한다.</li>
</ul>
</li>
<li>thread pool에서 실행될 task 개수에 제한이 없다면, <strong>thread pool의 큐가 사이즈 제한이 있는지 반드시 확인할 것</strong></li>
</ol>
<ul>
<li>큐에 요청이 무한정 쌓인다면???</li>
<li><strong>잠재적으로 메모리를 고갈시킬 수 있는 원인이 된다.</strong></li>
<li>그래서 <strong><em>큐에 제한이 없다면 제한을 걸어야 한다.</em></strong></li>
</ul>
</li>
<li>
<p>process pool 또한, process를 미리 만들어두는 방식을 말한다.</p>
</li>
<li>
<p>python에서는 <code>GIL</code> 때문에 CPU-bound task를 실행할려면, 동시에 CPU에서 여러 프로세스가 실행될 수 없으므로 thread pool을 사용해야 한다.</p>
</li>
</ul>
<h2 id=42-concurrentfutures-package>4.2 concurrent.futures package<a hidden class=anchor aria-hidden=true href=#42-concurrentfutures-package>#</a></h2>
<ul>
<li>
<p>concurrent.futures package</p>
<ul>
<li>비동기 실행을 위한 API를 고수준으로 작성하고, &lsquo;사용하기 쉽도록 개선&rsquo;하여 나온 것
<ul>
<li>전에는 &lsquo;import processing&rsquo;, &lsquo;import thread&rsquo; 으로 따로 호출해서 사용했었지만, 지금은 multi-threading / multi-processing API가 통일되어 매우 사용하기 쉽다.</li>
<li>또한, low level로 하지 않아도 가능하다.</li>
</ul>
</li>
<li>실행 중인 작업 취소, 완료 여부 체크, 타임아웃 옵션, 콜백 추가, 동기화 코드를 매우 쉽게 작성할 수 있다.</li>
</ul>
</li>
<li>
<p><code>concurrent.futures.ProcessPoolExecutor</code> 는 <code>multiprocessing.Process</code>와 동일한 역할을 한다.</p>
</li>
<li>
<p>하지만, <code>concurrent.futures.ProcessPoolExecutor</code>는 max_workers를 지정하여 fork할 process의 최대 갯수를 지정하는 게 가능하다.</p>
</li>
<li>
<p>process pool을 사용하여 호출을 비동기적으로 실행하는 method</p>
</li>
<li>
<p><code>ThreadPoolExecutor</code>는 process pool이 아닌, thread pool을 사용한다.</p>
<ul>
<li>thread pool이란 미리 만들어 놓은 thread 집단을 말한다.</li>
</ul>
</li>
</ul>
<hr>
<h1 id=5-exercise---poolexecutor>5. Exercise - PoolExecutor<a hidden class=anchor aria-hidden=true href=#5-exercise---poolexecutor>#</a></h1>
<ul>
<li><code>concurrent.futures</code> 사용법
<ul>
<li>ThreadPoolExecutor의 max_work 기본 값은 min(32, os.cpu_count() + 4)다.
<ul>
<li>이 기본값은 I/O 병목 작업을 위해 최소 5개의 작업자를 유지한다.</li>
</ul>
</li>
<li>ProcessPoolExecutor의 max_work 기본 값은 기계의 프로세서 수를 기본값으로 사용한다.</li>
<li>아래 코드의 pattern을 외우자.</li>
<li><code>map</code>은 작업 순서를 유지하고, 즉시 실행한다.
<ul>
<li>4개를 동시에 시작해서 그 결과값을 받아온다.</li>
<li>그런데 4개 중 한 작업이 1시간이 걸린다면 이 한 시간을 계속 기다린다.</li>
</ul>
</li>
</ul>
</li>
</ul>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yml data-lang=yml>&gt; import os
&gt; import time

<span style=color:#6272a4># threading, multi-processing이 저수준으로 만들어져 있는 걸 사용한다.</span>
&gt; from concurrent import futures

<span style=color:#6272a4># 1부터 각 성분값까지 합을 계산할 것이기 때문에, 4가지 작업을 동시에 실행한다.</span>
<span style=color:#6272a4># 실무에서는 각 값에 자신이 만든 함수를 넣어 사용해도 된다.</span>
&gt; WORK_LIST = [100000, 1000000, 10000000, 100000000]

<span style=color:#6272a4># 인자 n에 위 WORK_LIST의 성분 값들이 하나씩 넘어와서 합이 계산된다.</span>
<span style=color:#6272a4># 그래서 총 동시에 4개가 실행된다.</span>
<span style=color:#6272a4># 누적 합계 함수(generator)</span>
<span style=color:#ff79c6>&gt; def sum_generator(n)</span>:
&gt;     return sum(n for n in range(1, n+1))

<span style=color:#6272a4># worker의 수는 두 인수 중 작은 수로 한다.</span>
<span style=color:#6272a4># worker를 몇 개 할지 모르면 운영체제한테 맡긴다.</span>
<span style=color:#ff79c6>&gt; def main1()</span>:
&gt;    worker= min(10, len(WORK_LIST))

<span style=color:#6272a4>## 시작시간</span>
<span style=color:#6272a4># time.time은 현재 시간을 나타낸다.</span>
&gt;     start_tm = time.time()

<span style=color:#6272a4>## 결과 건수</span>
<span style=color:#6272a4># with문으로 해야 열고 닫는 게 자동적으로 이뤄진다.</span>
<span style=color:#6272a4># def main1 과의 차이점 (ThreadPoolExecutor)</span>
<span style=color:#ff79c6>&gt;     with futures.ThreadPoolExecutor() as excutor</span>:
&gt;        result = excutor.map(sum_generator, WORK_LIST)

<span style=color:#6272a4>## 종료시간</span>
<span style=color:#6272a4># 현재 시간을 나타낸 거에, 시작 시간을 빼서 총 걸린 시간을 나타낸다.</span>
&gt;    end_tm = time.time() - start_tm

<span style=color:#6272a4>## 출력 포맷</span>
<span style=color:#6272a4># float 형 데이터 출력에 소수점 둘째짜리까지 출력한다.</span>
&gt;    msg = &#39;\n Result -&gt; {} Time : {:.2f}s&#39;

&gt;    print(msg.format(list(result), end_tm))


<span style=color:#ff79c6>&gt; def main2()</span>:
&gt;     worker= min(10, len(WORK_LIST))

&gt;     start_tm = time.time()

<span style=color:#6272a4># def main2 와의 차이점 (ProcessPoolExcutor)</span>
<span style=color:#ff79c6>&gt;     with futures.ProcessPoolExecutor() as excutor</span>:
&gt;        result = excutor.map(sum_generator, WORK_LIST)

&gt;     end_tm = time.time() - start_tm

&gt;     msg = &#39;\n Result -&gt; {} Time : {:.2f}s&#39;
&gt;     print(msg.format(list(result), end_tm))

<span style=color:#6272a4>## 실행</span>
<span style=color:#6272a4># 진입점을 알려줘야, multi-processing이 실행될 때 작업을 할 수 있다.</span>
<span style=color:#ff79c6>&gt; if __name__ == &#39;__main__&#39;</span>:
&gt;     main1()
&gt;     main2()

 <span style=color:#ff79c6>Result -&gt; [5000050000, 500000500000, 50000005000000, 5000000050000000] Time </span>: <span style=color:#bd93f9>7.</span>61s

 <span style=color:#ff79c6>Result -&gt; [5000050000, 500000500000, 50000005000000, 5000000050000000] Time </span>: <span style=color:#bd93f9>7.</span>14s
</code></pre></div><ul>
<li>ProcessPool로 실행했을 때의 결과가 더 빠르다는 걸 확인했다.</li>
</ul>
<ul>
<li>그러면 동기적으로 진행했을 때의 시간을 측정해보자.</li>
</ul>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yml data-lang=yml>&gt; WORK_LIST = [100000, 1000000, 10000000, 100000000]

<span style=color:#6272a4># 시작 시간</span>
&gt; stm = time.time()
<span style=color:#ff79c6>&gt; for i in WORK_LIST</span>:
&gt;     sum(n for n in range(1, i+1))

<span style=color:#6272a4># 종료 시간</span>
&gt; etm = time.time() - stm

&gt; print(&#39;total time - {:0.2f}s&#39;.format(etm))
<span style=color:#bd93f9>8.</span>43s
</code></pre></div><ul>
<li>thread pool과 process pool을 사용하는 방법이 더 빠르다는 걸 알 수 있다.</li>
</ul>
<hr>
<h1 id=6-exercise---wait-as_completed>6. Exercise - wait, as_completed<a hidden class=anchor aria-hidden=true href=#6-exercise---wait-as_completed>#</a></h1>
<ul>
<li><a href=#5-exercise---poolexecutor>Exercise - PoolExecutor</a>에서 한 예제는 총 4가지에 대한 합계를 구하는 동시성을 구현해보는 예제였다.</li>
<li>그러면 동시적으로 수행되는 각 작업이 성공했는지, 확인할 수도 있어야 하지 않을까??</li>
<li>이를 확인하기 위해, <code>wait</code>과 <code>as_completed</code> module에 대해 먼저 알아보자.</li>
</ul>
<h2 id=61-wait>6.1 wait<a hidden class=anchor aria-hidden=true href=#61-wait>#</a></h2>
<blockquote>
<p>작업의 양이 작아서 금방 끝나서, 한 번에 다 끝난 다음에 작업을 하기 원할 때 wait을 사용한다.</p>
</blockquote>
<ul>
<li>각 작업이 정해진 시간(timeout)을 벗어나면 실패로 간주하고 중단시킨다.</li>
<li>완료된 작업들만 추출하고 싶으면 <code>.done</code> method를 사용한다.</li>
<li>완료되지 않은 작업들, 실패한 작업들을만 추출하고 싶으면 <code>.not_done</code> method를 사용한다.</li>
<li>결과값을 원할 때는 <code>.result</code>를 사용한다.</li>
</ul>
<h2 id=62-as_completed>6.2 as_completed<a hidden class=anchor aria-hidden=true href=#62-as_completed>#</a></h2>
<blockquote>
<p>하나라도 끝난 다음에 바로 일을 시작할려고 할 때, 즉 real time 작업을 하려고 할 때, as_completed를 사용한다.</p>
</blockquote>
<ul>
<li>먼저 끝나는 대로 순서를 반환한다. (yield)</li>
<li>결과값만 추출하기 원하면 <code>.result</code>를 사용한다.</li>
<li>완료된 작업들만 추출하고 싶으면 <code>.done</code> method를 사용한다.</li>
<li>완료되지 않은 작업들, 실패한 작업들을만 추출하고 싶으면 <code>.cancelled</code> method를 사용한다.</li>
</ul>
<ul>
<li>그러면 예시 코드로 적용해보자.</li>
</ul>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yml data-lang=yml>&gt; import os
&gt; import time

<span style=color:#6272a4># 이번에는 쓸만큼만 호출한다.</span>
&gt; from concurrent.futures import ThreadPoolExecutor, ProcessPoolExecutor, wait, as_completed

&gt; WORK_LIST = [100000, 1000000, 10000000, 100000000]

<span style=color:#ff79c6>&gt; def sum_generator(n)</span>:
&gt;     return sum(n for n in range(1, n+1))


<span style=color:#ff79c6>&gt; def main()</span>:
&gt;    worker= min(10, len(WORK_LIST))

<span style=color:#6272a4>## 시작시간</span>
&gt;     start_tm = time.time()

&gt;     future_list = []

<span style=color:#6272a4>## 결과 건수</span>
<span style=color:#6272a4># ThreadPoolExecutor로도 해보자.</span>
<span style=color:#ff79c6>&gt; with ProcessPoolExecutor() as excutor</span>:
<span style=color:#ff79c6>&gt;       for work in WORK_LIST</span>:
&gt;           furture = excutor.submit(sum_generator, work)
&gt;           futures_list.append(future)
&gt;           print(&#39;Scheduled for {} : {}&#39;.format(work, future))
&gt;           print()

<span style=color:#6272a4>## wait 결과 출력</span>
<span style=color:#6272a4># 스케쥴된 list를 인자로 받는다.</span>
<span style=color:#6272a4># timeout으로 정한 시간만큼 list를 기다린다.</span>
<span style=color:#6272a4># 이 정해진 시간 안에 일을 못 끝내면 실패로 간주하고 중단시킨다.</span>
<span style=color:#6272a4># sum_generator로 인한 연산 작업으로 future_list에 append될 때까지 7초를 넘으면 실패로 간주한다.</span>
&gt;       result = wait(futures_list, timeout = 7)

<span style=color:#6272a4>## 성공한 것들</span>
<span style=color:#ff79c6>&gt;       print(&#39;Completed Tasks </span>: <span style=color:#f1fa8c>&#39; + str(result.done))
</span><span style=color:#f1fa8c>&gt;       print()
</span><span style=color:#f1fa8c>
</span><span style=color:#f1fa8c>## 실패한 것들
</span><span style=color:#f1fa8c>&gt;       print(&#39;</span><span style=color:#ff79c6>Pending ones after waiting for 7seconds </span>: <span style=color:#f1fa8c>&#39; + str(result.not_done))
</span><span style=color:#f1fa8c>&gt;       print()
</span><span style=color:#f1fa8c>
</span><span style=color:#f1fa8c>## 결과 값 출력
</span><span style=color:#f1fa8c>&gt;       print([future.result() for future in result.done])
</span><span style=color:#f1fa8c>&gt;       print()
</span><span style=color:#f1fa8c>
</span><span style=color:#f1fa8c>
</span><span style=color:#f1fa8c>## as_completed 결과 출력
</span><span style=color:#f1fa8c>&gt;       for future in as_completed(futures_list):
</span><span style=color:#f1fa8c>&gt;           result = future.result()
</span><span style=color:#f1fa8c>&gt;           done = future.done()
</span><span style=color:#f1fa8c>&gt;           cancelled = future.cancelled
</span><span style=color:#f1fa8c>
</span><span style=color:#f1fa8c>## future 결과 확인
</span><span style=color:#f1fa8c>&gt;         print(&#39;</span><span style=color:#ff79c6>Future Result </span>: {<span style=color:#ff79c6>}, Done</span>: {}<span style=color:#f1fa8c>&#39;.format(result, done))
</span><span style=color:#f1fa8c>&gt;         print(&#39;</span><span style=color:#ff79c6>Future Cancelled </span>: {}<span style=color:#f1fa8c>&#39;.format(cancelled))
</span><span style=color:#f1fa8c>
</span><span style=color:#f1fa8c>## 종료시간
</span><span style=color:#f1fa8c>&gt;    end_tm = time.time() - start_tm
</span><span style=color:#f1fa8c>
</span><span style=color:#f1fa8c>## 출력 포맷
</span><span style=color:#f1fa8c>&gt;    msg = &#39;</span><span style=color:#ff79c6>\n Time </span>: {:.2f}s&#39;

&gt;    print(msg.format(end_tm))


<span style=color:#6272a4>## 실행</span>
<span style=color:#ff79c6>&gt; if __name__ == &#39;__main__&#39;</span>:
&gt;     main()

<span style=color:#6272a4>## 결과 건수에서 예약된 작업들</span>
<span style=color:#ff79c6>Scheduled for 100000 </span>: &lt;Future at 0x204190e5490 state=running&gt;

<span style=color:#ff79c6>Scheduled for 1000000 </span>: &lt;Future at 0x20419161130 state=pending&gt;

<span style=color:#ff79c6>Scheduled for 10000000 </span>: &lt;Future at 0x20419161370 state=pending&gt;

<span style=color:#ff79c6>Scheduled for 100000000 </span>: &lt;Future at 0x204191610d0 state=pending&gt;

<span style=color:#6272a4>## 성공한 것들</span>
<span style=color:#ff79c6>Completed Tasks </span>: {&lt;Future at 0x204190e5490 state=finished returned int&gt;, &lt;Future at 0x20419161130 state=finished returned int&gt;, &lt;Future at 0x20419161370 state=finished returned int&gt;}

<span style=color:#6272a4>## 실패한 것들</span>
<span style=color:#ff79c6>Pending ones after waiting for 7seconds </span>: {&lt;Future at 0x204191610d0 state=running&gt;}

<span style=color:#6272a4>## 결과값 출력</span>
[<span style=color:#bd93f9>5000050000</span>, <span style=color:#bd93f9>500000500000</span>, <span style=color:#bd93f9>50000005000000</span>]

<span style=color:#6272a4>## 종료시간</span>
 <span style=color:#ff79c6>Time </span>: <span style=color:#bd93f9>8.</span>47s
</code></pre></div><ul>
<li>
<p><code>submit(func, *args)</code>는 func에 *args 를 넘겨주어 그 결과값을 return하는 함수다.</p>
</li>
<li>
<p><code>Futures</code> chapter는 더 공부를 해야할 필요를 다른 단원보다 많이 느낀다.</p>
</li>
<li>
<p>파이썬에 대해 더 공부한 후, 파이썬 과정 level 4인 <a href=https://www.inflearn.com/course/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D-%ED%8C%8C%EC%9D%B4%EC%8D%AC-%EC%99%84%EC%84%B1-%EC%9D%B8%ED%94%84%EB%9F%B0-%EC%98%A4%EB%A6%AC%EC%A7%80%EB%84%90/dashboard>고수가 되는 파이썬 : 동시성과 병렬성 문법 배우기 Feat. 멀티스레딩 vs 멀티프로세싱 (Inflearn Original)</a> 을 공부하면서 깊이 있게 학습해야겠다.</p>
</li>
</ul>
<hr>
<h1 id=reference>Reference<a hidden class=anchor aria-hidden=true href=#reference>#</a></h1>
<ul>
<li><a href=https://www.inflearn.com/course/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D-%ED%8C%8C%EC%9D%B4%EC%8D%AC-%EC%A4%91%EA%B8%89-%EC%9D%B8%ED%94%84%EB%9F%B0-%EC%98%A4%EB%A6%AC%EC%A7%80%EB%84%90>인프런 파이썬 중급</a></li>
<li><a href=https://velog.io/@codemcd/Sync-VS-Async-Blocking-VS-Non-Blocking-sak6d01fhx>Sync VS Async, Blocking VS Non-Blocking</a></li>
<li><a href="https://www.youtube.com/watch?v=B4Of4UgLfWc">thread pool</a></li>
</ul>
</div>
<footer class=post-footer>
<ul class=post-tags>
<li><a href=http://jeha00.github.io/tags/til/>TIL</a></li>
<li><a href=http://jeha00.github.io/tags/python/>python</a></li>
</ul>
<nav class=paginav>
<a class=prev href=http://jeha00.github.io/post/python_basic/python_basic_39_mapfilterreduce/>
<span class=title>« Prev Page</span>
<br>
<span>[TIL] Python basic 39: Map, Filter, Reduce</span>
</a>
<a class=next href=http://jeha00.github.io/post/os/os_chapter_02_%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C_%EA%B0%9C%EC%9A%94/>
<span class=title>Next Page »</span>
<br>
<span>[TIL] Operating System Chapter 02: Introduction to Operating System</span>
</a>
</nav>
<div class=share-buttons>
<a target=_blank rel="noopener noreferrer" aria-label="share [TIL] Python basic 38: Futures on twitter" href="https://twitter.com/intent/tweet/?text=%5bTIL%5d%20Python%20basic%2038%3a%20Futures&url=http%3a%2f%2fjeha00.github.io%2fpost%2fpython_basic%2fpython_basic_38.futures%2f&hashtags=TIL%2cpython"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM195.519 424.544c135.939.0 210.268-112.643 210.268-210.268.0-3.218.0-6.437-.153-9.502 14.406-10.421 26.973-23.448 36.935-38.314-13.18 5.824-27.433 9.809-42.452 11.648 15.326-9.196 26.973-23.602 32.49-40.92-14.252 8.429-30.038 14.56-46.896 17.931-13.487-14.406-32.644-23.295-53.946-23.295-40.767.0-73.87 33.104-73.87 73.87.0 5.824.613 11.494 1.992 16.858-61.456-3.065-115.862-32.49-152.337-77.241-6.284 10.881-9.962 23.601-9.962 37.088.0 25.594 13.027 48.276 32.95 61.456-12.107-.307-23.448-3.678-33.41-9.196v.92c0 35.862 25.441 65.594 59.311 72.49-6.13 1.686-12.72 2.606-19.464 2.606-4.751.0-9.348-.46-13.946-1.38 9.349 29.426 36.628 50.728 68.965 51.341-25.287 19.771-57.164 31.571-91.8 31.571-5.977.0-11.801-.306-17.625-1.073 32.337 21.15 71.264 33.41 112.95 33.41z"/></svg>
</a>
<a target=_blank rel="noopener noreferrer" aria-label="share [TIL] Python basic 38: Futures on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&url=http%3a%2f%2fjeha00.github.io%2fpost%2fpython_basic%2fpython_basic_38.futures%2f&title=%5bTIL%5d%20Python%20basic%2038%3a%20Futures&summary=%5bTIL%5d%20Python%20basic%2038%3a%20Futures&source=http%3a%2f%2fjeha00.github.io%2fpost%2fpython_basic%2fpython_basic_38.futures%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg>
</a>
<a target=_blank rel="noopener noreferrer" aria-label="share [TIL] Python basic 38: Futures on reddit" href="https://reddit.com/submit?url=http%3a%2f%2fjeha00.github.io%2fpost%2fpython_basic%2fpython_basic_38.futures%2f&title=%5bTIL%5d%20Python%20basic%2038%3a%20Futures"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg>
</a>
<a target=_blank rel="noopener noreferrer" aria-label="share [TIL] Python basic 38: Futures on facebook" href="https://facebook.com/sharer/sharer.php?u=http%3a%2f%2fjeha00.github.io%2fpost%2fpython_basic%2fpython_basic_38.futures%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg>
</a>
<a target=_blank rel="noopener noreferrer" aria-label="share [TIL] Python basic 38: Futures on whatsapp" href="https://api.whatsapp.com/send?text=%5bTIL%5d%20Python%20basic%2038%3a%20Futures%20-%20http%3a%2f%2fjeha00.github.io%2fpost%2fpython_basic%2fpython_basic_38.futures%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg>
</a>
<a target=_blank rel="noopener noreferrer" aria-label="share [TIL] Python basic 38: Futures on telegram" href="https://telegram.me/share/url?text=%5bTIL%5d%20Python%20basic%2038%3a%20Futures&url=http%3a%2f%2fjeha00.github.io%2fpost%2fpython_basic%2fpython_basic_38.futures%2f"><svg viewBox="2 2 28 28"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg>
</a>
</div>
</footer><script src=https://utteranc.es/client.js repo=JeHa00/blog-comments issue-term=pathname theme=github-dark crossorigin=anonymous async></script>
</article>
</main>
<footer class=footer>
<span>&copy; 2022 <a href=http://jeha00.github.io/>Jeha00 DevLog</a></span>
<span>
Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a>
</span>
</footer>
<a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a>
<script>let menu=document.getElementById('menu');menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(a=>{a.addEventListener("click",function(b){b.preventDefault();var a=this.getAttribute("href").substr(1);window.matchMedia('(prefers-reduced-motion: reduce)').matches?document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView({behavior:"smooth"}),a==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${a}`)})})</script>
<script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script>
<script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove('dark'),localStorage.setItem("pref-theme",'light')):(document.body.classList.add('dark'),localStorage.setItem("pref-theme",'dark'))})</script>
</body>
</html>