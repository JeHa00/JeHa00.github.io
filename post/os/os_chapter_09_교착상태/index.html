<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>[TIL] OS Chapter 09: 교착 상태 | Jeha00 DevLog</title><meta name=keywords content="TIL,OS"><meta name=description content="교착 상태(deadlock)이란 무엇이고, deadlock 발생 조건 4가지는 무엇이며, 이에 따라 deadlock 처리 방법에 대해 알아본다."><meta name=author content="Jeha00"><link rel=canonical href=http://jeha00.github.io/post/os/os_chapter_09_%EA%B5%90%EC%B0%A9%EC%83%81%ED%83%9C/><meta name=google-site-verification content="XYZabc"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.min.1e44d58192cbf6d7a4eb649bc43dbc3d4cc432677e5d8adc69b08c34cbe461ac.css integrity="sha256-HkTVgZLL9tek62SbxD28PUzEMmd+XYrcabCMNMvkYaw=" rel="preload stylesheet" as=style><link rel=icon href=http://jeha00.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=http://jeha00.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=http://jeha00.github.io/favicon-32x32.png><link rel=apple-touch-icon href=http://jeha00.github.io/apple-touch-icon.png><link rel=mask-icon href=http://jeha00.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><meta name=generator content="Hugo 0.98.0"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script type=application/javascript>var doNotTrack=!1;doNotTrack||(function(e,o,i,a,t,n,s){e.GoogleAnalyticsObject=t,e[t]=e[t]||function(){(e[t].q=e[t].q||[]).push(arguments)},e[t].l=1*new Date,n=o.createElement(i),s=o.getElementsByTagName(i)[0],n.async=1,n.src=a,s.parentNode.insertBefore(n,s)}(window,document,"script","https://www.google-analytics.com/analytics.js","ga"),ga("create","UA-123-45","auto"),ga("send","pageview"))</script><meta property="og:title" content="[TIL] OS Chapter 09: 교착 상태"><meta property="og:description" content="교착 상태(deadlock)이란 무엇이고, deadlock 발생 조건 4가지는 무엇이며, 이에 따라 deadlock 처리 방법에 대해 알아본다."><meta property="og:type" content="article"><meta property="og:url" content="http://jeha00.github.io/post/os/os_chapter_09_%EA%B5%90%EC%B0%A9%EC%83%81%ED%83%9C/"><meta property="og:image" content="http://jeha00.github.io/47"><meta property="article:section" content="post"><meta property="article:published_time" content="2022-05-10T20:38:17+09:00"><meta property="article:modified_time" content="2022-05-10T20:38:17+09:00"><meta property="og:site_name" content="JeHa00 DevLog"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="http://jeha00.github.io/47"><meta name=twitter:title content="[TIL] OS Chapter 09: 교착 상태"><meta name=twitter:description content="교착 상태(deadlock)이란 무엇이고, deadlock 발생 조건 4가지는 무엇이며, 이에 따라 deadlock 처리 방법에 대해 알아본다."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"http://jeha00.github.io/post/"},{"@type":"ListItem","position":2,"name":"[TIL] OS Chapter 09: 교착 상태","item":"http://jeha00.github.io/post/os/os_chapter_09_%EA%B5%90%EC%B0%A9%EC%83%81%ED%83%9C/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"[TIL] OS Chapter 09: 교착 상태","name":"[TIL] OS Chapter 09: 교착 상태","description":"교착 상태(deadlock)이란 무엇이고, deadlock 발생 조건 4가지는 무엇이며, 이에 따라 deadlock 처리 방법에 대해 알아본다.","keywords":["TIL","OS"],"articleBody":"0. Introduction  해당 내용은 운영체제와 정보기술의 원리 -반효경 지음- 책에는 있지 않고, kocw 이화여자대학교 운영체제 -반효경 교수- 강의만 보고 정리한 내용이다. 정확하지 않은 내용이 있다면 말씀해주시면 감사하겠습니다.   1. The Deadlock Problem  deadlock이 현실 사례 비유  누군가가 희생하지 않으면 교착 상태는 발생하지 않는다. 즉, 각자 일부 자원을 가지고 있으면서, 상대방이 가지고 있는 걸 요구하는 상황    1.1 Deadlock이란??  일련의 프로세스들이 서로가 가진 자원을 기다리며 block된 상태\n 1.2 Resource (자원)이란??   하드웨어, 소프트웨어 등을 포함하는 개념 (예) I/O device, CPU cycle, memory space, semaphore 등     프로세스가 자원을 사용하는 절차\n Request(요청) → Allocate(할당) → Use(사용) → Release(반납)    Deadlock Example 1\n 시스템에 2개의 tape drive가 있다. 프로세스 P1과 P2 각각이 하나의 tape drive를 보유한 채 다른 하나를 기다리고 있다.    Deadlock Example 2\n Binary semaphore A and B Po: P(A) → P(B) P1: P(B) → P(A)  Po는 A를 획득한 후, B를 얻고 싶어한다. P1은 반대다. 서로 반대 것을 가지고 있기 때문에, Deadlock 상황이다.       2. Deadlock 발생의 4가지 조건  아래 4가지 조건을 다 만족해야 deadlock이 발생한다.\n   첫 번째: Mutal exclusion (상호 배제)\n 매 순간 하나의 프로세스만이 자원을 사용할 수 있다. (독점적 사용)    두 번째: No preemption (비선점)\n 프로세스는 자원을 스스로 내어놓을 뿐 강제로 빼앗기지 않는다.    세 번째: Hold and wait\n 자원을 가진 프로세스가 다른 자원을 기다릴 때, 보유 자원을 놓지 않고 계속 가지고 있는다.    네 번째: Circular wait\n 자원을 기다리는 프로세스 간에 사이클이 형성되어야 한다. 프로세스 Po, P1, …. ,Pn이 있을 때  Po는 P1이 가진 자원을 기다린다. P1은 P2가 가진 자원을 기다린다. Pn-1은 Pn이 가진 자원을 기다린다. Pn은 Po이 가진 자원을 기다린다.       3. Resource - Allocation Graph  Deadlock 발생하는지 확인하기 위해, resource - allocation graph (자원 할당 그래프)를 그려본다.\n 3.1 Graph 설명   Vertex (= 꼭지점, 정점)\n Process P = {P1. P2, …., Pn} Resource R = {R1, R2,…,Rm}    Edge (= 화살표 )\n Pi → Rj: request edge = Pi가 Rj 자원을 요청한다. Rj → Pi: assignment edge = Rj 자원을 Pi 자원이 가지고 있다.    자원의 점은 instance를 의미한다\n  3.2 deadlock 확인하기 그래프에 deadlock이 있는지 어떻게 알 수 있을까?\n graph에 cycle 유무에 따라 deadlock을 판단할 수 있다.\n   1번, Cycle 無 in graph - deadlock X\n  2번 Cycle 有 in graph -\n 2-1번 one instance per resource - deadlock O 2-2번 multiple intsnace per resource - deadlock X \u0026 가능성 O      오른쪽 graph: 2-2번 case\n P4가 resource를 다 사용 후, 반납하면 P3는 이용가능해진다. P2 또한 resource를 다 사용하고 반납하면 P1이 사용가능하다. 한 resource에 여러 개의 instance가 존재하기 때문에 deadlock이 아니다.    왼쪽 graph: 2-1번 case\n R2 자원을 P1과 P2가 가지고 있으면서, P3가 이 자원을 요청하는 상황이기 때문에, deadlock 이다.     4. Deadlock 처리 방법 위로 올라갈수록 강한 방법이다. 하지만, 맨 마지막 방법을 대부분의 OS가 채택하는 이유는 deadlock을 탐색하는 것과 deadlock에 대처하는 것 모든 것이 overhead이기 때문이다.\n  첫 번째, Deadlock Prevention\n 자원 할당 시, deadlock의 4가지 필요 조건 중 어느 하나가 만족되지 않도록 하는 것    두 번째, Deadlock Avoidance\n 자원 요청에 대한 부가적인 정보를 이용해서 deadlock의 가능성이 없는 경우에만 자원을 할당 시스템 state가 원래 state로 돌아올 수 있는 경우에만 자원 할당    세 번째, Deadlock Detection and recovery\n Deadlock 발생은 허용하되, 그에 대한 detection routine을 두어 deadlock 발견시 recover    네 번째, Deadlock Ignorance\n Deadlock을 시스템이 책임지지 않는다. Unix를 포함한 대부분의 OS가 채택  Deadlock은 빈번히 발생하는 문제가 아니기 때문에, 이를 방지하기 위해 오히려 많은 overhead가 발생하기 때문에, 이 방식을 택한다.      4.1 Deadlock 처리 방법 첫 번째: deadlock prevention  Process가 resource를 요구하는 방식에 제한을 두는 방식으로, deadlock이 발생하는 4가지 필요 조건 중 어느 하나가 만족되지 않도록 하는 것\n   Mutual Exclusion\n 공유해서는 안되는 자원의 경우, 반드시 성립해야 한다. 따라서, 이 조건의 발생을 막아 deadlock을 해결하는 건 불가능하다.    Hold and wait 조건에 대한 방법\n  프로세스가 자원을 요청할 때, 다른 어떤 자원도 가지고 있지 않기\n  방법 1: 프로세스 시작 시, 모든 필요한 자원을 할당받는 방법\n 다 사용하고 나서 자원을 반납한다.    방법 2: 자원이 필요할 경우, 보유 자원을 모두 놓고 다시 요청\n hold한 자원을 다 뱉는다.    하지만, 한 번에 한 프로세스만 자원을 소유할 수 있어서 효율적이지 않다.\n  starvation이 발생할 수 있고, throughput이 낮다.\n    No Preemption 조건에 대한 방법\n Preemption을 허락하기 Process가 어떤 자원을 기다려야 하는 경우, 이미 보유한 자원이 선점된다. 모든 필요한 자원을 얻을 수 있을 때, 그 프로세스는 다시 시작된다.  이 때, starvation이 발생할 수 있다.   state를 쉽게 save하고, restore할 수 있는 자원에서 주로 사용(CPU, memory)    Circular wait 막기\n 모든 자원 유형에 할당 순서를 정하여 정해진 순서대로만 자원을 할당하기 예를 들어 순서가 3인 자원 Ri를 보유 중인 프로세스가 순서가 1인 자원 Rj를 할당받기 위해서는 우선 Rj를 release해야 한다.    하지만, 생기지도 않을 수 있는 이런 제약들로 인해서 다음과 같은 문제점을 낳기 때문에, 이 방법은 잘 사용하지 않는다.\n⇒ Utilization 저하, throughout 감소, starvation 문제\n 4.2 Deadlock 처리 방법 두 번째: deadlock avoidance  자원에 대한 사전 정보를 이용해서 deadlock의 발생 가능성을 계속 검사하여, resource-allocation state가 safe state인 경우에만 자원을 할당하는 방식\n   자원에 대한 사전 정보\n 가장 단순하고 일반적인 예: 프로세스들이 필요로 하는 각 자원별 최대 사용량을 미리 선언    safe state란??\n 시스템 내의 프로세스들에 대한 safe sequence 가 존재하는 상태 순서가 어떻든 safe sequence가 존재하면 safe state다. 시스템이  safe state이면 no deadlock unsafe state이면 possibility of deadlock 존재      safe sequence란??\n n개의 프로세스 중 하나인 Pi(1≤ i ≤ n)의 자원요청이 가용 자원 + 모든 P_j(j  에 의해 충족되는 순서 safe sequence가 존재하면 cycle을 형성하지 않는다. 조건을 만족하면 다음 방법으로 모든 프로세스의 수행을 보장한다.  Pi의 자원 요청이 즉시 충족될 수 없으면 모든 Pj(j P(i-1)이 종료되면 Pi의 자원 요청을 만족시켜 수행한다.      Deadlock Avoidance\n 시스템이 unsafe state에 들어가지 않는 것을 보장한다. 2가지 경우의 avoidance algorithum  single instance per resource types  Resource Allocation Graph algorithum 사용   Multiple instances per resource types  Banker’s Algorithum (은행원 알고리즘) 사용        4.2.1 Resource Allocation Graph algorithum: single instance per resource types  위의 resource allocation graph algorithum에 claim edge 를 추가한다. Claim edge (점선): Pi → Rj  프로세스 Pi가 자원 Rj를 미래에 요청할 수 있음을 뜻한다. 프로세스가 해당 자원 요청 시 request edge로 바뀐다. (실선: 소유하고 있다) Rj가 release되면 assignment edge는 다시 claim edge로 바뀐다.   request edge의 assignment edge 변경 시(점선을 포함하여), cycle이 생기지 않는 경우에만 요청 자원을 할당. Cycle 생성 여부 조사 시, 프로세스의 수가 n일 때 O(n^2)의 Time Complexity 를 가진다.  4.2.2 Banker’s Algorithum: multiple instances per resource types   위의 single instance일 때를 넘어서 일반화하는 algorithum 이용 가능한 자원으로 요청 양을 만족할 수 있는지 판단한다. 충족할 수 있으면 이 프로세스의 요청은 다 받아들이고, 충족되지 않으면 다 받아들여지지 않는다.     가정\n 모든 프로세스는 자원의 최대 사용량을 미리 명시  avoidance 설명대로 각 자원 별 최대 사용량을 미리 선언한 것   프로세스가 요청 자원을 모두 할당받은 경우, 유한 시간 안에 이들 자원을 다시 반납 이 알고리즘은 최악의 상황을 가정한다.    방법\n 기본 개념: 자원 요청 시, safe 상태를 유지할 경우에만 할당한다.  충분히 할당할 수 있는 자원의 수가 있어도, safe 상태를 유지하지 못하면 할당하지 않는다는 의미   총 요청 자원의 수가 가용 자원의 수보다 적은 프로세스를 선택  그런 프로세스가 없으면 unsafe 상태   그런 프로세스가 있으면 그 프로세스에게 자원을 할당 할당(allocation)받은 프로세스가 종료되면 모든 자원을 반납 (available이 된다.) 모든 프로세스가 종료될 때까지 이러한 과정 반복    사전 정보\n Allocation: 각 프로세스에 할당된 각 자원의 양 Max: 각 프로세스의 자원별로 최대 요구하는 자원의 양 Available: 각 자원 별로 현재 남아있는 자원의 양 Need: 각 프로세스의 추가로 요청 가능한 자원의 양      Resource\n 총 자원: A 10개,B 5개, C 7개 A = 2 + 3 + 2 = 7 이고, 가용자원으로 A가 3개임을 확인할 수 있다. P0의 할당된 자원 B를 반납하면 이용가능한 B 자원의 수는 늘어난다.    safe sequence\n  P0: P0에 추가로 할당할 수 있는 자원이 존재하지만, Need한 만큼 요청하면 가용자원만으로는 불가능하기 때문에, 요청을 받아들이지 않고, 기다린다.\n  P1: 최대 필요 요청은 가용 자원으로 충분히 가능하기 때문에, P0와 달리 받아들인다.\n  P1이 가용자원을 가져가서 다 사용 후, 자원을 반납하면 available resource에 추가되고 P3가 그걸로 가능하다.\n 이런 순서가 나타나는게 P1,P3,P4,P2,P0다. 이런 순서가 존재하면 절대 dead lock이 발생하지 않는 safe state다.      뱅커스 알고리즘 이렇게 최대요청을 해도 deadlock이 발생하지 않는 상황에서만 요청을 받아들여 deadlock을 피해간다.\n 하지만, 이는 혹시 모를 상황을 대비하기 때문에 비효율적이다.     4.3 Deadlock Detection and Recovery  알고리즘을 통해 현재 시스템에 deadlock이 있는지 찾고, 알고리즘을 통해 deadlock을 복구하는 것\n 4.3.1 Single instance per resource type  wait-for graph algorithum을 사용하며, deadlock detection을 하기 위해서는 wait-for graph에서 cycle이 있는지를 판단한다.\n   wait-for graph\n  cycle이 곧 deadlock을 의미한다.\n  자원 할당 그래프의 변형\n  프로세스만으로 node 구성\n  Edge 의미\n Pk → Pj: Pj가 가지고 있는 자원을 Pk가 기다리는 경우 R(resource) → P: 이 자원을 P가 소유하고 있다. P - R(resource): P가 이 자원을 요청한다. 자원의 최대 사용량을 미리 알릴 필요가 없기 때문에, 그래프에 점선이 없다.      algorithum\n wait-for grpah에 cycle이 존재하는지를 주기적으로 조사 O(n^(2))    Resource-allocation graph에서 자원을 빼면 coreesponding wait-for graph가 된다.\n  4.3.1 Multiple instance per resource type  deadlock 찾는 방법은 banker’s algorithum과 유사한 방법 활용\n   Deadlock 존재 유무를 판단하기 위해서는 deadlock avoidance와 반대로 매우 보수적인 판단이 아닌, 긍정적인 판단을 해야 한다.\n 긍정적으로 바라보기 때문에, 각 프로세스는 가지고 있는 자원을 반납할 것이라 본다.    Deadlock 확인하기\n 가용자원(Avaoilable)이 몇 개 있는지 확인한다. 요청하지 않은 프로세스의 자원도 가용자원으로 합친다. 합친 가용자원으로 처리 가능한지 확인한다. 처리 후 처리된 프로세스의 자원도 합쳐서, 모든 프로세스가 끝낼 수 있는지 확인한다.    Deadlock detection과 recovery도 overhead가 크다.\n  4.3.2 Recovery   Process termination\n abort all deadlocked processes abort one process at a time until the deadlock cycle is eliminated    Resource Preemption\n 비용을 최소화할 victim으로 선정 safe state로 rollback하여 process를 restart starvation 문제  동일한 프로세스가 계속해서 victim으로 선정되는 경우 cost factor에 rollback 횟수도 같이 고려       4.4 Deadlock Ignorance  Deadlock이 일어나지 않는다고 생각하고, 아무런 조치도 취하지 않는 방식\n  Deadlock이 매우 드물게 발생하므로, deadlock에 대한 조치 자체가 더 큰 overhead일 수 있다. 만약 시스템에 deadlock이 발생한 경우, 직접 process를 죽이는 등의 방법으로 대처한다.  만약 한 번에 deadlock의 원인이 되는 process를 죽이면 효율적이지만, 원인이 되는 process가 죽을 수도 있다.   UNIX, Windows 등 대부분의 범용 OS가 채택하는 방식이다.    Reference  kocw 이화여자대학교 운영체제 - 반효경 교수 -  ","wordCount":"1553","inLanguage":"en","datePublished":"2022-05-10T20:38:17+09:00","dateModified":"2022-05-10T20:38:17+09:00","author":{"@type":"Person","name":"Jeha00"},"mainEntityOfPage":{"@type":"WebPage","@id":"http://jeha00.github.io/post/os/os_chapter_09_%EA%B5%90%EC%B0%A9%EC%83%81%ED%83%9C/"},"publisher":{"@type":"Organization","name":"Jeha00 DevLog","logo":{"@type":"ImageObject","url":"http://jeha00.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=http://jeha00.github.io/ accesskey=h title="Jeha00 (Alt + H)">Jeha00</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></span></div><ul id=menu><li><a href=http://jeha00.github.io/archives/ title=Archive><span>Archive</span></a></li><li><a href=http://jeha00.github.io/categories/ title=Categories><span>Categories</span></a></li><li><a href=http://jeha00.github.io/tags/ title=Tags><span>Tags</span></a></li><li><a href=http://jeha00.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=http://jeha00.github.io/>Home</a>&nbsp;»&nbsp;<a href=http://jeha00.github.io/post/>Posts</a></div><h1 class=post-title>[TIL] OS Chapter 09: 교착 상태</h1><div class=post-meta><span title="2022-05-10 20:38:17 +0900 KST">May 10, 2022</span>&nbsp;·&nbsp;8 min&nbsp;·&nbsp;Jeha00&nbsp;|&nbsp;<a href=https://github.com/JeHa00/blog/content/post/OS/OS_Chapter_09_%ea%b5%90%ec%b0%a9%ec%83%81%ed%83%9c.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#0-introduction aria-label="0. Introduction">0. Introduction</a></li><li><a href=#1-the-deadlock-problem aria-label="1. The Deadlock Problem">1. The Deadlock Problem</a><ul><li><a href=#11-deadlock%ec%9d%b4%eb%9e%80 aria-label="1.1 Deadlock이란??">1.1 Deadlock이란??</a></li><li><a href=#12-resource-%ec%9e%90%ec%9b%90%ec%9d%b4%eb%9e%80 aria-label="1.2 Resource (자원)이란??">1.2 Resource (자원)이란??</a></li></ul></li><li><a href=#2-deadlock-%eb%b0%9c%ec%83%9d%ec%9d%98-4%ea%b0%80%ec%a7%80-%ec%a1%b0%ea%b1%b4 aria-label="2. Deadlock 발생의 4가지 조건">2. Deadlock 발생의 4가지 조건</a></li><li><a href=#3-resource---allocation-graph aria-label="3. Resource - Allocation Graph">3. Resource - Allocation Graph</a><ul><li><a href=#31-graph-%ec%84%a4%eb%aa%85 aria-label="3.1 Graph 설명">3.1 Graph 설명</a></li><li><a href=#32-deadlock-%ed%99%95%ec%9d%b8%ed%95%98%ea%b8%b0 aria-label="3.2 deadlock 확인하기">3.2 deadlock 확인하기</a></li></ul></li><li><a href=#4-deadlock-%ec%b2%98%eb%a6%ac-%eb%b0%a9%eb%b2%95 aria-label="4. Deadlock 처리 방법">4. Deadlock 처리 방법</a><ul><li><a href=#41-deadlock-%ec%b2%98%eb%a6%ac-%eb%b0%a9%eb%b2%95-%ec%b2%ab-%eb%b2%88%ec%a7%b8-deadlock-prevention aria-label="4.1 Deadlock 처리 방법 첫 번째: deadlock prevention">4.1 Deadlock 처리 방법 첫 번째: deadlock prevention</a></li><li><a href=#42-deadlock-%ec%b2%98%eb%a6%ac-%eb%b0%a9%eb%b2%95-%eb%91%90-%eb%b2%88%ec%a7%b8-deadlock-avoidance aria-label="4.2 Deadlock 처리 방법 두 번째: deadlock avoidance">4.2 Deadlock 처리 방법 두 번째: deadlock avoidance</a><ul><li><a href=#421-resource-allocation-graph-algorithum-single-instance-per-resource-types aria-label="4.2.1 Resource Allocation Graph algorithum: single instance per resource types">4.2.1 Resource Allocation Graph algorithum: single instance per resource types</a></li><li><a href=#422-bankers-algorithum-multiple-instances-per-resource-types aria-label="4.2.2 Banker’s Algorithum: multiple instances per resource types">4.2.2 Banker’s Algorithum: multiple instances per resource types</a></li></ul></li><li><a href=#43-deadlock-detection-and-recovery aria-label="4.3 Deadlock Detection and Recovery">4.3 Deadlock Detection and Recovery</a><ul><li><a href=#431-single-instance-per-resource-type aria-label="4.3.1 Single instance per resource type">4.3.1 Single instance per resource type</a></li><li><a href=#431-multiple-instance-per-resource-type aria-label="4.3.1 Multiple instance per resource type">4.3.1 Multiple instance per resource type</a></li><li><a href=#432-recovery aria-label="4.3.2 Recovery">4.3.2 Recovery</a></li></ul></li><li><a href=#44-deadlock-ignorance aria-label="4.4 Deadlock Ignorance">4.4 Deadlock Ignorance</a></li></ul></li><li><a href=#reference aria-label=Reference>Reference</a></li></ul></div></details></div><div class=post-content><h1 id=0-introduction>0. Introduction<a hidden class=anchor aria-hidden=true href=#0-introduction>#</a></h1><ul><li>해당 내용은 <a href="http://www.kyobobook.co.kr/product/detailViewKor.laf?ejkGb=KOR&mallGb=KOR&barcode=9791158903589&orderClick=LAG&Kc=">운영체제와 정보기술의 원리 -반효경 지음-</a> 책에는 있지 않고, <a href="http://www.kocw.net/home/cview.do?lid=3dd1117c48123b8e">kocw 이화여자대학교 운영체제 -반효경 교수-</a> 강의만 보고 정리한 내용이다.</li><li>정확하지 않은 내용이 있다면 말씀해주시면 감사하겠습니다.</li></ul><hr><h1 id=1-the-deadlock-problem>1. The Deadlock Problem<a hidden class=anchor aria-hidden=true href=#1-the-deadlock-problem>#</a></h1><p><img loading=lazy src=https://user-images.githubusercontent.com/78094972/167450136-f73b9f27-c423-4563-b50a-2900a52e508f.png alt=Deadlock_1.PNG></p><ul><li><strong>deadlock이 현실 사례 비유</strong><ul><li>누군가가 희생하지 않으면 교착 상태는 발생하지 않는다.</li><li>즉, 각자 일부 자원을 가지고 있으면서, 상대방이 가지고 있는 걸 요구하는 상황</li></ul></li></ul><h2 id=11-deadlock이란>1.1 Deadlock이란??<a hidden class=anchor aria-hidden=true href=#11-deadlock이란>#</a></h2><blockquote><p><strong>일련의 프로세스들이 서로가 가진 자원을 기다리며 block된 상태</strong></p></blockquote><h2 id=12-resource-자원이란>1.2 Resource (자원)이란??<a hidden class=anchor aria-hidden=true href=#12-resource-자원이란>#</a></h2><blockquote><ul><li><strong>하드웨어, 소프트웨어 등을 포함하는 개념</strong></li><li>(예) I/O device, CPU cycle, memory space, semaphore 등</li></ul></blockquote><ul><li><p><strong>프로세스가 자원을 사용하는 절차</strong></p><ul><li>Request(요청) → Allocate(할당) → Use(사용) → Release(반납)</li></ul></li><li><p><strong>Deadlock Example 1</strong></p><ul><li>시스템에 2개의 tape drive가 있다.</li><li>프로세스 P1과 P2 각각이 하나의 tape drive를 보유한 채 다른 하나를 기다리고 있다.</li></ul></li><li><p><strong>Deadlock Example 2</strong></p><ul><li>Binary semaphore A and B</li><li>Po: P(A) → P(B)</li><li>P1: P(B) → P(A)<ul><li>Po는 A를 획득한 후, B를 얻고 싶어한다. P1은 반대다.</li><li>서로 반대 것을 가지고 있기 때문에, Deadlock 상황이다.</li></ul></li></ul></li></ul><hr><h1 id=2-deadlock-발생의-4가지-조건>2. Deadlock 발생의 4가지 조건<a hidden class=anchor aria-hidden=true href=#2-deadlock-발생의-4가지-조건>#</a></h1><blockquote><p><strong>아래 4가지 조건을 다 만족해야 deadlock이 발생한다.</strong></p></blockquote><ul><li><p><strong>첫 번째: Mutal exclusion (상호 배제)</strong></p><ul><li>매 순간 하나의 프로세스만이 자원을 사용할 수 있다. (독점적 사용)</li></ul></li><li><p><strong>두 번째: No preemption (비선점)</strong></p><ul><li>프로세스는 자원을 스스로 내어놓을 뿐 강제로 빼앗기지 않는다.</li></ul></li><li><p><strong>세 번째: Hold and wait</strong></p><ul><li>자원을 가진 프로세스가 다른 자원을 기다릴 때, 보유 자원을 놓지 않고 계속 가지고 있는다.</li></ul></li><li><p><strong>네 번째: Circular wait</strong></p><ul><li>자원을 기다리는 프로세스 간에 사이클이 형성되어야 한다.</li><li>프로세스 Po, P1, &mldr;. ,Pn이 있을 때<ul><li>Po는 P1이 가진 자원을 기다린다.</li><li>P1은 P2가 가진 자원을 기다린다.</li><li>Pn-1은 Pn이 가진 자원을 기다린다.</li><li>Pn은 Po이 가진 자원을 기다린다.</li></ul></li></ul></li></ul><hr><h1 id=3-resource---allocation-graph>3. Resource - Allocation Graph<a hidden class=anchor aria-hidden=true href=#3-resource---allocation-graph>#</a></h1><blockquote><p>Deadlock 발생하는지 확인하기 위해, resource - allocation graph (자원 할당 그래프)를 그려본다.</p></blockquote><h2 id=31-graph-설명>3.1 Graph 설명<a hidden class=anchor aria-hidden=true href=#31-graph-설명>#</a></h2><p><img loading=lazy src=https://user-images.githubusercontent.com/78094972/167449422-f5cbb6bc-0ccf-4094-b5df-aa427f592ede.PNG alt=Resource_allocation_graph.PNG></p><ul><li><p><strong>Vertex (= 꼭지점, 정점)</strong></p><ul><li>Process P = {P1. P2, &mldr;., Pn}</li><li>Resource R = {R1, R2,&mldr;,Rm}</li></ul></li><li><p><strong>Edge (= 화살표 )</strong></p><ul><li>Pi → Rj: request edge = Pi가 Rj 자원을 요청한다.</li><li>Rj → Pi: assignment edge = Rj 자원을 Pi 자원이 가지고 있다.</li></ul></li><li><p><strong>자원의 점은 instance를 의미한다</strong></p></li></ul><h2 id=32-deadlock-확인하기>3.2 deadlock 확인하기<a hidden class=anchor aria-hidden=true href=#32-deadlock-확인하기>#</a></h2><p>그래프에 deadlock이 있는지 어떻게 알 수 있을까?</p><blockquote><p>graph에 cycle 유무에 따라 deadlock을 판단할 수 있다.</p></blockquote><ul><li><p>1번, Cycle 無 in graph -> <strong>deadlock</strong> X</p></li><li><p>2번 <strong>Cycle 有 in graph -></strong></p><ul><li>2-1번 one instance per resource -> <strong>deadlock</strong> O</li><li>2-2번 multiple intsnace per resource -> <strong>deadlock</strong> X & 가능성 O</li></ul></li></ul><p><img loading=lazy src=https://user-images.githubusercontent.com/78094972/167449427-18a2166c-537c-405e-afc1-5db0bf276b6c.PNG alt=Resource_allocation_graph_1.PNG></p><ul><li><p><strong>오른쪽 graph: 2-2번 case</strong></p><ul><li>P4가 resource를 다 사용 후, 반납하면 P3는 이용가능해진다.</li><li>P2 또한 resource를 다 사용하고 반납하면 P1이 사용가능하다.</li><li>한 resource에 여러 개의 instance가 존재하기 때문에 deadlock이 아니다.</li></ul></li><li><p><strong>왼쪽 graph: 2-1번 case</strong></p><ul><li>R2 자원을 P1과 P2가 가지고 있으면서, P3가 이 자원을 요청하는 상황이기 때문에, deadlock 이다.</li></ul></li></ul><hr><h1 id=4-deadlock-처리-방법>4. Deadlock 처리 방법<a hidden class=anchor aria-hidden=true href=#4-deadlock-처리-방법>#</a></h1><p>위로 올라갈수록 강한 방법이다. 하지만, 맨 마지막 방법을 대부분의 OS가 채택하는 이유는 deadlock을 탐색하는 것과 deadlock에 대처하는 것 모든 것이 overhead이기 때문이다.</p><ul><li><p><strong>첫 번째, Deadlock Prevention</strong></p><ul><li>자원 할당 시, deadlock의 4가지 필요 조건 중 <strong>어느 하나가 만족되지 않도록 하는 것</strong></li></ul></li><li><p><strong>두 번째, Deadlock Avoidance</strong></p><ul><li>자원 요청에 대한 부가적인 정보를 이용해서 <strong>deadlock의 가능성이 없는 경우에만 자원을 할당</strong></li><li>시스템 state가 원래 state로 돌아올 수 있는 경우에만 자원 할당</li></ul></li><li><p><strong>세 번째, Deadlock Detection and recovery</strong></p><ul><li>Deadlock 발생은 허용하되, 그에 대한 detection routine을 두어 deadlock 발견시 recover</li></ul></li><li><p><strong>네 번째, Deadlock Ignorance</strong></p><ul><li>Deadlock을 시스템이 책임지지 않는다.</li><li>Unix를 포함한 대부분의 OS가 채택<ul><li>Deadlock은 빈번히 발생하는 문제가 아니기 때문에, 이를 방지하기 위해 오히려 많은 overhead가 발생하기 때문에, 이 방식을 택한다.</li></ul></li></ul></li></ul><h2 id=41-deadlock-처리-방법-첫-번째-deadlock-prevention>4.1 Deadlock 처리 방법 첫 번째: deadlock prevention<a hidden class=anchor aria-hidden=true href=#41-deadlock-처리-방법-첫-번째-deadlock-prevention>#</a></h2><blockquote><p><strong>Process가 resource를 요구하는 방식에 제한을 두는 방식으로, deadlock이 발생하는 4가지 필요 조건 중 어느 하나가 만족되지 않도록 하는 것</strong></p></blockquote><ul><li><p><strong>Mutual Exclusion</strong></p><ul><li>공유해서는 안되는 자원의 경우, 반드시 성립해야 한다.</li><li>따라서, 이 조건의 발생을 막아 deadlock을 해결하는 건 불가능하다.</li></ul></li><li><p><strong>Hold and wait 조건에 대한 방법</strong></p><ul><li><p>프로세스가 자원을 요청할 때, 다른 어떤 자원도 가지고 있지 않기</p></li><li><p>방법 1: 프로세스 시작 시, 모든 필요한 자원을 할당받는 방법</p><ul><li>다 사용하고 나서 자원을 반납한다.</li></ul></li><li><p>방법 2: 자원이 필요할 경우, 보유 자원을 모두 놓고 다시 요청</p><ul><li>hold한 자원을 다 뱉는다.</li></ul></li><li><p>하지만, 한 번에 한 프로세스만 자원을 소유할 수 있어서 효율적이지 않다.</p></li><li><p>starvation이 발생할 수 있고, throughput이 낮다.</p></li></ul></li><li><p><strong>No Preemption 조건에 대한 방법</strong></p><ul><li>Preemption을 허락하기</li><li>Process가 어떤 자원을 기다려야 하는 경우, 이미 보유한 자원이 선점된다.</li><li>모든 필요한 자원을 얻을 수 있을 때, 그 프로세스는 다시 시작된다.<ul><li>이 때, starvation이 발생할 수 있다.</li></ul></li><li>state를 쉽게 save하고, restore할 수 있는 자원에서 주로 사용(CPU, memory)</li></ul></li><li><p><strong>Circular wait 막기</strong></p><ul><li>모든 자원 유형에 할당 순서를 정하여 정해진 순서대로만 자원을 할당하기</li><li>예를 들어 순서가 3인 자원 Ri를 보유 중인 프로세스가 순서가 1인 자원 Rj를 할당받기 위해서는 우선 Rj를 release해야 한다.</li></ul></li></ul><p>하지만, 생기지도 않을 수 있는 이런 제약들로 인해서 다음과 같은 문제점을 낳기 때문에, 이 방법은 잘 사용하지 않는다.</p><p>⇒ <strong><em>Utilization 저하, throughout 감소, starvation 문제</em></strong></p><hr><h2 id=42-deadlock-처리-방법-두-번째-deadlock-avoidance>4.2 Deadlock 처리 방법 두 번째: deadlock avoidance<a hidden class=anchor aria-hidden=true href=#42-deadlock-처리-방법-두-번째-deadlock-avoidance>#</a></h2><blockquote><p><strong><em>자원에 대한 사전 정보를 이용해서 deadlock의 발생 가능성을 계속 검사하여, resource-allocation state가 safe state인 경우에만 자원을 할당하는 방식</em></strong></p></blockquote><ul><li><p><strong>자원에 대한 사전 정보</strong></p><ul><li>가장 단순하고 일반적인 예: 프로세스들이 필요로 하는 <strong>각 자원별 최대 사용량을 미리 선언</strong></li></ul></li><li><p><strong>safe state란??</strong></p><ul><li>시스템 내의 프로세스들에 대한 <em>safe sequence</em> 가 존재하는 상태</li><li>순서가 어떻든 safe sequence가 존재하면 safe state다.</li><li>시스템이<ul><li>safe state이면 no deadlock</li><li>unsafe state이면 possibility of deadlock 존재</li></ul></li></ul></li><li><p><strong>safe sequence란??</strong></p><ul><li>n개의 프로세스 중 하나인 Pi(1≤ i ≤ n)의 자원요청이 <strong><em>가용 자원 + 모든 P_j(j &lt; i)의 보유자원</em></strong> 에 의해 충족되는 순서</li><li>safe sequence가 존재하면 cycle을 형성하지 않는다.</li><li>조건을 만족하면 다음 방법으로 모든 프로세스의 수행을 보장한다.<ul><li>Pi의 자원 요청이 즉시 충족될 수 없으면 모든 Pj(j &lt;p i) 가 종료될 때까지 기다린다.</li><li>P(i-1)이 종료되면 Pi의 자원 요청을 만족시켜 수행한다.</li></ul></li></ul></li><li><p>Deadlock Avoidance</p><ul><li>시스템이 unsafe state에 들어가지 않는 것을 보장한다.</li><li>2가지 경우의 avoidance algorithum<ul><li><strong>single instance</strong> per resource types<ul><li><strong>Resource Allocation Graph algorithum 사용</strong></li></ul></li><li><strong>Multiple instances</strong> per resource types<ul><li><strong>Banker’s Algorithum (은행원 알고리즘) 사용</strong></li></ul></li></ul></li></ul></li></ul><h3 id=421-resource-allocation-graph-algorithum-single-instance-per-resource-types>4.2.1 Resource Allocation Graph algorithum: single instance per resource types<a hidden class=anchor aria-hidden=true href=#421-resource-allocation-graph-algorithum-single-instance-per-resource-types>#</a></h3><ul><li>위의 resource allocation graph algorithum에 <strong><em>claim edge</em></strong> 를 추가한다.</li><li><strong>Claim edge (점선):</strong> Pi → Rj<ul><li>프로세스 Pi가 자원 Rj를 <em>미래에</em> 요청할 수 있음을 뜻한다.</li><li>프로세스가 해당 자원 요청 시 request edge로 바뀐다. (실선: 소유하고 있다)</li><li>Rj가 release되면 assignment edge는 다시 claim edge로 바뀐다.</li></ul></li><li>request edge의 assignment edge 변경 시(점선을 포함하여), cycle이 생기지 않는 경우에만 요청 자원을 할당.</li><li>Cycle 생성 여부 조사 시, 프로세스의 수가 n일 때 O(n^2)의 Time Complexity 를 가진다.</li></ul><p><img loading=lazy src=https://user-images.githubusercontent.com/78094972/167449436-43b0974d-ae85-4c50-b61d-7a5a70412b3e.PNG alt=Resource_allocation_graph_algorithum.PNG></p><h3 id=422-bankers-algorithum-multiple-instances-per-resource-types>4.2.2 Banker’s Algorithum: multiple instances per resource types<a hidden class=anchor aria-hidden=true href=#422-bankers-algorithum-multiple-instances-per-resource-types>#</a></h3><blockquote><ul><li>위의 single instance일 때를 넘어서 일반화하는 algorithum</li><li>이용 가능한 자원으로 요청 양을 만족할 수 있는지 판단한다. 충족할 수 있으면 이 프로세스의 요청은 다 받아들이고, 충족되지 않으면 다 받아들여지지 않는다.</li></ul></blockquote><ul><li><p><strong>가정</strong></p><ul><li>모든 프로세스는 자원의 최대 사용량을 미리 명시<ul><li>avoidance 설명대로 각 자원 별 최대 사용량을 미리 선언한 것</li></ul></li><li>프로세스가 요청 자원을 모두 할당받은 경우, 유한 시간 안에 이들 자원을 다시 반납</li><li>이 알고리즘은 최악의 상황을 가정한다.</li></ul></li><li><p><strong>방법</strong></p><ul><li>기본 개념: 자원 요청 시, safe 상태를 유지할 경우에만 할당한다.<ul><li>충분히 할당할 수 있는 자원의 수가 있어도, safe 상태를 유지하지 못하면 할당하지 않는다는 의미</li></ul></li><li>총 요청 자원의 수가 가용 자원의 수보다 적은 프로세스를 선택<ul><li>그런 프로세스가 없으면 unsafe 상태</li></ul></li><li>그런 프로세스가 있으면 그 프로세스에게 자원을 할당</li><li>할당(allocation)받은 프로세스가 종료되면 모든 자원을 반납 (available이 된다.)</li><li>모든 프로세스가 종료될 때까지 이러한 과정 반복</li></ul></li><li><p><strong>사전 정보</strong></p><ul><li>Allocation: 각 프로세스에 할당된 각 자원의 양</li><li>Max: 각 프로세스의 자원별로 최대 요구하는 자원의 양</li><li>Available: 각 자원 별로 현재 남아있는 자원의 양</li><li>Need: 각 프로세스의 추가로 요청 가능한 자원의 양</li></ul></li></ul><p><img loading=lazy src=https://user-images.githubusercontent.com/78094972/167449405-f2a65211-5ccf-412b-b8da-6ea500ab81d3.PNG alt=Banker_algorithum.PNG></p><ul><li><p><strong>Resource</strong></p><ul><li>총 자원: A 10개,B 5개, C 7개</li><li>A = 2 + 3 + 2 = 7 이고, 가용자원으로 A가 3개임을 확인할 수 있다.</li><li>P0의 할당된 자원 B를 반납하면 이용가능한 B 자원의 수는 늘어난다.</li></ul></li><li><p><strong>safe sequence</strong></p><ul><li><p>P0: P0에 추가로 할당할 수 있는 자원이 존재하지만, Need한 만큼 요청하면 가용자원만으로는 불가능하기 때문에, 요청을 받아들이지 않고, 기다린다.</p></li><li><p>P1: 최대 필요 요청은 가용 자원으로 충분히 가능하기 때문에, P0와 달리 받아들인다.</p></li><li><p>P1이 가용자원을 가져가서 다 사용 후, 자원을 반납하면 available resource에 추가되고 P3가 그걸로 가능하다.</p><ul><li>이런 순서가 나타나는게 P1,P3,P4,P2,P0다.</li><li>이런 순서가 존재하면 절대 dead lock이 발생하지 않는 safe state다.</li></ul></li></ul></li><li><p>뱅커스 알고리즘 이렇게 최대요청을 해도 deadlock이 발생하지 않는 상황에서만 요청을 받아들여 deadlock을 피해간다.</p><ul><li>하지만, 이는 혹시 모를 상황을 대비하기 때문에 비효율적이다.</li></ul></li></ul><hr><h2 id=43-deadlock-detection-and-recovery>4.3 Deadlock Detection and Recovery<a hidden class=anchor aria-hidden=true href=#43-deadlock-detection-and-recovery>#</a></h2><blockquote><p>알고리즘을 통해 현재 시스템에 deadlock이 있는지 찾고, 알고리즘을 통해 deadlock을 복구하는 것</p></blockquote><h3 id=431-single-instance-per-resource-type>4.3.1 Single instance per resource type<a hidden class=anchor aria-hidden=true href=#431-single-instance-per-resource-type>#</a></h3><blockquote><p>wait-for graph algorithum을 사용하며, deadlock detection을 하기 위해서는 wait-for graph에서 cycle이 있는지를 판단한다.</p></blockquote><p><img loading=lazy src=https://user-images.githubusercontent.com/78094972/167449417-473a5dfa-cfdb-4ec7-9655-6338e5baca3b.PNG alt=deadlock_detection_recovery.PNG></p><ul><li><p><strong>wait-for graph</strong></p><ul><li><p>cycle이 곧 deadlock을 의미한다.</p></li><li><p>자원 할당 그래프의 변형</p></li><li><p>프로세스만으로 node 구성</p></li><li><p>Edge 의미</p><ul><li>Pk → Pj: Pj가 가지고 있는 자원을 Pk가 기다리는 경우</li><li>R(resource) → P: 이 자원을 P가 소유하고 있다.</li><li>P -> R(resource): P가 이 자원을 요청한다.</li><li>자원의 최대 사용량을 미리 알릴 필요가 없기 때문에, 그래프에 점선이 없다.</li></ul></li></ul></li><li><p><strong>algorithum</strong></p><ul><li>wait-for grpah에 cycle이 존재하는지를 주기적으로 조사</li><li>O(n^(2))</li></ul></li><li><p><strong>Resource-allocation graph에서 자원을 빼면 coreesponding wait-for graph가 된다.</strong></p></li></ul><h3 id=431-multiple-instance-per-resource-type>4.3.1 Multiple instance per resource type<a hidden class=anchor aria-hidden=true href=#431-multiple-instance-per-resource-type>#</a></h3><blockquote><p>deadlock 찾는 방법은 banker’s algorithum과 유사한 방법 활용</p></blockquote><p><img loading=lazy src=https://user-images.githubusercontent.com/78094972/167449419-f0d2688c-c311-47fb-b2a9-afd992598822.PNG alt="deadlock_detection_recovery_multiple instance.PNG"></p><ul><li><p>Deadlock 존재 유무를 판단하기 위해서는 deadlock avoidance와 반대로 매우 보수적인 판단이 아닌, 긍정적인 판단을 해야 한다.</p><ul><li>긍정적으로 바라보기 때문에, 각 프로세스는 가지고 있는 자원을 반납할 것이라 본다.</li></ul></li><li><p><strong>Deadlock 확인하기</strong></p><ol><li>가용자원(Avaoilable)이 몇 개 있는지 확인한다.</li><li>요청하지 않은 프로세스의 자원도 가용자원으로 합친다.</li><li>합친 가용자원으로 처리 가능한지 확인한다.</li><li>처리 후 처리된 프로세스의 자원도 합쳐서, 모든 프로세스가 끝낼 수 있는지 확인한다.</li></ol></li><li><p>Deadlock detection과 recovery도 overhead가 크다.</p></li></ul><h3 id=432-recovery>4.3.2 Recovery<a hidden class=anchor aria-hidden=true href=#432-recovery>#</a></h3><ul><li><p><strong>Process termination</strong></p><ul><li>abort <strong><em>all</em></strong> deadlocked processes</li><li>abort <strong><em>one process at a time</em></strong> until the deadlock cycle is eliminated</li></ul></li><li><p><strong>Resource Preemption</strong></p><ul><li>비용을 최소화할 victim으로 선정</li><li>safe state로 rollback하여 process를 restart</li><li>starvation 문제<ul><li>동일한 프로세스가 계속해서 victim으로 선정되는 경우</li><li>cost factor에 rollback 횟수도 같이 고려</li></ul></li></ul></li></ul><hr><h2 id=44-deadlock-ignorance>4.4 Deadlock Ignorance<a hidden class=anchor aria-hidden=true href=#44-deadlock-ignorance>#</a></h2><blockquote><p>Deadlock이 일어나지 않는다고 생각하고, 아무런 조치도 취하지 않는 방식</p></blockquote><ul><li>Deadlock이 매우 드물게 발생하므로, deadlock에 대한 조치 자체가 더 큰 overhead일 수 있다.</li><li>만약 시스템에 deadlock이 발생한 경우, 직접 process를 죽이는 등의 방법으로 대처한다.<ul><li>만약 한 번에 deadlock의 원인이 되는 process를 죽이면 효율적이지만, 원인이 되는 process가 죽을 수도 있다.</li></ul></li><li>UNIX, Windows 등 대부분의 범용 OS가 채택하는 방식이다.</li></ul><hr><h1 id=reference>Reference<a hidden class=anchor aria-hidden=true href=#reference>#</a></h1><ul><li><a href="http://www.kocw.net/home/cview.do?lid=3dd1117c48123b8e">kocw 이화여자대학교 운영체제 - 반효경 교수 -</a></li></ul></div><footer class=post-footer><ul class=post-tags><li><a href=http://jeha00.github.io/tags/til/>TIL</a></li><li><a href=http://jeha00.github.io/tags/os/>OS</a></li></ul><nav class=paginav><a class=prev href=http://jeha00.github.io/post/python/python_basic_43_underscore/><span class=title>« Prev Page</span><br><span>[TIL] Python basic 43: Underscore</span></a>
<a class=next href=http://jeha00.github.io/post/os/os_chapter_08_%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4_%EB%8F%99%EA%B8%B0%ED%99%94_2/><span class=title>Next Page »</span><br><span>[TIL] OS Chapter 08: 프로세스 동기화 2</span></a></nav><div class=share-buttons><a target=_blank rel="noopener noreferrer" aria-label="share [TIL] OS Chapter 09: 교착 상태 on twitter" href="https://twitter.com/intent/tweet/?text=%5bTIL%5d%20OS%20Chapter%2009%3a%20%ea%b5%90%ec%b0%a9%20%ec%83%81%ed%83%9c&url=http%3a%2f%2fjeha00.github.io%2fpost%2fos%2fos_chapter_09_%25EA%25B5%2590%25EC%25B0%25A9%25EC%2583%2581%25ED%2583%259C%2f&hashtags=TIL%2cOS"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM195.519 424.544c135.939.0 210.268-112.643 210.268-210.268.0-3.218.0-6.437-.153-9.502 14.406-10.421 26.973-23.448 36.935-38.314-13.18 5.824-27.433 9.809-42.452 11.648 15.326-9.196 26.973-23.602 32.49-40.92-14.252 8.429-30.038 14.56-46.896 17.931-13.487-14.406-32.644-23.295-53.946-23.295-40.767.0-73.87 33.104-73.87 73.87.0 5.824.613 11.494 1.992 16.858-61.456-3.065-115.862-32.49-152.337-77.241-6.284 10.881-9.962 23.601-9.962 37.088.0 25.594 13.027 48.276 32.95 61.456-12.107-.307-23.448-3.678-33.41-9.196v.92c0 35.862 25.441 65.594 59.311 72.49-6.13 1.686-12.72 2.606-19.464 2.606-4.751.0-9.348-.46-13.946-1.38 9.349 29.426 36.628 50.728 68.965 51.341-25.287 19.771-57.164 31.571-91.8 31.571-5.977.0-11.801-.306-17.625-1.073 32.337 21.15 71.264 33.41 112.95 33.41z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share [TIL] OS Chapter 09: 교착 상태 on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&url=http%3a%2f%2fjeha00.github.io%2fpost%2fos%2fos_chapter_09_%25EA%25B5%2590%25EC%25B0%25A9%25EC%2583%2581%25ED%2583%259C%2f&title=%5bTIL%5d%20OS%20Chapter%2009%3a%20%ea%b5%90%ec%b0%a9%20%ec%83%81%ed%83%9c&summary=%5bTIL%5d%20OS%20Chapter%2009%3a%20%ea%b5%90%ec%b0%a9%20%ec%83%81%ed%83%9c&source=http%3a%2f%2fjeha00.github.io%2fpost%2fos%2fos_chapter_09_%25EA%25B5%2590%25EC%25B0%25A9%25EC%2583%2581%25ED%2583%259C%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share [TIL] OS Chapter 09: 교착 상태 on reddit" href="https://reddit.com/submit?url=http%3a%2f%2fjeha00.github.io%2fpost%2fos%2fos_chapter_09_%25EA%25B5%2590%25EC%25B0%25A9%25EC%2583%2581%25ED%2583%259C%2f&title=%5bTIL%5d%20OS%20Chapter%2009%3a%20%ea%b5%90%ec%b0%a9%20%ec%83%81%ed%83%9c"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share [TIL] OS Chapter 09: 교착 상태 on facebook" href="https://facebook.com/sharer/sharer.php?u=http%3a%2f%2fjeha00.github.io%2fpost%2fos%2fos_chapter_09_%25EA%25B5%2590%25EC%25B0%25A9%25EC%2583%2581%25ED%2583%259C%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share [TIL] OS Chapter 09: 교착 상태 on whatsapp" href="https://api.whatsapp.com/send?text=%5bTIL%5d%20OS%20Chapter%2009%3a%20%ea%b5%90%ec%b0%a9%20%ec%83%81%ed%83%9c%20-%20http%3a%2f%2fjeha00.github.io%2fpost%2fos%2fos_chapter_09_%25EA%25B5%2590%25EC%25B0%25A9%25EC%2583%2581%25ED%2583%259C%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share [TIL] OS Chapter 09: 교착 상태 on telegram" href="https://telegram.me/share/url?text=%5bTIL%5d%20OS%20Chapter%2009%3a%20%ea%b5%90%ec%b0%a9%20%ec%83%81%ed%83%9c&url=http%3a%2f%2fjeha00.github.io%2fpost%2fos%2fos_chapter_09_%25EA%25B5%2590%25EC%25B0%25A9%25EC%2583%2581%25ED%2583%259C%2f"><svg viewBox="2 2 28 28"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></div></footer><script src=https://utteranc.es/client.js repo=JeHa00/blog-comments issue-term=pathname theme=github-dark crossorigin=anonymous async></script></article></main><footer class=footer><span>&copy; 2022 <a href=http://jeha00.github.io/>Jeha00 DevLog</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(t){t.preventDefault();var e=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(e)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(e)}']`).scrollIntoView({behavior:"smooth"}),e==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${e}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>