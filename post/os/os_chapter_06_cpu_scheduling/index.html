<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>[TIL] Chapter 06: CPU scheduling | Jeha DevLog</title><meta name=keywords content="TIL,OS"><meta name=description content="Bound process를 중심으로 CPU 스케쥴러가 왜 필요한지, 스케쥴링의 성능 척도는 무엇인지, CPU sheduling 알고리즘의 종류에는 무엇이 있고, 이 알고리즘 평가는 어떻게 이뤄지는지 알아보자."><meta name=author content><link rel=canonical href=http://jeha00.github.io/post/os/os_chapter_06_cpu_scheduling/><meta name=google-site-verification content="XYZabc"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.min.268b216eea772711d318d156ce02a8190962367a0bf469fa9a959114ea6b9ca3.css integrity="sha256-Joshbup3JxHTGNFWzgKoGQliNnoL9Gn6mpWRFOprnKM=" rel="preload stylesheet" as=style><link rel=icon href=http://jeha00.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=http://jeha00.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=http://jeha00.github.io/favicon-32x32.png><link rel=apple-touch-icon href=http://jeha00.github.io/apple-touch-icon.png><link rel=mask-icon href=http://jeha00.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><meta name=generator content="Hugo 0.101.0"><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><script type=application/javascript>var doNotTrack=!1;doNotTrack||(function(e,t,n,s,o,i,a){e.GoogleAnalyticsObject=o,e[o]=e[o]||function(){(e[o].q=e[o].q||[]).push(arguments)},e[o].l=1*new Date,i=t.createElement(n),a=t.getElementsByTagName(n)[0],i.async=1,i.src=s,a.parentNode.insertBefore(i,a)}(window,document,"script","https://www.google-analytics.com/analytics.js","ga"),ga("create","UA-123-45","auto"),ga("send","pageview"))</script><meta property="og:title" content="[TIL] Chapter 06: CPU scheduling"><meta property="og:description" content="Bound process를 중심으로 CPU 스케쥴러가 왜 필요한지, 스케쥴링의 성능 척도는 무엇인지, CPU sheduling 알고리즘의 종류에는 무엇이 있고, 이 알고리즘 평가는 어떻게 이뤄지는지 알아보자."><meta property="og:type" content="article"><meta property="og:url" content="http://jeha00.github.io/post/os/os_chapter_06_cpu_scheduling/"><meta property="og:image" content="http://jeha00.github.io/47"><meta property="article:section" content="post"><meta property="article:published_time" content="2022-04-22T18:50:51+09:00"><meta property="article:modified_time" content="2022-04-22T18:50:51+09:00"><meta property="og:site_name" content="JeHa00 DevLog"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="http://jeha00.github.io/47"><meta name=twitter:title content="[TIL] Chapter 06: CPU scheduling"><meta name=twitter:description content="Bound process를 중심으로 CPU 스케쥴러가 왜 필요한지, 스케쥴링의 성능 척도는 무엇인지, CPU sheduling 알고리즘의 종류에는 무엇이 있고, 이 알고리즘 평가는 어떻게 이뤄지는지 알아보자."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"http://jeha00.github.io/post/"},{"@type":"ListItem","position":2,"name":"[TIL] Chapter 06: CPU scheduling","item":"http://jeha00.github.io/post/os/os_chapter_06_cpu_scheduling/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"[TIL] Chapter 06: CPU scheduling","name":"[TIL] Chapter 06: CPU scheduling","description":"Bound process를 중심으로 CPU 스케쥴러가 왜 필요한지, 스케쥴링의 성능 척도는 무엇인지, CPU sheduling 알고리즘의 종류에는 무엇이 있고, 이 알고리즘 평가는 어떻게 이뤄지는지 알아보자.","keywords":["TIL","OS"],"articleBody":"0. Introduction 해당 내용은 운영체제와 정보기술의 원리 -반효경 지음- 와 kocw 이화여자대학교 운영체제 - 반효경 교수 -를 보고 정리한 내용입니다. 정확하지 않은 내용이 있다면 말씀해주시면 감사하겠습니다. 1. Bound process 1.1 CPU란?? CPU(Central Processing Unit): PC(Program Counter)가 가리키는 주소의 기계어 명령을 실제로 수행하는 컴퓨터 내의 중앙처리장치 PC: Program Counter로, 레지스터의 한 종류로서 현재 CPU에서 수행할 프로세스의 코드의 메모리 주소값을 가지고 있다. 1.2 기계어 명령의 종류 CPU에서 수행하는 기계어 명령어의 종류를 알아보자.\n1. CPU 내에서 수행되는 명령어\nAdd 명령어: CPU 내의 레지스터에 있는 두 값을 더해 레지스터에 저장하는 명령어 CPU 내에서만 수행되므로 명령의 수행 속도가 매우 빠르다. 2. 메모리 접근을 필요로 하는 명령어\nLoad 명령어: 메모리에 있는 데이터를 CPU로 읽어들이는 명령어 Store 명령어: CPU에서 계산된 결과값을 메모리에 저장하는 명령어 1번보다 느리지만, 비교적 짧은 시간에 수행 가능하다. 3. 입출력 동반 명령어\n입출력 작업(I/O 작업)이 필요한 경우, 사용하는 명령어 ex) 키보드로부터 입력을 받기, 화면에 출력하기 입출력 수반 명령은 1번과 2번에 비해 대단히 오랜 시간이 걸린다. 입출력 작업은 특권 명령으로 규정해서 user program이 직접 수행할 수 없고, OS를 통해서 서비스를 대행하도록 한다. 각 명령어 수행 속도 비교: 3번 \u003c 2번 \u003c 1번\n특권 명령과 일반 명령으로 분류\n특권 명령: 3번 일반 명령: 1번과 2번 1.3 CPU burst와 I/O burst user program이 실행되는 과정은 CPU 작업 과 I/O 작업의 반복이다.\n즉, CPU burst 와 I/O burst가 번갈아 실행된다.\nCPU burst(버스트): user program이 CPU만 연속적으로 사용하여 instruction만 실행하는 일련의 단계 -\u003e user mode I/O burst(버스트): I/O 요청이 발생해 kernel에 의해 입출력 작업을 진행하는 비교적 느린 단계 -\u003e kernel mode 위 2가지를 I/O 작업을 기준으로 분류해보자.\nCPU burst: program이 I/O를 한 번 완료한 후, 다음 번 I/O를 수행하기까지 직접 CPU를 가지고 명령을 수행하는 일련의 작업\nI/O burst: I/O 작업이 요청된 후, 다시 CPU burst로 돌아가기까지 일어나는 일련의 작업\n1.4 Bound process: CPU \u0026 I/O 각 program마다 CPU burst와 I/O burst의 비율이 균일하지 않다.\n그래서 CPU bound process와 I/O bound process로 나눠볼 수 있다.\nCPU bound process: 계산 위주의 jb\nfew very long CPU bursts 입출력 작업 없이 CPU 작업에 소모하는 계산 위주의 프로그램이 해당된다. I/O bound process: CPU를 잡고 계산하는 시간보다 I/O에 많은 시간이 필요한 job\nMany short CPU bursts 대화형 프로그램(interactive prgram)에 해당 즉, 사용자에게 입력을 받아 CPU 연산을 수행하여 그 결과를 다시 출력하는 작업에 해당 1.5 CPU sheduling이 필요한 이유 여러 종류의 process(=job)이 동일한 시스템 내부에서 섞여 있기 때문에, CPU scheduling이 필요하다.\nI/O는 interactive job으로서 적절한 response 필요하다.\nCPU와 I/O 장치 등 시스템 자원을 골고루 효율적으로 사용\n특히, 이 CPU는 한 시스템 내에 하나 밖에 없으므로, 시분할 시스템에서 매우 효율적으로 관리해야 한다.\n대부분의 짧은 CPU burst + 극히 일부분의 긴 CPU burst\n= 대부분 CPU를 오래 사용하기보다는 잠깐 사용하고, I/O 작업을 수행하는 process들이 많다.\n= CPU busrt가 짧은 process는 대부분 대화형 작업이다. = CPU 스케쥴링을 할 때, CPU burst가 짧은 process에게 우선적으로 CPU를 사용할 수 있도록 하는 스케쥴링이 필요\n그래서, I/O bound process의 우선순위를 높이는 것이 바람직한다.\nI/O bound process에게 늦게 주면 사용자는 답답함을 느낀다. 2. CPU 스케쥴러 CPU 스케쥴러란?? ready state에 있는 procese 중에서 이번에 CPU를 줄 프로세스를 결정하는 OS의 code\nHW가 아닌, os의 code 중 이 기능을 하는 부분을 CPU 스케쥴러라 부르는 것이다. CPU 스케쥴링이 필요한 경우\nI/O 요청 system call에 의해 running에서 blocked로 바뀐 경우 Timer interrupt에 의해 running에서 ready로 바뀐 경우 I/O 작업 요청으로 blocked 상태였던 process가 I/O 작업 완료에 의해 device controller가 interrupt 발생하여 ready 상태로 바뀐 경우 running 상태에 있는 프로세스가 종료(terminate)되는 경우 CPU 스케쥴링 방식 2가지: 비선점형(non-preemptive) 과 선점형(preemptive)\n비선점형(preemptive): process가 작업완료 후, 자발적으로 CPU를 반납하는 방식 -\u003e 1번과 4번 선점형(preemptive): CPU를 계속 사용하기 원해도, 강제로 빼앗는 방법 -\u003e 2번과 3번 ex) timer interrupt 3. Dispatcher Dispatcher란?? CPU scheduler에 의해 새롭게 선택된 프로세스가 CPU를 할당받아 작업을 수행하도록 환경설정을 하는 OS의 code\nHW가 아닌, os의 code 중 이 기능을 하는 부분을 CPU 스케쥴러라 부르는 것이다. Dispatcher 과정\n현재 수행 중이던 process context를 이 process의 PCB에 저장한다.\n-\u003e 새로운 process의 PCB를 복원\n-\u003e user mode로 전환하여 CPU를 넘긴다.\n-\u003e 복원된 context의 program counter로 현재 수행할 주소를 찾는다. Dispatch latency (디스패치 지연시간): 디스패치가 하나의 프로세스를 정지시키고 다른 프로세스에게 CPU를 전달하기까지 걸리는 시간\nDispatcher 과정에서 1번부터 3번까지 걸린 시간 context switching의 overhead에 해당 4. 스케쥴링의 성능 척도 스케쥴링의 성능을 평가하기 위해 여러 지표들이 사용된다.\n시스템 관점의 지표: CPU 이용률, 처리량(throughput) 사용자 관점의 지표: 소요시간, 대기시간, 응답시간 시스템 관점의 지표\nCPU 이용률(CPU utilization): 전체 시간 중 CPU가 일을 한 시간\n휴면 상태(idle)에 머무르는 시간을 최대한 줄이는 것이 CPU 스케쥴링의 중요한 목표 처리량(throughput): 주어진 시간 동안 ready queue에서 CPU burst를 완료한 프로세스의 개수\nCPU burst가 짧은 process에게 할당할수록 증가한다. 사용자 관점의 지표\n소요시간(turnaround time): process가 CPU를 요청한 시점부터 자신이 원하는 만큼 CPU를 다 쓰고, CPU burst가 끝날 때까지 걸린 시간\n대기시간(waiting time) + 실제로 CPU를 이용한 시간의 합 대기시간(waiting time): CPU burst 기간 중 process가 ready queue에서 CPU를 얻기 위해 기다린 시간의 합\nCPU burst 동안, CPU를 얻기 잃는 걸 반복한다. 응답시간(response time): process가 ready queue에 들어온 후, 첫 번째 CPU를 획득하기까지 기다린 시간\n사용자 응답하는 대화형 시스템에서 적합한 성능 척도 사용자 관점 지표에서 가장 중요 timer interrupt가 빈번할수록 응답시간 감소 생활 속의 비유: 중국집\n이용률과 처리량 -\u003e 중국집 입장에서의 척도 이용률: 전체 시간 중 주방장이 일한 시간의 비율 처리량: 주방장이 주어진 시간 동안 몇 명의 손님에게 요리를 만들어주었는지 중국집 입장에서는 주방장을 고용해서 가능한 많은 일을 시키는 것이 좋으므로, 이용률이 높은 것을 선호한다. 소요시간, 대기시간, 응답시간 -\u003e 손님 입장에서의 척도 소요시간: 손님이 중국집에 들어와서 주문한 음식을 다 먹고 나가기까지 소요된 총 시간 대기시간: 각각의 음식이 나오기까지 기다린 시간을 합한 것 응답시간: 최초의 음식이 나오기까지 기다린 시간 5. 스케쥴링 알고리즘 5.1 선입선출 스케쥴링(FCFS: First-Come First-Served) process가 ready queue에 도착한 순서대로 CPU를 할당하는 방식. 비선점형이다. FCFS 스케쥴링은 먼저 도착한 프로세스의 성격에 따라 평균 대기시간이 크게 달라진다.\nCPU burst가 긴 프로세스가 먼저 도착할 경우: 평균 대기시간이 길어진다. (Conboy effect) CPU burst가 짧은 프로세스가 먼저 도착할 경우: 평균 대기시간이 짧아진다. 단점\n콘보이 현상(Convoy effect): CPU burst가 긴 process가 짧은 process보다 먼저 도착하여 오랜 시간을 기다려야하는 현상으로, 평균 대기시간이 길어진다. FCFS의 대표적인 단점 예시\n프로세스 CPU burst 시간 P1 24 P2 3 P3 3 들어온 순서가 P1,P2,P3 일 때\n대기시간: P1 = 0, P2 = 24, P3 = 27 평균 대기시간: (0 + 24 + 27 ) / 3 = 17 들어온 순서가 P2, P3, P1 일 때\n대기시간: P1 = 6, P2 = 0, P3 = 3 평균 대기시간: (6+0+3)/3 = 3 5.2 최단작업 우선 스케쥴링(Shortest-Job First: SJF) CPU burst가 가장 짧은 process에게 제일 먼저 CPU를 할당하는 방식 평균 대기시간을 가장 짧게 하는 최적 알고리즘(optimal algorithum)이지만 최고의 알고리즘은 아니다. SJF algorithum의 방식: 비선점형(non-preemptive) 과 선점형(preemptive)\n효율적이지만, 형평성을 간과한 스케쥴링\n비선점형(preemptive): 프로세스가 CPU를 자진 반납하기 전까지는 CPU를 빼앗지 않는 방식 선점형(preemptive): ready queue에서 CPU burst가 가장 짧은 process에게 CPU를 할당했어도, 더 짧은 process가 도착할 경우, CPU를 빼앗아 더 짧은 process에게 부여하는 방식 SRTF(Shortest Remaining Time First)라고도 한다. process들이 ready queue에 도착시간이 불규칙한 환경에서는 선점형이 평균 대기시간을 최소화하는 최적의 알고리즘이 된다. SJF의 선점형 첫 번째 문제점: 기아 현상(starvation)\n기아 현상(starvation): CPU burst가 짧은 process가 계속 도착할 경우, 한 process는 영원히 CPU를 할당받지 못하는 현상 SJF의 두 번째 문제점: 현실적으로 미리 알 수 없는 CPU burst 시간\n하지만 과거의 data를 통해서 예측할 수 있다. 예시\n비선점형\n선점형\n5.3 우선순위 스케쥴링(Priority scheduling) ready queue에서 기다리는 process 중 우선선위가 가장 높은 process에게 제일 먼저 CPU를 할당하는 방식 우선순위는 우선순위값(priority number)을 통해 표시하며, 작을수록 높은 우선순위를 가지는 것으로 가정한다. 우선순위 스케쥴링도 비선점형 방식과 선점형 방식으로 각각 구현할 수 있다.\nSJF도 우선순위 스케쥴링의 한 종류다.\n왜냐하면, CPU burst 시간을 우선순위값으로 정의하며 우선순위 스케쥴링은 SJF 알고리즘과 동일하다. Problem: 우선순위 스케쥴링도 기아 현상(starvation) 문제점이 있다.\nSolution: 노화 기법(aging) 을 사용한다.\n기다리는 시간이 비례하여 우선순위를 높이는 것을 말한다.\nex) 버스나 지하철에서 나이 드신 분께 자리를 양보하는 것과 동일. 5.4 라운드 로빈 스케쥴링(Round Robin Scheduling) 시분할 시스템의 성질을 가장 잘 활용한 스케쥴링 방식 각 프로세스가 연속적으로 CPU를 사용할 수 있는 시간이 제한되며, 이 시간이 경과하면 CPU를 회수해 ready queue에 줄 슨다. 현대 CPU 스케쥴링의 기반 + CPU 설명의 기반 스케쥴링: 라운드 로빈 스케쥴링\n각 프로세스가 연속적으로 CPU를 사용할 수 있는 시간: 할당 시간(time quantum)\n규모: 수십 밀리초 정도의 규모 할당시간이 지나면 timer interrupt가 발생 CPU 사용 시간이 할당 시간보다 짧으면 스스로 반납한다. 할당 시간이 너무 짧으면 문맥교환의 오버헤드가 증가하여, 전체 시스템 성능이 저하된다. 대화형 프로세스의 빠른 응답 시간(response time)을 보장할 수 있다.\n라운드 로빈 스케쥴링의 기본적인 목적: 공정성\nCPU burst 시간이 짧은 프로세스가 빨리 CPU를 얻고, 동시에 CPU burst 시간이 긴 프로세스가 불이익 X CPU를 사용하고자 하는 양에 비례하여 소요시간이 증가하므로 공정하다. Round robine과 다른 scheduling 비교\nSJF와의 비교: SJF보다 평균 turnaround time이 길지만, response time은 더 짧다는 것이 중요한 장점이다.\nFCFS와의 비교: 할당시간을 크게 하면 FCFS와 동일\nCPU 버스트 시간이 동일한 프로세스들일 경우,\nFCFS: CPU를 먼저 쓰고 나가는 프로세스의 소요시간 및 대기시간이 짧아진다. Round robine: CPU를 조금씩 같이 쓰고, 거의 동시에 끝나게 되어 소요시간 및 대기시간이 가장 오래 기다린 프로세스에 맞춰진다. 따라서 Round robine 스케쥴링은 FCFS의 평균 대기시간 및 평균 소요시간이 FCFS보다 거의 두 배로 더 길어진다. 하지만, CPU burst 시간이 균일하지 않은 경우가 대부분이기 때문에, Round robine은 FCFS보다 합리적\n5.5 멀티레벨 큐(Multi-level queue) ready queue를 여러 개로 분할해 관리하는 스케쥴링 기법 공정하지 않은 알고리즘이지만, 우선순위가 높은 프로세스가 더 빨리 CPU를 얻어야 하기 때문이다. 이 기법의 경우, 다음과 같은 문제점이 발생한다.\n이 기법의 경우, 어떤 줄에 서 있는 프로세스를 우선적으로 스케쥴링할 것인가?? 프로세스가 도착했을 때, 어느 줄에 세워야할지 결정하는 메커니즘 필요 첫 번째 문제에 대한 해결책: 프로세스의 성격에 맞는 스케쥴링을 사용한다.\n전위 큐(foreground queue): 대화형 작업(interactive job)을 담기 위한 전위 -\u003e 응답시간을 짧게 하기 위해 Round robin scheduling 사용 후위 큐(background queue): 계산 위주의 작업을 담기 위한 후위 -\u003e 응답 시간이 큰 의미를 가지지 않기 때문에, 그리고 context switching overhead를 줄이기 위해 FCFS 사용 두 번째 문제에 대한 해결책: 고정 우선순위 방식(fixed priority scheduling)\nFixed priority scheduling(고정 우선순위 방식) Queue에 고정적인 우선순위를 부여하는 방식 우선순위가 높은 큐를 먼저 서비스 -\u003e 낮은 큐는 우선순위가 높은 큐가 비어있을 때만 서비스 실행. 즉, 전위 큐에 있는 프로세스에게 우선적으로 CPU를 부여하고, 전위 큐가 비어 있는 경우에만 후위 큐에 있는 프로세스에게 CPU를 할당한다. 하지만, starvation 이 발생할 수 있다. 두 번재 문제에 대한 또 다른 해결책: time slice\n각 queue에 CPU 시간을 적절한 비율로 할당 ex) RR인 전위 큐: 80% , FCFS인 후위 큐: 20% 5.6 멀티레벨 피드백 큐(Multi-level Feedback Queue) 멀티레벨 큐와 거의 다 동일하나, 차이점은 process가 하나의 queue에서 다른 큐로 이동이 가능하다. 즉, 프로세스의 우선순위가 바뀔 수 있다.\n우선순위 스케쥴링의 aging 기법을 멀티레벨 피드백 큐 방식으로 구현하면,\n기다렸으면 우선순위가 낮은 큐에서 높은 큐로 승격시키는 방식이다. 차근 차근 시간을 늘려 때문에, CPU 사용 시간을 예측할 필요가 없다. 멀티레벨 피드백 큐를 정의하는 요소들\n큐의 수 각 큐의 스케쥴링 알고리즘 프로세스를 상위 큐로 승격시키는 기준 프로세스를 하위 큐로 강등시키는 기준 프로세스가 도착했을 때, 들어갈 큐를 결정하는 기준 등등 멀티레벨 피드백 큐의 동작 예\n프로세스가 준비 큐에 도착하면 우선순위가 가장 높은 큐(Round robine, 할당시간 8)에 줄을 선다.\n-\u003e CPU 사용시간이 짧은 대화형 프로세스라면 빨리 서비스 박고 작업완료할 수 있다.\n-\u003e CPU burst가 긴 process라면 하위 큐(Round robine, 할당시간 16)로 강등시킨다. -\u003e 그럼에도 완료하지 못하면 계산위주의 프로세스로 간주하여 최하위 큐인 FCFS scheduling을 적용 5.7 다중처리기 스케쥴링(Multi-processor system) multi-processor 상황에서의 scheduling 기법\n은행창구에서 번호표를 뽑아 기다리는 것처럼 CPU가 알아서 다음 프로세스를 꺼내가도록 할 수 있다.\n하지만, 반드시 특정 CPU가 실행해야 한다든가 ex) 미용실에서 특정 미용사로 예약한 경우\nLoad sharing\n각 CPU 별 부하가 적절히 분산되도록 하는 매커니즘이 필요하다. 다중처리기 스케쥴링의 방식\n대칭형 다중처리(SMP, Symetric Multi-Processing): 모든 CPU가 대등해서 각자 알아서 스케줄링을 결정하는 방식 비대칭형 다중처리(asymmetric multiprogramming): 하나의 CPU가 다른 모든 CPU의 스케줄링 및 데이터 접근을 책임지고, CPU는 거기에 따라 움직이는 방식 5.8 실시간 스케쥴링(real-time system) 정해진 시간(dead line) 이내에 처리해야만 하는 스케줄링\n경성 실시간 시스템(Hard real-time system)과 연성 실시간 시스템(soft real-time system)으로 나눠진다. 전자는 원자로 제어, 미사일 발사 등 시간을 정확히 지켜야하는 시스템 후자는 데드라인이 존재하지만, 지키지 못했다고 하여 위험한 상황이 발생하지 않는다. 5.9 Thread scheduling Thread를 구현하는 방식 2가지 Local Scheduling (by user process) User level thread의 경우, process가 thread를 직접 관리하고 OS는 thread의 존재를 모른다. 그래서 OS는 이 thread에게 CPU를 줄지 결정한다. 그리고, process 내부에서 어떤 thread에게 줄지를 결정한다. Global Scheduling (by OS) Kernel level thread의 경우, 일반 프로세스와 마찬가지로 커널의 단기 스케쥴러가 어떤 thread를 스케줄할지 결정 즉, OS가 thread의 존재를 인지한다. 6. 스케쥴링 알고리즘의 평가 스케쥴링 알고리즘의 성능을 평가하는 방법에는 큐잉모델(Queuing model), 구현 및 실측(Implementation \u0026 measrrement), 시뮬레이션(Simulation)가 있다. Queueing model: 이론가들이 수행하는 방식 수학적 계산을 통해 performance index(CPU 처리량, Process 평균 대기시간 등)를 구한다. 밑에 방식이 훨씬 많이 사용된다. Implementation \u0026 measurement: 이론가가 아닌 구현가들이 수행하는 방식 동일한 program을 원래 kernel과 CPU scheduler code를 수정한 kernel에서 수행한 후, 실행시간을 측정하여 알고리즘을 평가한다. 이 방법이 어려우면 밑에 방법을 사용한다. Simulation: 가상으로 CPU scheduling program을 작성하는 방식 가상으로 CPU scheduling program을 작성한 후, 프로그램의 CPU 요청을 입력값으로 넣어 어떠한 결과가 나오는지 확인하는 방법 그래서 가상으로 생성된 값과 실제 system에서 추출한 입력값(이를 trace라 한다.)을 비교한다. Reference 운영체제와 정보기술의 원리 kocw 이화여자대학교 운영체제 - 반효경 교수 - ","wordCount":"2059","inLanguage":"en","datePublished":"2022-04-22T18:50:51+09:00","dateModified":"2022-04-22T18:50:51+09:00","mainEntityOfPage":{"@type":"WebPage","@id":"http://jeha00.github.io/post/os/os_chapter_06_cpu_scheduling/"},"publisher":{"@type":"Organization","name":"Jeha DevLog","logo":{"@type":"ImageObject","url":"http://jeha00.github.io/favicon.ico"}}}</script></head><body class=dark id=top><script>localStorage.getItem("pref-theme")==="light"&&document.body.classList.remove("dark")</script><header class=header><nav class=nav><div class=logo><a href=http://jeha00.github.io/ accesskey=h title="@Jeha00 (Alt + H)">@Jeha00</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></span></div><ul id=menu><li><a href=http://jeha00.github.io/me/ title=About><span>About</span></a></li><li><a href=http://jeha00.github.io/archives/ title=Archive><span>Archive</span></a></li><li><a href=http://jeha00.github.io/categories/ title=Categories><span>Categories</span></a></li><li><a href=http://jeha00.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=http://jeha00.github.io/>Home</a>&nbsp;»&nbsp;<a href=http://jeha00.github.io/post/>Posts</a></div><h1 class=post-title>[TIL] Chapter 06: CPU scheduling</h1><div class=post-meta>OS&nbsp;·&nbsp;<span title='2022-04-22 18:50:51 +0900 KST'>April 22, 2022</span></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#0-introduction aria-label="0. Introduction">0. Introduction</a><ul><li><a href=#1-bound-process aria-label="1. Bound process">1. Bound process</a><ul><li><a href=#11-cpu%eb%9e%80 aria-label="1.1 CPU란??">1.1 CPU란??</a></li><li><a href=#12-%ea%b8%b0%ea%b3%84%ec%96%b4-%eb%aa%85%eb%a0%b9%ec%9d%98-%ec%a2%85%eb%a5%98 aria-label="1.2 기계어 명령의 종류">1.2 기계어 명령의 종류</a></li><li><a href=#13-cpu-burst%ec%99%80-io-burst aria-label="1.3 CPU burst와 I/O burst">1.3 CPU burst와 I/O burst</a></li><li><a href=#14-bound-process-cpu--io aria-label="1.4 Bound process: CPU &amp;amp; I/O">1.4 Bound process: CPU & I/O</a></li><li><a href=#15-cpu-sheduling%ec%9d%b4-%ed%95%84%ec%9a%94%ed%95%9c-%ec%9d%b4%ec%9c%a0 aria-label="1.5 CPU sheduling이 필요한 이유">1.5 CPU sheduling이 필요한 이유</a></li></ul></li><li><a href=#2-cpu-%ec%8a%a4%ec%bc%80%ec%a5%b4%eb%9f%ac aria-label="2. CPU 스케쥴러">2. CPU 스케쥴러</a></li><li><a href=#3-dispatcher aria-label="3. Dispatcher">3. Dispatcher</a></li><li><a href=#4-%ec%8a%a4%ec%bc%80%ec%a5%b4%eb%a7%81%ec%9d%98-%ec%84%b1%eb%8a%a5-%ec%b2%99%eb%8f%84 aria-label="4. 스케쥴링의 성능 척도">4. 스케쥴링의 성능 척도</a></li><li><a href=#5-%ec%8a%a4%ec%bc%80%ec%a5%b4%eb%a7%81-%ec%95%8c%ea%b3%a0%eb%a6%ac%ec%a6%98 aria-label="5. 스케쥴링 알고리즘">5. 스케쥴링 알고리즘</a><ul><li><a href=#51-%ec%84%a0%ec%9e%85%ec%84%a0%ec%b6%9c-%ec%8a%a4%ec%bc%80%ec%a5%b4%eb%a7%81fcfs-first-come-first-served aria-label="5.1 선입선출 스케쥴링(FCFS: First-Come First-Served)">5.1 선입선출 스케쥴링(FCFS: First-Come First-Served)</a></li><li><a href=#52-%ec%b5%9c%eb%8b%a8%ec%9e%91%ec%97%85-%ec%9a%b0%ec%84%a0-%ec%8a%a4%ec%bc%80%ec%a5%b4%eb%a7%81shortest-job-first-sjf aria-label="5.2 최단작업 우선 스케쥴링(Shortest-Job First: SJF)">5.2 최단작업 우선 스케쥴링(Shortest-Job First: SJF)</a></li><li><a href=#53-%ec%9a%b0%ec%84%a0%ec%88%9c%ec%9c%84-%ec%8a%a4%ec%bc%80%ec%a5%b4%eb%a7%81priority-scheduling aria-label="5.3 우선순위 스케쥴링(Priority scheduling)">5.3 우선순위 스케쥴링(Priority scheduling)</a></li><li><a href=#54-%eb%9d%bc%ec%9a%b4%eb%93%9c-%eb%a1%9c%eb%b9%88-%ec%8a%a4%ec%bc%80%ec%a5%b4%eb%a7%81round-robin-scheduling aria-label="5.4 라운드 로빈 스케쥴링(Round Robin Scheduling)">5.4 라운드 로빈 스케쥴링(Round Robin Scheduling)</a></li><li><a href=#55-%eb%a9%80%ed%8b%b0%eb%a0%88%eb%b2%a8-%ed%81%90multi-level-queue aria-label="5.5 멀티레벨 큐(Multi-level queue)">5.5 멀티레벨 큐(Multi-level queue)</a></li><li><a href=#56-%eb%a9%80%ed%8b%b0%eb%a0%88%eb%b2%a8-%ed%94%bc%eb%93%9c%eb%b0%b1-%ed%81%90multi-level-feedback-queue aria-label="5.6 멀티레벨 피드백 큐(Multi-level Feedback Queue)">5.6 멀티레벨 피드백 큐(Multi-level Feedback Queue)</a></li><li><a href=#57-%eb%8b%a4%ec%a4%91%ec%b2%98%eb%a6%ac%ea%b8%b0-%ec%8a%a4%ec%bc%80%ec%a5%b4%eb%a7%81multi-processor-system aria-label="5.7 다중처리기 스케쥴링(Multi-processor system)">5.7 다중처리기 스케쥴링(Multi-processor system)</a></li><li><a href=#58-%ec%8b%a4%ec%8b%9c%ea%b0%84-%ec%8a%a4%ec%bc%80%ec%a5%b4%eb%a7%81real-time-system aria-label="5.8 실시간 스케쥴링(real-time system)">5.8 실시간 스케쥴링(real-time system)</a></li><li><a href=#59-thread-scheduling aria-label="5.9 Thread scheduling">5.9 Thread scheduling</a></li></ul></li><li><a href=#6-%ec%8a%a4%ec%bc%80%ec%a5%b4%eb%a7%81-%ec%95%8c%ea%b3%a0%eb%a6%ac%ec%a6%98%ec%9d%98-%ed%8f%89%ea%b0%80 aria-label="6. 스케쥴링 알고리즘의 평가">6. 스케쥴링 알고리즘의 평가</a></li></ul></li><li><a href=#reference aria-label=Reference>Reference</a></li></ul></div></details></div><div class=post-content><h1 id=0-introduction>0. Introduction<a hidden class=anchor aria-hidden=true href=#0-introduction>#</a></h1><ul><li>해당 내용은 <a href="http://www.kyobobook.co.kr/product/detailViewKor.laf?ejkGb=KOR&mallGb=KOR&barcode=9791158903589&orderClick=LAG&Kc=">운영체제와 정보기술의 원리 -반효경 지음-</a> 와 <a href="http://www.kocw.net/home/cview.do?lid=3dd1117c48123b8e">kocw 이화여자대학교 운영체제 - 반효경 교수 -</a>를 보고 정리한 내용입니다.</li><li>정확하지 않은 내용이 있다면 말씀해주시면 감사하겠습니다.</li></ul><p> </p><hr><h2 id=1-bound-process>1. Bound process<a hidden class=anchor aria-hidden=true href=#1-bound-process>#</a></h2><p> </p><h3 id=11-cpu란>1.1 CPU란??<a hidden class=anchor aria-hidden=true href=#11-cpu란>#</a></h3><ul><li><strong>CPU(Central Processing Unit): PC(Program Counter)가 가리키는 주소의 기계어 명령을 실제로 수행하는 컴퓨터 내의 중앙처리장치</strong><ul><li>PC: Program Counter로, 레지스터의 한 종류로서 현재 CPU에서 수행할 프로세스의 코드의 메모리 주소값을 가지고 있다.</li></ul></li></ul><p> </p><h3 id=12-기계어-명령의-종류>1.2 기계어 명령의 종류<a hidden class=anchor aria-hidden=true href=#12-기계어-명령의-종류>#</a></h3><ul><li><p><strong>CPU에서 수행하는 기계어 명령어의 종류를 알아보자.</strong></p><ul><li><p><strong>1. CPU 내에서 수행되는 명령어</strong></p><ul><li>Add 명령어: CPU 내의 레지스터에 있는 두 값을 더해 레지스터에 저장하는 명령어</li><li>CPU 내에서만 수행되므로 명령의 수행 속도가 매우 빠르다.</li></ul></li><li><p><strong>2. 메모리 접근을 필요로 하는 명령어</strong></p><ul><li>Load 명령어: 메모리에 있는 데이터를 CPU로 읽어들이는 명령어</li><li>Store 명령어: CPU에서 계산된 결과값을 메모리에 저장하는 명령어</li><li>1번보다 느리지만, 비교적 짧은 시간에 수행 가능하다.</li></ul></li><li><p><strong>3. 입출력 동반 명령어</strong></p><ul><li>입출력 작업(I/O 작업)이 필요한 경우, 사용하는 명령어<ul><li>ex) 키보드로부터 입력을 받기, 화면에 출력하기</li></ul></li><li>입출력 수반 명령은 1번과 2번에 비해 대단히 오랜 시간이 걸린다.</li><li>입출력 작업은 특권 명령으로 규정해서 user program이 직접 수행할 수 없고, OS를 통해서 서비스를 대행하도록 한다.</li></ul></li></ul></li><li><p><strong>각 명령어 수행 속도 비교: 3번 &lt; 2번 &lt; 1번</strong></p></li><li><p><strong>특권 명령과 일반 명령으로 분류</strong></p><ul><li>특권 명령: 3번</li><li>일반 명령: 1번과 2번</li></ul></li></ul><p> </p><h3 id=13-cpu-burst와-io-burst>1.3 CPU burst와 I/O burst<a hidden class=anchor aria-hidden=true href=#13-cpu-burst와-io-burst>#</a></h3><ul><li><p><strong>user program이 실행되는 과정은 CPU 작업 과 I/O 작업의 반복이다.</strong></p></li><li><p><strong>즉, CPU burst 와 I/O burst가 번갈아 실행된다.</strong></p><ul><li>CPU burst(버스트): user program이 CPU만 연속적으로 사용하여 instruction만 실행하는 일련의 단계 -> user mode</li><li>I/O burst(버스트): I/O 요청이 발생해 kernel에 의해 입출력 작업을 진행하는 비교적 느린 단계 -> kernel mode</li></ul></li><li><p><strong>위 2가지를 I/O 작업을 기준으로 분류해보자.</strong></p><ul><li><p>CPU burst: program이 I/O를 한 번 완료한 후, 다음 번 I/O를 수행하기까지 직접 CPU를 가지고 명령을 수행하는 일련의 작업</p></li><li><p>I/O burst: I/O 작업이 요청된 후, 다시 CPU burst로 돌아가기까지 일어나는 일련의 작업</p><p><img loading=lazy src=https://user-images.githubusercontent.com/78094972/164410780-5cab4ac8-b72b-430d-8eff-d26a77bf934e.PNG alt=image></p></li></ul></li></ul><p> </p><h3 id=14-bound-process-cpu--io>1.4 Bound process: CPU & I/O<a hidden class=anchor aria-hidden=true href=#14-bound-process-cpu--io>#</a></h3><ul><li><p><strong>각 program마다 CPU burst와 I/O burst의 비율이 균일하지 않다.</strong></p></li><li><p><strong>그래서 CPU bound process와 I/O bound process로 나눠볼 수 있다.</strong></p><ul><li><p>CPU bound process: 계산 위주의 jb</p><ul><li>few very long CPU bursts</li><li>입출력 작업 없이 CPU 작업에 소모하는 계산 위주의 프로그램이 해당된다.</li></ul></li><li><p>I/O bound process: CPU를 잡고 계산하는 시간보다 I/O에 많은 시간이 필요한 job</p><ul><li>Many short CPU bursts</li><li>대화형 프로그램(interactive prgram)에 해당</li><li>즉, 사용자에게 입력을 받아 CPU 연산을 수행하여 그 결과를 다시 출력하는 작업에 해당</li></ul></li></ul></li></ul><p> </p><h3 id=15-cpu-sheduling이-필요한-이유>1.5 CPU sheduling이 필요한 이유<a hidden class=anchor aria-hidden=true href=#15-cpu-sheduling이-필요한-이유>#</a></h3><ul><li><p><strong>여러 종류의 process(=job)이 동일한 시스템 내부에서 섞여 있기 때문에, CPU scheduling이 필요하다.</strong></p><ul><li><p>I/O는 interactive job으로서 적절한 response 필요하다.</p></li><li><p>CPU와 I/O 장치 등 시스템 자원을 골고루 효율적으로 사용</p><p><img loading=lazy src=https://user-images.githubusercontent.com/78094972/164412061-026db4a6-462c-40f8-8ae9-128ab40b7170.PNG alt=image></p></li></ul></li><li><p><strong>특히, 이 CPU는 한 시스템 내에 하나 밖에 없으므로, 시분할 시스템에서 매우 효율적으로 관리해야 한다.</strong></p></li><li><p><strong>대부분의 짧은 CPU burst + 극히 일부분의 긴 CPU burst</strong></p><p>= 대부분 CPU를 오래 사용하기보다는 잠깐 사용하고, I/O 작업을 수행하는 process들이 많다.<br>= CPU busrt가 짧은 process는 대부분 대화형 작업이다.
= CPU 스케쥴링을 할 때, CPU burst가 짧은 process에게 우선적으로 CPU를 사용할 수 있도록 하는 스케쥴링이 필요</p></li><li><p><strong>그래서, I/O bound process의 우선순위를 높이는 것이 바람직한다.</strong></p><ul><li>I/O bound process에게 늦게 주면 사용자는 답답함을 느낀다.</li></ul></li></ul><p> </p><hr><h2 id=2-cpu-스케쥴러>2. CPU 스케쥴러<a hidden class=anchor aria-hidden=true href=#2-cpu-스케쥴러>#</a></h2><ul><li><p>CPU 스케쥴러란?? <strong>ready state에 있는 procese 중에서 이번에 CPU를 줄 프로세스를 결정하는 OS의 code</strong></p><ul><li>HW가 아닌, os의 code 중 이 기능을 하는 부분을 CPU 스케쥴러라 부르는 것이다.</li></ul></li><li><p><strong>CPU 스케쥴링이 필요한 경우</strong></p><ol><li>I/O 요청 system call에 의해 running에서 blocked로 바뀐 경우</li><li>Timer interrupt에 의해 running에서 ready로 바뀐 경우</li><li>I/O 작업 요청으로 blocked 상태였던 process가 I/O 작업 완료에 의해 device controller가 interrupt 발생하여 ready 상태로 바뀐 경우</li><li>running 상태에 있는 프로세스가 종료(terminate)되는 경우</li></ol></li><li><p><strong>CPU 스케쥴링 방식 2가지: 비선점형(non-preemptive) 과 선점형(preemptive)</strong></p><ul><li>비선점형(preemptive): process가 작업완료 후, 자발적으로 CPU를 반납하는 방식 -> 1번과 4번</li><li>선점형(preemptive): CPU를 계속 사용하기 원해도, 강제로 빼앗는 방법 -> 2번과 3번<ul><li>ex) timer interrupt</li></ul></li></ul></li></ul><p> </p><hr><h2 id=3-dispatcher>3. Dispatcher<a hidden class=anchor aria-hidden=true href=#3-dispatcher>#</a></h2><ul><li><p>Dispatcher란?? <strong>CPU scheduler에 의해 새롭게 선택된 프로세스가 CPU를 할당받아 작업을 수행하도록 환경설정을 하는 OS의 code</strong></p><ul><li>HW가 아닌, os의 code 중 이 기능을 하는 부분을 CPU 스케쥴러라 부르는 것이다.</li></ul></li><li><p><strong>Dispatcher 과정</strong></p><ul><li>현재 수행 중이던 process context를 이 process의 PCB에 저장한다.<br>-> 새로운 process의 PCB를 복원<br>-> user mode로 전환하여 CPU를 넘긴다.<br>-> 복원된 context의 program counter로 현재 수행할 주소를 찾는다.</li></ul></li><li><p><strong>Dispatch latency (디스패치 지연시간): 디스패치가 하나의 프로세스를 정지시키고 다른 프로세스에게 CPU를 전달하기까지 걸리는 시간</strong></p><ul><li>Dispatcher 과정에서 1번부터 3번까지 걸린 시간</li><li>context switching의 overhead에 해당</li></ul></li></ul><p> </p><hr><h2 id=4-스케쥴링의-성능-척도>4. 스케쥴링의 성능 척도<a hidden class=anchor aria-hidden=true href=#4-스케쥴링의-성능-척도>#</a></h2><ul><li><p><strong>스케쥴링의 성능을 평가하기 위해 여러 지표들이 사용된다.</strong></p><ul><li>시스템 관점의 지표: CPU 이용률, 처리량(throughput)</li><li>사용자 관점의 지표: 소요시간, 대기시간, 응답시간</li></ul></li><li><p><strong>시스템 관점의 지표</strong></p><ol><li><p>CPU 이용률(CPU utilization): 전체 시간 중 CPU가 일을 한 시간</p><ul><li>휴면 상태(idle)에 머무르는 시간을 최대한 줄이는 것이 CPU 스케쥴링의 중요한 목표</li></ul></li><li><p>처리량(throughput): 주어진 시간 동안 ready queue에서 CPU burst를 완료한 프로세스의 개수</p><ul><li>CPU burst가 짧은 process에게 할당할수록 증가한다.</li></ul></li></ol></li><li><p><strong>사용자 관점의 지표</strong></p><ol><li><p>소요시간(turnaround time): process가 CPU를 요청한 시점부터 자신이 원하는 만큼 CPU를 다 쓰고, CPU burst가 끝날 때까지 걸린 시간</p><ul><li>대기시간(waiting time) + 실제로 CPU를 이용한 시간의 합</li></ul></li><li><p>대기시간(waiting time): CPU burst 기간 중 process가 ready queue에서 CPU를 얻기 위해 기다린 시간의 합</p><ul><li>CPU burst 동안, CPU를 얻기 잃는 걸 반복한다.</li></ul></li><li><p>응답시간(response time): process가 ready queue에 들어온 후, 첫 번째 CPU를 획득하기까지 기다린 시간</p><ul><li>사용자 응답하는 대화형 시스템에서 적합한 성능 척도</li><li>사용자 관점 지표에서 가장 중요</li><li>timer interrupt가 빈번할수록 응답시간 감소</li></ul></li></ol></li><li><p><strong>생활 속의 비유</strong>: 중국집</p><ul><li>이용률과 처리량 -> 중국집 입장에서의 척도<ul><li>이용률: 전체 시간 중 주방장이 일한 시간의 비율</li><li>처리량: 주방장이 주어진 시간 동안 몇 명의 손님에게 요리를 만들어주었는지</li><li>중국집 입장에서는 주방장을 고용해서 가능한 많은 일을 시키는 것이 좋으므로, 이용률이 높은 것을 선호한다.</li></ul></li><li>소요시간, 대기시간, 응답시간 -> 손님 입장에서의 척도<ul><li>소요시간: 손님이 중국집에 들어와서 주문한 음식을 다 먹고 나가기까지 소요된 총 시간</li><li>대기시간: 각각의 음식이 나오기까지 기다린 시간을 합한 것</li><li>응답시간: 최초의 음식이 나오기까지 기다린 시간</li></ul></li></ul></li></ul><p> </p><hr><h2 id=5-스케쥴링-알고리즘>5. 스케쥴링 알고리즘<a hidden class=anchor aria-hidden=true href=#5-스케쥴링-알고리즘>#</a></h2><p> </p><h3 id=51-선입선출-스케쥴링fcfs-first-come-first-served>5.1 선입선출 스케쥴링(FCFS: First-Come First-Served)<a hidden class=anchor aria-hidden=true href=#51-선입선출-스케쥴링fcfs-first-come-first-served>#</a></h3><blockquote><ul><li>process가 ready queue에 도착한 순서대로 CPU를 할당하는 방식.</li><li>비선점형이다.</li></ul></blockquote><ul><li><p>FCFS 스케쥴링은 먼저 도착한 프로세스의 성격에 따라 평균 대기시간이 크게 달라진다.</p><ul><li>CPU burst가 긴 프로세스가 먼저 도착할 경우: 평균 대기시간이 길어진다. (Conboy effect)</li><li>CPU burst가 짧은 프로세스가 먼저 도착할 경우: 평균 대기시간이 짧아진다.</li></ul></li><li><p><strong>단점</strong></p><ul><li><strong>콘보이 현상(Convoy effect)</strong>: CPU burst가 긴 process가 짧은 process보다 먼저 도착하여 오랜 시간을 기다려야하는 현상으로, 평균 대기시간이 길어진다.<ul><li>FCFS의 대표적인 단점</li></ul></li></ul></li><li><p>예시</p><table><thead><tr><th>프로세스</th><th>CPU burst 시간</th></tr></thead><tbody><tr><td>P1</td><td>24</td></tr><tr><td>P2</td><td>3</td></tr><tr><td>P3</td><td>3</td></tr></tbody></table><ul><li><p>들어온 순서가 P1,P2,P3 일 때</p><ul><li>대기시간: P1 = 0, P2 = 24, P3 = 27</li><li>평균 대기시간: (0 + 24 + 27 ) / 3 = 17</li></ul><p><img loading=lazy src=https://user-images.githubusercontent.com/78094972/164449468-3bd69ed3-a8db-4080-b100-04cd83aa3c5f.PNG alt=image></p></li><li><p>들어온 순서가 P2, P3, P1 일 때</p><ul><li>대기시간: P1 = 6, P2 = 0, P3 = 3</li><li>평균 대기시간: (6+0+3)/3 = 3</li></ul><p><img loading=lazy src=https://user-images.githubusercontent.com/78094972/164449789-cc9d22d7-f221-4f83-9f6b-bc897e191404.PNG alt=image></p></li></ul></li></ul><p> </p><h3 id=52-최단작업-우선-스케쥴링shortest-job-first-sjf>5.2 최단작업 우선 스케쥴링(Shortest-Job First: SJF)<a hidden class=anchor aria-hidden=true href=#52-최단작업-우선-스케쥴링shortest-job-first-sjf>#</a></h3><blockquote><ul><li>CPU burst가 가장 짧은 process에게 제일 먼저 CPU를 할당하는 방식</li><li>평균 대기시간을 가장 짧게 하는 최적 알고리즘(optimal algorithum)이지만 최고의 알고리즘은 아니다.</li></ul></blockquote><ul><li><p><strong>SJF algorithum의 방식: 비선점형(non-preemptive) 과 선점형(preemptive)</strong></p></li><li><p><strong>효율적이지만, 형평성을 간과한 스케쥴링</strong></p><ul><li>비선점형(preemptive): 프로세스가 CPU를 자진 반납하기 전까지는 CPU를 빼앗지 않는 방식</li><li>선점형(preemptive): ready queue에서 CPU burst가 가장 짧은 process에게 CPU를 할당했어도, 더 짧은 process가 도착할 경우, CPU를 빼앗아 더 짧은 process에게 부여하는 방식<ul><li><strong>SRTF</strong>(Shortest Remaining Time First)라고도 한다.</li><li>process들이 ready queue에 도착시간이 불규칙한 환경에서는 선점형이 평균 대기시간을 최소화하는 최적의 알고리즘이 된다.</li></ul></li></ul></li><li><p><strong>SJF의 선점형 첫 번째 문제점: 기아 현상(starvation)</strong></p><ul><li>기아 현상(starvation): CPU burst가 짧은 process가 계속 도착할 경우, 한 process는 영원히 CPU를 할당받지 못하는 현상</li></ul></li><li><p><strong>SJF의 두 번째 문제점: 현실적으로 미리 알 수 없는 CPU burst 시간</strong></p><ul><li>하지만 과거의 data를 통해서 예측할 수 있다.</li></ul></li><li><p>예시</p><ul><li><p>비선점형</p><p><img loading=lazy src=https://user-images.githubusercontent.com/78094972/164451643-b6bc61bc-ea3f-4b9f-9097-1f088050736a.PNG alt=image></p></li><li><p>선점형</p><p><img loading=lazy src=https://user-images.githubusercontent.com/78094972/164451957-43b6277b-830a-4f09-819f-6c3d375989bb.PNG alt=image></p></li></ul></li></ul><p> </p><h3 id=53-우선순위-스케쥴링priority-scheduling>5.3 우선순위 스케쥴링(Priority scheduling)<a hidden class=anchor aria-hidden=true href=#53-우선순위-스케쥴링priority-scheduling>#</a></h3><blockquote><ul><li>ready queue에서 기다리는 process 중 우선선위가 가장 높은 process에게 제일 먼저 CPU를 할당하는 방식</li><li>우선순위는 우선순위값(priority number)을 통해 표시하며, 작을수록 높은 우선순위를 가지는 것으로 가정한다.</li></ul></blockquote><ul><li><p><strong>우선순위 스케쥴링도 비선점형 방식과 선점형 방식으로 각각 구현할 수 있다.</strong></p></li><li><p><strong>SJF도 우선순위 스케쥴링의 한 종류다.</strong></p><ul><li>왜냐하면, CPU burst 시간을 우선순위값으로 정의하며 우선순위 스케쥴링은 SJF 알고리즘과 동일하다.</li></ul></li><li><p><strong>Problem: 우선순위 스케쥴링도 <em>기아 현상(starvation)</em> 문제점이 있다.</strong></p></li><li><p><strong>Solution: <em>노화 기법(aging)</em> 을 사용한다.</strong></p><ul><li>기다리는 시간이 비례하여 우선순위를 높이는 것을 말한다.<br>ex) 버스나 지하철에서 나이 드신 분께 자리를 양보하는 것과 동일.</li></ul></li></ul><p> </p><h3 id=54-라운드-로빈-스케쥴링round-robin-scheduling>5.4 라운드 로빈 스케쥴링(Round Robin Scheduling)<a hidden class=anchor aria-hidden=true href=#54-라운드-로빈-스케쥴링round-robin-scheduling>#</a></h3><blockquote><ul><li>시분할 시스템의 성질을 가장 잘 활용한 스케쥴링 방식</li><li>각 프로세스가 연속적으로 CPU를 사용할 수 있는 시간이 제한되며, 이 시간이 경과하면 CPU를 회수해 ready queue에 줄 슨다.</li></ul></blockquote><ul><li><p><strong>현대 CPU 스케쥴링의 기반 + CPU 설명의 기반 스케쥴링: 라운드 로빈 스케쥴링</strong></p></li><li><p><strong>각 프로세스가 연속적으로 CPU를 사용할 수 있는 시간: 할당 시간(time quantum)</strong></p><ul><li>규모: 수십 밀리초 정도의 규모</li><li>할당시간이 지나면 timer interrupt가 발생</li><li>CPU 사용 시간이 할당 시간보다 짧으면 스스로 반납한다.</li><li>할당 시간이 너무 짧으면 문맥교환의 오버헤드가 증가하여, 전체 시스템 성능이 저하된다.</li></ul></li><li><p><strong><em>대화형 프로세스의 빠른 응답 시간(response time)을 보장할 수 있다.</em></strong></p></li><li><p><strong>라운드 로빈 스케쥴링의 기본적인 목적: 공정성</strong></p><ul><li>CPU burst 시간이 짧은 프로세스가 빨리 CPU를 얻고, 동시에 CPU burst 시간이 긴 프로세스가 불이익 X</li><li>CPU를 사용하고자 하는 양에 비례하여 소요시간이 증가하므로 공정하다.</li></ul></li><li><p><strong>Round robine과 다른 scheduling 비교</strong></p><ul><li><p>SJF와의 비교: SJF보다 평균 turnaround time이 길지만, response time은 더 짧다는 것이 중요한 장점이다.</p></li><li><p>FCFS와의 비교: 할당시간을 크게 하면 FCFS와 동일</p><ul><li><p><strong>CPU 버스트 시간이 동일한 프로세스들일 경우,</strong></p><ul><li>FCFS: CPU를 먼저 쓰고 나가는 프로세스의 소요시간 및 대기시간이 짧아진다.</li><li>Round robine: CPU를 조금씩 같이 쓰고, 거의 동시에 끝나게 되어 소요시간 및 대기시간이 가장 오래 기다린 프로세스에 맞춰진다.</li><li>따라서 Round robine 스케쥴링은 FCFS의 평균 대기시간 및 평균 소요시간이 FCFS보다 거의 두 배로 더 길어진다.</li></ul></li><li><p><strong>하지만, CPU burst 시간이 균일하지 않은 경우가 대부분이기 때문에, Round robine은 FCFS보다 합리적</strong></p></li></ul><p><img loading=lazy src=https://user-images.githubusercontent.com/78094972/164458802-d87defe3-7159-4e00-aaa8-6c97c05e8acc.PNG alt=image></p></li></ul></li></ul><p> </p><h3 id=55-멀티레벨-큐multi-level-queue>5.5 멀티레벨 큐(Multi-level queue)<a hidden class=anchor aria-hidden=true href=#55-멀티레벨-큐multi-level-queue>#</a></h3><blockquote><ul><li>ready queue를 여러 개로 분할해 관리하는 스케쥴링 기법</li><li>공정하지 않은 알고리즘이지만, 우선순위가 높은 프로세스가 더 빨리 CPU를 얻어야 하기 때문이다.</li></ul></blockquote><p><img loading=lazy src=https://user-images.githubusercontent.com/78094972/164484103-7ed46059-0a87-4a76-b132-55a28eaf7623.png alt=image></p><ul><li><p><strong>이 기법의 경우, 다음과 같은 문제점이 발생한다.</strong></p><ul><li>이 기법의 경우, 어떤 줄에 서 있는 프로세스를 우선적으로 스케쥴링할 것인가??</li><li>프로세스가 도착했을 때, 어느 줄에 세워야할지 결정하는 메커니즘 필요</li></ul></li><li><p><strong>첫 번째 문제에 대한 해결책: 프로세스의 성격에 맞는 스케쥴링을 사용한다.</strong></p><ul><li>전위 큐(foreground queue): 대화형 작업(interactive job)을 담기 위한 전위
-> 응답시간을 짧게 하기 위해 Round robin scheduling 사용</li><li>후위 큐(background queue): 계산 위주의 작업을 담기 위한 후위
-> 응답 시간이 큰 의미를 가지지 않기 때문에, 그리고 context switching overhead를 줄이기 위해 FCFS 사용</li></ul></li><li><p><strong>두 번째 문제에 대한 해결책: 고정 우선순위 방식(fixed priority scheduling)</strong></p><ul><li>Fixed priority scheduling(고정 우선순위 방식)<ul><li>Queue에 고정적인 우선순위를 부여하는 방식<ul><li>우선순위가 높은 큐를 먼저 서비스 -> 낮은 큐는 우선순위가 높은 큐가 비어있을 때만 서비스 실행.</li></ul></li><li>즉, 전위 큐에 있는 프로세스에게 우선적으로 CPU를 부여하고, 전위 큐가 비어 있는 경우에만 후위 큐에 있는 프로세스에게 CPU를 할당한다.</li><li>하지만, <em>starvation</em> 이 발생할 수 있다.</li></ul></li></ul></li><li><p><strong>두 번재 문제에 대한 또 다른 해결책: time slice</strong></p><ul><li>각 queue에 CPU 시간을 적절한 비율로 할당<ul><li>ex) RR인 전위 큐: 80% , FCFS인 후위 큐: 20%</li></ul></li></ul></li></ul><p> </p><h3 id=56-멀티레벨-피드백-큐multi-level-feedback-queue>5.6 멀티레벨 피드백 큐(Multi-level Feedback Queue)<a hidden class=anchor aria-hidden=true href=#56-멀티레벨-피드백-큐multi-level-feedback-queue>#</a></h3><blockquote><p>멀티레벨 큐와 거의 다 동일하나, 차이점은 process가 하나의 queue에서 다른 큐로 이동이 가능하다. 즉, 프로세스의 우선순위가 바뀔 수 있다.</p></blockquote><p><img loading=lazy src=https://user-images.githubusercontent.com/78094972/164484385-69a85293-56f5-455a-b08b-1611d24335d2.PNG alt=image></p><ul><li><p><strong>우선순위 스케쥴링의 aging 기법을 멀티레벨 피드백 큐 방식으로 구현하면,</strong></p><ul><li>기다렸으면 우선순위가 낮은 큐에서 높은 큐로 승격시키는 방식이다.</li><li>차근 차근 시간을 늘려 때문에, CPU 사용 시간을 예측할 필요가 없다.</li></ul></li><li><p><strong>멀티레벨 피드백 큐를 정의하는 요소들</strong></p><ul><li>큐의 수</li><li>각 큐의 스케쥴링 알고리즘<ul><li>프로세스를 상위 큐로 승격시키는 기준</li><li>프로세스를 하위 큐로 강등시키는 기준</li><li>프로세스가 도착했을 때, 들어갈 큐를 결정하는 기준 등등</li></ul></li></ul></li><li><p><strong>멀티레벨 피드백 큐의 동작 예</strong></p><ul><li>프로세스가 준비 큐에 도착하면 우선순위가 가장 높은 큐(Round robine, 할당시간 8)에 줄을 선다.<br>-> CPU 사용시간이 짧은 대화형 프로세스라면 빨리 서비스 박고 작업완료할 수 있다.<br>-> CPU burst가 긴 process라면 하위 큐(Round robine, 할당시간 16)로 강등시킨다.
-> 그럼에도 완료하지 못하면 계산위주의 프로세스로 간주하여 최하위 큐인 FCFS scheduling을 적용</li></ul></li></ul><p> </p><h3 id=57-다중처리기-스케쥴링multi-processor-system>5.7 다중처리기 스케쥴링(Multi-processor system)<a hidden class=anchor aria-hidden=true href=#57-다중처리기-스케쥴링multi-processor-system>#</a></h3><blockquote><p>multi-processor 상황에서의 scheduling 기법</p></blockquote><ul><li><p>은행창구에서 번호표를 뽑아 기다리는 것처럼 <strong>CPU가 알아서 다음 프로세스를 꺼내가도록 할 수 있다.</strong></p></li><li><p>하지만, <strong>반드시 특정 CPU가 실행</strong>해야 한다든가 ex) 미용실에서 특정 미용사로 예약한 경우</p></li><li><p><strong>Load sharing</strong></p><ul><li>각 CPU 별 부하가 적절히 분산되도록 하는 매커니즘이 필요하다.</li></ul></li><li><p><strong>다중처리기 스케쥴링의 방식</strong></p><ul><li>대칭형 다중처리(SMP, Symetric Multi-Processing): 모든 CPU가 대등해서 각자 알아서 스케줄링을 결정하는 방식</li><li>비대칭형 다중처리(asymmetric multiprogramming): 하나의 CPU가 다른 모든 CPU의 스케줄링 및 데이터 접근을 책임지고, CPU는 거기에 따라 움직이는 방식</li></ul></li></ul><p> </p><h3 id=58-실시간-스케쥴링real-time-system>5.8 실시간 스케쥴링(real-time system)<a hidden class=anchor aria-hidden=true href=#58-실시간-스케쥴링real-time-system>#</a></h3><blockquote><p>정해진 시간(dead line) 이내에 처리해야만 하는 스케줄링</p></blockquote><ul><li><strong>경성 실시간 시스템(Hard real-time system)과 연성 실시간 시스템(soft real-time system)으로 나눠진다.</strong><ul><li>전자는 원자로 제어, 미사일 발사 등 시간을 정확히 지켜야하는 시스템</li><li>후자는 데드라인이 존재하지만, 지키지 못했다고 하여 위험한 상황이 발생하지 않는다.</li></ul></li></ul><p> </p><h3 id=59-thread-scheduling>5.9 Thread scheduling<a hidden class=anchor aria-hidden=true href=#59-thread-scheduling>#</a></h3><ul><li><strong>Thread를 구현하는 방식 2가지</strong><ul><li>Local Scheduling (by user process)<ul><li>User level thread의 경우, process가 thread를 직접 관리하고 OS는 thread의 존재를 모른다.</li><li>그래서 OS는 이 thread에게 CPU를 줄지 결정한다.</li><li>그리고, process 내부에서 어떤 thread에게 줄지를 결정한다.</li></ul></li><li>Global Scheduling (by OS)<ul><li>Kernel level thread의 경우, 일반 프로세스와 마찬가지로 커널의 단기 스케쥴러가 어떤 thread를 스케줄할지 결정</li><li>즉, OS가 thread의 존재를 인지한다.</li></ul></li></ul></li></ul><p> </p><hr><h2 id=6-스케쥴링-알고리즘의-평가>6. 스케쥴링 알고리즘의 평가<a hidden class=anchor aria-hidden=true href=#6-스케쥴링-알고리즘의-평가>#</a></h2><ul><li><strong>스케쥴링 알고리즘의 성능을 평가하는 방법에는 큐잉모델(Queuing model), 구현 및 실측(Implementation & measrrement), 시뮬레이션(Simulation)가 있다.</strong><ul><li>Queueing model: 이론가들이 수행하는 방식<ul><li>수학적 계산을 통해 performance index(CPU 처리량, Process 평균 대기시간 등)를 구한다.</li><li>밑에 방식이 훨씬 많이 사용된다.</li></ul></li><li>Implementation & measurement: 이론가가 아닌 구현가들이 수행하는 방식<ul><li>동일한 program을 원래 kernel과 CPU scheduler code를 수정한 kernel에서 수행한 후, 실행시간을 측정하여 알고리즘을 평가한다.</li><li>이 방법이 어려우면 밑에 방법을 사용한다.</li></ul></li><li>Simulation: 가상으로 CPU scheduling program을 작성하는 방식<ul><li>가상으로 CPU scheduling program을 작성한 후, 프로그램의 CPU 요청을 입력값으로 넣어 어떠한 결과가 나오는지 확인하는 방법</li><li>그래서 가상으로 생성된 값과 실제 system에서 추출한 입력값(이를 trace라 한다.)을 비교한다.</li></ul></li></ul></li></ul><p> </p><hr><h1 id=reference>Reference<a hidden class=anchor aria-hidden=true href=#reference>#</a></h1><ul><li><a href="http://www.kyobobook.co.kr/product/detailViewKor.laf?ejkGb=KOR&mallGb=KOR&barcode=9791158903589&orderClick=LAG&Kc=">운영체제와 정보기술의 원리</a></li><li><a href="http://www.kocw.net/home/cview.do?lid=3dd1117c48123b8e">kocw 이화여자대학교 운영체제 - 반효경 교수 -</a></li></ul></div><footer class=post-footer><ul class=post-tags><li><a href=http://jeha00.github.io/tags/til/>TIL</a></li><li><a href=http://jeha00.github.io/tags/os/>OS</a></li></ul><nav class=paginav><a class=prev href=http://jeha00.github.io/post/os/os_chapter_07_%EB%A9%94%EB%AA%A8%EB%A6%AC%EA%B4%80%EB%A6%AC_1/><span class=title>« Prev Page</span><br><span>[TIL] Chapter 07: 메모리 관리 1</span></a>
<a class=next href=http://jeha00.github.io/post/os/os_chapter_05_%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4_%EA%B4%80%EB%A6%AC/><span class=title>Next Page »</span><br><span>[TIL] Chapter 05: 프로세스 관리</span></a></nav><div class=share-buttons><a target=_blank rel="noopener noreferrer" aria-label="share [TIL] Chapter 06: CPU scheduling on twitter" href="https://twitter.com/intent/tweet/?text=%5bTIL%5d%20Chapter%2006%3a%20CPU%20scheduling&url=http%3a%2f%2fjeha00.github.io%2fpost%2fos%2fos_chapter_06_cpu_scheduling%2f&hashtags=TIL%2cOS"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM195.519 424.544c135.939.0 210.268-112.643 210.268-210.268.0-3.218.0-6.437-.153-9.502 14.406-10.421 26.973-23.448 36.935-38.314-13.18 5.824-27.433 9.809-42.452 11.648 15.326-9.196 26.973-23.602 32.49-40.92-14.252 8.429-30.038 14.56-46.896 17.931-13.487-14.406-32.644-23.295-53.946-23.295-40.767.0-73.87 33.104-73.87 73.87.0 5.824.613 11.494 1.992 16.858-61.456-3.065-115.862-32.49-152.337-77.241-6.284 10.881-9.962 23.601-9.962 37.088.0 25.594 13.027 48.276 32.95 61.456-12.107-.307-23.448-3.678-33.41-9.196v.92c0 35.862 25.441 65.594 59.311 72.49-6.13 1.686-12.72 2.606-19.464 2.606-4.751.0-9.348-.46-13.946-1.38 9.349 29.426 36.628 50.728 68.965 51.341-25.287 19.771-57.164 31.571-91.8 31.571-5.977.0-11.801-.306-17.625-1.073 32.337 21.15 71.264 33.41 112.95 33.41z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share [TIL] Chapter 06: CPU scheduling on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&url=http%3a%2f%2fjeha00.github.io%2fpost%2fos%2fos_chapter_06_cpu_scheduling%2f&title=%5bTIL%5d%20Chapter%2006%3a%20CPU%20scheduling&summary=%5bTIL%5d%20Chapter%2006%3a%20CPU%20scheduling&source=http%3a%2f%2fjeha00.github.io%2fpost%2fos%2fos_chapter_06_cpu_scheduling%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share [TIL] Chapter 06: CPU scheduling on reddit" href="https://reddit.com/submit?url=http%3a%2f%2fjeha00.github.io%2fpost%2fos%2fos_chapter_06_cpu_scheduling%2f&title=%5bTIL%5d%20Chapter%2006%3a%20CPU%20scheduling"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share [TIL] Chapter 06: CPU scheduling on facebook" href="https://facebook.com/sharer/sharer.php?u=http%3a%2f%2fjeha00.github.io%2fpost%2fos%2fos_chapter_06_cpu_scheduling%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share [TIL] Chapter 06: CPU scheduling on whatsapp" href="https://api.whatsapp.com/send?text=%5bTIL%5d%20Chapter%2006%3a%20CPU%20scheduling%20-%20http%3a%2f%2fjeha00.github.io%2fpost%2fos%2fos_chapter_06_cpu_scheduling%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share [TIL] Chapter 06: CPU scheduling on telegram" href="https://telegram.me/share/url?text=%5bTIL%5d%20Chapter%2006%3a%20CPU%20scheduling&url=http%3a%2f%2fjeha00.github.io%2fpost%2fos%2fos_chapter_06_cpu_scheduling%2f"><svg viewBox="2 2 28 28"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></div></footer></article></main><footer class=footer><span>&copy; 2023 <a href=http://jeha00.github.io/>Jeha DevLog</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerText="copy";function s(){t.innerText="copied!",setTimeout(()=>{t.innerText="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>