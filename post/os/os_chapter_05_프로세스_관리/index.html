<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>[TIL] OS Chapter 05: 프로세스 관리 | Jeha00 DevLog</title><meta name=keywords content="TIL,OS"><meta name=description content="프로세스란 무엇인지, 프로세스의 상태는 어떻게 흘러가는지, 문맥 교환이란 무엇인지, 프로세스가 어떻게 생성되고 종료되는지, 프로세스끼리 협력은 어떻게 하는지, thread는 무엇인지 알아보겠다."><meta name=author content><link rel=canonical href=http://jeha00.github.io/post/os/os_chapter_05_%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4_%EA%B4%80%EB%A6%AC/><meta name=google-site-verification content="XYZabc"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.min.1e44d58192cbf6d7a4eb649bc43dbc3d4cc432677e5d8adc69b08c34cbe461ac.css integrity="sha256-HkTVgZLL9tek62SbxD28PUzEMmd+XYrcabCMNMvkYaw=" rel="preload stylesheet" as=style><link rel=icon href=http://jeha00.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=http://jeha00.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=http://jeha00.github.io/favicon-32x32.png><link rel=apple-touch-icon href=http://jeha00.github.io/apple-touch-icon.png><link rel=mask-icon href=http://jeha00.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><meta name=generator content="Hugo 0.101.0"><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><script type=application/javascript>var doNotTrack=!1;doNotTrack||(function(e,t,n,s,o,i,a){e.GoogleAnalyticsObject=o,e[o]=e[o]||function(){(e[o].q=e[o].q||[]).push(arguments)},e[o].l=1*new Date,i=t.createElement(n),a=t.getElementsByTagName(n)[0],i.async=1,i.src=s,a.parentNode.insertBefore(i,a)}(window,document,"script","https://www.google-analytics.com/analytics.js","ga"),ga("create","UA-123-45","auto"),ga("send","pageview"))</script><meta property="og:title" content="[TIL] OS Chapter 05: 프로세스 관리"><meta property="og:description" content="프로세스란 무엇인지, 프로세스의 상태는 어떻게 흘러가는지, 문맥 교환이란 무엇인지, 프로세스가 어떻게 생성되고 종료되는지, 프로세스끼리 협력은 어떻게 하는지, thread는 무엇인지 알아보겠다."><meta property="og:type" content="article"><meta property="og:url" content="http://jeha00.github.io/post/os/os_chapter_05_%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4_%EA%B4%80%EB%A6%AC/"><meta property="og:image" content="http://jeha00.github.io/47"><meta property="article:section" content="post"><meta property="article:published_time" content="2022-04-18T23:25:25+09:00"><meta property="article:modified_time" content="2022-04-18T23:25:25+09:00"><meta property="og:site_name" content="JeHa00 DevLog"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="http://jeha00.github.io/47"><meta name=twitter:title content="[TIL] OS Chapter 05: 프로세스 관리"><meta name=twitter:description content="프로세스란 무엇인지, 프로세스의 상태는 어떻게 흘러가는지, 문맥 교환이란 무엇인지, 프로세스가 어떻게 생성되고 종료되는지, 프로세스끼리 협력은 어떻게 하는지, thread는 무엇인지 알아보겠다."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"http://jeha00.github.io/post/"},{"@type":"ListItem","position":2,"name":"[TIL] OS Chapter 05: 프로세스 관리","item":"http://jeha00.github.io/post/os/os_chapter_05_%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4_%EA%B4%80%EB%A6%AC/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"[TIL] OS Chapter 05: 프로세스 관리","name":"[TIL] OS Chapter 05: 프로세스 관리","description":"프로세스란 무엇인지, 프로세스의 상태는 어떻게 흘러가는지, 문맥 교환이란 무엇인지, 프로세스가 어떻게 생성되고 종료되는지, 프로세스끼리 협력은 어떻게 하는지, thread는 무엇인지 알아보겠다.","keywords":["TIL","OS"],"articleBody":"0. Introduction 해당 내용은 운영체제와 정보기술의 원리 -반효경 지음- 와 kocw 이화여자대학교 운영체제 - 반효경 교수 -를 보고 정리한 내용입니다. 정확하지 않은 내용이 있다면 말씀해주시면 감사하겠습니다. 1. 프로세스의 개념 1.1 Process (프로세스) is a prgram in execution 프로세스 = 실행 중인 프로그램 디스크에 실행파일 형태로 존재하는 상태(프로그램) → 메모리에 올라감 → 실행 이 실행 중일 때를 process라 한다. 1.2 Process context (프로세스 문맥 ) process의 수행 상태를 정확히 아는데 필요한 모든 요소\nprocess conetxt를 알아야 하는 이유???\nCPU는 시분할 시스템으로, timer interrupt에 의해서 여러 process가 돌아가면서 CPU를 사용한다. 이런 상황에서, 한 process가 CPU를 다른 process에게 이양했다가 다시 획득했을 때, 직전 수행 시점의 정확한 상태 를 재현하기 위해서 필요하다. Process context의 분류\nHardware context\nProgram counter 각종 register 이 register에 저장된 값들 Process의 address space\ncode, data, stack process만의 독자적인 주소 공간 process 관련 kernel 상의 문맥\nPCB (Process Control Block) Kernel stack OS가 process를 관리하기 위해 유지하는 자료구조들: PCB, kernel stack 2. 프로세스의 상태 2.1 Process의 상태도 Process는 다음 상태 중 어느 한 상태에 머무르며, 시간의 흐름에 따라 변한다.\nProcess의 상태를 나누는 이유는 컴퓨터의 자원을 효율적으로 관리하기 위함\nProcess의 상태도\nRunning: CPU를 잡고 instruction을 수행 중인 상태 Ready: 다른 조건은 다 만족하고, 메모리에는 올라와 CPU만 기다리는 상태 Blocked( wait, sleep ): CPU를 할당받아도 당장 instruction을 수행할 수 없는 상태 process 자신이 요청한 even가 즉시 만족되지 않아 이를 기다리는 상태 ex) disk에서 file을 읽어와야 하는 경우 (I/O 작업) New: process가 시작되어 자료구조는 생성되었지만, 메모리 획득을 승인받지 못한 상태 Terminated: execution(실행)이 끝났지만, 자료 구조 정리는 완료하지 못한 상태 Dispatch:\nCPU를 할당받을 process를 선택한 후, 실제로 CPU의 제어권을 넘겨받는 과정 2.2 Process 상태 변화 예시 2.2 Process 상태 변화 예시 입출력을 요청한 프로세스의 상태 변화\nRunning state\nA process가 CPU를 할당 받아 기계어 명령을 하나씩 수행 → I/O 요청\n파일의 내용을 disk에서 읽어와야 명령이 진행될 수 있으므로, 입출력 요청을 한다. → Blocked state\n입출력 요청이 완료될 때까지 CPU를 반환한 다음, disk 입출력 서비스를 기다리며 봉쇄 상태로 바뀐다. 그리고, 해당 process는 device I/O queue 뒤에 줄슨다. → Ready state의 process 중 선정\nCPU를 할당받을 process를 선택하기 위해, ready 상태의 process 들 중에서 CPU scheduler가 적절한 process를 하나 선정하여 CPU를 할당한다. → Running state\nB process가 CPU를 받아 자신의 code를 실행한다. → device controller 가 interrupt 발생\nI/O 작업을 하던 controller가 interrupt를 발생하여 CPU에게 I/O 작업 완료를 알림 → B process를 user mode에서 kernel mode 진입\ninterrupt의 발생 원인이 B process와 상관없어도, CPU가 현재 사용하고 있던 process가 kernel mode로 진입했다고 판단. → Ready state\nHW interrupt에 의해서 A process를 blocked state에서 ready state로 바꾼 후, CPU의 ready queue에 줄을 세운다. 그리고, device의 local buffer에 있는 내용을 memory로 이동한다. 3. 프로세스 제어블록 3.1 PCB란 ?? 운영체제가 각 process를 관리하기 위해, process 마다 유지하는 정보들을 담는, 커널 내의 자료구조 3.2 PCB의 구성 요소 1) OS가 관리를 위해 사용하는 정보 Process state, process ID process state: CPU를 할당해도 되는지 여부를 결정하기 위해 process ID: 효율적인 관리를 위해 process 마다 매긴 고유 번호 scheduling information, priority 2) CPU 수행 관련 HW 값 program counter: 다음에 수행할 명령의 위치를 가리킨다. registers 3) 메모리 관련 code, data, stack 4) 파일 관련 open file descriptors: 입출력 관련 상태 정보 4. 문맥교환 (Context switch) Context switch란?? CPU를 한 프로세스에서 다른 프로세스로 넘겨주는 과정\n문맥 교환 중, OS가 실행하는 것들\nCPU를 내어주는 process의 state를 이 process의 PCB에 저장\nCPU를 새롭에 얻는 process의 state를 PCB에서 읽어온다.\ncontext switch가 일어나는 경우와 그렇지 않은 경우\nSystem call이나 interrupt 발생 시, 반드시 문맥교환이 일어나는 게 아니다.\n첫 번째 경우, 단지 같은 process의 mode가 바뀌는 경우 두 번째 경우가 context switch다. 첫 번째 경우도 CPU 수행 정보 등 context의 일부를 PCB에 저장해야 하지만, context switch를 하는 경우, 오버헤드가 훨씬 크다. (eg. cache memory flush) A process의 address space의 code를 실행하다가, kernel address space의 code를 실행하는 것이기 때문에, PCB에 저장해야 한다. 문맥교환에 소요되는 시간은 일종의 오버헤드다.\n그래서, timer로 CPU 할당시간을 아주 작게 세팅하면 문맥교환이 빈번히 발생하기 때문에, 오버헤드가 상당히 커진다. 하지만, CPU 할당 시간을 너무 크게 설정하면 시분할 시스템의 의미가 퇴색된다. 그러므로, 적절한 CPU 할당시간을 정해야 한다. 5. 프로세스를 스케쥴링 하기 위한 큐 5.1 kernel의 process 상태 관리 process 상태 관리는 kernel의 주소 공간의 data 영역 에 다양한 queue를 두어 수행한다. process들은 각 queue들을 오가며 수행한다. 5.2 다양한 queue 종류 Job queue 현재 시스템 내에 있는 모든 프로세스를 관리하기 위한 큐 모든 process가 속한다. ready queue와 device queue가 다 포함된다. ready 큐에 포함하면 device 큐에는 포함되지 않는다. Ready queue 현재 메모리 내에 있으면서 CPU를 잡아서 실행되기를 기다리는 프로세스의 집합 Device queues (장치 큐) = HW queue 각 I/O device의 service를 기다리는 process의 집합 각 deivce마다 있기 때문에, 다양하다. 예) device controller가 줄 서 있는 순서대로 I/O 작업 수행 → 작업 완료하면 controller가 interrupt 발생 → interrupt service routine에 의해서 입출력 작업이 완료된 process는 I/O queue에서 나와 CPU대기 queue 슨다. resource queue = SW resource SW queue가 필요한 이유?? SW resource인 공유 데이터에 여러 process가 접근할 경우, 데이터의 일관성 훼손 이 발생할 수 있다. 그래서, 공유 데이터에는 매 시점 하나의 프로세스만이 접근하도록 한다. SW resource에 접근 중인 process가 다 사용하고 반납할 때까지, 다른 process가 CPU를 할당받았어도 접근하지 말고 공유 데이터 queue에서 기다려야 한다. 5.3 Process scheduling queue의 모습 위 image는 OS가 queue를 어떻게 자료구조로 구현하는지 보여준다. queue는 각 process의 PCB를 연결 list 형태로 관리하여 순서를 정한다. Queue header 큐의 가장 앞부분 PCB의 pointer 부분이 이어진다. queue 흐름 설명 process가 CPU 할당받고 수행 중 I/O 요청이 발생하면 해당 device queue에 줄을 슨다. device queue에 속한 process는 blocked state였다가, 해당 장치의 서비스를 받으면, device controller가 인터럽트를 발생시켜 준비 상태로 바껴 ready queue로 이동한다. ready queue에는 PCB 7 다음에, PCV 2가 대기하고 있다. magnetic tape에는 아무것도 대기하지 않는다. disk queue에는 PCB 3 ← PCB 14 ← PCB 6 순서로 대기하고 있다. terminal queue에는 PCB 5 만 대기하고 있다. 6. 스케쥴러 (Scheduler) 6.1 Long-term scheduler (장기 스케쥴러 or job scheduler) 시작 프로세스 중 어떤 것들을 ready queue 로 보낼지 결정 process에 memory (및 각종 자원) 을 주는 문제 메모리를 어느 것에 줄지를 결정 현대의 컴퓨터는 메모리를 기본적으로 바로 준다. degree of Multiprogramming 제어 multi-programming: 메모리에 여러 프로그램이 동시에 올라가는 것을 의미 이 메모리에 올라가는 수를 제어하는 것 → 컴퓨터 성능에 영향을 줌 현 컴퓨터에는 장기 스케쥴러는 없고, 프로그램이 시작하면 다 ready 상태로 들어간다. time sharing system에는 보통 장기 scheduler가 없다. (무조건 ready) 6.2 Short-term schduler (단기 scheduler or CPU scheduler) 어떤 프로세스를 다음 번에 running 시킬지 결정 프로세스에 CPU 를주는문제 충분히 빨라야 함 (milli-second 단위) 6.3 Medium-Term Scheduler (중기 스케쥴러 or Swapper) 여유 공간 마련을 위해 프로세스를 통째로 메모리에서 디스크로 쫓아낸다. 프로세스에게서 memory 를 뺏는 문제 메모리에 프로그램이 너무 많이 올라가면, 쫓아내어 전체적인 컴퓨터 성능을 개선. 시스템 입장에서는 장기 스케쥴러보다 중기 스케쥴러를 주는 게 더 이득 degree of multiprogramming 을 제어 현재 multi-programming을 제어하는 scheduler 이 중기 스케쥴러가 들어가 있기 때문에, 프로세스의 상태 3가지에 추가된 게 suspended다. 6.4 추가된 프로세스 상태도 중기 스케쥴러에 의해 suspended state가 추가되었다. Running CPU를 잡고 instruction을 수행 중인 상태 Ready CPU를 기다리는 상태( 메모리 등 다른 조건을 모두 만족하고) Blocked (wait, sleep) I/O 등의 event를 스스로 기다리는 상태 예) 디스크에서 file을 읽어와야 하는 경우 Suspended (stopped) 외부적인 이유로 강제로 프로세스의 수행이 정지된 상태 중기 스케쥴러에 의해 강제로 뺏긴 상태 이 상태의 프로세스는 통째로 디스크에 swap out 된다. 예) 사용자가 프로그램을 일시 정지시킨 경우 (break key). 이 경우에는 사람이 재개시켜야 위의 상태가 된다. 시스템이 여러 이유로 프로세스를 잠시 중단시킴 → 중기 스케쥴러 (메모리에 너무 많은 프로세스가 올라와 있을 때) blocked와 suspended 구분하기 Blocekd: 자신이 요청한 event가 만족되면(자신이 요청한 작업이 완료되면) Ready Suspended: 외부에서 정지된 상태이기 대문에, 외부에서 resume 해 주어야 Active 7. 프로세스의 생성 7.1 Process creation (프로세스 생성) : COW(Copy-On-Write) OS가 process를 전부 생성하는 게 아닌, 부팅 후 최초의 process는 운영체제가 직접 생성한다. 그 다음부터는 이미 존재하는 process가 다른 process를 복제 생성한다.\n부모 프로세스와 자식 프로세스의 정의 및 관계\nprocess를 생성하는 process: 부모 프로세스 부모 프로세스에 의해 생성된 process: 자식 프로세스 부모 프로세스 1개가 자식 프로세스 최소 1개를 복제 생성 한다. 또한, 자식 프로세스가 process를 생성할 수 있다. 그래서 프로세스의 트리(계층 구조) 형성 작업 수행을 위한 자원\n부모 프로세스는 OS로부터 받는다. 자식 프로세스는 부모 프로세스와 공유 한다. 부모와 자식 프로세스가 서로 모든 자원을 공유 하는 모델 일부를 공유 하는 모델 전혀 공유하지 않는 모델 주소 공간 (Address space)\nprocess 생성의 첫 번째: 부모 공간을 복사 → 두 번째: 복사한 공간에 새로운 프로그램의 주소 공간을 덮어씌운다. Process 와 관련한 system call (특권 명령 )\nfork() : create a child (copy) exec() : overlay new image = 새로운 프로그램으로서 덮어씌운다. wait() : sleep until child is done exit() : frees all the resources, notify parent UNIX의 예\nos에게 fork() system call 요청하여, 새로운 process를 생성 부모를 그대로 복사하고, 주고 공간을 할당 복사할 때, 부모 프로세스의 process ID는 제외한다. fork () 다음에 이어지는 exec () system cal을 통해 새로운 프로그램을 메모리에 올린다. fork () 와 exec () 둘 다 system call을 통해서 실행되므로, 운영체제가 생성한다. 7.2 Process Termination (프로세스 종료) 프로세스가 마지막 명령을 수행한 후, 운영체제에게 이를 알려준다. (’exit’ system call) 자식이 부모에게 output data를 보낸다. (via ‘wait’ system call) 프로세스의 각종 자원들이 운영체제에게 반납된다. 자식 프로세스가 먼저 종료 후 부모 프로세스가 종료되야 한다. 부모 프로세스에게 자식의 수행을 종료시킨다. (abort) 자식이 할당 자원의 한계치를 넘어설 때 자식에게 할당된 task가 더 이상 필요하지 않을 때 (자식 프로세스를 만든 이유가 일을 시키기 위함이기 때문) 부모가 종료(exit)할 때 운영체제는 부모프로세스가 종료하는 경우, 자식이 더 수행되도록 두지 않는다. 단계적인 종료( 손자 → 자식 → 부모 )가 지켜져야 한다. 7.3 fork () system call creats a new address space that is a duplicate of the caller 자식 process를 만들 때, 부모 process의 program counter까지 복사된다. 부모 process와 자식 process의 차이는 식별자 다. 그래서, program counter는 fork () 실행 후, 다음 코드를 가리키기 때문에, 자식 process는 fork ()한 이후부터 코드를 실행한다. 자식 process라 부르지만, 복제인간이라 생각하는 게 정확한다. 또한, 복제된 process는 자신을 원본이라 생각한다. 복제된 process인지 아닌지 구분하는 방법 fork 함수의 결과값으로 자식 process 는 0을, 부모 process에게는 양수를 준다. 7.4 exec () system call fork () 한 후, exec () system call을 통해서 자식 프로세스를 새로운 program으로 대체한다. (overwrite) 한 번 만들어지면 다시 되돌아갈 수 없다. 7.5 wait () system call wait () system call은 자식 process가 종료될 때까지 process A를 blocked state로 만든다. 자식 프로세스가 종료되면 kernel은 프로세스 A를 준비 상태로 변경하여 준비 큐에 진입. 7.6 exit() system call process의 종료 자발적 종료 마지막 statement 수행 후, OS에게 exit () system call로 자신이 종료됨을 알린다. 명시적으로 exit ()을 호출하지 않아도, main () 함수가 반환되는 위치에 compiler가 자동으로 삽입해 프로세스 종료 직전에 항상 호출한다. 비자발적 종료 (자식 프로세스 밖에서 종료시키는 경우) 부모 프로세스가 자식 프로세스를 강제 종료시킨다. When?? 자식 프로세스가 한계치를 넘어서는 할당 자원 요청을 할 때 자식에게 할당된 task가 더 이상 필요하지 않을 때 프로그램 종료 버튼을 누르는 경우나, 키보드로 kill, break 등을 친 경우 부모가 종료하는 경우 부모 프로세스가 종료하기 전에 자식들이 먼저 종료된다. 프로그램을 강제 종료시킨 후, 계속 수행시켜야하는 경우에는 종료되지 않는 다른 자식 프로세스로 이양시켜서, 기존 부모 프로세스가 종료된 후에도 다른 프로세스 아래에서 계속 수행한다. 부모가 죽기 전에 자식이 먼저 죽는다는 원칙은 여전히 지켜진다. 8. 프로세스 간의 협력 8.1 Process 간 협력하는 이유 독립적 프로세스 (Independent process)\n프로세스는 각자의 주소 공간을 가지고 수행되므로, 원칙적으로 하나의 프로세스는 다른 프로세스의 수행에 영향을 미치지 못한다. 하지만, process 간 협력한다면 왜 하고 어떻게 하는 것일까??\n협력 프로세스( Cooperating process)\nWhy? 업무의 효율성 증대: 부분적인 처리 결과, 정보를 공유할 수 있고, 처리 속도가 향상. How? IPC(Inter-Process Communication): process 간 통신과 동기화를 이루기 위한 mechanism 8.2 IPC의 대표적인 방법: 2가지 Message passing: 메시지 전달 방식\nMessage passing의 특징\n프로세스 사이에 공유 변수(shared variable)을 일체 사용하지 않고 통신하는 시스템. 중간에 kernel을 통해서 하는데, 명시적으로 process의 이름을 표시하냐 안하냐의 차이. kernel에 의해 send(message)와 receive(message)라는 두 가지 연산을 제공받는다. 즉, 이 두 가지 연산은 특권명령이다. Message passing 방식 2가지\n직접 통신 (direct communication) 간접 통신 (Indirect communication) Shared memory: 공유 메모리 방식\n8.3 Message passing 방식: 2가지 Message passing 방식에는 직접통신(direct communication)과 간접통신(indirect communication) 으로 나뉜다.\nDirect communication 통신하려는 프로세스의 이름을 명시적으로 표시한다. Send (Q, message): process Q에게 메시지를 전송하는 것을 의미 Receive (P, message): process P로부터 메시지를 전달받는 것을 의미 link는 자동적으로 생성되며, 하나의 link는 정확히 한 쌍의 process에게 할당된다. 각 쌍의 process에게는 오직 하나의 link만이 존재한다. Indirect communication 통신하려는 프로세스의 이름을 명시적으로 표시하지 않는다. mailbox ( or port)를 통해 메시지를 간접 전달한다. mailbox에는 고유의 ID가 있다. 이 mailbox를 공유하는 process 들끼리만 서로 통신할 수 있다. Send(M, message): M이라는 mailbox에 message를 전달하는 것 Receive(M, message): M이라는 mailbox로부터 메시지를 전달받는 것 mailbox를 3개 이상의 process가 공유할 경우, 각각의 프로세스에게 링크를 따로 생성가능. 8.4 Shared memory 서로 다른 process 간에도 일부 주소 공간을 공유하게 하는 mechanism 두 process가 서로 신뢰할 수 있는 process여야 한다. kernel에게 system call 후, memory가 공유된다. 물리적인 공간에 mapping 할 때, 공유된 상태로 진행한다. 이 방법에서 동기화 문제는 kernel 책임지지 않고, 공유되는 process 들이 책임져야 한다. 9. Thread 9.1 Thread란?? A Thread (or lightweight process) is a basic unit of CPU utilization\nCPU의 기본 실행 단위를 Thread 라 한다. Thread의 구성\nProgram counter register set stack space stack space에서 여러 thread로 나눠진다. process 내부에서 thread가 동료 thread와 공유하는 부분 = task\ncode section data section OS resources heavyweight process 는 하나의 thread를 가지고 있는 task 다.\nCPU가 명령 수행을 위해서는 코드의 실행될 부분을 가리키는 program counter가 있어야 한다. 또한, memory에 register 값 을 세팅해야 한다. OS는 process를 관리하기 위해 process마다 1개의 PCB를 둔다. 이 PCB를 보면 여러 thread로 구성된 걸 확인할 수 있다. 9.2 Thread의 장점 Responsiveness: 응답성 eg) multi-thread: 하나의 thread가 blocked state 인 동안에도, 동일한 task 내의 다른 thread가 계속 실행되어 빠른 처리를 할 수 있다. Resource sharing: 자원의 효율적인 관리 여러 thread가 process의 code, data, resource를 공유하기 때문에, 자원 관리가 효율적. Economy: 경제성 process를 새로 생성하는 것보다 thread를 새로 생성하는 게 오버헤드가 훨씬 적다. process 간의 switching보다, thread 간의 switching이 오버헤드가 훨씬 적다. Utilization of MP Architectures 병렬로 thread가 실행될 수 있다. 다중 thread가 협력하여 높은 처리율과 성능 향상을 얻는다. 9.3 Implementation of threads Some are supported by kernel ⇒ Kernel threads thread가 여러 개인 것을 운영체제가 알고 있음 예) Windows 95, 98 / NT Solaris Digital UNIX, Mach Others are supported by library ⇒ User Threads 운영체제가 프로세스 안에 thread가 여러개인 걸 모른다. 즉, User program이 thread를 관리한다. 예) POSIX Pthreads MAch C-threads Solaris threads Some are real time threads real time을 지원하는 thread Reference 운영체제와 정보기술의 원리 kocw 이화여자대학교 운영체제 - 반효경 교수 - ","wordCount":"2309","inLanguage":"en","datePublished":"2022-04-18T23:25:25+09:00","dateModified":"2022-04-18T23:25:25+09:00","mainEntityOfPage":{"@type":"WebPage","@id":"http://jeha00.github.io/post/os/os_chapter_05_%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4_%EA%B4%80%EB%A6%AC/"},"publisher":{"@type":"Organization","name":"Jeha00 DevLog","logo":{"@type":"ImageObject","url":"http://jeha00.github.io/favicon.ico"}}}</script></head><body class=dark id=top><script>localStorage.getItem("pref-theme")==="light"&&document.body.classList.remove("dark")</script><header class=header><nav class=nav><div class=logo><a href=http://jeha00.github.io/ accesskey=h title="Jeha00 (Alt + H)">Jeha00</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></span></div><ul id=menu><li><a href=http://jeha00.github.io/me/ title=About><span>About</span></a></li><li><a href=http://jeha00.github.io/archives/ title=Archive><span>Archive</span></a></li><li><a href=http://jeha00.github.io/categories/ title=Categories><span>Categories</span></a></li><li><a href=http://jeha00.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=http://jeha00.github.io/>Home</a>&nbsp;»&nbsp;<a href=http://jeha00.github.io/post/>Posts</a></div><h1 class=post-title>[TIL] OS Chapter 05: 프로세스 관리</h1><div class=post-meta><span title='2022-04-18 23:25:25 +0900 KST'>April 18, 2022</span>&nbsp;|&nbsp;<a href=https://github.com/JeHa00/blog/content/post/OS/OS_Chapter_05_%ed%94%84%eb%a1%9c%ec%84%b8%ec%8a%a4_%ea%b4%80%eb%a6%ac.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#0-introduction aria-label="0. Introduction">0. Introduction</a></li><li><a href=#1-%ed%94%84%eb%a1%9c%ec%84%b8%ec%8a%a4%ec%9d%98-%ea%b0%9c%eb%85%90 aria-label="1. 프로세스의 개념">1. 프로세스의 개념</a><ul><li><a href=#11-process-%ed%94%84%eb%a1%9c%ec%84%b8%ec%8a%a4 aria-label="1.1 Process (프로세스)">1.1 Process (프로세스)</a></li><li><a href=#12-process-context-%ed%94%84%eb%a1%9c%ec%84%b8%ec%8a%a4-%eb%ac%b8%eb%a7%a5- aria-label="1.2 Process context (프로세스 문맥 )">1.2 Process context (프로세스 문맥 )</a></li></ul></li><li><a href=#2-%ed%94%84%eb%a1%9c%ec%84%b8%ec%8a%a4%ec%9d%98-%ec%83%81%ed%83%9c aria-label="2. 프로세스의 상태">2. 프로세스의 상태</a><ul><li><a href=#21-process%ec%9d%98-%ec%83%81%ed%83%9c%eb%8f%84 aria-label="2.1 Process의 상태도">2.1 Process의 상태도</a></li><li><a href=#22-process-%ec%83%81%ed%83%9c-%eb%b3%80%ed%99%94-%ec%98%88%ec%8b%9c aria-label="2.2 Process 상태 변화 예시">2.2 Process 상태 변화 예시</a></li><li><a href=#22-process-%ec%83%81%ed%83%9c-%eb%b3%80%ed%99%94-%ec%98%88%ec%8b%9c-1 aria-label="2.2 Process 상태 변화 예시">2.2 Process 상태 변화 예시</a></li></ul></li><li><a href=#3-%ed%94%84%eb%a1%9c%ec%84%b8%ec%8a%a4-%ec%a0%9c%ec%96%b4%eb%b8%94%eb%a1%9d aria-label="3. 프로세스 제어블록">3. 프로세스 제어블록</a><ul><li><a href=#31-pcb%eb%9e%80- aria-label="3.1 PCB란 ??">3.1 PCB란 ??</a></li><li><a href=#32-pcb%ec%9d%98-%ea%b5%ac%ec%84%b1-%ec%9a%94%ec%86%8c aria-label="3.2 PCB의 구성 요소">3.2 PCB의 구성 요소</a></li></ul></li><li><a href=#4-%eb%ac%b8%eb%a7%a5%ea%b5%90%ed%99%98-context-switch aria-label="4. 문맥교환 (Context switch)">4. 문맥교환 (Context switch)</a><ul><li><a href=#context-switch%eb%9e%80 aria-label="Context switch란??">Context switch란??</a></li></ul></li><li><a href=#5-%ed%94%84%eb%a1%9c%ec%84%b8%ec%8a%a4%eb%a5%bc-%ec%8a%a4%ec%bc%80%ec%a5%b4%eb%a7%81-%ed%95%98%ea%b8%b0-%ec%9c%84%ed%95%9c-%ed%81%90 aria-label="5. 프로세스를 스케쥴링 하기 위한 큐">5. 프로세스를 스케쥴링 하기 위한 큐</a><ul><li><a href=#51-kernel%ec%9d%98-process-%ec%83%81%ed%83%9c-%ea%b4%80%eb%a6%ac aria-label="5.1 kernel의 process 상태 관리">5.1 kernel의 process 상태 관리</a></li><li><a href=#52-%eb%8b%a4%ec%96%91%ed%95%9c-queue-%ec%a2%85%eb%a5%98 aria-label="5.2 다양한 queue 종류">5.2 다양한 queue 종류</a></li><li><a href=#53-process-scheduling-queue%ec%9d%98-%eb%aa%a8%ec%8a%b5 aria-label="5.3 Process scheduling queue의 모습">5.3 Process scheduling queue의 모습</a></li></ul></li><li><a href=#6-%ec%8a%a4%ec%bc%80%ec%a5%b4%eb%9f%ac-scheduler aria-label="6. 스케쥴러 (Scheduler)">6. 스케쥴러 (Scheduler)</a><ul><li><a href=#61-long-term-scheduler-%ec%9e%a5%ea%b8%b0-%ec%8a%a4%ec%bc%80%ec%a5%b4%eb%9f%ac-or-job-scheduler aria-label="6.1 Long-term scheduler (장기 스케쥴러 or job scheduler)">6.1 Long-term scheduler (장기 스케쥴러 or job scheduler)</a></li><li><a href=#62-short-term-schduler-%eb%8b%a8%ea%b8%b0-scheduler-or-cpu-scheduler aria-label="6.2 Short-term schduler (단기 scheduler or CPU scheduler)">6.2 Short-term schduler (단기 scheduler or CPU scheduler)</a></li><li><a href=#63-medium-term-scheduler-%ec%a4%91%ea%b8%b0-%ec%8a%a4%ec%bc%80%ec%a5%b4%eb%9f%ac-or-swapper aria-label="6.3 Medium-Term Scheduler (중기 스케쥴러 or Swapper)">6.3 Medium-Term Scheduler (중기 스케쥴러 or Swapper)</a></li><li><a href=#64-%ec%b6%94%ea%b0%80%eb%90%9c-%ed%94%84%eb%a1%9c%ec%84%b8%ec%8a%a4-%ec%83%81%ed%83%9c%eb%8f%84 aria-label="6.4 추가된 프로세스 상태도">6.4 추가된 프로세스 상태도</a></li></ul></li><li><a href=#7-%ed%94%84%eb%a1%9c%ec%84%b8%ec%8a%a4%ec%9d%98-%ec%83%9d%ec%84%b1 aria-label="7. 프로세스의 생성">7. 프로세스의 생성</a><ul><li><a href=#71-process-creation-%ed%94%84%eb%a1%9c%ec%84%b8%ec%8a%a4-%ec%83%9d%ec%84%b1--cowcopy-on-write aria-label="7.1 Process creation (프로세스 생성) : COW(Copy-On-Write)">7.1 Process creation (프로세스 생성) : COW(Copy-On-Write)</a></li><li><a href=#72-process-termination-%ed%94%84%eb%a1%9c%ec%84%b8%ec%8a%a4-%ec%a2%85%eb%a3%8c aria-label="7.2 Process Termination (프로세스 종료)">7.2 Process Termination (프로세스 종료)</a></li><li><a href=#73-fork--system-call aria-label="7.3 fork () system call">7.3 fork () system call</a></li><li><a href=#74-exec--system-call aria-label="7.4 exec () system call">7.4 exec () system call</a></li><li><a href=#75-wait--system-call aria-label="7.5 wait () system call">7.5 wait () system call</a></li><li><a href=#76-exit-system-call aria-label="7.6 exit() system call">7.6 exit() system call</a></li></ul></li><li><a href=#8-%ed%94%84%eb%a1%9c%ec%84%b8%ec%8a%a4-%ea%b0%84%ec%9d%98-%ed%98%91%eb%a0%a5 aria-label="8. 프로세스 간의 협력">8. 프로세스 간의 협력</a><ul><li><a href=#81-process-%ea%b0%84-%ed%98%91%eb%a0%a5%ed%95%98%eb%8a%94-%ec%9d%b4%ec%9c%a0 aria-label="8.1 Process 간 협력하는 이유">8.1 Process 간 협력하는 이유</a></li><li><a href=#82-ipc%ec%9d%98-%eb%8c%80%ed%91%9c%ec%a0%81%ec%9d%b8-%eb%b0%a9%eb%b2%95-2%ea%b0%80%ec%a7%80 aria-label="8.2 IPC의 대표적인 방법: 2가지">8.2 IPC의 대표적인 방법: 2가지</a></li><li><a href=#83-message-passing-%eb%b0%a9%ec%8b%9d-2%ea%b0%80%ec%a7%80 aria-label="8.3 Message passing 방식: 2가지">8.3 Message passing 방식: 2가지</a><ul><li><a href=#direct-communication aria-label="Direct communication">Direct communication</a></li><li><a href=#indirect-communication aria-label="Indirect communication">Indirect communication</a></li></ul></li><li><a href=#84-shared-memory aria-label="8.4 Shared memory">8.4 Shared memory</a></li></ul></li><li><a href=#9-thread aria-label="9. Thread">9. Thread</a><ul><li><a href=#91-thread%eb%9e%80 aria-label="9.1 Thread란??">9.1 Thread란??</a></li><li><a href=#92-thread%ec%9d%98-%ec%9e%a5%ec%a0%90 aria-label="9.2 Thread의 장점">9.2 Thread의 장점</a></li><li><a href=#93-implementation-of-threads aria-label="9.3 Implementation of threads">9.3 Implementation of threads</a></li></ul></li><li><a href=#reference aria-label=Reference>Reference</a></li></ul></div></details></div><div class=post-content><h1 id=0-introduction>0. Introduction<a hidden class=anchor aria-hidden=true href=#0-introduction>#</a></h1><ul><li>해당 내용은 <a href="http://www.kyobobook.co.kr/product/detailViewKor.laf?ejkGb=KOR&mallGb=KOR&barcode=9791158903589&orderClick=LAG&Kc=">운영체제와 정보기술의 원리 -반효경 지음-</a> 와 <a href="http://www.kocw.net/home/cview.do?lid=3dd1117c48123b8e">kocw 이화여자대학교 운영체제 - 반효경 교수 -</a>를 보고 정리한 내용입니다.</li><li>정확하지 않은 내용이 있다면 말씀해주시면 감사하겠습니다.</li></ul><hr><h1 id=1-프로세스의-개념>1. 프로세스의 개념<a hidden class=anchor aria-hidden=true href=#1-프로세스의-개념>#</a></h1><h2 id=11-process-프로세스>1.1 Process (프로세스)<a hidden class=anchor aria-hidden=true href=#11-process-프로세스>#</a></h2><ul><li><strong><em>is a prgram in execution</em></strong><ul><li><strong>프로세스 = 실행 중인 프로그램</strong></li><li>디스크에 실행파일 형태로 존재하는 상태(프로그램) → 메모리에 올라감 → 실행</li><li>이 실행 중일 때를 process라 한다.</li></ul></li></ul><h2 id=12-process-context-프로세스-문맥->1.2 Process context (프로세스 문맥 )<a hidden class=anchor aria-hidden=true href=#12-process-context-프로세스-문맥->#</a></h2><ul><li><p><strong><em>process의 수행 상태를 정확히 아는데 필요한 모든 요소</em></strong></p></li><li><p><strong><em>process conetxt를 알아야 하는 이유???</em></strong></p><ul><li>CPU는 시분할 시스템으로, timer interrupt에 의해서 여러 process가 돌아가면서 CPU를 사용한다.</li><li>이런 상황에서, 한 process가 CPU를 다른 process에게 이양했다가 다시 획득했을 때, <code>직전 수행 시점의 정확한 상태</code> 를 재현하기 위해서 필요하다.</li></ul></li><li><p><strong><em>Process context의 분류</em></strong></p><p><img loading=lazy src=https://user-images.githubusercontent.com/78094972/163820432-78db934f-e417-470c-bba1-9b762dcbfe1d.PNG alt=image></p></li><li><p><strong>Hardware context</strong></p><ul><li>Program counter</li><li>각종 register<ul><li>이 register에 저장된 값들</li></ul></li></ul></li><li><p><strong>Process의 address space</strong></p><ul><li>code, data, stack<ul><li>process만의 독자적인 주소 공간</li></ul></li></ul></li><li><p><strong>process 관련 kernel 상의 문맥</strong></p><ul><li>PCB (Process Control Block)</li><li>Kernel stack<ul><li>OS가 process를 관리하기 위해 유지하는 자료구조들: PCB, kernel stack</li></ul></li></ul></li></ul><hr><h1 id=2-프로세스의-상태>2. 프로세스의 상태<a hidden class=anchor aria-hidden=true href=#2-프로세스의-상태>#</a></h1><h2 id=21-process의-상태도>2.1 Process의 상태도<a hidden class=anchor aria-hidden=true href=#21-process의-상태도>#</a></h2><ul><li><p><strong><em>Process는 다음 상태 중 어느 한 상태에 머무르며, 시간의 흐름에 따라 변한다.</em></strong></p></li><li><p><strong><em>Process의 상태를 나누는 이유는</em></strong> <code>컴퓨터의 자원을 효율적으로 관리</code><strong><em>하기 위함</em></strong></p></li><li><p><strong><em>Process의 상태도</em></strong></p><p><img loading=lazy src=https://user-images.githubusercontent.com/78094972/163820864-6ac76cf5-16ca-44cb-921a-81603cd2a278.png alt=image></p><ul><li><strong>Running:</strong><ul><li>CPU를 잡고 instruction을 수행 중인 상태</li></ul></li><li><strong>Ready:</strong><ul><li>다른 조건은 다 만족하고, 메모리에는 올라와 CPU만 기다리는 상태</li></ul></li><li><strong>Blocked( wait, sleep ):</strong><ul><li>CPU를 할당받아도 당장 instruction을 수행할 수 없는 상태</li><li>process 자신이 요청한 even가 즉시 만족되지 않아 이를 기다리는 상태<ul><li>ex) disk에서 file을 읽어와야 하는 경우 (I/O 작업)</li></ul></li></ul></li><li><strong>New</strong>:<ul><li>process가 시작되어 자료구조는 생성되었지만, 메모리 획득을 승인받지 못한 상태</li></ul></li><li><strong>Terminated:</strong><ul><li>execution(실행)이 끝났지만, 자료 구조 정리는 완료하지 못한 상태</li></ul></li></ul></li><li><p><strong><em>Dispatch:</em></strong></p><ul><li>CPU를 할당받을 process를 선택한 후, 실제로 CPU의 제어권을 넘겨받는 과정</li></ul></li></ul><h2 id=22-process-상태-변화-예시>2.2 Process 상태 변화 예시<a hidden class=anchor aria-hidden=true href=#22-process-상태-변화-예시>#</a></h2><h2 id=22-process-상태-변화-예시-1>2.2 Process 상태 변화 예시<a hidden class=anchor aria-hidden=true href=#22-process-상태-변화-예시-1>#</a></h2><blockquote><p><strong><em>입출력을 요청한 프로세스의 상태 변화</em></strong></p></blockquote><ul><li><p><strong>Running state</strong></p><ul><li>A process가 CPU를 할당 받아 기계어 명령을 하나씩 수행</li></ul></li><li><p><strong>→ I/O 요청</strong></p><ul><li>파일의 내용을 disk에서 읽어와야 명령이 진행될 수 있으므로, 입출력 요청을 한다.</li></ul></li><li><p><strong>→ Blocked state</strong></p><ul><li>입출력 요청이 완료될 때까지 CPU를 반환한 다음, disk 입출력 서비스를 기다리며 봉쇄 상태로 바뀐다.</li><li>그리고, 해당 process는 device I/O queue 뒤에 줄슨다.</li></ul></li><li><p><strong>→ Ready state의 process 중 선정</strong></p><ul><li>CPU를 할당받을 process를 선택하기 위해, ready 상태의 process 들 중에서 CPU scheduler가 적절한 process를 하나 선정하여 CPU를 할당한다.</li></ul></li><li><p><strong>→ Running state</strong></p><ul><li>B process가 CPU를 받아 자신의 code를 실행한다.</li></ul></li><li><p><strong>→ device controller 가 interrupt 발생</strong></p><ul><li>I/O 작업을 하던 controller가 interrupt를 발생하여 CPU에게 I/O 작업 완료를 알림</li></ul></li><li><p><strong>→ B process를 user mode에서 kernel mode 진입</strong></p><ul><li>interrupt의 발생 원인이 B process와 상관없어도, CPU가 현재 사용하고 있던 process가 kernel mode로 진입했다고 판단.</li></ul></li><li><p><strong>→ Ready state</strong></p><ul><li>HW interrupt에 의해서 A process를 blocked state에서 ready state로 바꾼 후, CPU의 ready queue에 줄을 세운다.</li><li>그리고, device의 local buffer에 있는 내용을 memory로 이동한다.</li></ul></li></ul><hr><h1 id=3-프로세스-제어블록>3. 프로세스 제어블록<a hidden class=anchor aria-hidden=true href=#3-프로세스-제어블록>#</a></h1><h2 id=31-pcb란->3.1 PCB란 ??<a hidden class=anchor aria-hidden=true href=#31-pcb란->#</a></h2><ul><li><strong><em>운영체제가 각 process를 관리하기 위해,</em></strong></li><li><strong><em>process 마다 유지하는 정보들을 담는,</em></strong></li><li><strong><em>커널 내의 자료구조</em></strong></li></ul><h2 id=32-pcb의-구성-요소>3.2 PCB의 구성 요소<a hidden class=anchor aria-hidden=true href=#32-pcb의-구성-요소>#</a></h2><p><img loading=lazy src=https://user-images.githubusercontent.com/78094972/163820308-930acc88-ce46-40a9-9b49-662d5e4e6364.PNG alt=image></p><ul><li><strong><em>1) OS가 관리를 위해 사용하는 정보</em></strong><ul><li>Process state, process ID<ul><li>process state: CPU를 할당해도 되는지 여부를 결정하기 위해</li><li>process ID: 효율적인 관리를 위해 process 마다 매긴 고유 번호</li></ul></li><li>scheduling information, priority</li></ul></li><li><strong><em>2) CPU 수행 관련 HW 값</em></strong><ul><li>program counter: 다음에 수행할 명령의 위치를 가리킨다.</li><li>registers</li></ul></li><li><strong><em>3) 메모리 관련</em></strong><ul><li>code, data, stack</li></ul></li><li><strong><em>4) 파일 관련</em></strong><ul><li>open file descriptors: 입출력 관련 상태 정보</li></ul></li></ul><hr><h1 id=4-문맥교환-context-switch>4. 문맥교환 (Context switch)<a hidden class=anchor aria-hidden=true href=#4-문맥교환-context-switch>#</a></h1><h2 id=context-switch란>Context switch란??<a hidden class=anchor aria-hidden=true href=#context-switch란>#</a></h2><ul><li><p><strong><em>CPU를 한 프로세스에서</em></strong> <code>다른 프로세스</code><strong><em>로 넘겨주는 과정</em></strong></p></li><li><p><strong><em>문맥 교환 중, OS가 실행하는 것들</em></strong></p><ul><li><p>CPU를 내어주는 process의 state를 이 process의 PCB에 저장</p></li><li><p>CPU를 새롭에 얻는 process의 state를 PCB에서 읽어온다.</p><p><img loading=lazy src=https://user-images.githubusercontent.com/78094972/163820300-8838c513-97f3-4790-aef9-fd106932a80b.PNG alt=image></p></li></ul></li><li><p><strong><em>context switch가 일어나는 경우와 그렇지 않은 경우</em></strong></p><ul><li><p>System call이나 interrupt 발생 시, 반드시 문맥교환이 일어나는 게 아니다.</p><p><img loading=lazy src=https://user-images.githubusercontent.com/78094972/163820304-52c54fbd-6ef6-43a4-8356-1ad303d1bf9b.PNG alt=image></p><ul><li>첫 번째 경우, 단지 같은 process의 mode가 바뀌는 경우</li><li>두 번째 경우가 context switch다.</li><li>첫 번째 경우도 CPU 수행 정보 등 context의 일부를 PCB에 저장해야 하지만, context switch를 하는 경우, 오버헤드가 훨씬 크다. (eg. cache memory flush)<ul><li>A process의 address space의 code를 실행하다가, kernel address space의 code를 실행하는 것이기 때문에, PCB에 저장해야 한다.</li></ul></li></ul></li></ul></li><li><p>문맥교환에 소요되는 시간은 일종의 오버헤드다.</p><ul><li>그래서, timer로 CPU 할당시간을 아주 작게 세팅하면 문맥교환이 빈번히 발생하기 때문에, 오버헤드가 상당히 커진다.</li><li>하지만, CPU 할당 시간을 너무 크게 설정하면 시분할 시스템의 의미가 퇴색된다.</li><li>그러므로, 적절한 CPU 할당시간을 정해야 한다.</li></ul></li></ul><hr><h1 id=5-프로세스를-스케쥴링-하기-위한-큐>5. 프로세스를 스케쥴링 하기 위한 큐<a hidden class=anchor aria-hidden=true href=#5-프로세스를-스케쥴링-하기-위한-큐>#</a></h1><h2 id=51-kernel의-process-상태-관리>5.1 kernel의 process 상태 관리<a hidden class=anchor aria-hidden=true href=#51-kernel의-process-상태-관리>#</a></h2><ul><li>process 상태 관리는 <strong><em>kernel의 주소 공간의 data 영역</em></strong> 에 다양한 queue를 두어 수행한다.</li><li><strong><em>process들은 각 queue들을 오가며 수행한다.</em></strong></li></ul><h2 id=52-다양한-queue-종류>5.2 다양한 queue 종류<a hidden class=anchor aria-hidden=true href=#52-다양한-queue-종류>#</a></h2><p><img loading=lazy src=https://user-images.githubusercontent.com/78094972/163820309-3c8a43a4-72cf-4296-8abb-a55e111e8da5.PNG alt=image></p><ul><li><strong><em>Job queue</em></strong><ul><li>현재 시스템 내에 있는 모든 프로세스를 관리하기 위한 큐</li><li>모든 process가 속한다.</li><li>ready queue와 device queue가 다 포함된다.</li><li>ready 큐에 포함하면 device 큐에는 포함되지 않는다.</li></ul></li><li><strong><em>Ready queue</em></strong><ul><li>현재 메모리 내에 있으면서 CPU를 잡아서 실행되기를 기다리는 프로세스의 집합</li></ul></li><li><strong><em>Device queues (장치 큐) = HW queue</em></strong><ul><li>각 I/O device의 service를 기다리는 process의 집합</li><li>각 deivce마다 있기 때문에, 다양하다.</li><li>예)<ul><li>device controller가 줄 서 있는 순서대로 I/O 작업 수행 → 작업 완료하면 controller가 interrupt 발생 → interrupt service routine에 의해서 입출력 작업이 완료된 process는 I/O queue에서 나와 CPU대기 queue 슨다.</li></ul></li></ul></li><li><strong><em>resource queue = SW resource</em></strong><ul><li><strong><em>SW queue가 필요한 이유??</em></strong><ul><li>SW resource인 공유 데이터에 여러 process가 접근할 경우, <code>데이터의 일관성 훼손</code> 이 발생할 수 있다.</li><li>그래서, 공유 데이터에는 매 시점 하나의 프로세스만이 접근하도록 한다.<ul><li>SW resource에 접근 중인 process가 다 사용하고 반납할 때까지, 다른 process가 CPU를 할당받았어도 접근하지 말고 공유 데이터 queue에서 기다려야 한다.</li></ul></li></ul></li></ul></li></ul><h2 id=53-process-scheduling-queue의-모습>5.3 Process scheduling queue의 모습<a hidden class=anchor aria-hidden=true href=#53-process-scheduling-queue의-모습>#</a></h2><p><img loading=lazy src=https://user-images.githubusercontent.com/78094972/163820315-d2f69068-caa3-410c-bdf1-e7126f93e98e.PNG alt=image></p><ul><li><strong><em>위 image는 OS가 queue를 어떻게 자료구조로 구현하는지 보여준다.</em></strong></li><li><strong><em>queue는 각 process의 PCB를 연결 list 형태로 관리하여 순서를 정한다.</em></strong></li><li><strong><em>Queue header</em></strong><ul><li>큐의 가장 앞부분</li><li>PCB의 pointer 부분이 이어진다.</li></ul></li><li><strong><em>queue 흐름 설명</em></strong><ul><li>process가 CPU 할당받고 수행 중 I/O 요청이 발생하면 해당 device queue에 줄을 슨다.</li><li>device queue에 속한 process는 blocked state였다가, 해당 장치의 서비스를 받으면, device controller가 인터럽트를 발생시켜 준비 상태로 바껴 ready queue로 이동한다.</li><li>ready queue에는 PCB 7 다음에, PCV 2가 대기하고 있다.</li><li>magnetic tape에는 아무것도 대기하지 않는다.</li><li>disk queue에는 PCB 3 ← PCB 14 ← PCB 6 순서로 대기하고 있다.</li><li>terminal queue에는 PCB 5 만 대기하고 있다.</li></ul></li></ul><hr><h1 id=6-스케쥴러-scheduler>6. 스케쥴러 (Scheduler)<a hidden class=anchor aria-hidden=true href=#6-스케쥴러-scheduler>#</a></h1><h2 id=61-long-term-scheduler-장기-스케쥴러-or-job-scheduler>6.1 Long-term scheduler (장기 스케쥴러 or job scheduler)<a hidden class=anchor aria-hidden=true href=#61-long-term-scheduler-장기-스케쥴러-or-job-scheduler>#</a></h2><ul><li>시작 프로세스 중 어떤 것들을 <strong><em>ready queue</em></strong> 로 보낼지 결정</li><li><strong><em>process에 memory (및 각종 자원) 을 주는 문제</em></strong><ul><li>메모리를 어느 것에 줄지를 결정</li><li>현대의 컴퓨터는 메모리를 기본적으로 바로 준다.</li></ul></li><li><strong><em>degree of Multiprogramming</em></strong> 제어<ul><li>multi-programming: 메모리에 여러 프로그램이 동시에 올라가는 것을 의미</li><li>이 메모리에 올라가는 수를 제어하는 것 → 컴퓨터 성능에 영향을 줌</li><li>현 컴퓨터에는 장기 스케쥴러는 없고, 프로그램이 시작하면 다 ready 상태로 들어간다.</li></ul></li><li>time sharing system에는 보통 장기 scheduler가 없다. (무조건 ready)</li></ul><h2 id=62-short-term-schduler-단기-scheduler-or-cpu-scheduler>6.2 Short-term schduler (단기 scheduler or CPU scheduler)<a hidden class=anchor aria-hidden=true href=#62-short-term-schduler-단기-scheduler-or-cpu-scheduler>#</a></h2><ul><li>어떤 프로세스를 다음 번에 <strong><em>running</em></strong> 시킬지 결정</li><li>프로세스에 <strong><em>CPU</em></strong> 를주는문제</li><li>충분히 빨라야 함 (milli-second 단위)</li></ul><h2 id=63-medium-term-scheduler-중기-스케쥴러-or-swapper>6.3 Medium-Term Scheduler (중기 스케쥴러 or Swapper)<a hidden class=anchor aria-hidden=true href=#63-medium-term-scheduler-중기-스케쥴러-or-swapper>#</a></h2><ul><li>여유 공간 마련을 위해 프로세스를 통째로 메모리에서 디스크로 쫓아낸다.</li><li>프로세스에게서 <strong>memory</strong> 를 뺏는 문제<ul><li>메모리에 프로그램이 너무 많이 올라가면, 쫓아내어 전체적인 컴퓨터 성능을 개선.</li><li>시스템 입장에서는 장기 스케쥴러보다 중기 스케쥴러를 주는 게 더 이득</li></ul></li><li><strong>degree of multiprogramming</strong> 을 제어<ul><li>현재 multi-programming을 제어하는 scheduler</li><li>이 중기 스케쥴러가 들어가 있기 때문에, 프로세스의 상태 3가지에 추가된 게 suspended다.</li></ul></li></ul><h2 id=64-추가된-프로세스-상태도>6.4 추가된 프로세스 상태도<a hidden class=anchor aria-hidden=true href=#64-추가된-프로세스-상태도>#</a></h2><p><img loading=lazy src=https://user-images.githubusercontent.com/78094972/163820311-f438ce19-30fe-46b7-aa55-9a0749ab4a70.PNG alt=image></p><ul><li>중기 스케쥴러에 의해 suspended state가 추가되었다.</li><li><strong><em>Running</em></strong><ul><li>CPU를 잡고 instruction을 수행 중인 상태</li></ul></li><li><strong><em>Ready</em></strong><ul><li>CPU를 기다리는 상태( 메모리 등 다른 조건을 모두 만족하고)</li></ul></li><li><strong><em>Blocked (wait, sleep)</em></strong><ul><li>I/O 등의 event를 스스로 기다리는 상태</li><li>예) 디스크에서 file을 읽어와야 하는 경우</li></ul></li><li><strong><em>Suspended (stopped)</em></strong><ul><li>외부적인 이유로 <strong>강제로</strong> 프로세스의 수행이 정지된 상태<ul><li>중기 스케쥴러에 의해 강제로 뺏긴 상태</li></ul></li><li>이 상태의 프로세스는 통째로 디스크에 swap out 된다.</li><li>예) 사용자가 프로그램을 일시 정지시킨 경우 (break key). 이 경우에는 사람이 재개시켜야 위의 상태가 된다.<ul><li>시스템이 여러 이유로 프로세스를 잠시 중단시킴 → 중기 스케쥴러</li><li>(메모리에 너무 많은 프로세스가 올라와 있을 때)</li></ul></li></ul></li><li><strong><em>blocked와 suspended 구분하기</em></strong><ul><li>Blocekd: <strong>자신이 요청한 event가 만족되면(자신이 요청한 작업이 완료되면) Ready</strong></li><li>Suspended: <strong>외부에서 정지된 상태이기 대문에, 외부에서 resume 해 주어야 Active</strong></li></ul></li></ul><hr><h1 id=7-프로세스의-생성>7. 프로세스의 생성<a hidden class=anchor aria-hidden=true href=#7-프로세스의-생성>#</a></h1><h2 id=71-process-creation-프로세스-생성--cowcopy-on-write>7.1 Process creation (프로세스 생성) : COW(Copy-On-Write)<a hidden class=anchor aria-hidden=true href=#71-process-creation-프로세스-생성--cowcopy-on-write>#</a></h2><ul><li><p><strong>OS가 process를 전부 생성하는 게 아닌, 부팅 후 최초의 process는 운영체제가 직접 생성한다. 그 다음부터는 이미 존재하는 process가 다른 process를 복제 생성한다.</strong></p></li><li><p>부모 프로세스와 자식 프로세스의 정의 및 관계</p><ul><li><strong>process를 생성하는 process: <code>부모 프로세스</code></strong></li><li><strong>부모 프로세스에 의해 생성된 process: <code>자식 프로세스</code></strong><ul><li>부모 프로세스 1개가 자식 프로세스 최소 1개를 <strong>복제 생성</strong> 한다.</li><li>또한, 자식 프로세스가 process를 생성할 수 있다.</li><li>그래서 프로세스의 트리(계층 구조) 형성</li></ul></li></ul></li><li><p><strong>작업 수행을 위한 자원</strong></p><ul><li>부모 프로세스는 OS로부터 받는다.</li><li>자식 프로세스는 부모 프로세스와 <strong>공유</strong> 한다.<ul><li>부모와 자식 프로세스가 <strong>서로 모든 자원을 공유</strong> 하는 모델</li><li><strong>일부를 공유</strong> 하는 모델</li><li>전혀 공유하지 않는 모델</li></ul></li></ul></li><li><p><strong>주소 공간 (Address space)</strong></p><ul><li>process 생성의 첫 번째: 부모 공간을 복사 → 두 번째: 복사한 공간에 새로운 프로그램의 주소 공간을 <strong>덮어씌운다</strong>.</li></ul></li><li><p><strong>Process 와 관련한 system call (특권 명령 )</strong></p><ul><li>fork() : create a child (copy)</li><li>exec() : overlay new image = 새로운 프로그램으로서 덮어씌운다.</li><li>wait() : sleep until child is done</li><li>exit() : frees all the resources, notify parent</li></ul></li><li><p>UNIX의 예</p><ul><li>os에게 fork() system call 요청하여, 새로운 process를 생성<ul><li>부모를 그대로 복사하고, 주고 공간을 할당</li><li><strong>복사할 때, 부모 프로세스의 process ID는 제외한다.</strong></li></ul></li><li>fork () 다음에 이어지는 exec () system cal을 통해 새로운 프로그램을 메모리에 올린다.</li><li>fork () 와 exec () 둘 다 system call을 통해서 실행되므로, 운영체제가 생성한다.</li></ul></li></ul><h2 id=72-process-termination-프로세스-종료>7.2 Process Termination (프로세스 종료)<a hidden class=anchor aria-hidden=true href=#72-process-termination-프로세스-종료>#</a></h2><ul><li><strong><em>프로세스가 마지막 명령을 수행한 후, 운영체제에게 이를 알려준다. (’exit’ system call)</em></strong><ul><li>자식이 부모에게 output data를 보낸다. (via ‘<strong>wait’ system call</strong>)</li><li>프로세스의 각종 자원들이 운영체제에게 반납된다.</li><li>자식 프로세스가 먼저 종료 후 부모 프로세스가 종료되야 한다.</li></ul></li><li><strong><em>부모 프로세스에게 자식의 수행을 종료시킨다. (abort)</em></strong><ul><li>자식이 할당 자원의 한계치를 넘어설 때</li><li>자식에게 할당된 task가 더 이상 필요하지 않을 때 (자식 프로세스를 만든 이유가 일을 시키기 위함이기 때문)</li><li>부모가 종료(exit)할 때<ul><li>운영체제는 부모프로세스가 종료하는 경우, 자식이 더 수행되도록 두지 않는다.</li><li>단계적인 종료( 손자 → 자식 → 부모 )가 지켜져야 한다.</li></ul></li></ul></li></ul><h2 id=73-fork--system-call>7.3 fork () system call<a hidden class=anchor aria-hidden=true href=#73-fork--system-call>#</a></h2><ul><li><strong><em>creats a new address space that is a duplicate of the caller</em></strong></li><li><strong><em>자식 process를 만들 때, 부모 process의 program counter까지 복사된다.</em></strong><ul><li>부모 process와 자식 process의 차이는 <strong><em>식별자</em></strong> 다.</li></ul></li><li><strong><em>그래서, program counter는 fork () 실행 후, 다음 코드를 가리키기 때문에, 자식 process는 fork ()한 이후부터 코드를 실행한다.</em></strong><ul><li>자식 process라 부르지만, 복제인간이라 생각하는 게 정확한다.</li><li>또한, 복제된 process는 자신을 원본이라 생각한다.</li></ul></li><li><strong><em>복제된 process인지 아닌지 구분하는 방법</em></strong><ul><li>fork 함수의 결과값으로 자식 process 는 0을, 부모 process에게는 양수를 준다.</li></ul></li></ul><h2 id=74-exec--system-call>7.4 exec () system call<a hidden class=anchor aria-hidden=true href=#74-exec--system-call>#</a></h2><ul><li>fork () 한 후, exec () system call을 통해서 자식 프로세스를 새로운 program으로 대체한다. (overwrite)</li><li>한 번 만들어지면 다시 되돌아갈 수 없다.</li></ul><h2 id=75-wait--system-call>7.5 wait () system call<a hidden class=anchor aria-hidden=true href=#75-wait--system-call>#</a></h2><ul><li>wait () system call은 자식 process가 종료될 때까지 process A를 blocked state로 만든다.</li><li>자식 프로세스가 종료되면 kernel은 프로세스 A를 준비 상태로 변경하여 준비 큐에 진입.</li></ul><h2 id=76-exit-system-call>7.6 exit() system call<a hidden class=anchor aria-hidden=true href=#76-exit-system-call>#</a></h2><ul><li>process의 종료<ul><li>자발적 종료<ul><li>마지막 statement 수행 후, OS에게 exit () system call로 자신이 종료됨을 알린다.</li><li>명시적으로 exit ()을 호출하지 않아도, main () 함수가 반환되는 위치에 compiler가 자동으로 삽입해 프로세스 종료 직전에 항상 호출한다.</li></ul></li><li>비자발적 종료 (자식 프로세스 밖에서 종료시키는 경우)<ul><li>부모 프로세스가 자식 프로세스를 강제 종료시킨다.</li><li>When??<ul><li>자식 프로세스가 한계치를 넘어서는 할당 자원 요청을 할 때</li><li>자식에게 할당된 task가 더 이상 필요하지 않을 때</li></ul></li><li>프로그램 종료 버튼을 누르는 경우나, 키보드로 kill, break 등을 친 경우</li><li>부모가 종료하는 경우<ul><li>부모 프로세스가 종료하기 전에 자식들이 먼저 종료된다.</li></ul></li></ul></li></ul></li><li>프로그램을 강제 종료시킨 후, 계속 수행시켜야하는 경우에는 종료되지 않는 다른 자식 프로세스로 이양시켜서, 기존 부모 프로세스가 종료된 후에도 다른 프로세스 아래에서 계속 수행한다.<ul><li>부모가 죽기 전에 자식이 먼저 죽는다는 원칙은 여전히 지켜진다.</li></ul></li></ul><hr><h1 id=8-프로세스-간의-협력>8. 프로세스 간의 협력<a hidden class=anchor aria-hidden=true href=#8-프로세스-간의-협력>#</a></h1><h2 id=81-process-간-협력하는-이유>8.1 Process 간 협력하는 이유<a hidden class=anchor aria-hidden=true href=#81-process-간-협력하는-이유>#</a></h2><ul><li><p><strong><em>독립적 프로세스 (Independent process)</em></strong></p><ul><li>프로세스는 각자의 주소 공간을 가지고 수행되므로, 원칙적으로 하나의 프로세스는 다른 프로세스의 수행에 영향을 미치지 못한다.</li></ul></li><li><p><strong><em>하지만, process 간 협력한다면 왜 하고 어떻게 하는 것일까??</em></strong></p></li><li><p><strong><em>협력 프로세스( Cooperating process)</em></strong></p><ul><li>Why?<ul><li>업무의 효율성 증대: 부분적인 처리 결과, 정보를 공유할 수 있고, 처리 속도가 향상.</li></ul></li><li>How?<ul><li>IPC(Inter-Process Communication): process 간 통신과 동기화를 이루기 위한 mechanism</li></ul></li></ul></li></ul><h2 id=82-ipc의-대표적인-방법-2가지>8.2 IPC의 대표적인 방법: 2가지<a hidden class=anchor aria-hidden=true href=#82-ipc의-대표적인-방법-2가지>#</a></h2><ul><li><p><strong><em>Message passing: 메시지 전달 방식</em></strong></p><ul><li><p>Message passing의 특징</p><ul><li>프로세스 사이에 <code>공유 변수(shared variable)을 일체 사용하지 않고</code> 통신하는 시스템.</li><li>중간에 <code>kernel을 통해서</code> 하는데, 명시적으로 process의 이름을 표시하냐 안하냐의 차이.</li><li>kernel에 의해 <code>send(message)</code>와 <code>receive(message)</code>라는 두 가지 연산을 제공받는다.<ul><li>즉, 이 두 가지 연산은 특권명령이다.</li></ul></li></ul></li><li><p><strong><em>Message passing 방식 2가지</em></strong></p><ul><li>직접 통신 (direct communication)</li><li>간접 통신 (Indirect communication)</li></ul><p><img loading=lazy src=https://user-images.githubusercontent.com/78094972/163955059-05996ad0-a585-4b3c-975a-2608a4829d3a.png alt=image></p></li></ul></li><li><p><strong><em>Shared memory: 공유 메모리 방식</em></strong></p></li></ul><h2 id=83-message-passing-방식-2가지>8.3 Message passing 방식: 2가지<a hidden class=anchor aria-hidden=true href=#83-message-passing-방식-2가지>#</a></h2><p><strong><em>Message passing 방식에는 직접통신(direct communication)과 간접통신(indirect communication) 으로 나뉜다.</em></strong></p><h3 id=direct-communication>Direct communication<a hidden class=anchor aria-hidden=true href=#direct-communication>#</a></h3><p><img loading=lazy src=https://user-images.githubusercontent.com/78094972/163952882-fb4ef53a-5293-4ddd-b5a7-86463ee14d82.png alt=image></p><ul><li>통신하려는 프로세스의 이름을 명시적으로 표시한다.</li><li>Send (Q, message): process Q에게 메시지를 전송하는 것을 의미</li><li>Receive (P, message): process P로부터 메시지를 전달받는 것을 의미</li><li>link는 자동적으로 생성되며, 하나의 link는 정확히 한 쌍의 process에게 할당된다.</li><li>각 쌍의 process에게는 오직 하나의 link만이 존재한다.</li></ul><h3 id=indirect-communication>Indirect communication<a hidden class=anchor aria-hidden=true href=#indirect-communication>#</a></h3><p><img loading=lazy src=https://user-images.githubusercontent.com/78094972/163952887-cddbe514-95a3-4e50-a325-f1dc43e7b01a.png alt=image></p><ul><li>통신하려는 프로세스의 이름을 명시적으로 표시하지 않는다.</li><li>mailbox ( or port)를 통해 메시지를 간접 전달한다.</li><li>mailbox에는 고유의 ID가 있다.</li><li>이 mailbox를 공유하는 process 들끼리만 서로 통신할 수 있다.</li><li>Send(M, message): M이라는 mailbox에 message를 전달하는 것</li><li>Receive(M, message): M이라는 mailbox로부터 메시지를 전달받는 것</li><li>mailbox를 3개 이상의 process가 공유할 경우, 각각의 프로세스에게 링크를 따로 생성가능.</li></ul><h2 id=84-shared-memory>8.4 Shared memory<a hidden class=anchor aria-hidden=true href=#84-shared-memory>#</a></h2><ul><li>서로 다른 process 간에도 일부 주소 공간을 공유하게 하는 mechanism</li><li>두 process가 서로 신뢰할 수 있는 process여야 한다.</li><li>kernel에게 system call 후, memory가 공유된다.</li><li>물리적인 공간에 mapping 할 때, 공유된 상태로 진행한다.</li><li>이 방법에서 동기화 문제는 kernel 책임지지 않고, 공유되는 process 들이 책임져야 한다.</li></ul><hr><h1 id=9-thread>9. Thread<a hidden class=anchor aria-hidden=true href=#9-thread>#</a></h1><h2 id=91-thread란>9.1 Thread란??<a hidden class=anchor aria-hidden=true href=#91-thread란>#</a></h2><ul><li><p><strong><em>A Thread (or lightweight process) is a basic unit of CPU utilization</em></strong></p><ul><li>CPU의 기본 실행 단위를 <code>Thread</code> 라 한다.</li></ul></li><li><p><strong><em>Thread의 구성</em></strong></p><ul><li>Program counter</li><li>register set</li><li>stack space<ul><li>stack space에서 여러 thread로 나눠진다.</li></ul></li></ul></li><li><p><strong><em>process 내부에서 thread가 동료 thread와 공유하는 부분 = task</em></strong></p><ul><li>code section</li><li>data section</li><li>OS resources</li></ul></li><li><p><strong><em>heavyweight process 는 하나의 thread를 가지고 있는 task 다.</em></strong></p><p><img loading=lazy src=https://user-images.githubusercontent.com/78094972/163952889-5ec16d16-59e5-41d0-87d7-fe0478ffb2e0.png alt=image></p><p><img loading=lazy src=https://user-images.githubusercontent.com/78094972/163952874-762af2a9-2ab7-4c21-930f-be722d55da8d.png alt=image></p><ul><li>CPU가 명령 수행을 위해서는 코드의 실행될 부분을 가리키는 <code>program counter</code>가 있어야 한다.</li><li>또한, memory에 <code>register 값</code> 을 세팅해야 한다.</li><li>OS는 process를 관리하기 위해 process마다 1개의 PCB를 둔다.</li><li>이 PCB를 보면 여러 thread로 구성된 걸 확인할 수 있다.</li></ul></li></ul><h2 id=92-thread의-장점>9.2 Thread의 장점<a hidden class=anchor aria-hidden=true href=#92-thread의-장점>#</a></h2><ul><li><strong><em>Responsiveness: 응답성</em></strong><ul><li>eg) multi-thread: 하나의 thread가 blocked state 인 동안에도, 동일한 task 내의 다른 thread가 계속 실행되어 빠른 처리를 할 수 있다.</li></ul></li><li><strong><em>Resource sharing: 자원의 효율적인 관리</em></strong><ul><li>여러 thread가 process의 code, data, resource를 공유하기 때문에, 자원 관리가 효율적.</li></ul></li><li><strong><em>Economy: 경제성</em></strong><ul><li>process를 새로 생성하는 것보다 thread를 새로 생성하는 게 오버헤드가 훨씬 적다.</li><li>process 간의 switching보다, thread 간의 switching이 오버헤드가 훨씬 적다.</li></ul></li><li><strong><em>Utilization of MP Architectures</em></strong><ul><li>병렬로 thread가 실행될 수 있다.</li><li>다중 thread가 협력하여 높은 처리율과 성능 향상을 얻는다.</li></ul></li></ul><h2 id=93-implementation-of-threads>9.3 Implementation of threads<a hidden class=anchor aria-hidden=true href=#93-implementation-of-threads>#</a></h2><ul><li><strong><em>Some are supported by kernel ⇒ Kernel threads</em></strong><ul><li>thread가 여러 개인 것을 운영체제가 알고 있음</li><li>예)<ul><li>Windows 95, 98 / NT</li><li>Solaris</li><li>Digital UNIX, Mach</li></ul></li></ul></li><li><strong><em>Others are supported by library ⇒ User Threads</em></strong><ul><li>운영체제가 프로세스 안에 thread가 여러개인 걸 모른다.</li><li>즉, User program이 thread를 관리한다.</li><li>예)<ul><li>POSIX Pthreads</li><li>MAch C-threads</li><li>Solaris threads</li></ul></li></ul></li><li><strong><em>Some are real time threads</em></strong><ul><li>real time을 지원하는 thread</li></ul></li></ul><hr><h1 id=reference>Reference<a hidden class=anchor aria-hidden=true href=#reference>#</a></h1><ul><li><a href="http://www.kyobobook.co.kr/product/detailViewKor.laf?ejkGb=KOR&mallGb=KOR&barcode=9791158903589&orderClick=LAG&Kc=">운영체제와 정보기술의 원리</a></li><li><a href="http://www.kocw.net/home/cview.do?lid=3dd1117c48123b8e">kocw 이화여자대학교 운영체제 - 반효경 교수 -</a></li></ul></div><footer class=post-footer><ul class=post-tags><li><a href=http://jeha00.github.io/tags/til/>TIL</a></li><li><a href=http://jeha00.github.io/tags/os/>OS</a></li></ul><nav class=paginav><a class=prev href=http://jeha00.github.io/post/os/os_chapter_06_cpu_scheduling/><span class=title>« Prev Page</span><br><span>[TIL] OS Chapter 06: CPU scheduling</span></a>
<a class=next href=http://jeha00.github.io/post/os/os_chapter_04_%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%A8%EC%9D%98%EA%B5%AC%EC%A1%B0%EC%99%80%EC%8B%A4%ED%96%89/><span class=title>Next Page »</span><br><span>[TIL] OS Chapter 04: 프로그램의 구조와 실행</span></a></nav><div class=share-buttons><a target=_blank rel="noopener noreferrer" aria-label="share [TIL] OS Chapter 05: 프로세스 관리 on twitter" href="https://twitter.com/intent/tweet/?text=%5bTIL%5d%20OS%20Chapter%2005%3a%20%ed%94%84%eb%a1%9c%ec%84%b8%ec%8a%a4%20%ea%b4%80%eb%a6%ac&url=http%3a%2f%2fjeha00.github.io%2fpost%2fos%2fos_chapter_05_%25ED%2594%2584%25EB%25A1%259C%25EC%2584%25B8%25EC%258A%25A4_%25EA%25B4%2580%25EB%25A6%25AC%2f&hashtags=TIL%2cOS"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM195.519 424.544c135.939.0 210.268-112.643 210.268-210.268.0-3.218.0-6.437-.153-9.502 14.406-10.421 26.973-23.448 36.935-38.314-13.18 5.824-27.433 9.809-42.452 11.648 15.326-9.196 26.973-23.602 32.49-40.92-14.252 8.429-30.038 14.56-46.896 17.931-13.487-14.406-32.644-23.295-53.946-23.295-40.767.0-73.87 33.104-73.87 73.87.0 5.824.613 11.494 1.992 16.858-61.456-3.065-115.862-32.49-152.337-77.241-6.284 10.881-9.962 23.601-9.962 37.088.0 25.594 13.027 48.276 32.95 61.456-12.107-.307-23.448-3.678-33.41-9.196v.92c0 35.862 25.441 65.594 59.311 72.49-6.13 1.686-12.72 2.606-19.464 2.606-4.751.0-9.348-.46-13.946-1.38 9.349 29.426 36.628 50.728 68.965 51.341-25.287 19.771-57.164 31.571-91.8 31.571-5.977.0-11.801-.306-17.625-1.073 32.337 21.15 71.264 33.41 112.95 33.41z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share [TIL] OS Chapter 05: 프로세스 관리 on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&url=http%3a%2f%2fjeha00.github.io%2fpost%2fos%2fos_chapter_05_%25ED%2594%2584%25EB%25A1%259C%25EC%2584%25B8%25EC%258A%25A4_%25EA%25B4%2580%25EB%25A6%25AC%2f&title=%5bTIL%5d%20OS%20Chapter%2005%3a%20%ed%94%84%eb%a1%9c%ec%84%b8%ec%8a%a4%20%ea%b4%80%eb%a6%ac&summary=%5bTIL%5d%20OS%20Chapter%2005%3a%20%ed%94%84%eb%a1%9c%ec%84%b8%ec%8a%a4%20%ea%b4%80%eb%a6%ac&source=http%3a%2f%2fjeha00.github.io%2fpost%2fos%2fos_chapter_05_%25ED%2594%2584%25EB%25A1%259C%25EC%2584%25B8%25EC%258A%25A4_%25EA%25B4%2580%25EB%25A6%25AC%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share [TIL] OS Chapter 05: 프로세스 관리 on reddit" href="https://reddit.com/submit?url=http%3a%2f%2fjeha00.github.io%2fpost%2fos%2fos_chapter_05_%25ED%2594%2584%25EB%25A1%259C%25EC%2584%25B8%25EC%258A%25A4_%25EA%25B4%2580%25EB%25A6%25AC%2f&title=%5bTIL%5d%20OS%20Chapter%2005%3a%20%ed%94%84%eb%a1%9c%ec%84%b8%ec%8a%a4%20%ea%b4%80%eb%a6%ac"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share [TIL] OS Chapter 05: 프로세스 관리 on facebook" href="https://facebook.com/sharer/sharer.php?u=http%3a%2f%2fjeha00.github.io%2fpost%2fos%2fos_chapter_05_%25ED%2594%2584%25EB%25A1%259C%25EC%2584%25B8%25EC%258A%25A4_%25EA%25B4%2580%25EB%25A6%25AC%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share [TIL] OS Chapter 05: 프로세스 관리 on whatsapp" href="https://api.whatsapp.com/send?text=%5bTIL%5d%20OS%20Chapter%2005%3a%20%ed%94%84%eb%a1%9c%ec%84%b8%ec%8a%a4%20%ea%b4%80%eb%a6%ac%20-%20http%3a%2f%2fjeha00.github.io%2fpost%2fos%2fos_chapter_05_%25ED%2594%2584%25EB%25A1%259C%25EC%2584%25B8%25EC%258A%25A4_%25EA%25B4%2580%25EB%25A6%25AC%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share [TIL] OS Chapter 05: 프로세스 관리 on telegram" href="https://telegram.me/share/url?text=%5bTIL%5d%20OS%20Chapter%2005%3a%20%ed%94%84%eb%a1%9c%ec%84%b8%ec%8a%a4%20%ea%b4%80%eb%a6%ac&url=http%3a%2f%2fjeha00.github.io%2fpost%2fos%2fos_chapter_05_%25ED%2594%2584%25EB%25A1%259C%25EC%2584%25B8%25EC%258A%25A4_%25EA%25B4%2580%25EB%25A6%25AC%2f"><svg viewBox="2 2 28 28"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></div></footer></article></main><footer class=footer><span>&copy; 2022 <a href=http://jeha00.github.io/>Jeha00 DevLog</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerText="copy";function s(){t.innerText="copied!",setTimeout(()=>{t.innerText="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>