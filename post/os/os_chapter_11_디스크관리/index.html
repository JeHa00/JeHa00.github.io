<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>[TIL] Chapter 11: 디스크 관리 | Jeha DevLog</title><meta name=keywords content="TIL,OS"><meta name=description content="디스크의 물리적인 구조는 어떻고, 이 디스크 스케쥴링이 왜 필요하고 어떤 알고리즘들로 스케쥴링되는지, disk의 역할 2가지는 무엇인지, 다중 디스크 상황의 장점은 무엇인지 알아본다."><meta name=author content><link rel=canonical href=http://jeha00.github.io/post/os/os_chapter_11_%EB%94%94%EC%8A%A4%ED%81%AC%EA%B4%80%EB%A6%AC/><meta name=google-site-verification content="XYZabc"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.min.268b216eea772711d318d156ce02a8190962367a0bf469fa9a959114ea6b9ca3.css integrity="sha256-Joshbup3JxHTGNFWzgKoGQliNnoL9Gn6mpWRFOprnKM=" rel="preload stylesheet" as=style><link rel=icon href=http://jeha00.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=http://jeha00.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=http://jeha00.github.io/favicon-32x32.png><link rel=apple-touch-icon href=http://jeha00.github.io/apple-touch-icon.png><link rel=mask-icon href=http://jeha00.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><meta name=generator content="Hugo 0.101.0"><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><script type=application/javascript>var doNotTrack=!1;doNotTrack||(function(e,t,n,s,o,i,a){e.GoogleAnalyticsObject=o,e[o]=e[o]||function(){(e[o].q=e[o].q||[]).push(arguments)},e[o].l=1*new Date,i=t.createElement(n),a=t.getElementsByTagName(n)[0],i.async=1,i.src=s,a.parentNode.insertBefore(i,a)}(window,document,"script","https://www.google-analytics.com/analytics.js","ga"),ga("create","UA-123-45","auto"),ga("send","pageview"))</script><meta property="og:title" content="[TIL] Chapter 11: 디스크 관리"><meta property="og:description" content="디스크의 물리적인 구조는 어떻고, 이 디스크 스케쥴링이 왜 필요하고 어떤 알고리즘들로 스케쥴링되는지, disk의 역할 2가지는 무엇인지, 다중 디스크 상황의 장점은 무엇인지 알아본다."><meta property="og:type" content="article"><meta property="og:url" content="http://jeha00.github.io/post/os/os_chapter_11_%EB%94%94%EC%8A%A4%ED%81%AC%EA%B4%80%EB%A6%AC/"><meta property="og:image" content="http://jeha00.github.io/47"><meta property="article:section" content="post"><meta property="article:published_time" content="2022-05-25T13:37:20+09:00"><meta property="article:modified_time" content="2022-05-25T13:37:20+09:00"><meta property="og:site_name" content="JeHa00 DevLog"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="http://jeha00.github.io/47"><meta name=twitter:title content="[TIL] Chapter 11: 디스크 관리"><meta name=twitter:description content="디스크의 물리적인 구조는 어떻고, 이 디스크 스케쥴링이 왜 필요하고 어떤 알고리즘들로 스케쥴링되는지, disk의 역할 2가지는 무엇인지, 다중 디스크 상황의 장점은 무엇인지 알아본다."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"http://jeha00.github.io/post/"},{"@type":"ListItem","position":2,"name":"[TIL] Chapter 11: 디스크 관리","item":"http://jeha00.github.io/post/os/os_chapter_11_%EB%94%94%EC%8A%A4%ED%81%AC%EA%B4%80%EB%A6%AC/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"[TIL] Chapter 11: 디스크 관리","name":"[TIL] Chapter 11: 디스크 관리","description":"디스크의 물리적인 구조는 어떻고, 이 디스크 스케쥴링이 왜 필요하고 어떤 알고리즘들로 스케쥴링되는지, disk의 역할 2가지는 무엇인지, 다중 디스크 상황의 장점은 무엇인지 알아본다.","keywords":["TIL","OS"],"articleBody":"0. Introduction 해당 내용은 운영체제와 정보기술의 원리 -반효경 지음- 와 kocw 이화여자대학교 운영체제 - 반효경 교수 -를 보고 정리한 내용이다. 정확하지 않은 내용이 있다면 말씀해주시면 감사하겠습니다. 1. 디스크의 구조 디스크(disk): 컴퓨터 시스템의 대표적인 2차 저장장치 memory는 volatile(휘발성) 저장장치이지만, disk는 영구 보관할 수 있는 2차 저장장치 디스크의 효율적인 관리를 위해 디스크 스케쥴링 기법 과 저전력 디스크 관리 기법 에 대해 알아보자. 또한, 엘리베이터 scheduling 문제를 통해 쉽게 이해해보자. 1.1 논리 블록(logical block) 단위 디스크 외부(=컴퓨터 host의 내부)에서 보는 디스크의 단위 정보 저장 공간들을 말한다. 내부에서는 sector로 바라본다.\n주소를 가진 1차원 배열처럼 취급\nhost에서 disk의 정보를 읽을 때, sector 몇 번지가 아니라 1차원 배열에서 몇 번째 있는 정보를 달라고 요청한다. 정보를 전송하는 최소 단위\ndisk에 데이터 저장과 disk 외부로의 입출력은 논리 블록 단위로 저장 및 전송이 이뤄진다. 어떻게 논리 블록의 저장된 데이터에 접근하는가??\n해당 블록의 index 번호를 disk controller에 전달 → disk controller가 대응되는 sector를 찾아 요청 데이터에 대한 입출력 작업을 수행 1.2 디스크의 물리적 구조 디스크의 물리적인 구조: 마그네틱의 원판 으로 구성\n원판 = 트랙(track) 으로 구성\n트랙(track) = 섹터(sector) 로 구성 논리블록 단위의 disk 내에 물리적인 위치 = 섹터(Sector)\n논리 블록 하나가 섹터 하나와 1대1 매핑되어 저장되기 때문 sector 0: 최외곽 실린더의 첫 트랙에 있는 첫 번째 섹터 실린더(Cylinder)\n상대적 위치가 동일한 트랙들의 집합 track과 거의 유사하게 사용 암(Arm) = disk의 data를 읽고 쓰기 위해서, 해당 섹터가 위치한 실린더로 이동하는 장치\n헤드(head) = 암에 붙어있는 data를 읽고 쓰는 장치\nPartitioning\ndisk를 하나 이상의 실린더 그룹으로 나누는 과정 OS는 이것을 독립적인 disk 로 취급(logical disk) 1.3 Booting Logical formatting\n파일 시스템을 만드는 것 컴퓨터 전원을 키면 이 파일 시스템에 있는 운영체제가 메모리에 올라와서 booting FAT, inode, free space 등의 구조 포함 Booting 의 간결한 절차 순서\ndisk에 CPU가 직접 접근하지 못 하는데 어떻게 접근하는가???\n전원 on -\u003e CPU가 ROM의 small bootstrap loader가 실행 -\u003e ROM: 전원이 나가도 기억하는 소량의 memory small bootstrap loader: booting을 위한 loader small bootstrp loader의 지시에 의해 sector 0 (boot block)을 memory에 load하여 실행-\u003e 이 sector 0은 어떤 파일 시스템이든 공통이기 때문에, 이 sector 0에 있는 boot block을 메모리에 올려서 실행한다. OS를 disk에서 load하여 실행 boot block이 file system에서 OS의 kernel 위치를 찾아서 memory에 올려서 실행하라고 지시한다. 2. 디스크 스케쥴링 2.1 접근시간(Access time)의 구성 탐색시간(seek time), 회전지연시간(rotational latency), 전송시간(transfer time)으로 구분\n탐색시간(seek time)\ndisk head를 해당 실린더 위치로 이동시키는데 걸리는 시간 회전지연시간(rotational latency)\n디스크가 회전해서 읽고 쓰려는 섹터가 헤드 위치에 도달하기까지 걸리는 시간 전송시간(transfer time)\n해당 sector가 head 위치에 도달한 후, data를 실제로 sector에 읽고 쓰는 데 소요되는 시간 disk I/O에 소요되는 접근시간 최소화 ⇒ disk I/O 효율 상승\n회전지연시간, 전송시간은 OS가 통제하기 힘들다. 그래서, 탐색시간 을 줄이기 위해 헤드의 움직임을 최소화하는 스케쥴링 작업을 실행한다. 2.2 Disk scheduling 작업 효율적인 disk I/O를 위해 여러 sector들에 대한 I/O 요청이 들어왔을 때, 이들을 어떤 순서로 처리할지 결정하는 mechanism\n목표: disk head의 이동거리를 줄이는 것 seek time을 최소화하는 것과 유사 2.2.1 FCFS(First Come First Served) scheduling 디스크에 먼저 들어온 요청을 먼저 처리하는 방식\n은행창구처럼 고정된 장소에서 이뤄지는 게 아니라, 데스크 헤드가 움직이면서 서비스를 하기 때문에, 비효율적 그룹화를 하지 않고 진행하기 때문. 2.2.2 SSTF(Shortest Seek Time First) scheduling head의 현재 위치로부터 가장 가까운 위치에 있는 요청을 제일 먼저 처리하는 방식\n문제점: 기아 현상(starvation)\n헤드 위치에서 멀리 떨어진 곳의 요청은 무한히 기다려야 하는 문제가 발생 이동거리 측면에서 가장 우수한 알고리즘은 아니다.\n2.2.3 SCAN algorithum head가 disk 원판의 안쪽 끝과 바깥쪽 끝을 오가며, 그 경로에 존재하는 모든 요청을 처리\n엘리베이터에서 사용하는 스케쥴링 알고리즘과 유사\nelevator scheduling algorithum 이라 불리기도 한다. 효율성과 형평성을 모두 만족하는 알고리즘\nFCFS처럼 불필요한 헤드의 이동 발생 X SSTF처럼 starvation 현상 발생 X 문제점\n이동 거리 측면에서 효율적이나, 모든 실린더 위치의 기다리는 시간이 공평한 것 X 제일 안쪽과 바깥쪽 위치보다 가운데 위치가 기다리는 평균시간이 더 짧기 때문 2.2.4 C-SCAN algorithum 출발점에서 다른 쪽 끝으로 이동하며 가는 길목에 있는 모든 요청을 처리하는 것까지 SCAN과 동일하나, 다른 쪽 끝에 도달해 원래 출발점 방향으로 이동할 때, 요청을 처리하지 않고, 바로 이동만 한다.\nSCAN algorithum을 개선한 것으로, circular-SCAN의 줄임말이다. 장점: 이동거리는 조금 길어지지만, 균일한 탐색시간을 제공 2.2.5 LOOK and C-LOOK algorithum head가 한쪽 방향으로 이동하다가 그 방향에 더 이상 대기 중인 요청이 없으면 head의 이동 방향을 즉시 반대로 바꾸는 scheduling 방식\nSCAN과 C-SCAN을 개선한 방식 진행 방향에 요청이 있는지 살핀 후, 이동하기 때문에 LOOK 이라 한다. 지금까지 살펴본 디스크 스케쥴링 기법들 중 LOOK 과 C-LOOK 등의 알고리즘이 많은 시스템에서 FCFS 와 SSTF에 비해 더 효율적인 것으로 알려져있다. 3. Swap-space management Disk를 사용하는 두 가지 이유\nMemory의 volatile 특성 -\u003e file system 프로그램 실행을 위한 memory 공간 부족 -\u003e swap space (swap area) Swap space\nVirtual memory system에서는 디스크를 memory의 연장 공간으로서 사용 파일 시스템 내부에 둘 수도 있으나, 별도 partion 사용이 일반적 공간 효율성보다는 속도 효율성이 우선 process가 끝나면 다 사라져버리는 내용이기 때문에, 공간효율성보다는 속도 효율성이 중요하다. 일반 파일보다 훨씬 짧은 시간만 존재하고 자주 참조된다. 따라서, block의 크기 및 저장 방식이 일반 파일 시스템과 다름 4. 다중 디스크 환경에서의 스케쥴링(RAID) RAID(Redundant Array of Independent Disks)\n여러 개의 disk를 묶어서 사용 어디서 다중 디스크를 사용하는가???\n동시 사용자가 많은 서버에서는 다수의 disk를 함께 사용한다. RAID의 사용 목적과 장점\n디스크 처리 속도 향상\n여러 disk에 block의 내용을 분산 저장 병렬적으로 읽어온다. 신뢰성(Reliability) 향상\n동일 정보를 여러 디스크에 중복 저장 -\u003e 동시 서비스 가능 하나의 디스크가 고장 시, 다른 디스크에서 읽어온다. 단순한 중복 저장이 아니라, 일부 디스크에 parity를 저장하여 공간의 효율성을 높일 수 있다. 다중 디스크의 문제와 스케쥴링 목적\n다중 디스크 환경에서는 어느 디스크에서 요청을 처리할지 결정하는 스케쥴링 문제까지 포함 다중 디스크 환경에서의 스케쥴링 목적: 부하 균형(load balancing)을 이루면서 확장성 있는 서비스가 목표 일부 디스크가 과부하에 걸리지 않도록, 모든 디스크에 골고루 분배하도록 스케쥴링 다중 디스크 스케쥴링의 또 다른 목표: 전력 소모 감소\n하나의 디스크로부터 요청을 충분히 감당할 수 있을 때, 다른 디스크들의 회전은 정지하는 게 효율적 유사한 예시: 그룹 엘리베이터 이웃한 여러 대의 엘리베이터가 독립적으로 운영되는 게 아니라, 동일한 제어 시스템에 의해서 공동으로 운영된다. 목표: 다수의 승객이 오래 기다리지 않고, 빠른 서비스를 받는 시스템의 확장성 사용자가 적을 경우, 한 대의 엘리베이터로 운행하는 게 효율적 5. 디스크의 저전력 관리 5.1 비활성화 기법 디스크의 상태는 전력소모를 기준으로 4가지 상태로 나뉜다.\n활동(active) 상태: 현재 head가 data를 읽거나 쓰고 있는 상태 공회전(idle) 상태: disk가 회전 중이지만, data를 읽거나 쓰지 않는 상태 준비(standby) : disk 회전하지 않지만, interface가 활성화된 상태 휴면(sleep) 상태: disk 회전 X, interface 비활성화 활성 상태와 비활성 상태\n활성 상태 = active + idle 비활성 상태 = standby + sleep 전력 소모 관점에서의 상태\n전력 소모가 비활성 상태일 때, 더 적다.\n각 상태로 전환 시, 부가적인 전력 및 시간 소모된다.\n후속 요청까지의 시간 간격이 일정 시간 이상이어야만, 디스크의 회전을 정지시키는 것이 전력 소모 절감에 효과적\n비활성화 시점을 결정하는 게 중요하다는 것\n디스크 비활성화 시점 결정 방법\n시간기반(timeout based): 일정 시간 동안 디스크가 공회전 상태이면 장치를 정지 → 요청이 들어오면 디스크 활성화 예측기반(prediction based): 과거 요청을 관찰하여, 다음 공회전 구간의 길이를 예측 후, 비활성화 시점 결정 확률기반(stochastic based): 확률분포를 사용 5.2 회전속도 조절 기법 디스크의 회전속도(RPM)를 가변적으로 조절하는 기법 OS는 시스템 자원과 부하를 포괄적으로 볼 수 있기 때문에, 하드웨어 혼자보다 더 많은 전력 절감 효과 얻음 멀티미디어 환경에서는 미래의 참조 예측이 비교적 정확해서 전력 소모를 줄일 수 있다. 5.3 디스크의 데이터 배치 기법 데이터의 복제본을 많이 만들어, 헤드 위치에서 가까운 복제본에 접근하여 빠른 응답시간과 전력 소모량 절감을 얻는 FS2 file 시스템(free space file system) 5.4 버퍼캐싱 및 사전인출 기법 전제:미래에 요청할 데이터를 미리 알거나, 어느 정도 예측할 수 있다면 활성 상태일 때 헤드 위치로부터 가까운 데이터를 사전 인출하여, 디스크의 비활성화 가능성을 높여 전력 소모를 줄임 5.5 쓰기전략을 통한 저전력 디스크 기법 디스크가 비활성화 상태일 때는 기다리다가, 활성 상태일 때 쓰는 방식으로 전력 소모를 줄이는 방안 Reference kocw 이화여자대학교 운영체제 - 반효경 교수 - 운영체제와 정보기술의 원리 - 반효경 지음 - ","wordCount":"1229","inLanguage":"en","datePublished":"2022-05-25T13:37:20+09:00","dateModified":"2022-05-25T13:37:20+09:00","mainEntityOfPage":{"@type":"WebPage","@id":"http://jeha00.github.io/post/os/os_chapter_11_%EB%94%94%EC%8A%A4%ED%81%AC%EA%B4%80%EB%A6%AC/"},"publisher":{"@type":"Organization","name":"Jeha DevLog","logo":{"@type":"ImageObject","url":"http://jeha00.github.io/favicon.ico"}}}</script></head><body class=dark id=top><script>localStorage.getItem("pref-theme")==="light"&&document.body.classList.remove("dark")</script><header class=header><nav class=nav><div class=logo><a href=http://jeha00.github.io/ accesskey=h title="@Jeha00 (Alt + H)">@Jeha00</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></span></div><ul id=menu><li><a href=http://jeha00.github.io/me/ title=About><span>About</span></a></li><li><a href=http://jeha00.github.io/archives/ title=Archive><span>Archive</span></a></li><li><a href=http://jeha00.github.io/categories/ title=Categories><span>Categories</span></a></li><li><a href=http://jeha00.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=http://jeha00.github.io/>Home</a>&nbsp;»&nbsp;<a href=http://jeha00.github.io/post/>Posts</a></div><h1 class=post-title>[TIL] Chapter 11: 디스크 관리</h1><div class=post-meta>OS&nbsp;·&nbsp;<span title='2022-05-25 13:37:20 +0900 KST'>May 25, 2022</span></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#0-introduction aria-label="0. Introduction">0. Introduction</a></li><li><a href=#1-%eb%94%94%ec%8a%a4%ed%81%ac%ec%9d%98-%ea%b5%ac%ec%a1%b0 aria-label="1. 디스크의 구조">1. 디스크의 구조</a><ul><li><a href=#11-%eb%85%bc%eb%a6%ac-%eb%b8%94%eb%a1%9dlogical-block-%eb%8b%a8%ec%9c%84 aria-label="1.1 논리 블록(logical block) 단위">1.1 논리 블록(logical block) 단위</a></li><li><a href=#12-%eb%94%94%ec%8a%a4%ed%81%ac%ec%9d%98-%eb%ac%bc%eb%a6%ac%ec%a0%81-%ea%b5%ac%ec%a1%b0 aria-label="1.2 디스크의 물리적 구조">1.2 디스크의 물리적 구조</a></li><li><a href=#13-booting aria-label="1.3 Booting">1.3 Booting</a></li></ul></li><li><a href=#2-%eb%94%94%ec%8a%a4%ed%81%ac-%ec%8a%a4%ec%bc%80%ec%a5%b4%eb%a7%81 aria-label="2. 디스크 스케쥴링">2. 디스크 스케쥴링</a><ul><li><a href=#21-%ec%a0%91%ea%b7%bc%ec%8b%9c%ea%b0%84access-time%ec%9d%98-%ea%b5%ac%ec%84%b1 aria-label="2.1 접근시간(Access time)의 구성">2.1 접근시간(Access time)의 구성</a></li><li><a href=#22-disk-scheduling-%ec%9e%91%ec%97%85 aria-label="2.2 Disk scheduling 작업">2.2 Disk scheduling 작업</a><ul><li><a href=#221-fcfsfirst-come-first-served-scheduling aria-label="2.2.1 FCFS(First Come First Served) scheduling">2.2.1 FCFS(First Come First Served) scheduling</a></li><li><a href=#222-sstfshortest-seek-time-first-scheduling aria-label="2.2.2 SSTF(Shortest Seek Time First) scheduling">2.2.2 SSTF(Shortest Seek Time First) scheduling</a></li><li><a href=#223-scan-algorithum aria-label="2.2.3 SCAN algorithum">2.2.3 SCAN algorithum</a></li><li><a href=#224-c-scan-algorithum aria-label="2.2.4 C-SCAN algorithum">2.2.4 C-SCAN algorithum</a></li><li><a href=#225-look-and-c-look-algorithum aria-label="2.2.5 LOOK and C-LOOK algorithum">2.2.5 LOOK and C-LOOK algorithum</a></li></ul></li></ul></li><li><a href=#3-swap-space-management aria-label="3. Swap-space management">3. Swap-space management</a></li><li><a href=#4-%eb%8b%a4%ec%a4%91-%eb%94%94%ec%8a%a4%ed%81%ac-%ed%99%98%ea%b2%bd%ec%97%90%ec%84%9c%ec%9d%98-%ec%8a%a4%ec%bc%80%ec%a5%b4%eb%a7%81raid aria-label="4. 다중 디스크 환경에서의 스케쥴링(RAID)">4. 다중 디스크 환경에서의 스케쥴링(RAID)</a></li><li><a href=#5-%eb%94%94%ec%8a%a4%ed%81%ac%ec%9d%98-%ec%a0%80%ec%a0%84%eb%a0%a5-%ea%b4%80%eb%a6%ac aria-label="5. 디스크의 저전력 관리">5. 디스크의 저전력 관리</a><ul><li><a href=#51-%eb%b9%84%ed%99%9c%ec%84%b1%ed%99%94-%ea%b8%b0%eb%b2%95 aria-label="5.1 비활성화 기법">5.1 비활성화 기법</a></li><li><a href=#52-%ed%9a%8c%ec%a0%84%ec%86%8d%eb%8f%84-%ec%a1%b0%ec%a0%88-%ea%b8%b0%eb%b2%95 aria-label="5.2 회전속도 조절 기법">5.2 회전속도 조절 기법</a></li><li><a href=#53-%eb%94%94%ec%8a%a4%ed%81%ac%ec%9d%98-%eb%8d%b0%ec%9d%b4%ed%84%b0-%eb%b0%b0%ec%b9%98-%ea%b8%b0%eb%b2%95 aria-label="5.3 디스크의 데이터 배치 기법">5.3 디스크의 데이터 배치 기법</a></li><li><a href=#54-%eb%b2%84%ed%8d%bc%ec%ba%90%ec%8b%b1-%eb%b0%8f-%ec%82%ac%ec%a0%84%ec%9d%b8%ec%b6%9c-%ea%b8%b0%eb%b2%95 aria-label="5.4 버퍼캐싱 및 사전인출 기법">5.4 버퍼캐싱 및 사전인출 기법</a></li><li><a href=#55-%ec%93%b0%ea%b8%b0%ec%a0%84%eb%9e%b5%ec%9d%84-%ed%86%b5%ed%95%9c-%ec%a0%80%ec%a0%84%eb%a0%a5-%eb%94%94%ec%8a%a4%ed%81%ac-%ea%b8%b0%eb%b2%95 aria-label="5.5 쓰기전략을 통한 저전력 디스크 기법">5.5 쓰기전략을 통한 저전력 디스크 기법</a></li></ul></li><li><a href=#reference aria-label=Reference>Reference</a></li></ul></div></details></div><div class=post-content><h1 id=0-introduction>0. Introduction<a hidden class=anchor aria-hidden=true href=#0-introduction>#</a></h1><ul><li>해당 내용은 <a href="http://www.kyobobook.co.kr/product/detailViewKor.laf?ejkGb=KOR&mallGb=KOR&barcode=9791158903589&orderClick=LAG&Kc=">운영체제와 정보기술의 원리 -반효경 지음-</a> 와 <a href="http://www.kocw.net/home/cview.do?lid=3dd1117c48123b8e">kocw 이화여자대학교 운영체제 - 반효경 교수 -</a>를 보고 정리한 내용이다.</li><li>정확하지 않은 내용이 있다면 말씀해주시면 감사하겠습니다.</li></ul><p> </p><hr><h1 id=1-디스크의-구조>1. 디스크의 구조<a hidden class=anchor aria-hidden=true href=#1-디스크의-구조>#</a></h1><ul><li>디스크(disk): 컴퓨터 시스템의 대표적인 2차 저장장치<ul><li>memory는 volatile(휘발성) 저장장치이지만, disk는 영구 보관할 수 있는 2차 저장장치</li></ul></li><li>디스크의 효율적인 관리를 위해 <code>디스크 스케쥴링 기법</code> 과 <code>저전력 디스크 관리 기법</code> 에 대해 알아보자.</li><li>또한, 엘리베이터 scheduling 문제를 통해 쉽게 이해해보자.</li></ul><p> </p><h2 id=11-논리-블록logical-block-단위>1.1 논리 블록(logical block) 단위<a hidden class=anchor aria-hidden=true href=#11-논리-블록logical-block-단위>#</a></h2><blockquote><p>디스크 외부(=컴퓨터 host의 내부)에서 보는 디스크의 단위 정보 저장 공간들을 말한다. 내부에서는 sector로 바라본다.</p></blockquote><ul><li><p><strong>주소를 가진 1차원 배열처럼 취급</strong></p><ul><li>host에서 disk의 정보를 읽을 때, sector 몇 번지가 아니라 1차원 배열에서 몇 번째 있는 정보를 달라고 요청한다.</li></ul></li><li><p><strong>정보를 전송하는 최소 단위</strong></p><ul><li>disk에 데이터 저장과 disk 외부로의 입출력은 <code>논리 블록 단위</code>로 저장 및 전송이 이뤄진다.</li></ul></li><li><p><strong>어떻게 논리 블록의 저장된 데이터에 접근하는가??</strong></p><ul><li>해당 블록의 index 번호를 disk controller에 전달 → disk controller가 대응되는 sector를 찾아 요청 데이터에 대한 입출력 작업을 수행</li></ul></li></ul><p> </p><h2 id=12-디스크의-물리적-구조>1.2 디스크의 물리적 구조<a hidden class=anchor aria-hidden=true href=#12-디스크의-물리적-구조>#</a></h2><p><img loading=lazy src=https://user-images.githubusercontent.com/78094972/170026928-a4779945-46b9-4770-8058-08e7a5e00854.PNG alt=image></p><ul><li><p><strong>디스크의 물리적인 구조</strong>: 마그네틱의 <code>원판</code> 으로 구성</p></li><li><p>원판 = <code>트랙(track)</code> 으로 구성</p><ul><li>트랙(track) = <code>섹터(sector)</code> 로 구성</li></ul></li><li><p><strong>논리블록 단위의 disk 내에 물리적인 위치 = <code>섹터(Sector)</code></strong></p><ul><li>논리 블록 하나가 섹터 하나와 1대1 매핑되어 저장되기 때문</li><li><code>sector 0</code>: 최외곽 실린더의 첫 트랙에 있는 첫 번째 섹터</li></ul></li><li><p><strong>실린더(Cylinder)</strong></p><ul><li>상대적 위치가 동일한 트랙들의 집합</li><li>track과 거의 유사하게 사용</li></ul></li><li><p><strong>암(Arm)</strong> = disk의 data를 읽고 쓰기 위해서, 해당 섹터가 위치한 실린더로 이동하는 장치</p></li><li><p><strong>헤드(head)</strong> = 암에 붙어있는 data를 읽고 쓰는 장치</p></li><li><p><strong>Partitioning</strong></p><ul><li>disk를 하나 이상의 실린더 그룹으로 나누는 과정</li><li>OS는 이것을 <em>독립적인 disk</em> 로 취급(logical disk)</li></ul></li></ul><p> </p><h2 id=13-booting>1.3 Booting<a hidden class=anchor aria-hidden=true href=#13-booting>#</a></h2><ul><li><p><strong>Logical formatting</strong></p><ul><li>파일 시스템을 만드는 것<ul><li>컴퓨터 전원을 키면 이 파일 시스템에 있는 운영체제가 메모리에 올라와서 booting</li></ul></li><li>FAT, inode, free space 등의 구조 포함</li></ul></li><li><p><strong>Booting 의 간결한 절차 순서</strong></p></li></ul><blockquote><p>disk에 CPU가 직접 접근하지 못 하는데 어떻게 접근하는가???</p></blockquote><ul><li><strong>전원 on -> CPU가 ROM의 small bootstrap loader가 실행 -></strong><ul><li>ROM: 전원이 나가도 기억하는 소량의 memory</li><li>small bootstrap loader: booting을 위한 loader</li></ul></li><li><strong>small bootstrp loader의 지시에 의해 sector 0 (boot block)을 memory에 load하여 실행-></strong><ul><li>이 sector 0은 어떤 파일 시스템이든 공통이기 때문에, 이 sector 0에 있는 boot block을 메모리에 올려서 실행한다.</li></ul></li><li><strong>OS를 disk에서 load하여 실행</strong><ul><li>boot block이 file system에서 OS의 kernel 위치를 찾아서 memory에 올려서 실행하라고 지시한다.</li></ul></li></ul><p> </p><hr><h1 id=2-디스크-스케쥴링>2. 디스크 스케쥴링<a hidden class=anchor aria-hidden=true href=#2-디스크-스케쥴링>#</a></h1><p> </p><h2 id=21-접근시간access-time의-구성>2.1 접근시간(Access time)의 구성<a hidden class=anchor aria-hidden=true href=#21-접근시간access-time의-구성>#</a></h2><blockquote><p>탐색시간(seek time), 회전지연시간(rotational latency), 전송시간(transfer time)으로 구분</p></blockquote><ul><li><p><strong>탐색시간(seek time)</strong></p><ul><li>disk head를 해당 실린더 위치로 이동시키는데 걸리는 시간</li></ul></li><li><p><strong>회전지연시간(rotational latency)</strong></p><ul><li>디스크가 회전해서 읽고 쓰려는 섹터가 헤드 위치에 도달하기까지 걸리는 시간</li></ul></li><li><p><strong>전송시간(transfer time)</strong></p><ul><li>해당 sector가 head 위치에 도달한 후, data를 실제로 sector에 읽고 쓰는 데 소요되는 시간</li></ul></li><li><p><strong>disk I/O에 소요되는 접근시간 최소화 ⇒ disk I/O 효율 상승</strong></p><ul><li>회전지연시간, 전송시간은 OS가 통제하기 힘들다.</li><li>그래서, <code>탐색시간</code> 을 줄이기 위해 헤드의 움직임을 최소화하는 스케쥴링 작업을 실행한다.</li></ul></li></ul><p> </p><h2 id=22-disk-scheduling-작업>2.2 Disk scheduling 작업<a hidden class=anchor aria-hidden=true href=#22-disk-scheduling-작업>#</a></h2><blockquote><p>효율적인 disk I/O를 위해 여러 sector들에 대한 I/O 요청이 들어왔을 때, 이들을 어떤 순서로 처리할지 결정하는 mechanism</p></blockquote><ul><li>목표: disk head의 이동거리를 줄이는 것<ul><li>seek time을 최소화하는 것과 유사</li></ul></li></ul><p> </p><h3 id=221-fcfsfirst-come-first-served-scheduling>2.2.1 FCFS(First Come First Served) scheduling<a hidden class=anchor aria-hidden=true href=#221-fcfsfirst-come-first-served-scheduling>#</a></h3><blockquote><p>디스크에 먼저 들어온 요청을 먼저 처리하는 방식</p></blockquote><p><img loading=lazy src=https://user-images.githubusercontent.com/78094972/170041063-a6dd7181-743f-4a42-9140-d2ae321fb4d2.PNG alt=image></p><ul><li>은행창구처럼 고정된 장소에서 이뤄지는 게 아니라, 데스크 헤드가 움직이면서 서비스를 하기 때문에, 비효율적</li><li>그룹화를 하지 않고 진행하기 때문.</li></ul><p> </p><h3 id=222-sstfshortest-seek-time-first-scheduling>2.2.2 SSTF(Shortest Seek Time First) scheduling<a hidden class=anchor aria-hidden=true href=#222-sstfshortest-seek-time-first-scheduling>#</a></h3><blockquote><p>head의 현재 위치로부터 가장 가까운 위치에 있는 요청을 제일 먼저 처리하는 방식</p></blockquote><p><img loading=lazy src=https://user-images.githubusercontent.com/78094972/170041289-f24abf40-75e1-4fa6-8c7d-3f110024caf3.PNG alt=image></p><ul><li><p><strong>문제점: 기아 현상(starvation)</strong></p><ul><li>헤드 위치에서 멀리 떨어진 곳의 요청은 무한히 기다려야 하는 문제가 발생</li></ul></li><li><p>이동거리 측면에서 가장 우수한 알고리즘은 아니다.</p></li></ul><p> </p><h3 id=223-scan-algorithum>2.2.3 SCAN algorithum<a hidden class=anchor aria-hidden=true href=#223-scan-algorithum>#</a></h3><blockquote><p>head가 disk 원판의 안쪽 끝과 바깥쪽 끝을 오가며, 그 경로에 존재하는 모든 요청을 처리</p></blockquote><p><img loading=lazy src=https://user-images.githubusercontent.com/78094972/170043962-f0bd1cbb-019c-4aab-8497-e14f982d4ac6.PNG alt=image></p><p><img loading=lazy src=https://user-images.githubusercontent.com/78094972/170045075-c5cab1a9-8778-4424-bfc3-fd850e04eb56.PNG alt=image></p><ul><li><p>엘리베이터에서 사용하는 스케쥴링 알고리즘과 유사</p><ul><li>elevator scheduling algorithum 이라 불리기도 한다.</li></ul></li><li><p>효율성과 형평성을 모두 만족하는 알고리즘</p><ul><li>FCFS처럼 불필요한 헤드의 이동 발생 X</li><li>SSTF처럼 starvation 현상 발생 X</li></ul></li><li><p><strong>문제점</strong></p><ul><li>이동 거리 측면에서 효율적이나, 모든 실린더 위치의 기다리는 시간이 공평한 것 X</li><li>제일 안쪽과 바깥쪽 위치보다 가운데 위치가 기다리는 평균시간이 더 짧기 때문</li></ul></li></ul><p> </p><h3 id=224-c-scan-algorithum>2.2.4 C-SCAN algorithum<a hidden class=anchor aria-hidden=true href=#224-c-scan-algorithum>#</a></h3><blockquote><p>출발점에서 다른 쪽 끝으로 이동하며 가는 길목에 있는 모든 요청을 처리하는 것까지 SCAN과 동일하나, 다른 쪽 끝에 도달해 원래 출발점 방향으로 이동할 때, 요청을 처리하지 않고, 바로 이동만 한다.</p></blockquote><p><img loading=lazy src=https://user-images.githubusercontent.com/78094972/170045357-04be1f12-503c-439f-9474-22c4db297f0f.PNG alt=image></p><p><img loading=lazy src=https://user-images.githubusercontent.com/78094972/170046609-2d0f296a-d228-4eae-b75b-0e79dc89e2b6.PNG alt=image></p><ul><li>SCAN algorithum을 개선한 것으로, circular-SCAN의 줄임말이다.</li><li>장점: 이동거리는 조금 길어지지만, 균일한 탐색시간을 제공</li></ul><p> </p><h3 id=225-look-and-c-look-algorithum>2.2.5 LOOK and C-LOOK algorithum<a hidden class=anchor aria-hidden=true href=#225-look-and-c-look-algorithum>#</a></h3><blockquote><p>head가 한쪽 방향으로 이동하다가 그 방향에 더 이상 대기 중인 요청이 없으면 head의 이동 방향을 즉시 반대로 바꾸는 scheduling 방식</p></blockquote><p><img loading=lazy src=https://user-images.githubusercontent.com/78094972/170052143-fff630d0-c783-492b-90bb-97135babe2c8.PNG alt=image></p><ul><li>SCAN과 C-SCAN을 개선한 방식</li><li>진행 방향에 요청이 있는지 살핀 후, 이동하기 때문에 <code>LOOK</code> 이라 한다.</li><li>지금까지 살펴본 디스크 스케쥴링 기법들 중 LOOK 과 C-LOOK 등의 알고리즘이 많은 시스템에서 FCFS 와 SSTF에 비해 더 효율적인 것으로 알려져있다.</li></ul><p> </p><hr><h1 id=3-swap-space-management>3. Swap-space management<a hidden class=anchor aria-hidden=true href=#3-swap-space-management>#</a></h1><p><img loading=lazy src=https://user-images.githubusercontent.com/78094972/170165358-3285a49c-3a9d-47e9-8efd-6940b79d56e4.PNG alt=image></p><ul><li><p><strong>Disk를 사용하는 두 가지 이유</strong></p><ul><li>Memory의 volatile 특성 -> <strong>file system</strong></li><li>프로그램 실행을 위한 memory 공간 부족 -> <strong>swap space (swap area)</strong></li></ul></li><li><p><strong>Swap space</strong></p><ul><li>Virtual memory system에서는 디스크를 memory의 연장 공간으로서 사용</li><li>파일 시스템 내부에 둘 수도 있으나, 별도 partion 사용이 일반적<ul><li>공간 효율성보다는 속도 효율성이 우선<ul><li>process가 끝나면 다 사라져버리는 내용이기 때문에, 공간효율성보다는 속도 효율성이 중요하다.</li></ul></li><li>일반 파일보다 훨씬 짧은 시간만 존재하고 자주 참조된다.</li><li>따라서, block의 크기 및 저장 방식이 일반 파일 시스템과 다름</li></ul></li></ul></li></ul><p> </p><hr><h1 id=4-다중-디스크-환경에서의-스케쥴링raid>4. 다중 디스크 환경에서의 스케쥴링(RAID)<a hidden class=anchor aria-hidden=true href=#4-다중-디스크-환경에서의-스케쥴링raid>#</a></h1><ul><li><p><strong>RAID(Redundant Array of Independent Disks)</strong></p><ul><li>여러 개의 disk를 묶어서 사용</li></ul></li><li><p><strong>어디서 다중 디스크를 사용하는가???</strong></p><ul><li>동시 사용자가 많은 서버에서는 다수의 disk를 함께 사용한다.</li></ul></li><li><p><strong>RAID의 사용 목적과 장점</strong></p><ul><li><p><strong>디스크 처리 속도 향상</strong></p><ul><li>여러 disk에 block의 내용을 분산 저장</li><li>병렬적으로 읽어온다.</li></ul></li><li><p><strong>신뢰성(Reliability) 향상</strong></p><ul><li>동일 정보를 여러 디스크에 중복 저장 -> 동시 서비스 가능</li><li>하나의 디스크가 고장 시, 다른 디스크에서 읽어온다.</li><li>단순한 중복 저장이 아니라, 일부 디스크에 parity를 저장하여 공간의 효율성을 높일 수 있다.</li></ul></li></ul></li><li><p><strong>다중 디스크의 문제와 스케쥴링 목적</strong></p><ul><li>다중 디스크 환경에서는 어느 디스크에서 요청을 처리할지 결정하는 스케쥴링 문제까지 포함</li><li>다중 디스크 환경에서의 스케쥴링 목적: 부하 균형(load balancing)을 이루면서 확장성 있는 서비스가 목표<ul><li>일부 디스크가 과부하에 걸리지 않도록, 모든 디스크에 골고루 분배하도록 스케쥴링</li></ul></li></ul></li><li><p><strong>다중 디스크 스케쥴링의 또 다른 목표: 전력 소모 감소</strong></p><ul><li>하나의 디스크로부터 요청을 충분히 감당할 수 있을 때, 다른 디스크들의 회전은 정지하는 게 효율적</li><li>유사한 예시: 그룹 엘리베이터<ul><li>이웃한 여러 대의 엘리베이터가 독립적으로 운영되는 게 아니라, 동일한 제어 시스템에 의해서 공동으로 운영된다.</li><li>목표: 다수의 승객이 오래 기다리지 않고, 빠른 서비스를 받는 시스템의 확장성</li><li>사용자가 적을 경우, 한 대의 엘리베이터로 운행하는 게 효율적</li></ul></li></ul></li></ul><p> </p><hr><h1 id=5-디스크의-저전력-관리>5. 디스크의 저전력 관리<a hidden class=anchor aria-hidden=true href=#5-디스크의-저전력-관리>#</a></h1><p> </p><h2 id=51-비활성화-기법>5.1 비활성화 기법<a hidden class=anchor aria-hidden=true href=#51-비활성화-기법>#</a></h2><p><img loading=lazy src=https://user-images.githubusercontent.com/78094972/170171982-76cd7d2d-b7fc-4aff-980a-bac53fcf5226.jpg alt=image></p><ul><li><p><strong>디스크의 상태는 전력소모를 기준으로 4가지 상태로 나뉜다.</strong></p><ul><li>활동(active) 상태: 현재 head가 data를 읽거나 쓰고 있는 상태</li><li>공회전(idle) 상태: disk가 회전 중이지만, data를 읽거나 쓰지 않는 상태</li><li>준비(standby) : disk 회전하지 않지만, interface가 활성화된 상태</li><li>휴면(sleep) 상태: disk 회전 X, interface 비활성화</li></ul></li><li><p><strong>활성 상태와 비활성 상태</strong></p><ul><li>활성 상태 = active + idle</li><li>비활성 상태 = standby + sleep</li></ul></li><li><p><strong>전력 소모 관점에서의 상태</strong></p><ul><li><p>전력 소모가 비활성 상태일 때, 더 적다.</p></li><li><p>각 상태로 전환 시, 부가적인 전력 및 시간 소모된다.</p></li><li><p>후속 요청까지의 시간 간격이 일정 시간 이상이어야만, 디스크의 회전을 정지시키는 것이 전력 소모 절감에 효과적</p></li><li><p>비활성화 시점을 결정하는 게 중요하다는 것</p></li></ul></li><li><p><strong>디스크 비활성화 시점 결정 방법</strong></p><ul><li>시간기반(timeout based): 일정 시간 동안 디스크가 공회전 상태이면 장치를 정지 → 요청이 들어오면 디스크 활성화</li><li>예측기반(prediction based): 과거 요청을 관찰하여, 다음 공회전 구간의 길이를 예측 후, 비활성화 시점 결정</li><li>확률기반(stochastic based): 확률분포를 사용</li></ul></li></ul><p> </p><h2 id=52-회전속도-조절-기법>5.2 회전속도 조절 기법<a hidden class=anchor aria-hidden=true href=#52-회전속도-조절-기법>#</a></h2><ul><li>디스크의 회전속도(RPM)를 가변적으로 조절하는 기법</li><li>OS는 시스템 자원과 부하를 포괄적으로 볼 수 있기 때문에, 하드웨어 혼자보다 더 많은 전력 절감 효과 얻음</li><li>멀티미디어 환경에서는 미래의 참조 예측이 비교적 정확해서 전력 소모를 줄일 수 있다.</li></ul><p> </p><h2 id=53-디스크의-데이터-배치-기법>5.3 디스크의 데이터 배치 기법<a hidden class=anchor aria-hidden=true href=#53-디스크의-데이터-배치-기법>#</a></h2><ul><li>데이터의 복제본을 많이 만들어, 헤드 위치에서 가까운 복제본에 접근하여 빠른 응답시간과 전력 소모량 절감을 얻는 FS2 file 시스템(free space file system)</li></ul><p> </p><h2 id=54-버퍼캐싱-및-사전인출-기법>5.4 버퍼캐싱 및 사전인출 기법<a hidden class=anchor aria-hidden=true href=#54-버퍼캐싱-및-사전인출-기법>#</a></h2><ul><li>전제:미래에 요청할 데이터를 미리 알거나, 어느 정도 예측할 수 있다면<ul><li>활성 상태일 때 헤드 위치로부터 가까운 데이터를 사전 인출하여, 디스크의 비활성화 가능성을 높여 전력 소모를 줄임</li></ul></li></ul><p> </p><h2 id=55-쓰기전략을-통한-저전력-디스크-기법>5.5 쓰기전략을 통한 저전력 디스크 기법<a hidden class=anchor aria-hidden=true href=#55-쓰기전략을-통한-저전력-디스크-기법>#</a></h2><ul><li>디스크가 비활성화 상태일 때는 기다리다가, 활성 상태일 때 쓰는 방식으로 전력 소모를 줄이는 방안</li></ul><p> </p><hr><h1 id=reference>Reference<a hidden class=anchor aria-hidden=true href=#reference>#</a></h1><ul><li><a href="http://www.kocw.net/home/cview.do?lid=3dd1117c48123b8e">kocw 이화여자대학교 운영체제 - 반효경 교수 -</a></li><li><a href="http://www.kyobobook.co.kr/product/detailViewKor.laf?ejkGb=KOR&mallGb=KOR&barcode=9791158903589&orderClick=LAG&Kc=">운영체제와 정보기술의 원리 - 반효경 지음 -</a></li></ul></div><footer class=post-footer><ul class=post-tags><li><a href=http://jeha00.github.io/tags/til/>TIL</a></li><li><a href=http://jeha00.github.io/tags/os/>OS</a></li></ul><nav class=paginav><a class=prev href=http://jeha00.github.io/post/os/os_chapter_12_%ED%8C%8C%EC%9D%BC%EC%8B%9C%EC%8A%A4%ED%85%9C_1/><span class=title>« Prev Page</span><br><span>[TIL] Chapter 12: 파일 시스템 1</span></a>
<a class=next href=http://jeha00.github.io/post/os/os_chapter_10_%EA%B0%80%EC%83%81%EB%A9%94%EB%AA%A8%EB%A6%AC/><span class=title>Next Page »</span><br><span>[TIL] Chapter 10: 가상 메모리</span></a></nav><div class=share-buttons><a target=_blank rel="noopener noreferrer" aria-label="share [TIL] Chapter 11: 디스크 관리 on twitter" href="https://twitter.com/intent/tweet/?text=%5bTIL%5d%20Chapter%2011%3a%20%eb%94%94%ec%8a%a4%ed%81%ac%20%ea%b4%80%eb%a6%ac&url=http%3a%2f%2fjeha00.github.io%2fpost%2fos%2fos_chapter_11_%25EB%2594%2594%25EC%258A%25A4%25ED%2581%25AC%25EA%25B4%2580%25EB%25A6%25AC%2f&hashtags=TIL%2cOS"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM195.519 424.544c135.939.0 210.268-112.643 210.268-210.268.0-3.218.0-6.437-.153-9.502 14.406-10.421 26.973-23.448 36.935-38.314-13.18 5.824-27.433 9.809-42.452 11.648 15.326-9.196 26.973-23.602 32.49-40.92-14.252 8.429-30.038 14.56-46.896 17.931-13.487-14.406-32.644-23.295-53.946-23.295-40.767.0-73.87 33.104-73.87 73.87.0 5.824.613 11.494 1.992 16.858-61.456-3.065-115.862-32.49-152.337-77.241-6.284 10.881-9.962 23.601-9.962 37.088.0 25.594 13.027 48.276 32.95 61.456-12.107-.307-23.448-3.678-33.41-9.196v.92c0 35.862 25.441 65.594 59.311 72.49-6.13 1.686-12.72 2.606-19.464 2.606-4.751.0-9.348-.46-13.946-1.38 9.349 29.426 36.628 50.728 68.965 51.341-25.287 19.771-57.164 31.571-91.8 31.571-5.977.0-11.801-.306-17.625-1.073 32.337 21.15 71.264 33.41 112.95 33.41z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share [TIL] Chapter 11: 디스크 관리 on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&url=http%3a%2f%2fjeha00.github.io%2fpost%2fos%2fos_chapter_11_%25EB%2594%2594%25EC%258A%25A4%25ED%2581%25AC%25EA%25B4%2580%25EB%25A6%25AC%2f&title=%5bTIL%5d%20Chapter%2011%3a%20%eb%94%94%ec%8a%a4%ed%81%ac%20%ea%b4%80%eb%a6%ac&summary=%5bTIL%5d%20Chapter%2011%3a%20%eb%94%94%ec%8a%a4%ed%81%ac%20%ea%b4%80%eb%a6%ac&source=http%3a%2f%2fjeha00.github.io%2fpost%2fos%2fos_chapter_11_%25EB%2594%2594%25EC%258A%25A4%25ED%2581%25AC%25EA%25B4%2580%25EB%25A6%25AC%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share [TIL] Chapter 11: 디스크 관리 on reddit" href="https://reddit.com/submit?url=http%3a%2f%2fjeha00.github.io%2fpost%2fos%2fos_chapter_11_%25EB%2594%2594%25EC%258A%25A4%25ED%2581%25AC%25EA%25B4%2580%25EB%25A6%25AC%2f&title=%5bTIL%5d%20Chapter%2011%3a%20%eb%94%94%ec%8a%a4%ed%81%ac%20%ea%b4%80%eb%a6%ac"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share [TIL] Chapter 11: 디스크 관리 on facebook" href="https://facebook.com/sharer/sharer.php?u=http%3a%2f%2fjeha00.github.io%2fpost%2fos%2fos_chapter_11_%25EB%2594%2594%25EC%258A%25A4%25ED%2581%25AC%25EA%25B4%2580%25EB%25A6%25AC%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share [TIL] Chapter 11: 디스크 관리 on whatsapp" href="https://api.whatsapp.com/send?text=%5bTIL%5d%20Chapter%2011%3a%20%eb%94%94%ec%8a%a4%ed%81%ac%20%ea%b4%80%eb%a6%ac%20-%20http%3a%2f%2fjeha00.github.io%2fpost%2fos%2fos_chapter_11_%25EB%2594%2594%25EC%258A%25A4%25ED%2581%25AC%25EA%25B4%2580%25EB%25A6%25AC%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share [TIL] Chapter 11: 디스크 관리 on telegram" href="https://telegram.me/share/url?text=%5bTIL%5d%20Chapter%2011%3a%20%eb%94%94%ec%8a%a4%ed%81%ac%20%ea%b4%80%eb%a6%ac&url=http%3a%2f%2fjeha00.github.io%2fpost%2fos%2fos_chapter_11_%25EB%2594%2594%25EC%258A%25A4%25ED%2581%25AC%25EA%25B4%2580%25EB%25A6%25AC%2f"><svg viewBox="2 2 28 28"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></div></footer></article></main><footer class=footer><span>&copy; 2023 <a href=http://jeha00.github.io/>Jeha DevLog</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerText="copy";function s(){t.innerText="copied!",setTimeout(()=>{t.innerText="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>