<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>[TIL] Chapter 13: 웹캐싱 기법 | Jeha DevLog</title><meta name=keywords content="TIL,OS"><meta name=description content="캐싱이란 무엇이고, 웹에서 사용되는 캐싱은 무엇을 목적으로 하는지, 웹캐싱이 전통적인 캐싱 기법과 무엇이 다른지, ICP는 무엇인지, 정적 웹과 동적 웹이란 무엇인지 등을 알아본다."><meta name=author content><link rel=canonical href=http://jeha00.github.io/post/os/os_chapter_13_%EC%9B%B9%EC%BA%90%EC%8B%B1/><meta name=google-site-verification content="XYZabc"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.min.82ffb49f4dad536e46fbe180b43e230f0d308d3cb9127068102090318b24d48c.css integrity="sha256-gv+0n02tU25G++GAtD4jDw0wjTy5EnBoECCQMYsk1Iw=" rel="preload stylesheet" as=style><link rel=icon href=http://jeha00.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=http://jeha00.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=http://jeha00.github.io/favicon-32x32.png><link rel=apple-touch-icon href=http://jeha00.github.io/apple-touch-icon.png><link rel=mask-icon href=http://jeha00.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><meta name=generator content="Hugo 0.101.0"><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><script type=application/javascript>var doNotTrack=!1;doNotTrack||(function(e,t,n,s,o,i,a){e.GoogleAnalyticsObject=o,e[o]=e[o]||function(){(e[o].q=e[o].q||[]).push(arguments)},e[o].l=1*new Date,i=t.createElement(n),a=t.getElementsByTagName(n)[0],i.async=1,i.src=s,a.parentNode.insertBefore(i,a)}(window,document,"script","https://www.google-analytics.com/analytics.js","ga"),ga("create","UA-123-45","auto"),ga("send","pageview"))</script><meta property="og:title" content="[TIL] Chapter 13: 웹캐싱 기법"><meta property="og:description" content="캐싱이란 무엇이고, 웹에서 사용되는 캐싱은 무엇을 목적으로 하는지, 웹캐싱이 전통적인 캐싱 기법과 무엇이 다른지, ICP는 무엇인지, 정적 웹과 동적 웹이란 무엇인지 등을 알아본다."><meta property="og:type" content="article"><meta property="og:url" content="http://jeha00.github.io/post/os/os_chapter_13_%EC%9B%B9%EC%BA%90%EC%8B%B1/"><meta property="og:image" content="http://jeha00.github.io/47"><meta property="article:section" content="post"><meta property="article:published_time" content="2022-05-31T20:20:17+09:00"><meta property="article:modified_time" content="2022-05-31T20:20:17+09:00"><meta property="og:site_name" content="JeHa00 DevLog"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="http://jeha00.github.io/47"><meta name=twitter:title content="[TIL] Chapter 13: 웹캐싱 기법"><meta name=twitter:description content="캐싱이란 무엇이고, 웹에서 사용되는 캐싱은 무엇을 목적으로 하는지, 웹캐싱이 전통적인 캐싱 기법과 무엇이 다른지, ICP는 무엇인지, 정적 웹과 동적 웹이란 무엇인지 등을 알아본다."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"http://jeha00.github.io/post/"},{"@type":"ListItem","position":2,"name":"[TIL] Chapter 13: 웹캐싱 기법","item":"http://jeha00.github.io/post/os/os_chapter_13_%EC%9B%B9%EC%BA%90%EC%8B%B1/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"[TIL] Chapter 13: 웹캐싱 기법","name":"[TIL] Chapter 13: 웹캐싱 기법","description":"캐싱이란 무엇이고, 웹에서 사용되는 캐싱은 무엇을 목적으로 하는지, 웹캐싱이 전통적인 캐싱 기법과 무엇이 다른지, ICP는 무엇인지, 정적 웹과 동적 웹이란 무엇인지 등을 알아본다.","keywords":["TIL","OS"],"articleBody":"0. Introduction 해당 내용은 운영체제와 정보기술의 원리 -반효경 지음- 와 kocw 이화여자대학교 운영체제 - 반효경 교수 -를 보고 정리한 내용이다. 정확하지 않은 내용이 있다면 말씀해주시면 감사하겠습니다. 1. 다양한 caching 환경 1.1 caching 기법 한정된 빠른 공간(= 캐쉬)에 요청된 데이터를 저장해 두었다가 후속 요청시 캐쉬로부터 직접 서비스하는 방식\n저장장치 계층 간의 속도 차이를 완충시켜주기 위해 컴퓨터 구조, 운영체제, DB 등의 분야에서 각각 다음과 같은 기법 등으로 사용되고 있다.\npaging system 외에도 cache memory, buffer caching, Web caching 등 다양한 분야에서 사용된다.\ncache memory: CPU와 main memory 사이에 cache memory가 있다. 이 cache memory에 없는 file을 main memory에 요청한다. buffer caching: file system에 대한 read/write 요청을 memory에서 빠르게 서비스하는 방식 Web caching: web page를 server에서 가져오는데 동일한 url을 요청할 때를 대비해서 신속히 서비스를 제공하기 위해서, caching 기법으로 제공하는 방법 cache 운영의 시간 제약\n교체 알고리즘에서 삭제할 항목을 결정하는 일에 지나치게 많은 시간이 걸리는 경우, 실제 시스템에서 사용할 수 없다.\nBuffer caching이나 Web caching의 경우\nO(1)에서 O(log n) 정도까지 허용 Paging system인 경우\npage fault인 경우에만 OS가 관여한다. 페이지가 이미 메모리에 존재하는 경우, 참조시각 등의 정보를 OS가 알 수 없다. O(1)인 LRU의 list 조작 조차 불가능 1.2 웹캐싱이란? 웹 사용자에 의해 빈번히 요청되는 데이터를 사용자와 지리적으로 가까운 웹캐시 서버에 보관해, 빠른 서비스를 제공하여 서비스 지연시간을 줄이고 웹서버 부하도 줄이는 기법\n2. 웹캐시의 교체 알고리즘(Cache replacement algorithum) 한정된 캐시 공간 안에서 사용자들의 지속적인 요청을 처리하기 위해서, 미래에 참조될 가능성이 높은 객체를 선별한 후, 한정된 캐시 공간 안에 보관할 객체를 온라인으로 결정하는 알고리즘\n웹캐시는 객체를 가지고 있는 근원지 서버의 위치 및 특성에 따라 객체를 캐시로 읽어오는 비용이 다르다.\n하나의 URL에 대응되는 파일 단위로 캐싱이 이뤄져서 캐싱 단위의 크기가 균일하지 않다.\n2.1 교체 알고리즘의 성능 척도 캐시 교체 알고리즘의 목표는 참조 가능성이 높은 객체를 캐시에 보관해 ‘캐시적중률(Hit rate)‘을 높이는 것\n캐시 적중률\n사용자의 총 요청 중 캐시에서 적중되어 서비스된 요청의 비율 하지만, 웹캐싱에서는 객체들의 크기와 인출 비용이 균일하지 않기 때문에 , 객체들의 참조 가능성과 이질성을 함께 고려해야 한다.\n이런 경우, 비용절감률(Cost-Savings Ratio: CSR) 로 정형화시킨다.\n객체 크기와 인출 비용이 모두 균일하면 비용절감률은 캐시 적중률과 동일한 의미를 가진다. 2.2 참조 가능성의 예측 캐시 교체 알고리즘은 전통적인 캐싱 기법인 LRU(Least Recently Used), LFU(Least Frequently Used) 등의 알고리즘처럼 최근 참조 성향과 참조 빈도에 근거해 미래의 참조 성향을 예측하는 방법을 사용한다.\n그러면 전통적인 교체 알고리즘들의 구체적인 예를 살펴보고, 웹캐시의 교체 알고리즘은 이들 중 어떤 방법을 채택하는지 알아보자.\n2.2.1 전통적인 교체 알고리즘 과거 참조 기록을 바탕으로 객체 A와 B를 평가한다고 하자.\nLRU는 최근 참조 성향만을 고려한다.\n(a) 객체 B가 더 최근(t1)에 참조되었기 때문에, (a) B에 더 높은 가치를 부여한다. 하지만, 이 방법은 자주 참조되는 객체와 그렇지 않은 객체를 구분할 수 없다는 단점이 있다. (b)에서는 A의 가치가 더 높게 평가된다는 사실은 LRU의 문제점을 보여준다. LFU는 참조 횟수만을 고려한다.\n(a) A의 참조 횟수가 (a) B보다 더 많기 때문에, (a) A에 더 높은 가치를 부여한다. 이 알고리즘의 문제점은 오래 전에 많이 참조된 객체에 높은 가치를 부여해, 새로 참조되기 시작한 객체를 캐시에서 쫓아낼 우려가 있다. 오히려 (c)에서 B의 가치가 더 높게 평가된다는 사실이 LFU의 문제점을 보여준다. 최근 참조 성향과 참조 횟수에 근거해 객체의 참조 가능성을 평가하는 방법은 최근에 참조된 객체가 다시 참조될 가능성이 높다는 점 ( 시간지역성, temporal locality )과, 참조 횟수가 많은 객체일수록 다시 참조될 가능성이 높다는 점 ( 인기도, popularity ), 이 두 가지 사실을 기본으로 가정한다.\n위에 두 가지가 컴퓨터 프로그램의 참조 성향을 모델링하는데 널리 사용되는 요소다.\n2.2.2 웹캐시의 교체 알고리즘 시간지역성 측면 -\u003e 웹 캐시 알고리즘들은 객체의 직전 참조 시각을 활용\n참조 인기도 측면 -\u003e 객체 참조 횟수에 노화 기법을 추가하여, 캐시 오염(cache pollution)을 방지한다.\n노화 기법: 오래전에 이루어진 참조에 대해 참조 횟수 계산할 때, 가중치를 줄이는 방법 2.3 객체의 이질성에 대한 고려 웹캐싱 같이 캐싱의 단위 객체들의 크기와 인출 비용이 균일하지 않은 환경에서는 이 특성을 고려한 합리적인 가치 평가를 해야 한다.\n이 합리적인 평가를 하기 위해서는 객체의 참조 가능성 과 캐시 적중률 로 실제 절약할 수 있는 비용을 동시에 고려해야 한다.\n캐시 적중률의 경우, 크기가 작은 객체에 높은 가치를 부여한다. 왜냐하면, 한정된 캐시 공간에 많은 객체를 보관하면 캐시 적중률이 높아지기 때문이다.\n2.4 알고리즘의 시간 복잡도 캐시 교체 알고리즘이 실제 시스템에 유효하게 사용되기 위해서는 시간 복잡도 측면에서 현실성이 있어야 한다.\n시간 복잡도 O(n): cache 내에 있는 객체의 수가 n개라고 할 때, 어떤 객체를 캐시에서 삭제할지 결정하기 위해 n에 비례하는 비교나 연산이 필요하다는 의미\nproxy cache의 경우, 통상적으로 cache 내에 수백만 개의 객체가 존재하기 때문에 이들을 다 조사하는 시간 복잡도의 방법은 부담이 크기 때문에, 웹 환경에서는 이 알고리즘으로 사용하기 어렵다.\nLRU\n가장 최근에 참조된 시각을 기준으로 객체들의 가치를 일렬로 세워놓고 새롭게 참조된 객체만 가치가 가장 높은 위치로 옮기면 되므로, O(1)의 시간 복잡도 구현이 가능하다. O(1): 캐시 내에 존재하는 객체의 수 n이 커지더라도, 이에 관계없이 캐시에서 이루어지는 비교나 연산이 정해진 적은 횟수로 충분하다는 의미 나머지 알고리즘\n힙(heap) 자료구조를 이용해 O(log n)의 시간 복잡도에 각종 캐시 연산을 구현하게 된다. 하지만, 최근 참조 시각을 이용하는 알고리즘에서는 객체의 가치가 시간과 비례하여 다르게 평가되기 때문에, 가치의 대소 관계가 변할 수 있다. 그래서, O(n)의 시간 복잡도가 필요하다. 3. 웹캐시의 일관성 유지 기법 cache에 보관된 웹 객체는 근원지 서버에서 변경될 수 있으므로 일관성 유지를 위한 기법으로, 특히 웹캐시의 일관성은 컴퓨터 시스템에서의 캐시와 달리 큰 문제를 야기하지 않으므로, 적응적 TTL(adaptive Time-To-Live) 기법과 같은 약한 일관성 유지 기법을 사용한다.\n약한 일관성 유지 기법\n사용자의 요청이 있을 때마다 서버에서 일일이 확인하는 게 아닌, 변경될 가능성이 높은 경우에만 확인하는 기법 예) adaptive TTL 강한 일관성 유지 기법\n최신 정보가 사용자에게 전달되는 것을 보장하는 기법 예) polling-every-time, invalidation 웹서버와 네트워크의 부담이 커서 득보다 실이 많아 일반적으로 약한 일관성 유지 기법을 사용한다.\n4. 웹캐시의 공유 및 협력 기법 웹캐싱 효과를 극대화 하기 위해 웹캐시 간의 공유 및 협력 기법이 필요하다.\n4.1 ICP (Internet Cache Protocal, 인터넷 캐시 프로토콜) 동료 proxy cache 사이에서 웹 객체의 검색 및 전송을 지원하기 위한 protocol\n사용자가 프락시서버에 웹 객체를 요구했는데, 프락시서버가 그 객체를 캐싱하고 있지 않은 경우, ICP에서 모든 동료 프락시들에게 ICP 질의를 멀티캐스트(multicast)해서 누가 요청된 웹 객체를 가지고 있는지 확인한다.\n웹 객체를 가지고 있는 동료 프락시가 답신을 보낸다.\n프락시 서버(Proxy server) : 클라이언트와 서버 사이에서 data를 중계하는 역할을 하는 서버 ICP 질의를 보냈던 프락시는 답신을 준 프락시에 HTTP 요청을 보내서 해당 객체를 받아온 후 사용자에게 전달한다.\nHTTP와 ICP의 차이\nHTTP는 웹 객체의 전송을 위한 프로토콜인 반면, ICP는 공유 웹캐시들 간의 객체 위치를 확인하기 위한 프로토콜 HTTP에 비해 매우 부담이 적은 프로토콜 4.2 CARP (Cache Array Routing Protocol, 캐시 배열 간 경로지정 프로토콜) 공유 웹캐시들에 동일한 웹 객체들이 중복 저장되는 것을 막기 위해 URL 공간을 분할해, 각각의 캐시는 자신에게 배정되는 객체들만을 캐싱는 기법\n5. 웹캐시의 사전인출 기법 웹 서비스의 응답 지연시간을 줄이기 위해, 사용자에 의해 아직 요청되지 않은 객체를 미리 받아오는 기법으로 2가지로 나눠진다.\n5.1 예측 사전인출 기법(predictive prefetching) 웹페이지들 간의 관계 그래프 등을 구성해 하나의 웹 페이지가 참조되었을 때, 과거 참조 기록을 통해 새로운 웹페이지가 참조될 된 것을 기반으로 사전인출을 수행하는 방법 5.2 대화식 사전인출 기법(interactive prefetching) 사용자가 HTML 문서를 요청했을 때, 웹캐시는 캐싱하고 있던 HTML 문서를 미리 파싱(parsing)한다. 그래서 그 문서에 포함되거나 연결된 웹 객체를 미리 받아와서 사용자의 후속 요청에 곧바로 전달하는 기법 6. 동적 웹 객체의 캐싱 기법 6.1 정적 웹 페이지와 동적 웹 페이지의 차이 정적 웹 페이지\n실시간으로 변하지 않고 서버에 저장되어 있는 HTML+CSS file 그대로 보여주는 방식 동적 웹 페이지\n상황에 따라 서버에 저장되어 있는 HTML에 데이터 추가/가공하여 보여주는 방법으로, 실시간성 을 요구하는 콘텐츠를 처리하는 웹 페이지를 말한다. 6.2 동적 웹 객체의 캐싱 기법 동적 웹 페이지의 콘텐츠는 실시간성이 있어서, 결과물이 이전과 정확히 일치하지 않지만, 상당 부분 유사하다.\n그래서 부분적으로 캐싱하여 추후 그 결과를 활용할 수 있다.\nReference kocw 이화여자대학교 운영체제 - 반효경 교수 - 운영체제와 정보기술의 원리 - 반효경 지음 - ","wordCount":"1208","inLanguage":"en","datePublished":"2022-05-31T20:20:17+09:00","dateModified":"2022-05-31T20:20:17+09:00","mainEntityOfPage":{"@type":"WebPage","@id":"http://jeha00.github.io/post/os/os_chapter_13_%EC%9B%B9%EC%BA%90%EC%8B%B1/"},"publisher":{"@type":"Organization","name":"Jeha DevLog","logo":{"@type":"ImageObject","url":"http://jeha00.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=http://jeha00.github.io/ accesskey=h title="@Jeha00 (Alt + H)">@Jeha00</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></span></div><ul id=menu><li><a href=http://jeha00.github.io/me/ title=About><span>About</span></a></li><li><a href=http://jeha00.github.io/archives/ title=Archive><span>Archive</span></a></li><li><a href=http://jeha00.github.io/categories/ title=Categories><span>Categories</span></a></li><li><a href=http://jeha00.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=http://jeha00.github.io/>Home</a>&nbsp;»&nbsp;<a href=http://jeha00.github.io/post/>Posts</a></div><h1 class=post-title>[TIL] Chapter 13: 웹캐싱 기법</h1><div class=post-meta>OS&nbsp;·&nbsp;<span title='2022-05-31 20:20:17 +0900 KST'>May 31, 2022</span></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#0-introduction aria-label="0. Introduction">0. Introduction</a></li><li><a href=#1-%eb%8b%a4%ec%96%91%ed%95%9c-caching-%ed%99%98%ea%b2%bd aria-label="1. 다양한 caching 환경">1. 다양한 caching 환경</a><ul><li><a href=#11-caching-%ea%b8%b0%eb%b2%95 aria-label="1.1 caching 기법">1.1 caching 기법</a></li><li><a href=#12-%ec%9b%b9%ec%ba%90%ec%8b%b1%ec%9d%b4%eb%9e%80 aria-label="1.2 웹캐싱이란?">1.2 웹캐싱이란?</a></li></ul></li><li><a href=#2-%ec%9b%b9%ec%ba%90%ec%8b%9c%ec%9d%98-%ea%b5%90%ec%b2%b4-%ec%95%8c%ea%b3%a0%eb%a6%ac%ec%a6%98cache-replacement-algorithum aria-label="2. 웹캐시의 교체 알고리즘(Cache replacement algorithum)">2. 웹캐시의 교체 알고리즘(Cache replacement algorithum)</a><ul><li><a href=#21-%ea%b5%90%ec%b2%b4-%ec%95%8c%ea%b3%a0%eb%a6%ac%ec%a6%98%ec%9d%98-%ec%84%b1%eb%8a%a5-%ec%b2%99%eb%8f%84 aria-label="2.1 교체 알고리즘의 성능 척도">2.1 교체 알고리즘의 성능 척도</a></li><li><a href=#22-%ec%b0%b8%ec%a1%b0-%ea%b0%80%eb%8a%a5%ec%84%b1%ec%9d%98-%ec%98%88%ec%b8%a1 aria-label="2.2 참조 가능성의 예측">2.2 참조 가능성의 예측</a><ul><li><a href=#221-%ec%a0%84%ed%86%b5%ec%a0%81%ec%9d%b8-%ea%b5%90%ec%b2%b4-%ec%95%8c%ea%b3%a0%eb%a6%ac%ec%a6%98 aria-label="2.2.1 전통적인 교체 알고리즘">2.2.1 전통적인 교체 알고리즘</a></li><li><a href=#222-%ec%9b%b9%ec%ba%90%ec%8b%9c%ec%9d%98-%ea%b5%90%ec%b2%b4-%ec%95%8c%ea%b3%a0%eb%a6%ac%ec%a6%98 aria-label="2.2.2 웹캐시의 교체 알고리즘">2.2.2 웹캐시의 교체 알고리즘</a></li></ul></li><li><a href=#23-%ea%b0%9d%ec%b2%b4%ec%9d%98-%ec%9d%b4%ec%a7%88%ec%84%b1%ec%97%90-%eb%8c%80%ed%95%9c-%ea%b3%a0%eb%a0%a4 aria-label="2.3 객체의 이질성에 대한 고려">2.3 객체의 이질성에 대한 고려</a></li><li><a href=#24-%ec%95%8c%ea%b3%a0%eb%a6%ac%ec%a6%98%ec%9d%98-%ec%8b%9c%ea%b0%84-%eb%b3%b5%ec%9e%a1%eb%8f%84 aria-label="2.4 알고리즘의 시간 복잡도">2.4 알고리즘의 시간 복잡도</a></li></ul></li><li><a href=#3-%ec%9b%b9%ec%ba%90%ec%8b%9c%ec%9d%98-%ec%9d%bc%ea%b4%80%ec%84%b1-%ec%9c%a0%ec%a7%80-%ea%b8%b0%eb%b2%95 aria-label="3. 웹캐시의 일관성 유지 기법">3. 웹캐시의 일관성 유지 기법</a></li><li><a href=#4-%ec%9b%b9%ec%ba%90%ec%8b%9c%ec%9d%98-%ea%b3%b5%ec%9c%a0-%eb%b0%8f-%ed%98%91%eb%a0%a5-%ea%b8%b0%eb%b2%95 aria-label="4. 웹캐시의 공유 및 협력 기법">4. 웹캐시의 공유 및 협력 기법</a><ul><li><a href=#41-icp-internet-cache-protocal-%ec%9d%b8%ed%84%b0%eb%84%b7-%ec%ba%90%ec%8b%9c-%ed%94%84%eb%a1%9c%ed%86%a0%ec%bd%9c aria-label="4.1 ICP (Internet Cache Protocal, 인터넷 캐시 프로토콜)">4.1 ICP (Internet Cache Protocal, 인터넷 캐시 프로토콜)</a></li><li><a href=#42-carp-cache-array-routing-protocol-%ec%ba%90%ec%8b%9c-%eb%b0%b0%ec%97%b4-%ea%b0%84-%ea%b2%bd%eb%a1%9c%ec%a7%80%ec%a0%95-%ed%94%84%eb%a1%9c%ed%86%a0%ec%bd%9c aria-label="4.2 CARP (Cache Array Routing Protocol, 캐시 배열 간 경로지정 프로토콜)">4.2 CARP (Cache Array Routing Protocol, 캐시 배열 간 경로지정 프로토콜)</a></li></ul></li><li><a href=#5-%ec%9b%b9%ec%ba%90%ec%8b%9c%ec%9d%98-%ec%82%ac%ec%a0%84%ec%9d%b8%ec%b6%9c-%ea%b8%b0%eb%b2%95 aria-label="5. 웹캐시의 사전인출 기법">5. 웹캐시의 사전인출 기법</a><ul><li><a href=#51-%ec%98%88%ec%b8%a1-%ec%82%ac%ec%a0%84%ec%9d%b8%ec%b6%9c-%ea%b8%b0%eb%b2%95predictive-prefetching aria-label="5.1 예측 사전인출 기법(predictive prefetching)">5.1 예측 사전인출 기법(predictive prefetching)</a></li><li><a href=#52-%eb%8c%80%ed%99%94%ec%8b%9d-%ec%82%ac%ec%a0%84%ec%9d%b8%ec%b6%9c-%ea%b8%b0%eb%b2%95interactive-prefetching aria-label="5.2 대화식 사전인출 기법(interactive prefetching)">5.2 대화식 사전인출 기법(interactive prefetching)</a></li></ul></li><li><a href=#6-%eb%8f%99%ec%a0%81-%ec%9b%b9-%ea%b0%9d%ec%b2%b4%ec%9d%98-%ec%ba%90%ec%8b%b1-%ea%b8%b0%eb%b2%95 aria-label="6. 동적 웹 객체의 캐싱 기법">6. 동적 웹 객체의 캐싱 기법</a><ul><li><a href=#61-%ec%a0%95%ec%a0%81-%ec%9b%b9-%ed%8e%98%ec%9d%b4%ec%a7%80%ec%99%80-%eb%8f%99%ec%a0%81-%ec%9b%b9-%ed%8e%98%ec%9d%b4%ec%a7%80%ec%9d%98-%ec%b0%a8%ec%9d%b4 aria-label="6.1 정적 웹 페이지와 동적 웹 페이지의 차이">6.1 정적 웹 페이지와 동적 웹 페이지의 차이</a></li><li><a href=#62-%eb%8f%99%ec%a0%81-%ec%9b%b9-%ea%b0%9d%ec%b2%b4%ec%9d%98-%ec%ba%90%ec%8b%b1-%ea%b8%b0%eb%b2%95 aria-label="6.2 동적 웹 객체의 캐싱 기법">6.2 동적 웹 객체의 캐싱 기법</a></li></ul></li><li><a href=#reference aria-label=Reference>Reference</a></li></ul></div></details></div><div class=post-content><h1 id=0-introduction>0. Introduction<a hidden class=anchor aria-hidden=true href=#0-introduction>#</a></h1><p> </p><ul><li>해당 내용은 <a href="http://www.kyobobook.co.kr/product/detailViewKor.laf?ejkGb=KOR&mallGb=KOR&barcode=9791158903589&orderClick=LAG&Kc=">운영체제와 정보기술의 원리 -반효경 지음-</a> 와 <a href="http://www.kocw.net/home/cview.do?lid=3dd1117c48123b8e">kocw 이화여자대학교 운영체제 - 반효경 교수 -</a>를 보고 정리한 내용이다.</li><li>정확하지 않은 내용이 있다면 말씀해주시면 감사하겠습니다.</li></ul><p> </p><hr><h1 id=1-다양한-caching-환경>1. 다양한 caching 환경<a hidden class=anchor aria-hidden=true href=#1-다양한-caching-환경>#</a></h1><p> </p><h2 id=11-caching-기법>1.1 caching 기법<a hidden class=anchor aria-hidden=true href=#11-caching-기법>#</a></h2><blockquote><p><strong><em>한정된 빠른 공간(= 캐쉬)에 요청된 데이터를 저장해 두었다가 후속 요청시 캐쉬로부터 직접 서비스하는 방식</em></strong></p></blockquote><ul><li><p>저장장치 계층 간의 속도 차이를 완충시켜주기 위해 컴퓨터 구조, 운영체제, DB 등의 분야에서 각각 다음과 같은 기법 등으로 사용되고 있다.</p></li><li><p>paging system 외에도 cache memory, buffer caching, Web caching 등 다양한 분야에서 사용된다.</p><ul><li>cache memory: CPU와 main memory 사이에 cache memory가 있다. 이 cache memory에 없는 file을 main memory에 요청한다.</li><li>buffer caching: file system에 대한 read/write 요청을 memory에서 빠르게 서비스하는 방식</li><li>Web caching: web page를 server에서 가져오는데 동일한 url을 요청할 때를 대비해서 신속히 서비스를 제공하기 위해서, caching 기법으로 제공하는 방법</li></ul></li><li><p><strong>cache 운영의 시간 제약</strong></p><ul><li><p>교체 알고리즘에서 삭제할 항목을 결정하는 일에 지나치게 많은 시간이 걸리는 경우, 실제 시스템에서 사용할 수 없다.</p></li><li><p>Buffer caching이나 Web caching의 경우</p><ul><li>O(1)에서 O(log n) 정도까지 허용</li></ul></li><li><p>Paging system인 경우</p><ul><li>page fault인 경우에만 OS가 관여한다.</li><li>페이지가 이미 메모리에 존재하는 경우, 참조시각 등의 정보를 OS가 알 수 없다.</li><li>O(1)인 LRU의 list 조작 조차 불가능</li></ul></li></ul></li></ul><p> </p><h2 id=12-웹캐싱이란>1.2 웹캐싱이란?<a hidden class=anchor aria-hidden=true href=#12-웹캐싱이란>#</a></h2><blockquote><p><strong><em>웹 사용자에 의해 빈번히 요청되는 데이터를 사용자와 지리적으로 가까운 웹캐시 서버에 보관해, 빠른 서비스를 제공하여 서비스 지연시간을 줄이고 웹서버 부하도 줄이는 기법</em></strong></p></blockquote><p> </p><hr><h1 id=2-웹캐시의-교체-알고리즘cache-replacement-algorithum>2. 웹캐시의 교체 알고리즘(Cache replacement algorithum)<a hidden class=anchor aria-hidden=true href=#2-웹캐시의-교체-알고리즘cache-replacement-algorithum>#</a></h1><blockquote><p><strong><em>한정된 캐시 공간 안에서 사용자들의 지속적인 요청을 처리하기 위해서, 미래에 참조될 가능성이 높은 객체를 선별한 후, 한정된 캐시 공간 안에 보관할 객체를 온라인으로 결정하는 알고리즘</em></strong></p></blockquote><ul><li><p>웹캐시는 객체를 가지고 있는 근원지 서버의 위치 및 특성에 따라 객체를 캐시로 읽어오는 비용이 다르다.</p></li><li><p>하나의 URL에 대응되는 파일 단위로 캐싱이 이뤄져서 캐싱 단위의 크기가 균일하지 않다.</p></li></ul><p> </p><h2 id=21-교체-알고리즘의-성능-척도>2.1 교체 알고리즘의 성능 척도<a hidden class=anchor aria-hidden=true href=#21-교체-알고리즘의-성능-척도>#</a></h2><blockquote><p><strong><em>캐시 교체 알고리즘의 목표는 참조 가능성이 높은 객체를 캐시에 보관해 &lsquo;캐시적중률(Hit rate)&lsquo;을 높이는 것</em></strong></p></blockquote><ul><li><p><strong>캐시 적중률</strong></p><ul><li>사용자의 총 요청 중 캐시에서 적중되어 서비스된 요청의 비율</li></ul></li><li><p>하지만, <strong><em>웹캐싱에서는 객체들의 크기와 인출 비용이 균일하지 않기 때문에</em></strong> , 객체들의 참조 가능성과 이질성을 함께 고려해야 한다.</p></li><li><p>이런 경우, <strong>비용절감률(Cost-Savings Ratio: CSR)</strong> 로 정형화시킨다.</p><ul><li>객체 크기와 인출 비용이 모두 균일하면 비용절감률은 캐시 적중률과 동일한 의미를 가진다.</li></ul></li></ul><p> </p><h2 id=22-참조-가능성의-예측>2.2 참조 가능성의 예측<a hidden class=anchor aria-hidden=true href=#22-참조-가능성의-예측>#</a></h2><ul><li><p>캐시 교체 알고리즘은 전통적인 캐싱 기법인 LRU(Least Recently Used), LFU(Least Frequently Used) 등의 알고리즘처럼 최근 참조 성향과 참조 빈도에 근거해 미래의 참조 성향을 예측하는 방법을 사용한다.</p></li><li><p>그러면 전통적인 교체 알고리즘들의 구체적인 예를 살펴보고, 웹캐시의 교체 알고리즘은 이들 중 어떤 방법을 채택하는지 알아보자.</p></li></ul><p> </p><h3 id=221-전통적인-교체-알고리즘>2.2.1 전통적인 교체 알고리즘<a hidden class=anchor aria-hidden=true href=#221-전통적인-교체-알고리즘>#</a></h3><p><img loading=lazy src=https://user-images.githubusercontent.com/78094972/171148493-ea14c77c-d56a-4d5e-b52f-28b24882b4d9.jpg alt=image></p><ul><li><p>과거 참조 기록을 바탕으로 객체 A와 B를 평가한다고 하자.</p></li><li><p>LRU는 최근 참조 성향만을 고려한다.</p><ul><li>(a) 객체 B가 더 최근(t1)에 참조되었기 때문에, (a) B에 더 높은 가치를 부여한다. 하지만, 이 방법은 자주 참조되는 객체와 그렇지 않은 객체를 구분할 수 없다는 단점이 있다. (b)에서는 A의 가치가 더 높게 평가된다는 사실은 LRU의 문제점을 보여준다.</li></ul></li><li><p>LFU는 참조 횟수만을 고려한다.</p><ul><li>(a) A의 참조 횟수가 (a) B보다 더 많기 때문에, (a) A에 더 높은 가치를 부여한다. 이 알고리즘의 문제점은 오래 전에 많이 참조된 객체에 높은 가치를 부여해, 새로 참조되기 시작한 객체를 캐시에서 쫓아낼 우려가 있다. 오히려 (c)에서 B의 가치가 더 높게 평가된다는 사실이 LFU의 문제점을 보여준다.</li></ul></li><li><p>최근 참조 성향과 참조 횟수에 근거해 객체의 참조 가능성을 평가하는 방법은 최근에 참조된 객체가 다시 참조될 가능성이 높다는 점 ( <strong><em>시간지역성, temporal locality</em></strong> )과, 참조 횟수가 많은 객체일수록 다시 참조될 가능성이 높다는 점 ( <strong><em>인기도, popularity</em></strong> ), 이 두 가지 사실을 기본으로 가정한다.</p></li><li><p>위에 두 가지가 컴퓨터 프로그램의 참조 성향을 모델링하는데 널리 사용되는 요소다.</p></li></ul><p> </p><h3 id=222-웹캐시의-교체-알고리즘>2.2.2 웹캐시의 교체 알고리즘<a hidden class=anchor aria-hidden=true href=#222-웹캐시의-교체-알고리즘>#</a></h3><ul><li><p><strong>시간지역성 측면</strong> -> 웹 캐시 알고리즘들은 객체의 직전 참조 시각을 활용</p></li><li><p><strong>참조 인기도 측면</strong> -> 객체 참조 횟수에 노화 기법을 추가하여, 캐시 오염(cache pollution)을 방지한다.</p><ul><li>노화 기법: 오래전에 이루어진 참조에 대해 참조 횟수 계산할 때, 가중치를 줄이는 방법</li></ul></li></ul><p> </p><h2 id=23-객체의-이질성에-대한-고려>2.3 객체의 이질성에 대한 고려<a hidden class=anchor aria-hidden=true href=#23-객체의-이질성에-대한-고려>#</a></h2><blockquote><p><strong><em>웹캐싱 같이 캐싱의 단위 객체들의 크기와 인출 비용이 균일하지 않은 환경에서는 이 특성을 고려한 합리적인 가치 평가를 해야 한다.</em></strong></p></blockquote><ul><li><p>이 합리적인 평가를 하기 위해서는 <strong><em>객체의 참조 가능성</em></strong> 과 <strong><em>캐시 적중률</em></strong> 로 실제 절약할 수 있는 비용을 동시에 고려해야 한다.</p></li><li><p>캐시 적중률의 경우, 크기가 작은 객체에 높은 가치를 부여한다. 왜냐하면, 한정된 캐시 공간에 많은 객체를 보관하면 캐시 적중률이 높아지기 때문이다.</p></li></ul><p> </p><h2 id=24-알고리즘의-시간-복잡도>2.4 알고리즘의 시간 복잡도<a hidden class=anchor aria-hidden=true href=#24-알고리즘의-시간-복잡도>#</a></h2><blockquote><p><strong><em>캐시 교체 알고리즘이 실제 시스템에 유효하게 사용되기 위해서는 시간 복잡도 측면에서 현실성이 있어야 한다.</em></strong></p></blockquote><ul><li><p>시간 복잡도 O(n): cache 내에 있는 객체의 수가 n개라고 할 때, 어떤 객체를 캐시에서 삭제할지 결정하기 위해 n에 비례하는 비교나 연산이 필요하다는 의미</p></li><li><p>proxy cache의 경우, 통상적으로 cache 내에 수백만 개의 객체가 존재하기 때문에 이들을 다 조사하는 시간 복잡도의 방법은 부담이 크기 때문에, 웹 환경에서는 이 알고리즘으로 사용하기 어렵다.</p></li><li><p>LRU</p><ul><li>가장 최근에 참조된 시각을 기준으로 객체들의 가치를 일렬로 세워놓고 새롭게 참조된 객체만 가치가 가장 높은 위치로 옮기면 되므로, O(1)의 시간 복잡도 구현이 가능하다.</li><li>O(1): 캐시 내에 존재하는 객체의 수 n이 커지더라도, 이에 관계없이 캐시에서 이루어지는 비교나 연산이 정해진 적은 횟수로 충분하다는 의미</li></ul></li><li><p>나머지 알고리즘</p><ul><li>힙(heap) 자료구조를 이용해 O(log n)의 시간 복잡도에 각종 캐시 연산을 구현하게 된다. 하지만, 최근 참조 시각을 이용하는 알고리즘에서는 객체의 가치가 시간과 비례하여 다르게 평가되기 때문에, 가치의 대소 관계가 변할 수 있다. 그래서, O(n)의 시간 복잡도가 필요하다.</li></ul></li></ul><p> </p><hr><h1 id=3-웹캐시의-일관성-유지-기법>3. 웹캐시의 일관성 유지 기법<a hidden class=anchor aria-hidden=true href=#3-웹캐시의-일관성-유지-기법>#</a></h1><blockquote><p><strong><em>cache에 보관된 웹 객체는 근원지 서버에서 변경될 수 있으므로 일관성 유지를 위한 기법으로, 특히 웹캐시의 일관성은 컴퓨터 시스템에서의 캐시와 달리 큰 문제를 야기하지 않으므로, 적응적 TTL(adaptive Time-To-Live) 기법과 같은 약한 일관성 유지 기법을 사용한다.</em></strong></p></blockquote><ul><li><p><strong>약한 일관성 유지 기법</strong></p><ul><li>사용자의 요청이 있을 때마다 서버에서 일일이 확인하는 게 아닌, 변경될 가능성이 높은 경우에만 확인하는 기법<ul><li>예) adaptive TTL</li></ul></li></ul></li><li><p><strong>강한 일관성 유지 기법</strong></p><ul><li>최신 정보가 사용자에게 전달되는 것을 보장하는 기법<ul><li>예) polling-every-time, invalidation</li></ul></li></ul></li><li><p>웹서버와 네트워크의 부담이 커서 득보다 실이 많아 일반적으로 약한 일관성 유지 기법을 사용한다.</p></li></ul><p> </p><hr><h1 id=4-웹캐시의-공유-및-협력-기법>4. 웹캐시의 공유 및 협력 기법<a hidden class=anchor aria-hidden=true href=#4-웹캐시의-공유-및-협력-기법>#</a></h1><blockquote><p><strong><em>웹캐싱 효과를 극대화 하기 위해 웹캐시 간의 공유 및 협력 기법이 필요하다.</em></strong></p></blockquote><p> </p><h2 id=41-icp-internet-cache-protocal-인터넷-캐시-프로토콜>4.1 ICP (Internet Cache Protocal, 인터넷 캐시 프로토콜)<a hidden class=anchor aria-hidden=true href=#41-icp-internet-cache-protocal-인터넷-캐시-프로토콜>#</a></h2><blockquote><p><strong><em>동료 proxy cache 사이에서 웹 객체의 검색 및 전송을 지원하기 위한 protocol</em></strong></p></blockquote><ul><li><p>사용자가 프락시서버에 웹 객체를 요구했는데, 프락시서버가 그 객체를 캐싱하고 있지 않은 경우, ICP에서 모든 동료 프락시들에게 ICP 질의를 멀티캐스트(multicast)해서 누가 요청된 웹 객체를 가지고 있는지 확인한다.</p></li><li><p>웹 객체를 가지고 있는 동료 프락시가 답신을 보낸다.</p><ul><li><strong>프락시 서버(Proxy server)</strong> : 클라이언트와 서버 사이에서 data를 중계하는 역할을 하는 서버</li></ul></li><li><p>ICP 질의를 보냈던 프락시는 답신을 준 프락시에 HTTP 요청을 보내서 해당 객체를 받아온 후 사용자에게 전달한다.</p></li><li><p><strong>HTTP와 ICP의 차이</strong></p><ul><li>HTTP는 웹 객체의 전송을 위한 프로토콜인 반면, ICP는 공유 웹캐시들 간의 객체 위치를 확인하기 위한 프로토콜</li><li>HTTP에 비해 매우 부담이 적은 프로토콜</li></ul></li></ul><p> </p><h2 id=42-carp-cache-array-routing-protocol-캐시-배열-간-경로지정-프로토콜>4.2 CARP (Cache Array Routing Protocol, 캐시 배열 간 경로지정 프로토콜)<a hidden class=anchor aria-hidden=true href=#42-carp-cache-array-routing-protocol-캐시-배열-간-경로지정-프로토콜>#</a></h2><blockquote><p><strong><em>공유 웹캐시들에 동일한 웹 객체들이 중복 저장되는 것을 막기 위해 URL 공간을 분할해, 각각의 캐시는 자신에게 배정되는 객체들만을 캐싱는 기법</em></strong></p></blockquote><p> </p><hr><h1 id=5-웹캐시의-사전인출-기법>5. 웹캐시의 사전인출 기법<a hidden class=anchor aria-hidden=true href=#5-웹캐시의-사전인출-기법>#</a></h1><blockquote><p><strong><em>웹 서비스의 응답 지연시간을 줄이기 위해, 사용자에 의해 아직 요청되지 않은 객체를 미리 받아오는 기법으로 2가지로 나눠진다.</em></strong></p></blockquote><p> </p><h2 id=51-예측-사전인출-기법predictive-prefetching>5.1 예측 사전인출 기법(predictive prefetching)<a hidden class=anchor aria-hidden=true href=#51-예측-사전인출-기법predictive-prefetching>#</a></h2><ul><li>웹페이지들 간의 관계 그래프 등을 구성해 하나의 웹 페이지가 참조되었을 때, 과거 참조 기록을 통해 새로운 웹페이지가 참조될 된 것을 기반으로 사전인출을 수행하는 방법</li></ul><p> </p><h2 id=52-대화식-사전인출-기법interactive-prefetching>5.2 대화식 사전인출 기법(interactive prefetching)<a hidden class=anchor aria-hidden=true href=#52-대화식-사전인출-기법interactive-prefetching>#</a></h2><ul><li>사용자가 HTML 문서를 요청했을 때, 웹캐시는 캐싱하고 있던 HTML 문서를 미리 파싱(parsing)한다. 그래서 그 문서에 포함되거나 연결된 웹 객체를 미리 받아와서 사용자의 후속 요청에 곧바로 전달하는 기법</li></ul><p> </p><hr><h1 id=6-동적-웹-객체의-캐싱-기법>6. 동적 웹 객체의 캐싱 기법<a hidden class=anchor aria-hidden=true href=#6-동적-웹-객체의-캐싱-기법>#</a></h1><p> </p><h2 id=61-정적-웹-페이지와-동적-웹-페이지의-차이>6.1 정적 웹 페이지와 동적 웹 페이지의 차이<a hidden class=anchor aria-hidden=true href=#61-정적-웹-페이지와-동적-웹-페이지의-차이>#</a></h2><ul><li><p><strong>정적 웹 페이지</strong></p><ul><li>실시간으로 변하지 않고 서버에 저장되어 있는 HTML+CSS file 그대로 보여주는 방식</li></ul></li><li><p><strong>동적 웹 페이지</strong></p><ul><li>상황에 따라 서버에 저장되어 있는 HTML에 데이터 추가/가공하여 보여주는 방법으로, <strong><em>실시간성</em></strong> 을 요구하는 콘텐츠를 처리하는 웹 페이지를 말한다.</li></ul></li></ul><p> </p><h2 id=62-동적-웹-객체의-캐싱-기법>6.2 동적 웹 객체의 캐싱 기법<a hidden class=anchor aria-hidden=true href=#62-동적-웹-객체의-캐싱-기법>#</a></h2><ul><li><p>동적 웹 페이지의 콘텐츠는 실시간성이 있어서, 결과물이 이전과 정확히 일치하지 않지만, 상당 부분 유사하다.</p></li><li><p>그래서 부분적으로 캐싱하여 추후 그 결과를 활용할 수 있다.</p></li></ul><p> </p><hr><h1 id=reference>Reference<a hidden class=anchor aria-hidden=true href=#reference>#</a></h1><ul><li><a href="http://www.kocw.net/home/cview.do?lid=3dd1117c48123b8e">kocw 이화여자대학교 운영체제 - 반효경 교수 -</a></li><li><a href="http://www.kyobobook.co.kr/product/detailViewKor.laf?ejkGb=KOR&mallGb=KOR&barcode=9791158903589&orderClick=LAG&Kc=">운영체제와 정보기술의 원리 - 반효경 지음 -</a></li></ul></div><footer class=post-footer><ul class=post-tags><li><a href=http://jeha00.github.io/tags/til/>TIL</a></li><li><a href=http://jeha00.github.io/tags/os/>OS</a></li></ul><nav class=paginav><a class=prev href=http://jeha00.github.io/post/git/0_whatisgit/><span class=title>« Prev Page</span><br><span>[Pro git 2/E study] What is Git ?</span></a>
<a class=next href=http://jeha00.github.io/post/os/os_chapter_12_%ED%8C%8C%EC%9D%BC%EC%8B%9C%EC%8A%A4%ED%85%9C_2/><span class=title>Next Page »</span><br><span>[TIL] Chapter 12: 파일 시스템 2</span></a></nav><div class=share-buttons><a target=_blank rel="noopener noreferrer" aria-label="share [TIL] Chapter 13: 웹캐싱 기법 on twitter" href="https://twitter.com/intent/tweet/?text=%5bTIL%5d%20Chapter%2013%3a%20%ec%9b%b9%ec%ba%90%ec%8b%b1%20%ea%b8%b0%eb%b2%95&url=http%3a%2f%2fjeha00.github.io%2fpost%2fos%2fos_chapter_13_%25EC%259B%25B9%25EC%25BA%2590%25EC%258B%25B1%2f&hashtags=TIL%2cOS"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM195.519 424.544c135.939.0 210.268-112.643 210.268-210.268.0-3.218.0-6.437-.153-9.502 14.406-10.421 26.973-23.448 36.935-38.314-13.18 5.824-27.433 9.809-42.452 11.648 15.326-9.196 26.973-23.602 32.49-40.92-14.252 8.429-30.038 14.56-46.896 17.931-13.487-14.406-32.644-23.295-53.946-23.295-40.767.0-73.87 33.104-73.87 73.87.0 5.824.613 11.494 1.992 16.858-61.456-3.065-115.862-32.49-152.337-77.241-6.284 10.881-9.962 23.601-9.962 37.088.0 25.594 13.027 48.276 32.95 61.456-12.107-.307-23.448-3.678-33.41-9.196v.92c0 35.862 25.441 65.594 59.311 72.49-6.13 1.686-12.72 2.606-19.464 2.606-4.751.0-9.348-.46-13.946-1.38 9.349 29.426 36.628 50.728 68.965 51.341-25.287 19.771-57.164 31.571-91.8 31.571-5.977.0-11.801-.306-17.625-1.073 32.337 21.15 71.264 33.41 112.95 33.41z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share [TIL] Chapter 13: 웹캐싱 기법 on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&url=http%3a%2f%2fjeha00.github.io%2fpost%2fos%2fos_chapter_13_%25EC%259B%25B9%25EC%25BA%2590%25EC%258B%25B1%2f&title=%5bTIL%5d%20Chapter%2013%3a%20%ec%9b%b9%ec%ba%90%ec%8b%b1%20%ea%b8%b0%eb%b2%95&summary=%5bTIL%5d%20Chapter%2013%3a%20%ec%9b%b9%ec%ba%90%ec%8b%b1%20%ea%b8%b0%eb%b2%95&source=http%3a%2f%2fjeha00.github.io%2fpost%2fos%2fos_chapter_13_%25EC%259B%25B9%25EC%25BA%2590%25EC%258B%25B1%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share [TIL] Chapter 13: 웹캐싱 기법 on reddit" href="https://reddit.com/submit?url=http%3a%2f%2fjeha00.github.io%2fpost%2fos%2fos_chapter_13_%25EC%259B%25B9%25EC%25BA%2590%25EC%258B%25B1%2f&title=%5bTIL%5d%20Chapter%2013%3a%20%ec%9b%b9%ec%ba%90%ec%8b%b1%20%ea%b8%b0%eb%b2%95"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share [TIL] Chapter 13: 웹캐싱 기법 on facebook" href="https://facebook.com/sharer/sharer.php?u=http%3a%2f%2fjeha00.github.io%2fpost%2fos%2fos_chapter_13_%25EC%259B%25B9%25EC%25BA%2590%25EC%258B%25B1%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share [TIL] Chapter 13: 웹캐싱 기법 on whatsapp" href="https://api.whatsapp.com/send?text=%5bTIL%5d%20Chapter%2013%3a%20%ec%9b%b9%ec%ba%90%ec%8b%b1%20%ea%b8%b0%eb%b2%95%20-%20http%3a%2f%2fjeha00.github.io%2fpost%2fos%2fos_chapter_13_%25EC%259B%25B9%25EC%25BA%2590%25EC%258B%25B1%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share [TIL] Chapter 13: 웹캐싱 기법 on telegram" href="https://telegram.me/share/url?text=%5bTIL%5d%20Chapter%2013%3a%20%ec%9b%b9%ec%ba%90%ec%8b%b1%20%ea%b8%b0%eb%b2%95&url=http%3a%2f%2fjeha00.github.io%2fpost%2fos%2fos_chapter_13_%25EC%259B%25B9%25EC%25BA%2590%25EC%258B%25B1%2f"><svg viewBox="2 2 28 28"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></div></footer></article></main><footer class=footer><span>&copy; 2024 <a href=http://jeha00.github.io/>Jeha DevLog</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerText="copy";function s(){t.innerText="copied!",setTimeout(()=>{t.innerText="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>