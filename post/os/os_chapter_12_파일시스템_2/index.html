<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>[TIL] Chapter 12: 파일 시스템 2 | Jeha DevLog</title><meta name=keywords content="TIL,OS"><meta name=description content="Disk의 할당방식 3가지, FAT file system이란 무엇인지, disk의 빈 공간을 어떻게 관리하는지, page cache와 buffer cache와의 차이점과 마지막으로 통합 buffer cache에서의 Memory mapped 방식에 대해 알아본다."><meta name=author content><link rel=canonical href=http://jeha00.github.io/post/os/os_chapter_12_%ED%8C%8C%EC%9D%BC%EC%8B%9C%EC%8A%A4%ED%85%9C_2/><meta name=google-site-verification content="XYZabc"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.min.268b216eea772711d318d156ce02a8190962367a0bf469fa9a959114ea6b9ca3.css integrity="sha256-Joshbup3JxHTGNFWzgKoGQliNnoL9Gn6mpWRFOprnKM=" rel="preload stylesheet" as=style><link rel=icon href=http://jeha00.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=http://jeha00.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=http://jeha00.github.io/favicon-32x32.png><link rel=apple-touch-icon href=http://jeha00.github.io/apple-touch-icon.png><link rel=mask-icon href=http://jeha00.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><meta name=generator content="Hugo 0.101.0"><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><script type=application/javascript>var doNotTrack=!1;doNotTrack||(function(e,t,n,s,o,i,a){e.GoogleAnalyticsObject=o,e[o]=e[o]||function(){(e[o].q=e[o].q||[]).push(arguments)},e[o].l=1*new Date,i=t.createElement(n),a=t.getElementsByTagName(n)[0],i.async=1,i.src=s,a.parentNode.insertBefore(i,a)}(window,document,"script","https://www.google-analytics.com/analytics.js","ga"),ga("create","UA-123-45","auto"),ga("send","pageview"))</script><meta property="og:title" content="[TIL] Chapter 12: 파일 시스템 2"><meta property="og:description" content="Disk의 할당방식 3가지, FAT file system이란 무엇인지, disk의 빈 공간을 어떻게 관리하는지, page cache와 buffer cache와의 차이점과 마지막으로 통합 buffer cache에서의 Memory mapped 방식에 대해 알아본다."><meta property="og:type" content="article"><meta property="og:url" content="http://jeha00.github.io/post/os/os_chapter_12_%ED%8C%8C%EC%9D%BC%EC%8B%9C%EC%8A%A4%ED%85%9C_2/"><meta property="og:image" content="http://jeha00.github.io/47"><meta property="article:section" content="post"><meta property="article:published_time" content="2022-05-29T18:16:18+09:00"><meta property="article:modified_time" content="2022-05-29T18:16:18+09:00"><meta property="og:site_name" content="JeHa00 DevLog"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="http://jeha00.github.io/47"><meta name=twitter:title content="[TIL] Chapter 12: 파일 시스템 2"><meta name=twitter:description content="Disk의 할당방식 3가지, FAT file system이란 무엇인지, disk의 빈 공간을 어떻게 관리하는지, page cache와 buffer cache와의 차이점과 마지막으로 통합 buffer cache에서의 Memory mapped 방식에 대해 알아본다."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"http://jeha00.github.io/post/"},{"@type":"ListItem","position":2,"name":"[TIL] Chapter 12: 파일 시스템 2","item":"http://jeha00.github.io/post/os/os_chapter_12_%ED%8C%8C%EC%9D%BC%EC%8B%9C%EC%8A%A4%ED%85%9C_2/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"[TIL] Chapter 12: 파일 시스템 2","name":"[TIL] Chapter 12: 파일 시스템 2","description":"Disk의 할당방식 3가지, FAT file system이란 무엇인지, disk의 빈 공간을 어떻게 관리하는지, page cache와 buffer cache와의 차이점과 마지막으로 통합 buffer cache에서의 Memory mapped 방식에 대해 알아본다.","keywords":["TIL","OS"],"articleBody":"0. Introduction 해당 내용은 운영체제와 정보기술의 원리 -반효경 지음- 와 kocw 이화여자대학교 운영체제 - 반효경 교수 -를 보고 정리한 내용이다. 정확하지 않은 내용이 있다면 말씀해주시면 감사하겠습니다. 6. Allocation of File data in disk disk에 균일하지 않은 크기의 file을 저장할 때는 disk를 균일한 크기로 쪼갠 sector 단위로 저장한다.\ndisk에 file을 저장하는 방식 3가지 (paging 기법과 유사)\nContiguous Allocation (연속 할당) Linked Allocation (연결 할당) Indexed Allocation (인덱스를 이용한 할당) sector와 block의 차이\nsector: disk에서 물리적으로 저장하는 단위 block: file system에서 file이 저장되는 단위 6.1 Contiguous Allocation 하나의 file을 sector들에 Array 구조로 저장하여, 나누어진 각 블록들이 연속된 번호를 부여받아 저장된다.\ndirectory를 설명하자면\n‘count’ file은 0부터 시작해서 총 2개의 sector를 차지한다. ’tr’ file은 14부터 시작해서 총 3개의 sector를 차지한다. 장점\nFast I/O (시간 효율성 증가) file이 모두 연속해서 붙어 있으므로 한 번의 seek / rotation으로 많은 양의 데이터를 받을 수 있다. 대부분의 접근 시간은 header가 움직이면서 읽어들이는 시간이기 때문에, 시간 효율성이 증가한다. Realtime file 용 또는 이미 run 중이던 process의 swapping 용도로 사용된다. Direct access (= random access) 가능 몇 번 sector부터 시작하는지 directory가 알기 때문에 가능하다. 단점\nExternal fragmentation (hole 발생) File grow가 어렵다. file grow를 해도 낭비 발생 (internal fragmentation) file이 커져서 sector를 늘려 저장하려할 때, 다른 file이 옆 sector를 차지하고 있다면 늘릴 수 없다. 그래서 file이 커질 것을 대비하여 미리 할당했을지라도, 할당된 만큼만 커질 수 있다는 단점이 있다. 그리고 미리 할당된거면서 사용하지 않는 조각이기 때문에, 내부 조각이 발생된다. 6.2 Linked Allocation sector들이 각각 node되어 linked list 구조로 파일을 저장한다.\n장점\n외부 단편화가 발생하지 않는다. 단점\n첫 요소부터 차례대로 읽어야하므로, 직접 접근이 불가능하다. 또한, 각 sector로 header가 이동해야하므로, 시간이 더 걸린다. 신뢰성 문제 한 sector가 고장나 pointer가 유실되면 그 이후 모든 sector로 접근할 수 없다. pointer란 block 주소를 의미한다고 생각하자. 포인터를 위한 공간이 필요하므로 공간 효율성을 떨어뜨린다. 512 bytes/sector, 4 bytes/pointer 변형\nFile-Allocation Table (FAT) 파일 시스템 pointer를 별도의 sector에 보관하여 신뢰성 문제와 공간 효율성 문제를 해결한다. 6.3 Indexed Allocation directory에 file의 index block을 표시하여 이 index block을 통해서 직접 접근이 가능한 방식\nindex block이란??\nfile이 어디에 나눠져 있는지 index를 적어 두는 block 하나 장점\nExternal fragmentation(외부 조각 hole) 발생 X 직접 접근 (= 임의 접근)이 가능하다. 단점\n작은 파일의 경우, 공간 낭비가 심하며 실제로 많은 파일들이 사이즈가 작다. index block을 위한 sector와 실제 file 저장을 위한 sector가 필요하기 때문에 공간 낭비가 심하다. 매우 큰 파일의 경우, 하나의 index block으로 커버할 수 없다. 해결 방안: linked scheme, multi-level index 전자는 index block을 여러 개 두는 것이고, 후자는 block의 마지막에 다음 index block을 가리키는 값을 설정하여 서로 연결하는 것이다. 이번 소챕터에서는 이론적으로 disk에 file을 어떻게 할당하는 지를 알아봤으니, 다음 소챕터에서는 실제로 어떠한지 알아보자.\n7. UNIX 파일 시스템의 구조 Partition(= Logical Disk) 은 Boot block, Super block, Inode list, Data block으로 구성된다.\n7.1 Boot block Booting에 필요한 정보를 담고 있는 block\n0번 block이며, bootstrap loader라고도 한다. 모든 file system에 존재하는 블록 7.2 Super block file system에 관한 총체적인 정보를 담고 있는 블록\n어느 부분이 비어 있는 블록인지, 어느 부분이 사용 중인 블록인지, 어디부터가 Inode 블록인지, data 블록인지 등을 알려주는 정보를 가지고 있다. 7.3 Inode list 파일 이름을 제외한 파일의 모든 ‘메타 데이터’ 를 따로 저장하고 있는 list\n파일 하나당 Inode가 하나씩 할당된다. 해당 Inode는 파일의 meta data를 가지고 있는데, 파일의 이름과 Inode 번호는 directory가 가지고 있다. direct blocks 파일이 존재하는 인덱스를 저장하는 index block 파일의 크기가 크지 않다면 이 블록을 이용하여 파일을 접근할 수 있다. direct blocks로 커버할 수 있는 크기보다 저장 용량이 큰 파일은 single indirect를 통해서 하나의 level을 두어 저장하는 방식을 취하고, 그보다 더 큰 파일은 double indirect, 더 큰 파일은 triple indirect 방식을 취한다. 7.4 Data block 파일의 실제 내용을 보관하는 블록\n이 중 directory file은 자신의 directory에 속한 file의 이름과 inode 번호를 가지고 있다. file의 이름은 실제로 data block이 가지고 있고, 나머지는 Inode 번호로 가진다. 8. FAT 파일 시스템 window 계열에서 주로 사용되는 file system 방식으로, Partition(= Logical Disk)은 Boot block, FAT, Root directory, Data block으로 구성된다.\n구조: Boot block + FAT + Root directory + Data block\nfile의 metadata의 일부(위치 정보)를 FAT에 저장하고, 나머지 정보는 root directory가 가지고 있다. (file name, 접근 권한, 소유주, 파일의 첫 번째 위치 등)\n위 사진에서 217번이 첫 번째 블록인데, 다음 블록의 위치를 FAT에 별도로 관리한다. 그래서 FAT을 통해서 직접 접근이 가능하다. FAT table 전체를 메모리에 올려 놓았으므로 연결 할당(linked allocation)의 단점을 전부 극복하였다.\nFAT는 중요한 정보이므로 복제본을 만들어 두어야 한다.\n9. Free-space management Sector가 할당되고 나서 발생하는 hole을 관리하는 디스크 자유 공간 관리방법으로, 아래 4가지가 있다.\n9.1 Bit map or Bit vector 각 block 마다 bit를 둬서 bit가 0이면 free block이고, 1이면 sector에 저장된 block이다.\n연속된 n개의 free block(빈 공간)을 찾기 효과적이지만, 0 또는 1을 저장할 부가적인 공간을 필요로 한다.\nUNIX file system의 경우, super block에 정보를 저장한다.\n9.2 Linked list 모든 free block을 link로 연결 (free list)한 방식\n회색이 비어있는 공간\n연속적인 가용 공간을 찾기 어렵지만, 공간의 낭비가 없다.\n9.3 Grouping Linked list의 변형으로, 첫 번째 자유 블록(free block)이 n개의 블록 주소(pointer)를 저장하는 방법\nn개의 블록 주소 중, (n-1)개는 실제로 비어있는 블록의 주소다. 그러나 마지막 1개는 첫 번째와 마찬가지로, (n-1)개의 빈 블록 주소를 가지고 있는 또 다른 자유 블록을 가리킨다. linked list와 달리 비어있는 block을 한 번에 찾기에는 효율적이지만, 연속적인 free block을 찾기에는 효과적이지 않다. 9.4 Counting free block의 위치를 가리키고, 거기서부터 몇 개가 비어 있는지 알려주는 방식\n프로그램들이 종종 여러 개의 연속적인 block을 할당하고 반납한다는 사실에 착안했다. 모든 블록을 일일이 추적할 필요 없이, 자유 블록의 첫 번째와 연속된 계수만 유지하면 보다 효율적이다. 10. Directory Implementation Linear list\n의 list 구현이 간단하다. 하지만, directory 내에 파일이 있는지 찾기 위해서는 선형 탐색이 필요하다. 해시 테이블\n선형 리스트 + 해싱 hashing: 더 짧은 길이의 값이나 키로 변환하는 것 Hash table은 file name을 선형 리스트의 위치로 hashing한다. 탐색 시간이 O(1)이다. 해시 충돌이 발생할 수 있다. -\u003e 자료 구조 관련 내용 파일의 메타 데이터 보관 위치\nDirectory 내에 직접 보관 Directory 에는 포인터를 두고 다른 곳에 보관 UNIX에서는 대부분 Inode에서 저장, FAT file system에서는 다음 block 위치를 가지고 있었다. Long file name의 지원\n의 list에서 각 entry는 일반적으로 고정 크기다. 하지만 file name이 엔트리의 고정 길이보다 길어지는 경우, entry의 마지막 부분에 file name의 뒷 부분이 위치한 곳의 pointer를 둔다. file 이름의 나머지 부분은 동일한 directory file의 일부에 존재한다. 11. VFS와 NFS Virtual File System (VFS)\n서로 다른 다양한 파일 시스템에 대한 동일한 시스템 콜 인터페이스(API)를 통해 접근할 수 있게 해주는 OS의 layer Network file System (NFS)\n분산 환경에서 네트워크를 통해 파일이 공유되는 대표적인 공유 방법 어떤 파일 시스템을 쓰든 상관 없이 VFS interface를 사용한다.\nclient 입장에서 VFS interface를 거쳐서 file system이 없으면 NFS를 사용한다.\n분산 시스템에서는 네트워크를 통해 파일을 공유하기 위해 NFS client와 NFS server가 이용된다.\nclient와 server 모두에 NFS module이 있어서, 같은 약속으로 접근이 가능하다. 12. Page cache and buffer cache 12.1 Page cache Virtual memory의 paging system에서 사용하는 page frame을 page cache라 부르는 것으로, cache의 관점에서 설명하는 용어다. 이 관점에서는 프로세스의 주소 공간을 구성하는 페이지가 swap area에 내려가 있는가, page cache에 올라와 있는가로 바라본다.\nMemory-Mapped I/O 를 쓰는 경우, 파일의 I/O에서도 page cache를 사용한다. page cache는 운영체제에게 주어진 정보가 극히 제한적이라, clock 알고리즘을 사용한다. 12.2 Memory-Mapped I/O 디스크 파일의 일부를 가상 메모리에 매핑하여 사용하는 것으로, 매핑 후에는 system call을 하지 않고 메모리에서 사용자가 직접 읽고 쓴다.\n매핑한 영역에 대한 메모리 접근 연산은 파일의 입출력을 수행하게 한다. 12.3 Buffer cache: File system 관점 프로그램이 I/O 시, disk의 file system에서 system call에 의해 OS가 대신 read() 작업을 수행하여, 읽어온 data를 kernel의 memmory 영역에 copy 하여 놓은 data를 buffer cache라 한다. 즉 이 관점에서는 disk에 있는냐 아니면 kernel의 memory 영역에 copy되어 있느냐로 바라본다.\n파일 시스템을 통한 I/O 연산은 메모리의 특정 영역인 buffer cache를 사용한다. 한 번 읽어 온 블록에 대한 후속 요청 시, buffer cache에서 즉시 전달 모든 process가 공용으로 사용 교체 알고리즘 필요 (LRU, LFU 등) 12.4 Unified(통합) buffer cache 최근의 OS에서 기존의 buffer cache가 page cahce에 통합되어 사용되는 방식\n별도의 구분 없이 필요할 때만 할당해서 사용하는 방식이다. 12.5 통합 buffer cache로 인한 차이점 13. 프로그램의 실행 프로그램이 실행되면 실행 파일이 프로세스가 되며, 프로세스만의 독자적인 주소 공간이 만들어진다.\n이 공간은 code, data, stack으로 구분되며 Address translation을 통해서 당장 사용될 부분은 물리적 메모리에 올라가고, 당장 사용되지 않는 부분은 swap area로 내려간다.\n이 때, 코드 부분은 이미 파일 시스템에 있고, 프로세스의 주소에 이미 mapping된 경우이기 때문에, swap area에 내리지 않고 필요 없으면 물리적 메모리에서 지운다. 나중에 필요하면 file system에서 가져오면 된다. 즉, 이 code 부분은 memory mapping된 대표적인 예다.\n13.1 Memory Mapped I/O 수행 프로세스가 일반 데이터 파일을 I/O하고 싶을 수 있다.\n이때 mmap()을 호출하면 Memory Mapped I/O 방식으로 파일을 I/O할 수 있고, mmap()은 시스템 콜이므로 운영 체제에게 CPU의 제어권이 넘어간다.\n운영 체제는 데이터 파일의 일부를 프로세스 주소 공간에 매핑한다.\n만약 데이터 파일이 매핑된 영역을 접근했을 때, 실제 물리적인 메모리에 페이지가 올라와 있지 않다면 페이지 부재가 발생한다. 그렇지 않으면 가상 메모리의 mapping된 영역은 물리적 메모리의 페이지 프레임과 일치가 되므로, 프로세스가 데이터 파일에 대해 I/O를 하고 싶을 때, 운영 체제의 도움 없이 독자적으로 I/O를 수행할 수 있다.\n물리적 메모리에 올라간 데이터 파일과 매핑된 페이지 프레임을 쫓아내야 할 때는 swap area로 내리는 것이 아니라, 수정된 사항을 file system에 적용하고 물리적 메모리에서 지운다.\n현재 process B가 데이터 파일에 대해 Memory Mapped I/O를 수행하여, 물리적 메모리에 페이지 프레임을 올려 두었는데도, 프로세스 A도 이 page frame을 공유하여 사용할 수 있다.\n13.2 read() 수행 프로세스가 일반 데이터 파일을 I/O를 하는 방법으로, read() system call을 호출할 수도 있다.\nread() system call을 호출하면 memory의 buffer cache를 확인해야 하는데, 통합 buffer cache 환경에서는 페이지 캐시가 buffer cache 역할을 동시에 수행한다. 그래서 Memory Mapped I/O 로 올라간 페이지 cache를 buffer cache로 사용할 수 있다.\n운영 체제는 buffer cache에 있던 내용을 복사하여 process의 주소 공간에 할당한다. 13.3 Memory Mapped I/O vs read() Memory Mapped I/O\n가상 메모리에 올라 온 영역이 곧 파일이므로, system call 없이 I/O 작업을 할 수 있다. page cache에 있는 내용을 복사할 필요가 없다. 여러 프로세스가 mmap()를 사용하여 같은 영역을 공유하여 사용하면 일관성 문제가 발생할 수 있다. read()\n매번 운영체제의 중재를 받는다. page cache에 있는 내용을 복사해야 한다. 여러 프로세스가 read()를 사용해도 일관성 문제가 발생하지 않는다. Reference kocw 이화여자대학교 운영체제 - 반효경 교수 - 운영체제와 정보기술의 원리 - 반효경 지음 - 느리더라도 꾸준하게: [반효경 운영체제] File System Implementations 1\u00262 연결 리스트(Linked list) ","wordCount":"1634","inLanguage":"en","datePublished":"2022-05-29T18:16:18+09:00","dateModified":"2022-05-29T18:16:18+09:00","mainEntityOfPage":{"@type":"WebPage","@id":"http://jeha00.github.io/post/os/os_chapter_12_%ED%8C%8C%EC%9D%BC%EC%8B%9C%EC%8A%A4%ED%85%9C_2/"},"publisher":{"@type":"Organization","name":"Jeha DevLog","logo":{"@type":"ImageObject","url":"http://jeha00.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=http://jeha00.github.io/ accesskey=h title="@Jeha00 (Alt + H)">@Jeha00</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></span></div><ul id=menu><li><a href=http://jeha00.github.io/me/ title=About><span>About</span></a></li><li><a href=http://jeha00.github.io/archives/ title=Archive><span>Archive</span></a></li><li><a href=http://jeha00.github.io/categories/ title=Categories><span>Categories</span></a></li><li><a href=http://jeha00.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=http://jeha00.github.io/>Home</a>&nbsp;»&nbsp;<a href=http://jeha00.github.io/post/>Posts</a></div><h1 class=post-title>[TIL] Chapter 12: 파일 시스템 2</h1><div class=post-meta>OS&nbsp;·&nbsp;<span title='2022-05-29 18:16:18 +0900 KST'>May 29, 2022</span></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#0-introduction aria-label="0. Introduction">0. Introduction</a></li><li><a href=#6-allocation-of-file-data-in-disk aria-label="6. Allocation of File data in disk">6. Allocation of File data in disk</a><ul><li><a href=#61-contiguous-allocation aria-label="6.1 Contiguous Allocation">6.1 Contiguous Allocation</a></li><li><a href=#62-linked-allocation aria-label="6.2 Linked Allocation">6.2 Linked Allocation</a></li><li><a href=#63-indexed-allocation aria-label="6.3 Indexed Allocation">6.3 Indexed Allocation</a></li></ul></li><li><a href=#7-unix-%ed%8c%8c%ec%9d%bc-%ec%8b%9c%ec%8a%a4%ed%85%9c%ec%9d%98-%ea%b5%ac%ec%a1%b0 aria-label="7. UNIX 파일 시스템의 구조">7. UNIX 파일 시스템의 구조</a><ul><li><a href=#71-boot-block aria-label="7.1 Boot block">7.1 Boot block</a></li><li><a href=#72-super-block aria-label="7.2 Super block">7.2 Super block</a></li><li><a href=#73-inode-list aria-label="7.3 Inode list">7.3 Inode list</a></li><li><a href=#74-data-block aria-label="7.4 Data block">7.4 Data block</a></li></ul></li><li><a href=#8-fat-%ed%8c%8c%ec%9d%bc-%ec%8b%9c%ec%8a%a4%ed%85%9c aria-label="8. FAT 파일 시스템">8. FAT 파일 시스템</a></li><li><a href=#9-free-space-management aria-label="9. Free-space management">9. Free-space management</a><ul><li><a href=#91-bit-map-or-bit-vector aria-label="9.1 Bit map or Bit vector">9.1 Bit map or Bit vector</a></li><li><a href=#92-linked-list aria-label="9.2 Linked list">9.2 Linked list</a></li><li><a href=#93-grouping aria-label="9.3 Grouping">9.3 Grouping</a></li><li><a href=#94-counting aria-label="9.4 Counting">9.4 Counting</a></li></ul></li><li><a href=#10-directory-implementation aria-label="10. Directory Implementation">10. Directory Implementation</a></li><li><a href=#11-vfs%ec%99%80-nfs aria-label="11. VFS와 NFS">11. VFS와 NFS</a></li><li><a href=#12-page-cache-and-buffer-cache aria-label="12. Page cache and buffer cache">12. Page cache and buffer cache</a><ul><li><a href=#121-page-cache aria-label="12.1 Page cache">12.1 Page cache</a></li><li><a href=#122-memory-mapped-io aria-label="12.2 Memory-Mapped I/O">12.2 Memory-Mapped I/O</a></li><li><a href=#123-buffer-cache-file-system-%ea%b4%80%ec%a0%90 aria-label="12.3 Buffer cache: File system 관점">12.3 Buffer cache: File system 관점</a></li><li><a href=#124-unified%ed%86%b5%ed%95%a9-buffer-cache aria-label="12.4 Unified(통합) buffer cache">12.4 Unified(통합) buffer cache</a></li><li><a href=#125-%ed%86%b5%ed%95%a9-buffer-cache%eb%a1%9c-%ec%9d%b8%ed%95%9c-%ec%b0%a8%ec%9d%b4%ec%a0%90 aria-label="12.5 통합 buffer cache로 인한 차이점">12.5 통합 buffer cache로 인한 차이점</a></li></ul></li><li><a href=#13-%ed%94%84%eb%a1%9c%ea%b7%b8%eb%9e%a8%ec%9d%98-%ec%8b%a4%ed%96%89 aria-label="13. 프로그램의 실행">13. 프로그램의 실행</a><ul><li><a href=#131-memory-mapped-io-%ec%88%98%ed%96%89 aria-label="13.1 Memory Mapped I/O 수행">13.1 Memory Mapped I/O 수행</a></li><li><a href=#132-read-%ec%88%98%ed%96%89 aria-label="13.2 read() 수행">13.2 read() 수행</a></li><li><a href=#133-memory-mapped-io-vs-read aria-label="13.3 Memory Mapped I/O vs read()">13.3 Memory Mapped I/O vs read()</a></li></ul></li><li><a href=#reference aria-label=Reference>Reference</a></li></ul></div></details></div><div class=post-content><h1 id=0-introduction>0. Introduction<a hidden class=anchor aria-hidden=true href=#0-introduction>#</a></h1><p> </p><ul><li>해당 내용은 <a href="http://www.kyobobook.co.kr/product/detailViewKor.laf?ejkGb=KOR&mallGb=KOR&barcode=9791158903589&orderClick=LAG&Kc=">운영체제와 정보기술의 원리 -반효경 지음-</a> 와 <a href="http://www.kocw.net/home/cview.do?lid=3dd1117c48123b8e">kocw 이화여자대학교 운영체제 - 반효경 교수 -</a>를 보고 정리한 내용이다.</li><li>정확하지 않은 내용이 있다면 말씀해주시면 감사하겠습니다.</li></ul><p> </p><hr><h1 id=6-allocation-of-file-data-in-disk>6. Allocation of File data in disk<a hidden class=anchor aria-hidden=true href=#6-allocation-of-file-data-in-disk>#</a></h1><blockquote><p><strong><em>disk에 균일하지 않은 크기의 file을 저장할 때는 disk를 균일한 크기로 쪼갠 sector 단위로 저장한다.</em></strong></p></blockquote><ul><li><p><strong>disk에 file을 저장하는 방식 3가지 (paging 기법과 유사)</strong></p><ul><li>Contiguous Allocation (연속 할당)</li><li>Linked Allocation (연결 할당)</li><li>Indexed Allocation (인덱스를 이용한 할당)</li></ul></li><li><p><strong>sector와 block</strong>의 차이</p><ul><li>sector: disk에서 물리적으로 저장하는 단위</li><li>block: file system에서 file이 저장되는 단위</li></ul></li></ul><p> </p><h2 id=61-contiguous-allocation>6.1 Contiguous Allocation<a hidden class=anchor aria-hidden=true href=#61-contiguous-allocation>#</a></h2><blockquote><p><strong><em>하나의 file을 sector들에 Array 구조로 저장하여, 나누어진 각 블록들이 연속된 번호를 부여받아 저장된다.</em></strong></p></blockquote><p><img loading=lazy src=https://user-images.githubusercontent.com/78094972/170855629-77feddc0-8a48-4373-b8f3-5d64f26b96b5.PNG alt=image></p><ul><li><p><strong>directory를 설명하자면</strong></p><ul><li>&lsquo;count&rsquo; file은 0부터 시작해서 총 2개의 sector를 차지한다.</li><li>&rsquo;tr&rsquo; file은 14부터 시작해서 총 3개의 sector를 차지한다.</li></ul></li><li><p><strong>장점</strong></p><ul><li>Fast I/O (시간 효율성 증가)<ul><li>file이 모두 연속해서 붙어 있으므로 한 번의 seek / rotation으로 많은 양의 데이터를 받을 수 있다.<ul><li>대부분의 접근 시간은 header가 움직이면서 읽어들이는 시간이기 때문에, 시간 효율성이 증가한다.</li></ul></li><li>Realtime file 용 또는 이미 run 중이던 process의 swapping 용도로 사용된다.</li></ul></li><li>Direct access (= random access) 가능<ul><li>몇 번 sector부터 시작하는지 directory가 알기 때문에 가능하다.</li></ul></li></ul></li><li><p><strong>단점</strong></p><ul><li>External fragmentation (hole 발생)</li><li>File grow가 어렵다. file grow를 해도 낭비 발생 (internal fragmentation)<ul><li>file이 커져서 sector를 늘려 저장하려할 때, 다른 file이 옆 sector를 차지하고 있다면 늘릴 수 없다. 그래서 file이 커질 것을 대비하여 미리 할당했을지라도, 할당된 만큼만 커질 수 있다는 단점이 있다.</li><li>그리고 미리 할당된거면서 사용하지 않는 조각이기 때문에, 내부 조각이 발생된다.</li></ul></li></ul></li></ul><p> </p><h2 id=62-linked-allocation>6.2 Linked Allocation<a hidden class=anchor aria-hidden=true href=#62-linked-allocation>#</a></h2><blockquote><p><strong><em>sector들이 각각 node되어 linked list 구조로 파일을 저장한다.</em></strong></p></blockquote><p><img loading=lazy src=https://user-images.githubusercontent.com/78094972/170928917-e73edb98-e2f0-4f21-a31f-9b23dc0f684e.PNG alt=image></p><ul><li><p><strong>장점</strong></p><ul><li>외부 단편화가 발생하지 않는다.</li></ul></li><li><p><strong>단점</strong></p><ul><li>첫 요소부터 차례대로 읽어야하므로, 직접 접근이 불가능하다.<ul><li>또한, 각 sector로 header가 이동해야하므로, 시간이 더 걸린다.</li></ul></li><li>신뢰성 문제<ul><li>한 sector가 고장나 pointer가 유실되면 그 이후 모든 sector로 접근할 수 없다.</li><li>pointer란 block 주소를 의미한다고 생각하자.</li></ul></li><li>포인터를 위한 공간이 필요하므로 공간 효율성을 떨어뜨린다.<ul><li>512 bytes/sector, 4 bytes/pointer</li></ul></li></ul></li><li><p><strong>변형</strong></p><ul><li>File-Allocation Table (FAT) 파일 시스템<ul><li>pointer를 별도의 sector에 보관하여 신뢰성 문제와 공간 효율성 문제를 해결한다.</li></ul></li></ul></li></ul><p> </p><h2 id=63-indexed-allocation>6.3 Indexed Allocation<a hidden class=anchor aria-hidden=true href=#63-indexed-allocation>#</a></h2><blockquote><p><strong><em>directory에 file의 index block을 표시하여 이 index block을 통해서 직접 접근이 가능한 방식</em></strong></p></blockquote><p><img loading=lazy src=https://user-images.githubusercontent.com/78094972/170928911-7825ae70-00b2-418f-b769-70a917944992.PNG alt=image></p><ul><li><p><strong>index block이란??</strong></p><ul><li>file이 어디에 나눠져 있는지 index를 적어 두는 block 하나</li></ul></li><li><p><strong>장점</strong></p><ul><li>External fragmentation(외부 조각 hole) 발생 X</li><li>직접 접근 (= 임의 접근)이 가능하다.</li></ul></li><li><p><strong>단점</strong></p><ul><li>작은 파일의 경우, 공간 낭비가 심하며 실제로 많은 파일들이 사이즈가 작다.<ul><li>index block을 위한 sector와 실제 file 저장을 위한 sector가 필요하기 때문에 공간 낭비가 심하다.</li></ul></li><li>매우 큰 파일의 경우, 하나의 index block으로 커버할 수 없다.<ul><li>해결 방안: linked scheme, multi-level index</li><li>전자는 index block을 여러 개 두는 것이고, 후자는 block의 마지막에 다음 index block을 가리키는 값을 설정하여 서로 연결하는 것이다.</li></ul></li></ul></li><li><p>이번 소챕터에서는 이론적으로 disk에 file을 어떻게 할당하는 지를 알아봤으니, 다음 소챕터에서는 실제로 어떠한지 알아보자.</p></li></ul><p> </p><hr><h1 id=7-unix-파일-시스템의-구조>7. UNIX 파일 시스템의 구조<a hidden class=anchor aria-hidden=true href=#7-unix-파일-시스템의-구조>#</a></h1><blockquote><p><strong><em>Partition(= Logical Disk) 은 Boot block, Super block, Inode list, Data block으로 구성된다.</em></strong></p></blockquote><p><img loading=lazy src=https://user-images.githubusercontent.com/78094972/170928918-dc248b34-06a7-4868-8e63-08916c03ccc9.PNG alt=image></p><h2 id=71-boot-block>7.1 Boot block<a hidden class=anchor aria-hidden=true href=#71-boot-block>#</a></h2><blockquote><p><em>Booting에 필요한 정보를 담고 있는 block</em></p></blockquote><ul><li>0번 block이며, bootstrap loader라고도 한다.</li><li>모든 file system에 존재하는 블록</li></ul><p> </p><h2 id=72-super-block>7.2 Super block<a hidden class=anchor aria-hidden=true href=#72-super-block>#</a></h2><blockquote><p><em>file system에 관한 총체적인 정보를 담고 있는 블록</em></p></blockquote><ul><li>어느 부분이 비어 있는 블록인지, 어느 부분이 사용 중인 블록인지, 어디부터가 Inode 블록인지, data 블록인지 등을 알려주는 정보를 가지고 있다.</li></ul><p> </p><h2 id=73-inode-list>7.3 Inode list<a hidden class=anchor aria-hidden=true href=#73-inode-list>#</a></h2><blockquote><p><em>파일 이름을 제외한 파일의 모든 &lsquo;메타 데이터&rsquo; 를 따로 저장하고 있는 list</em></p></blockquote><ul><li>파일 하나당 Inode가 하나씩 할당된다.</li><li>해당 Inode는 파일의 meta data를 가지고 있는데, 파일의 이름과 Inode 번호는 directory가 가지고 있다.</li><li>direct blocks<ul><li>파일이 존재하는 인덱스를 저장하는 index block</li><li>파일의 크기가 크지 않다면 이 블록을 이용하여 파일을 접근할 수 있다.</li><li>direct blocks로 커버할 수 있는 크기보다 저장 용량이 큰 파일은 single indirect를 통해서 하나의 level을 두어 저장하는 방식을 취하고, 그보다 더 큰 파일은 double indirect, 더 큰 파일은 triple indirect 방식을 취한다.</li></ul></li></ul><p> </p><h2 id=74-data-block>7.4 Data block<a hidden class=anchor aria-hidden=true href=#74-data-block>#</a></h2><blockquote><p><em>파일의 실제 내용을 보관하는 블록</em></p></blockquote><ul><li>이 중 directory file은 자신의 directory에 속한 file의 이름과 inode 번호를 가지고 있다.<ul><li>file의 이름은 실제로 data block이 가지고 있고, 나머지는 Inode 번호로 가진다.</li></ul></li></ul><p> </p><hr><h1 id=8-fat-파일-시스템>8. FAT 파일 시스템<a hidden class=anchor aria-hidden=true href=#8-fat-파일-시스템>#</a></h1><blockquote><p><strong><em>window 계열에서 주로 사용되는 file system 방식으로, Partition(= Logical Disk)은 Boot block, FAT, Root directory, Data block으로 구성된다.</em></strong></p></blockquote><p><img loading=lazy src=https://user-images.githubusercontent.com/78094972/170930369-c4c991bc-1dea-4473-bd43-2aae64e9ea6b.PNG alt=image></p><ul><li><p>구조: Boot block + FAT + Root directory + Data block</p></li><li><p>file의 metadata의 일부(위치 정보)를 FAT에 저장하고, 나머지 정보는 root directory가 가지고 있다. (file name, 접근 권한, 소유주, 파일의 첫 번째 위치 등)</p><ul><li>위 사진에서 217번이 첫 번째 블록인데, 다음 블록의 위치를 FAT에 별도로 관리한다. 그래서 FAT을 통해서 직접 접근이 가능하다.</li></ul></li><li><p>FAT table 전체를 메모리에 올려 놓았으므로 연결 할당(linked allocation)의 단점을 전부 극복하였다.</p></li><li><p>FAT는 중요한 정보이므로 복제본을 만들어 두어야 한다.</p></li></ul><p> </p><hr><h1 id=9-free-space-management>9. Free-space management<a hidden class=anchor aria-hidden=true href=#9-free-space-management>#</a></h1><blockquote><p><strong><em>Sector가 할당되고 나서 발생하는 hole을 관리하는 디스크 자유 공간 관리방법으로, 아래 4가지가 있다.</em></strong></p></blockquote><p> </p><h2 id=91-bit-map-or-bit-vector>9.1 Bit map or Bit vector<a hidden class=anchor aria-hidden=true href=#91-bit-map-or-bit-vector>#</a></h2><blockquote><p>각 block 마다 bit를 둬서 bit가 0이면 free block이고, 1이면 sector에 저장된 block이다.</p></blockquote><ul><li><p>연속된 n개의 free block(빈 공간)을 찾기 효과적이지만, 0 또는 1을 저장할 부가적인 공간을 필요로 한다.</p></li><li><p>UNIX file system의 경우, super block에 정보를 저장한다.</p></li></ul><p> </p><h2 id=92-linked-list>9.2 Linked list<a hidden class=anchor aria-hidden=true href=#92-linked-list>#</a></h2><blockquote><p>모든 free block을 link로 연결 (free list)한 방식</p></blockquote><p><img loading=lazy src=https://user-images.githubusercontent.com/78094972/170934993-d13d3fec-6ae1-4e92-9cb1-f7db076409c7.PNG alt=image></p><ul><li><p>회색이 비어있는 공간</p></li><li><p>연속적인 가용 공간을 찾기 어렵지만, 공간의 낭비가 없다.</p></li></ul><p> </p><h2 id=93-grouping>9.3 Grouping<a hidden class=anchor aria-hidden=true href=#93-grouping>#</a></h2><blockquote><p>Linked list의 변형으로, 첫 번째 자유 블록(free block)이 n개의 블록 주소(pointer)를 저장하는 방법</p></blockquote><p><img loading=lazy src="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FclhXFc%2Fbtq7EBezgFt%2FlgPe7idbx1Kv4CcgszN8KK%2Fimg.png" alt=image></p><ul><li>n개의 블록 주소 중, (n-1)개는 실제로 비어있는 블록의 주소다.</li><li>그러나 마지막 1개는 첫 번째와 마찬가지로, (n-1)개의 빈 블록 주소를 가지고 있는 또 다른 자유 블록을 가리킨다.</li><li>linked list와 달리 비어있는 block을 한 번에 찾기에는 효율적이지만, 연속적인 free block을 찾기에는 효과적이지 않다.</li></ul><p> </p><h2 id=94-counting>9.4 Counting<a hidden class=anchor aria-hidden=true href=#94-counting>#</a></h2><blockquote><p>free block의 위치를 가리키고, 거기서부터 몇 개가 비어 있는지 알려주는 방식</p></blockquote><ul><li>프로그램들이 종종 여러 개의 연속적인 block을 할당하고 반납한다는 사실에 착안했다.</li><li>모든 블록을 일일이 추적할 필요 없이, 자유 블록의 첫 번째와 연속된 계수만 유지하면 보다 효율적이다.</li></ul><p> </p><hr><h1 id=10-directory-implementation>10. Directory Implementation<a hidden class=anchor aria-hidden=true href=#10-directory-implementation>#</a></h1><p><img loading=lazy src=https://user-images.githubusercontent.com/78094972/170945376-272bb8b1-6ad2-4d97-802c-bb3bc84740eb.PNG alt=image></p><ul><li><p><strong>Linear list</strong></p><ul><li>&lt;file name, file의 메타 데이터>의 list</li><li>구현이 간단하다.</li><li>하지만, directory 내에 파일이 있는지 찾기 위해서는 선형 탐색이 필요하다.</li></ul></li><li><p><strong>해시 테이블</strong></p><ul><li>선형 리스트 + 해싱<ul><li>hashing: 더 짧은 길이의 값이나 키로 변환하는 것</li></ul></li><li>Hash table은 file name을 선형 리스트의 위치로 hashing한다.</li><li>탐색 시간이 O(1)이다.</li><li>해시 충돌이 발생할 수 있다. -> 자료 구조 관련 내용</li></ul></li></ul><p><img loading=lazy src=https://user-images.githubusercontent.com/78094972/170950405-3e8aa2bd-6a40-4513-b9d1-f51f0708bc50.png alt=image></p><ul><li><p><strong>파일의 메타 데이터 보관 위치</strong></p><ul><li>Directory 내에 직접 보관</li><li>Directory 에는 포인터를 두고 다른 곳에 보관<ul><li>UNIX에서는 대부분 Inode에서 저장, FAT file system에서는 다음 block 위치를 가지고 있었다.</li></ul></li></ul></li><li><p><strong>Long file name의 지원</strong></p><ul><li>&lt;file name, file의 metadata>의 list에서 각 entry는 일반적으로 고정 크기다.</li><li>하지만 file name이 엔트리의 고정 길이보다 길어지는 경우, entry의 마지막 부분에 file name의 뒷 부분이 위치한 곳의 pointer를 둔다.</li><li>file 이름의 나머지 부분은 동일한 directory file의 일부에 존재한다.</li></ul></li></ul><p> </p><hr><h1 id=11-vfs와-nfs>11. VFS와 NFS<a hidden class=anchor aria-hidden=true href=#11-vfs와-nfs>#</a></h1><ul><li><p><strong>Virtual File System (VFS)</strong></p><ul><li>서로 다른 다양한 파일 시스템에 대한 동일한 시스템 콜 인터페이스(API)를 통해 접근할 수 있게 해주는 OS의 layer</li></ul></li><li><p><strong>Network file System (NFS)</strong></p><ul><li>분산 환경에서 네트워크를 통해 파일이 공유되는 대표적인 공유 방법</li></ul></li></ul><p><img loading=lazy src=https://user-images.githubusercontent.com/78094972/170955105-5de37812-539e-4741-8e96-093d8e491be0.png alt=image></p><ul><li><p><strong>어떤 파일 시스템을 쓰든 상관 없이 VFS interface를 사용한다.</strong></p></li><li><p>client 입장에서 VFS interface를 거쳐서 file system이 없으면 NFS를 사용한다.</p></li><li><p><strong>분산 시스템에서는 네트워크를 통해 파일을 공유하기 위해 NFS client와 NFS server가 이용된다.</strong></p><ul><li>client와 server 모두에 NFS module이 있어서, 같은 약속으로 접근이 가능하다.</li></ul></li></ul><p> </p><hr><h1 id=12-page-cache-and-buffer-cache>12. Page cache and buffer cache<a hidden class=anchor aria-hidden=true href=#12-page-cache-and-buffer-cache>#</a></h1><p><img loading=lazy src=https://user-images.githubusercontent.com/78094972/170955100-774e0fcb-f2ab-416b-aac6-e9af64d6eab3.png alt=image></p><h2 id=121-page-cache>12.1 Page cache<a hidden class=anchor aria-hidden=true href=#121-page-cache>#</a></h2><blockquote><p><strong><em>Virtual memory의 paging system에서 사용하는 page frame을 page cache라 부르는 것으로, cache의 관점에서 설명하는 용어다. 이 관점에서는 프로세스의 주소 공간을 구성하는 페이지가 swap area에 내려가 있는가, page cache에 올라와 있는가로 바라본다.</em></strong></p></blockquote><ul><li>Memory-Mapped I/O 를 쓰는 경우, 파일의 I/O에서도 page cache를 사용한다.</li><li>page cache는 운영체제에게 주어진 정보가 극히 제한적이라, clock 알고리즘을 사용한다.</li></ul><p> </p><h2 id=122-memory-mapped-io>12.2 Memory-Mapped I/O<a hidden class=anchor aria-hidden=true href=#122-memory-mapped-io>#</a></h2><blockquote><p><strong><em>디스크 파일의 일부를 가상 메모리에 매핑하여 사용하는 것으로, 매핑 후에는 system call을 하지 않고 메모리에서 사용자가 직접 읽고 쓴다.</em></strong></p></blockquote><ul><li>매핑한 영역에 대한 메모리 접근 연산은 파일의 입출력을 수행하게 한다.</li></ul><p> </p><h2 id=123-buffer-cache-file-system-관점>12.3 Buffer cache: File system 관점<a hidden class=anchor aria-hidden=true href=#123-buffer-cache-file-system-관점>#</a></h2><blockquote><p><strong><em>프로그램이 I/O 시, disk의 file system에서 system call에 의해 OS가 대신 read() 작업을 수행하여, 읽어온 data를 kernel의 memmory 영역에 copy 하여 놓은 data를 buffer cache라 한다.</em></strong> 즉 이 관점에서는 disk에 있는냐 아니면 kernel의 memory 영역에 copy되어 있느냐로 바라본다.</p></blockquote><ul><li>파일 시스템을 통한 I/O 연산은 메모리의 특정 영역인 buffer cache를 사용한다.</li><li>한 번 읽어 온 블록에 대한 후속 요청 시, buffer cache에서 즉시 전달</li><li>모든 process가 공용으로 사용</li><li>교체 알고리즘 필요 (LRU, LFU 등)</li></ul><p> </p><h2 id=124-unified통합-buffer-cache>12.4 Unified(통합) buffer cache<a hidden class=anchor aria-hidden=true href=#124-unified통합-buffer-cache>#</a></h2><blockquote><p><strong><em>최근의 OS에서 기존의 buffer cache가 page cahce에 통합되어 사용되는 방식</em></strong></p></blockquote><ul><li>별도의 구분 없이 필요할 때만 할당해서 사용하는 방식이다.</li></ul><p> </p><h2 id=125-통합-buffer-cache로-인한-차이점>12.5 통합 buffer cache로 인한 차이점<a hidden class=anchor aria-hidden=true href=#125-통합-buffer-cache로-인한-차이점>#</a></h2><p><img loading=lazy src=https://user-images.githubusercontent.com/78094972/170958342-0f2c376b-e3f8-4b26-aa71-2596ec1ce965.png alt=image></p><p> </p><hr><h1 id=13-프로그램의-실행>13. 프로그램의 실행<a hidden class=anchor aria-hidden=true href=#13-프로그램의-실행>#</a></h1><p><img loading=lazy src=https://user-images.githubusercontent.com/78094972/170959950-fca5a8e8-3ae6-49ad-a75b-6f1c97bd353c.png alt=image></p><ul><li><p>프로그램이 실행되면 실행 파일이 프로세스가 되며, 프로세스만의 독자적인 주소 공간이 만들어진다.</p></li><li><p>이 공간은 code, data, stack으로 구분되며 Address translation을 통해서 당장 사용될 부분은 물리적 메모리에 올라가고, 당장 사용되지 않는 부분은 swap area로 내려간다.</p></li><li><p>이 때, 코드 부분은 이미 파일 시스템에 있고, 프로세스의 주소에 이미 mapping된 경우이기 때문에, swap area에 내리지 않고 필요 없으면 물리적 메모리에서 지운다. 나중에 필요하면 file system에서 가져오면 된다. 즉, 이 code 부분은 memory mapping된 대표적인 예다.</p></li></ul><p> </p><h2 id=131-memory-mapped-io-수행>13.1 Memory Mapped I/O 수행<a hidden class=anchor aria-hidden=true href=#131-memory-mapped-io-수행>#</a></h2><p><img loading=lazy src=https://user-images.githubusercontent.com/78094972/170959379-ddaad2e4-2e5f-407e-890d-a908f7f284c7.png alt=image></p><ul><li><p>프로세스가 일반 데이터 파일을 I/O하고 싶을 수 있다.</p></li><li><p>이때 <code>mmap()</code>을 호출하면 Memory Mapped I/O 방식으로 파일을 I/O할 수 있고, <code>mmap()</code>은 시스템 콜이므로 운영 체제에게 CPU의 제어권이 넘어간다.</p></li></ul><p><img loading=lazy src=https://user-images.githubusercontent.com/78094972/170959380-d626b3f5-e119-41c0-9062-7b181455a515.png alt=image></p><ul><li><p>운영 체제는 데이터 파일의 일부를 프로세스 주소 공간에 매핑한다.</p></li><li><p>만약 데이터 파일이 매핑된 영역을 접근했을 때, 실제 물리적인 메모리에 페이지가 올라와 있지 않다면 페이지 부재가 발생한다. 그렇지 않으면 가상 메모리의 mapping된 영역은 물리적 메모리의 페이지 프레임과 일치가 되므로, 프로세스가 데이터 파일에 대해 I/O를 하고 싶을 때, 운영 체제의 도움 없이 독자적으로 I/O를 수행할 수 있다.</p></li><li><p>물리적 메모리에 올라간 데이터 파일과 매핑된 페이지 프레임을 쫓아내야 할 때는 swap area로 내리는 것이 아니라, 수정된 사항을 file system에 적용하고 물리적 메모리에서 지운다.</p></li><li><p>현재 process B가 데이터 파일에 대해 Memory Mapped I/O를 수행하여, 물리적 메모리에 페이지 프레임을 올려 두었는데도, 프로세스 A도 이 page frame을 공유하여 사용할 수 있다.</p></li></ul><p> </p><h2 id=132-read-수행>13.2 read() 수행<a hidden class=anchor aria-hidden=true href=#132-read-수행>#</a></h2><p><img loading=lazy src=https://user-images.githubusercontent.com/78094972/170959383-322fd132-1405-4f0b-9e16-8a8b1037c320.png alt=image></p><ul><li><p>프로세스가 일반 데이터 파일을 I/O를 하는 방법으로, <code>read()</code> system call을 호출할 수도 있다.</p></li><li><p><code>read()</code> system call을 호출하면 memory의 buffer cache를 확인해야 하는데, 통합 buffer cache 환경에서는 페이지 캐시가 buffer cache 역할을 동시에 수행한다. 그래서 Memory Mapped I/O 로 올라간 페이지 cache를 buffer cache로 사용할 수 있다.</p></li></ul><p><img loading=lazy src=https://user-images.githubusercontent.com/78094972/170959385-84d19d3b-359a-42d7-ae92-97fd5a7586fd.png alt=image></p><ul><li>운영 체제는 buffer cache에 있던 내용을 복사하여 process의 주소 공간에 할당한다.</li></ul><p> </p><h2 id=133-memory-mapped-io-vs-read>13.3 Memory Mapped I/O vs read()<a hidden class=anchor aria-hidden=true href=#133-memory-mapped-io-vs-read>#</a></h2><ul><li><p><strong>Memory Mapped I/O</strong></p><ul><li>가상 메모리에 올라 온 영역이 곧 파일이므로, system call 없이 I/O 작업을 할 수 있다.</li><li>page cache에 있는 내용을 복사할 필요가 없다.</li><li>여러 프로세스가 <code>mmap()</code>를 사용하여 같은 영역을 공유하여 사용하면 일관성 문제가 발생할 수 있다.</li></ul></li><li><p><strong>read()</strong></p><ul><li>매번 운영체제의 중재를 받는다.</li><li>page cache에 있는 내용을 복사해야 한다.</li><li>여러 프로세스가 <code>read()</code>를 사용해도 일관성 문제가 발생하지 않는다.</li></ul></li></ul><p> </p><hr><h1 id=reference>Reference<a hidden class=anchor aria-hidden=true href=#reference>#</a></h1><ul><li><a href="http://www.kocw.net/home/cview.do?lid=3dd1117c48123b8e">kocw 이화여자대학교 운영체제 - 반효경 교수 -</a></li><li><a href="http://www.kyobobook.co.kr/product/detailViewKor.laf?ejkGb=KOR&mallGb=KOR&barcode=9791158903589&orderClick=LAG&Kc=">운영체제와 정보기술의 원리 - 반효경 지음 -</a></li><li><a href=https://steady-coding.tistory.com/578>느리더라도 꾸준하게: [반효경 운영체제] File System Implementations 1&2</a></li><li><a href=https://velog.io/@mmindoong/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0-%EC%97%B0%EA%B2%B0-%EB%A6%AC%EC%8A%A4%ED%8A%B8Linked-List>연결 리스트(Linked list)</a></li></ul></div><footer class=post-footer><ul class=post-tags><li><a href=http://jeha00.github.io/tags/til/>TIL</a></li><li><a href=http://jeha00.github.io/tags/os/>OS</a></li></ul><nav class=paginav><a class=prev href=http://jeha00.github.io/post/os/os_chapter_13_%EC%9B%B9%EC%BA%90%EC%8B%B1/><span class=title>« Prev Page</span><br><span>[TIL] Chapter 13: 웹캐싱 기법</span></a>
<a class=next href=http://jeha00.github.io/post/os/os_chapter_12_%ED%8C%8C%EC%9D%BC%EC%8B%9C%EC%8A%A4%ED%85%9C_1/><span class=title>Next Page »</span><br><span>[TIL] Chapter 12: 파일 시스템 1</span></a></nav><div class=share-buttons><a target=_blank rel="noopener noreferrer" aria-label="share [TIL] Chapter 12: 파일 시스템 2 on twitter" href="https://twitter.com/intent/tweet/?text=%5bTIL%5d%20Chapter%2012%3a%20%ed%8c%8c%ec%9d%bc%20%ec%8b%9c%ec%8a%a4%ed%85%9c%202&url=http%3a%2f%2fjeha00.github.io%2fpost%2fos%2fos_chapter_12_%25ED%258C%258C%25EC%259D%25BC%25EC%258B%259C%25EC%258A%25A4%25ED%2585%259C_2%2f&hashtags=TIL%2cOS"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM195.519 424.544c135.939.0 210.268-112.643 210.268-210.268.0-3.218.0-6.437-.153-9.502 14.406-10.421 26.973-23.448 36.935-38.314-13.18 5.824-27.433 9.809-42.452 11.648 15.326-9.196 26.973-23.602 32.49-40.92-14.252 8.429-30.038 14.56-46.896 17.931-13.487-14.406-32.644-23.295-53.946-23.295-40.767.0-73.87 33.104-73.87 73.87.0 5.824.613 11.494 1.992 16.858-61.456-3.065-115.862-32.49-152.337-77.241-6.284 10.881-9.962 23.601-9.962 37.088.0 25.594 13.027 48.276 32.95 61.456-12.107-.307-23.448-3.678-33.41-9.196v.92c0 35.862 25.441 65.594 59.311 72.49-6.13 1.686-12.72 2.606-19.464 2.606-4.751.0-9.348-.46-13.946-1.38 9.349 29.426 36.628 50.728 68.965 51.341-25.287 19.771-57.164 31.571-91.8 31.571-5.977.0-11.801-.306-17.625-1.073 32.337 21.15 71.264 33.41 112.95 33.41z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share [TIL] Chapter 12: 파일 시스템 2 on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&url=http%3a%2f%2fjeha00.github.io%2fpost%2fos%2fos_chapter_12_%25ED%258C%258C%25EC%259D%25BC%25EC%258B%259C%25EC%258A%25A4%25ED%2585%259C_2%2f&title=%5bTIL%5d%20Chapter%2012%3a%20%ed%8c%8c%ec%9d%bc%20%ec%8b%9c%ec%8a%a4%ed%85%9c%202&summary=%5bTIL%5d%20Chapter%2012%3a%20%ed%8c%8c%ec%9d%bc%20%ec%8b%9c%ec%8a%a4%ed%85%9c%202&source=http%3a%2f%2fjeha00.github.io%2fpost%2fos%2fos_chapter_12_%25ED%258C%258C%25EC%259D%25BC%25EC%258B%259C%25EC%258A%25A4%25ED%2585%259C_2%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share [TIL] Chapter 12: 파일 시스템 2 on reddit" href="https://reddit.com/submit?url=http%3a%2f%2fjeha00.github.io%2fpost%2fos%2fos_chapter_12_%25ED%258C%258C%25EC%259D%25BC%25EC%258B%259C%25EC%258A%25A4%25ED%2585%259C_2%2f&title=%5bTIL%5d%20Chapter%2012%3a%20%ed%8c%8c%ec%9d%bc%20%ec%8b%9c%ec%8a%a4%ed%85%9c%202"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share [TIL] Chapter 12: 파일 시스템 2 on facebook" href="https://facebook.com/sharer/sharer.php?u=http%3a%2f%2fjeha00.github.io%2fpost%2fos%2fos_chapter_12_%25ED%258C%258C%25EC%259D%25BC%25EC%258B%259C%25EC%258A%25A4%25ED%2585%259C_2%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share [TIL] Chapter 12: 파일 시스템 2 on whatsapp" href="https://api.whatsapp.com/send?text=%5bTIL%5d%20Chapter%2012%3a%20%ed%8c%8c%ec%9d%bc%20%ec%8b%9c%ec%8a%a4%ed%85%9c%202%20-%20http%3a%2f%2fjeha00.github.io%2fpost%2fos%2fos_chapter_12_%25ED%258C%258C%25EC%259D%25BC%25EC%258B%259C%25EC%258A%25A4%25ED%2585%259C_2%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share [TIL] Chapter 12: 파일 시스템 2 on telegram" href="https://telegram.me/share/url?text=%5bTIL%5d%20Chapter%2012%3a%20%ed%8c%8c%ec%9d%bc%20%ec%8b%9c%ec%8a%a4%ed%85%9c%202&url=http%3a%2f%2fjeha00.github.io%2fpost%2fos%2fos_chapter_12_%25ED%258C%258C%25EC%259D%25BC%25EC%258B%259C%25EC%258A%25A4%25ED%2585%259C_2%2f"><svg viewBox="2 2 28 28"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></div></footer></article></main><footer class=footer><span>&copy; 2023 <a href=http://jeha00.github.io/>Jeha DevLog</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerText="copy";function s(){t.innerText="copied!",setTimeout(()=>{t.innerText="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>