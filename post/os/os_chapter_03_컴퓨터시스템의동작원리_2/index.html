<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>[TIL] Chapter 03: 컴퓨터 시스템의 동작원리 2 | Jeha DevLog</title><meta name=keywords content="TIL,OS"><meta name=description content="입출력 구조, DMA, 저장장치의 구조 그리고 계층구조에 대해 알아본다. 또한, 하드웨어, 메모리, CPU의 각 보안 방법에 대해 알아본다."><meta name=author content="Me"><link rel=canonical href=http://jeha00.github.io/post/os/os_chapter_03_%EC%BB%B4%ED%93%A8%ED%84%B0%EC%8B%9C%EC%8A%A4%ED%85%9C%EC%9D%98%EB%8F%99%EC%9E%91%EC%9B%90%EB%A6%AC_2/><meta name=google-site-verification content="XYZabc"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.min.8330bf30523628d00ababead16d63a7b5cd7570bd4901cb3c11ec258628d7a67.css integrity="sha256-gzC/MFI2KNAKur6tFtY6e1zXVwvUkByzwR7CWGKNemc=" rel="preload stylesheet" as=style><link rel=icon href=http://jeha00.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=http://jeha00.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=http://jeha00.github.io/favicon-32x32.png><link rel=apple-touch-icon href=http://jeha00.github.io/apple-touch-icon.png><link rel=mask-icon href=http://jeha00.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><meta name=generator content="Hugo 0.101.0"><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><script type=application/javascript>var doNotTrack=!1;doNotTrack||(function(e,t,n,s,o,i,a){e.GoogleAnalyticsObject=o,e[o]=e[o]||function(){(e[o].q=e[o].q||[]).push(arguments)},e[o].l=1*new Date,i=t.createElement(n),a=t.getElementsByTagName(n)[0],i.async=1,i.src=s,a.parentNode.insertBefore(i,a)}(window,document,"script","https://www.google-analytics.com/analytics.js","ga"),ga("create","UA-123-45","auto"),ga("send","pageview"))</script><meta property="og:title" content="[TIL] Chapter 03: 컴퓨터 시스템의 동작원리 2"><meta property="og:description" content="입출력 구조, DMA, 저장장치의 구조 그리고 계층구조에 대해 알아본다. 또한, 하드웨어, 메모리, CPU의 각 보안 방법에 대해 알아본다."><meta property="og:type" content="article"><meta property="og:url" content="http://jeha00.github.io/post/os/os_chapter_03_%EC%BB%B4%ED%93%A8%ED%84%B0%EC%8B%9C%EC%8A%A4%ED%85%9C%EC%9D%98%EB%8F%99%EC%9E%91%EC%9B%90%EB%A6%AC_2/"><meta property="og:image" content="http://jeha00.github.io/47"><meta property="article:section" content="post"><meta property="article:published_time" content="2022-04-14T14:54:58+09:00"><meta property="article:modified_time" content="2022-04-14T14:54:58+09:00"><meta property="og:site_name" content="JeHa00 DevLog"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="http://jeha00.github.io/47"><meta name=twitter:title content="[TIL] Chapter 03: 컴퓨터 시스템의 동작원리 2"><meta name=twitter:description content="입출력 구조, DMA, 저장장치의 구조 그리고 계층구조에 대해 알아본다. 또한, 하드웨어, 메모리, CPU의 각 보안 방법에 대해 알아본다."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"http://jeha00.github.io/post/"},{"@type":"ListItem","position":2,"name":"[TIL] Chapter 03: 컴퓨터 시스템의 동작원리 2","item":"http://jeha00.github.io/post/os/os_chapter_03_%EC%BB%B4%ED%93%A8%ED%84%B0%EC%8B%9C%EC%8A%A4%ED%85%9C%EC%9D%98%EB%8F%99%EC%9E%91%EC%9B%90%EB%A6%AC_2/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"[TIL] Chapter 03: 컴퓨터 시스템의 동작원리 2","name":"[TIL] Chapter 03: 컴퓨터 시스템의 동작원리 2","description":"입출력 구조, DMA, 저장장치의 구조 그리고 계층구조에 대해 알아본다. 또한, 하드웨어, 메모리, CPU의 각 보안 방법에 대해 알아본다.","keywords":["TIL","OS"],"articleBody":"0. Introduction 해당 내용은 운영체제와 정보기술의 원리 -반효경 지음- 와 kocw 이화여자대학교 운영체제 - 반효경 교수 -를 보고 정리한 내용입니다. 정확하지 않은 내용이 있다면 말씀해주시면 감사하겠습니다. 5. 입출력 구조 CPU의 명령 수행 속도는 빠르지만, 입출력 연산은 매우 느리다. 이 입출력 방식에는 동기식 입출력 과 비동기식 입출력 이 있다. 5.1 동기식 입출력(Synchronous I/O) 일반적으로 사용하는 방식으로 어떤 프로그램이 입출력했을 때, 입출력 작업이 완료된 후에야 그 프로그램이 후속 작업을 수행할 수 있는 방식이다.\n예) 프로그램이 CPU를 점유한 상태에서 디스크에 정보를 읽어오라는 요청을 했다. 디스크 입출력이 완료되기까지 어느 정도의 시간이 소요된다. 이 때 동기식은 입출력 작업이 완료될 때까지 다음 명령을 수행하지 않고 기다린다. 그러다가 입출력이 완료되면 인터럽트를 통해 이 사실을 대기하고 있던 CPU에게 전달하고, CPU의 제어권이 프로그램에게 넘어가서 다음 명령을 수행할 수 있다. 동기식 입출력 과정\nA process가 code 실행 중에 I/O 요청이 필요한 명령을 만나서 I/O 요청을 한다\n→ A는 CPU에게 system call이라는 SW interrupt를 발생\n→ CPU는 프로그램 A의 코드를 실행하던 일을 멈추고, 현재 상태를 프로그램의 PCB에 저장한다\n→ CPU의 제어권이 운영체제에게 넘어간다\n→ A가 입출력 연산을 요청했으므로, 운영체제가 프로세스 A를 봉쇄상태로 표시 그리고, 운영체제는 인터럽트 처리루틴 수행\n→ CPU는 컨트롤러에게 입출력 연산을 요청\n→ 컨트롤러는 A가 요청한 데이터를 디스크로부터 자신의 로컬 버퍼로 읽어온다.\nA가 직접 입출력 작업을 하는 건 아니지만, A의 요청에 의해서 하는 것이므로, 이 과정을 프로세스 A가 입출력 작업을 수행 중이라 언급한다.\n→ 컨트롤러가 읽어오는 동안 CPU를 다른 프로그램 B에 할당해 계속 CPU가 일을 할 수 있도록 한다\n→ 원하는 정보가 로컬버퍼로 다 들어오면 컨트롤러는 CPU에게 입출력이 완료되었다는 사실을 인터럽트를 발생시켜 알린다. 이 때 발생시킨 인터럽트는 하드웨어 인터럽트다\n프로세스 A가 입출력 작업을 완료했다고 언급한다.\n→ 프로그램 B를 수행 중이던 CPU는 수행하던 지점 및 상태를 process B의 PCB에 저장하고, 인터럽트를 처리\n→ 인터럽트 처리 루틴은 로컬 버퍼에 있는 A가 요청한 데이터를 A의 메모리 영역으로 읽어오고 A의 봉쇄 상태를 해제시킨다.\n→ A는 CPU를 기다리는 줄에 다시 선다\n→ 다시 B로 돌아와 업무를 중단한 지점부터 계속 진행\n→ A는 CPU를 큐에서 기다리다가 자신의 차례가 되면 CPU를 할당받고 입출력 연산 이후의 작업을 수행\n5.1.1 입출력 연산 동안 CPU를 다른 process에게 할당하는 이유 기본지식\n입출력 연산 속도는 CPU 연산 속도보다 매우 느리다. 매 시점 시스템 내에서는 하나의 입출력만 수행할 수 있다. 하지만, 동기화는 자동적으로 이뤄진다. 이유: CPU 낭비 방지를 위해서\n입출력 연산 속도는 매우 느려서 이를 수행하고 있는 프로그램이 CPU를 계속 점유하면, 프로그램의 입출력 연산이 끝날 때까지 CPU는 인터럽트를 기다리며 아무런 일을 하지 못한다. 그래서 일반적으로 프로그램이 입출력을 수행 중인 경우, CPU를 다른 프로그램에게 이양해 CPU가 쉬지 않고 일하도록 관리한다. 입출력 작업을 수행 중인 프로세스에게 CPU를 할당해도 명령을 수행하지 못하는 이유\n입출력 중인 프로그램의 상태를 봉쇄 상태(Bblocked state) 로 전환하기 때문 봉쇄 상태의 프로그램에게는 CPU를 할당하지 않고, CPU 할당 시 곧바로 명령을 수행할 수 있는 프로그램에만 CPU를 할당한다. 인터럽트를 보내면 프로그램의 상태를 봉쇄 상태로부터 해제시킨다. 5.1.2 봉쇄 해제 후, ready 상태로 큐에서 기다리는 이유 이유: 동기성 보장 = 동기화를 위해서\n입출력 수행 중일 때 다른 프로그램에게 CPU를 양도하면, 다수의 입출력 연산이 동시에 요청되거나 처리되어 동기화에 문제가 발생할 수 있다. 그래서 입출력 요청의 동기화를 위해 장치별로 큐(queue)를 두어 요청한 순서대로 처리할 수 있도록 한다. 예시\n프로그램 A가 먼저 요청했으면 이를 먼저 큐에 넣고, 그 후에 발생한 B의 요청을 A 요청 뒤에 삽입한다. 디스크 차원에서는 큐에 있는 순서대로 처리하여 동기화 문제를 해결할 수 있다. 5.1.3 Summary 동기식 입출력을 요청한 프로그램은 입출력이 완료될 때까지 다음 명령을 수행할 수 없어 CPU가 낭비된다. 그러나, CPU의 효율적인 사용을 위해 입출력이 수행하는 동안 다른 프로그램에게 CPU를 양도하면 동시에 다수의 입출력 연산이 일어날 수 있다. 그래서 다수의 프로그램이 동시에 입출력 연산을 요청하는 경우 동기성(synchronization)을 보장하기 위해 장치마다 큐를 두어 요청된 순서대로 처리할 수 있도록 한다. 5.2 비동기식 입출력(Asynchronous I/O) I/O가 시작된 후, 입출력 작업이 끝나기를 기다리지 않고 즉시 제어가 사용자 프로그램에 넘어간다. 그래서 입출력 연산과 무관한 처리 가능한 작업부터 처리한다. 6. DMA Direct Memory Access의 약어로, CPU의 중재 없이 device controller가 device의 buffer storage에 읽어오면 CPU를 대신하여 읽어온 내용을 메모리에 block 단위로 직접 복사한 후, CPU에게 interrupt를 발생시키는 장치\n왜 DMA가 필요한가??? 문제점: CPU가 interrupt로 많은 방해를 받아 효율이 많이 떨어진다. Interrupt가 발생하면 CPU는 controller의 local buffer와 memory 사이에서 데이터를 옮기는 일을 수행하는데, 만약 사용자 프로그램이 CPU를 사용하는 중에 I/O 장치가 interrupt를 많이 걸면, CPU가 많은 방해를 받아 CPU 효율이 많이 떨어진다. 해결책: DMA가 CPU를 대신하여 local buffer에서 메모리로 읽어오는 작업을 수행한다. CPU는 바이트(byte) 단위로 읽어오지만, DMA는 byte가 아닌 block이라는 큰 단위로 정보를 메모리로 읽어온 후에 CPU에게 인터럽트를 발생시켜 해당 작업의 완료를 알리기 때문에, 인터럽트의 빈도를 줄인다. 결과: DMA를 통해 CPU를 효율적으로 관리하고, 입출력 연산을 빠르게 수행 가능 메모리에는 CPU 뿐만 아니라 DMA도 접근할 수 있다는 걸 알 수 있다.\n7. 저장장치의 구조 저장장치 = 주기억장치 + 보조기억장치 주기억장치 = 메모리 = RAM with 휘발성(volatile) 보조기억장치 = 마그네틱 디스크 with 비휘발성(non-volatile) ex) 마그네틱 디스크(하드디스크), 플래시 메모리, CD, 마그네틱 테이프 보조기억장치의 용도 = file system용 + swap area용 file system용: 비휘발성 성질을 이용하여 전원이 나가도 유지해야할 정보를 파일형태로 저장하는 용도 swap area용: 메모리 한계로 메모리 연장 용도로 사용. 프로그램 수행에 필요한 부분만 메모리에 올려놓고(process), 그렇지 않은 부분은 swap area에 내려놓는다. swap area에 내려놓는 일을 swap out(스왑 아웃) 이라 한다. 비휘발성으로 사용되는 file system용과 구분 하드디스크의 물리적 구조 여러 개의 마그네틱 원판들이 회전축에 붙어있고, 원판의 표면은 track으로 나눠지고, 각 track은 sector로 나눠지며, 이 sector에 최소한의 단위 정보가 저장된다. Arm assembly에 연결된 arm이 움직이면서 head가 저장된 데이터를 읽고 쓴다. 8. 저장장치의 계층 구조 컴퓨터 시스템의 저장장치 계층 구조는 다음과 같다. 위로 올라갈수록 속도는 빨라지고, 가격은 비싸지고, 용량은 적어진다. 저장장치 = Primary(주기억장치) + Secondary(보조기억장치) Primary 적은 용량, 빠른 속도, 비싼 가격 CPU는 한 clock 당 한 instruction이 걸리지만, Main memory는 10 clock 당 한 instruction이 걸린다. 그래서 그 중간의 완충으로 cache memory를 둔다. 당장 필요한 정보를 저장 구성: 휘발성 저장장치로 구성되어, 전원이 나가면 그 내용이 사라진다. 최상위 CPU 내부에 존재하는 register부터 cache memory, main memory 등 regsiter: CPU 내부에 존재하는 작은 저장 장소 cache memory: CPU 내부에 있는 메모리로써, CPU와 main memory 간 속도 차이를 줄이기 위해 사용 Secondary 많은 용량, 느린 속도, 저렴한 가격 당장 필요하지 않은 정보 구성: 비휘발성 저장장치로 구성되어, 전원이 나가도 지워지지 않는다. Caching: copying information into faster storage system 상대적으로 용량이 적은 빠른 저장장치를 이용해 느린 저장장치의 성능을 향상하는 총체적인 기법 상대적으로 ‘느린 저장장치’ 에 있는 내용 중 당장 필요한 것만 ‘빠른 저장장치’ 에 선별적으로 복사 저장 하여 두 저장장치의 속도를 완충시킨다. 프로그램을 구성하는 모든 부분이 균일하게 사용되는 게 아니라, 일부분만 집중적으로 사용되기 때문에 적은 용량으로도 효과를 거둔다. 9. 하드웨어의 보안 하드웨어의 보안이 필요한 이유?? OS는 multi-programming 환경에서 동작하기 때문에, 프로그램 간에 충돌이나, 다른 프로그램의 실행을 방해할 수 있기 때문. Solution: 보조 장치 Mode bit 사용 Mode bit 을 통해 하드웨어적으로 두 가지 모드의 operation 지원 Mode bit == 0: kernel mode 운영체제가 CPU를 수행하는 mode 모든 종류의 명령 실행 가능 보안을 해칠 수 있는 중요 명령어는 특권명령 으로 규정 모든 I/O 명령은 특권명령이므로, kernel mode에서 실행 interrupt가 들어오면 mode bit는 0으로 setting Mode bit == 1: user mode 사용자 프로그램이 CPU를 수행하는 mode 자신의 메모리 영역 주소만 보고 수행하여, 모든 기계어 실행을 막는다. 사용자가 무한 루프로 CPU를 사용할 경우에도 timer가 있기 때문에 CPU 독점 사용 방지가능 운영체제가 CPU 제어권을 사용자 프로그램에게 넘길 때 mode bit를 1로 세팅하여 넘긴다. 전환 mechanism CPU는 보안 관련 명령을 수행하기 전에는 항상 mode bit가 0인지 확인한다. 입출력도 보안 관련 명령이므로, 사용자 프로그램이 입출력을 직접 할 수 없고, 운영체제가 한다. 그래서, 사용자 프로그램이 입출력을 하고 싶으면 sw interrupt인 system call을 CPU에 걸어서 운영체제가 CPU를 할당 받고, interrupt vector가 가리키는 위치를 통해 interrupt service routine으로 이동한다. sw interrupt를 거는 순간 mode bit 는 1에서 0으로 세팅되어 입출력 명령을 수행할 수 있다. 10. 메모리 보안 메모리 보안이 필요한 이유?? 메모리에 여러 프로그램들이 동시에 올라와 실행되기 때문에, 한 사용자 프로그램이 다른 사용자 프로그램이나 운영체제가 위치한 메모리 영역을 침범할 수 있기 때문이다. 그래서 프로세스가 합법적인 메모리 범위에 있는지 체크하는 방법을 사용한다. Solution: 기준 레지스터(base register) + 한계 레지스터(limit register) 기준 레지스터(base register) 어떤 프로그램이 수행하는 동안 그 프로그램이 합법적으로 접근할 수 있는 메모리 상의 가장 작은 주소를 보관한다. 한계 레지스터(limit register) 프로그램이 기준 레지스터값부터 접근할 수 있는 메모리의 범위를 보관 이 Solution을 어떻게 사용하는가??? 사용자 프로그램이 base register + limit register 값을 벗어나는 주소에 접근하면 불법적인 메모리 접근이므로, SW interrupt인 exception을 발생시킨다. 그래서 CPU의 제어권을 해당 프로그램으로부터 운영체제로 이양시키고, 예외상황을 발생시킨 프로그램을 강제로 종료시킨다. 메모리 보안에서 특권명령 기준 레지스터와 한계 레지스터의 값을 세팅하는 연산은 특권명령으로 규정. 메모리 접근 연산은 사용자 프로그램이 CPU를 가지고 있는 동안 수행되므로 특권명령이 아니다. kernel mode와 user mode의 메모리 접근 차이 kernel mode: 메모리에 무제한 접근 가능 user mode: base register와 limit register를 사용해서 메모리를 보호 11. CPU 보호 CPU의 독점 사용을 방지하기 위해 Timer(타이머) 라는 하드웨어를 사용한다. 사용자 프로그램이 CPU를 보유하고 있다가 정해진 시간이 흐른 뒤, 운영체제에게 제어권이 넘어가도록 interrupt를 발생시키는 하드웨어 매 clock tick 때마다 1씩 감소하다가, 0이 되면 interrupt가 발생한다. timer의 값을 setting하는 명령을 load timer 라 하며, 특권 명령 이다. timer는 시분할 시스템을 구현하기 위해서도 사용된다. 12. 시스템 콜을 이용한 입출력 수행 모든 입출력(I/O) 명령은 특권 명령(kernel 영역)에 해당한다. 그러면 사용자 프로그램은 어떻게 I/O를 하는가?? system call이라는 SW interrupt를 통하여 운영체제에게 I/O 서비스 대행 요청을 한다. 그러면 제어권이 사용자 프로그램에서 운영체제로 넘어간다. 그리고, 운영체제는 인터럽트 처리 루틴을 실행한다. 입출력 완료 시, 제어권을 사용자 프로그램에게 넘긴다. Reference 운영체제와 정보기술의 원리 kocw 이화여자대학교 운영체제 - 반효경 교수 - ","wordCount":"1475","inLanguage":"en","datePublished":"2022-04-14T14:54:58+09:00","dateModified":"2022-04-14T14:54:58+09:00","author":[{"@type":"Person","name":"Me"}],"mainEntityOfPage":{"@type":"WebPage","@id":"http://jeha00.github.io/post/os/os_chapter_03_%EC%BB%B4%ED%93%A8%ED%84%B0%EC%8B%9C%EC%8A%A4%ED%85%9C%EC%9D%98%EB%8F%99%EC%9E%91%EC%9B%90%EB%A6%AC_2/"},"publisher":{"@type":"Organization","name":"Jeha DevLog","logo":{"@type":"ImageObject","url":"http://jeha00.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=http://jeha00.github.io/ accesskey=h title="@Jeha00 (Alt + H)">@Jeha00</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></span></div><ul id=menu><li><a href=http://jeha00.github.io/me/ title=About><span>About</span></a></li><li><a href=http://jeha00.github.io/archives/ title=Archive><span>Archive</span></a></li><li><a href=http://jeha00.github.io/categories/ title=Categories><span>Categories</span></a></li><li><a href=http://jeha00.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=http://jeha00.github.io/>Home</a>&nbsp;»&nbsp;<a href=http://jeha00.github.io/post/>Posts</a></div><h1 class=post-title>[TIL] Chapter 03: 컴퓨터 시스템의 동작원리 2</h1><div class=post-meta>OS&nbsp;·&nbsp;<span title='2022-04-14 14:54:58 +0900 KST'>April 14, 2022</span>&nbsp;·&nbsp;Me</div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#0-introduction aria-label="0. Introduction">0. Introduction</a></li><li><a href=#5-%ec%9e%85%ec%b6%9c%eb%a0%a5-%ea%b5%ac%ec%a1%b0 aria-label="5. 입출력 구조">5. 입출력 구조</a><ul><li><a href=#51-%eb%8f%99%ea%b8%b0%ec%8b%9d-%ec%9e%85%ec%b6%9c%eb%a0%a5synchronous-io aria-label="5.1 동기식 입출력(Synchronous I/O)">5.1 동기식 입출력(Synchronous I/O)</a><ul><li><a href=#511-%ec%9e%85%ec%b6%9c%eb%a0%a5-%ec%97%b0%ec%82%b0-%eb%8f%99%ec%95%88-cpu%eb%a5%bc-%eb%8b%a4%eb%a5%b8-process%ec%97%90%ea%b2%8c-%ed%95%a0%eb%8b%b9%ed%95%98%eb%8a%94-%ec%9d%b4%ec%9c%a0 aria-label="5.1.1 입출력 연산 동안 CPU를 다른 process에게 할당하는 이유">5.1.1 입출력 연산 동안 CPU를 다른 process에게 할당하는 이유</a></li><li><a href=#512-%eb%b4%89%ec%87%84-%ed%95%b4%ec%a0%9c-%ed%9b%84-ready-%ec%83%81%ed%83%9c%eb%a1%9c-%ed%81%90%ec%97%90%ec%84%9c-%ea%b8%b0%eb%8b%a4%eb%a6%ac%eb%8a%94-%ec%9d%b4%ec%9c%a0 aria-label="5.1.2 봉쇄 해제 후, ready 상태로 큐에서 기다리는 이유">5.1.2 봉쇄 해제 후, ready 상태로 큐에서 기다리는 이유</a></li><li><a href=#513-summary aria-label="5.1.3 Summary">5.1.3 Summary</a></li></ul></li><li><a href=#52-%eb%b9%84%eb%8f%99%ea%b8%b0%ec%8b%9d-%ec%9e%85%ec%b6%9c%eb%a0%a5asynchronous-io aria-label="5.2 비동기식 입출력(Asynchronous I/O)">5.2 비동기식 입출력(Asynchronous I/O)</a></li></ul></li><li><a href=#6-dma aria-label="6. DMA">6. DMA</a></li><li><a href=#7-%ec%a0%80%ec%9e%a5%ec%9e%a5%ec%b9%98%ec%9d%98-%ea%b5%ac%ec%a1%b0 aria-label="7. 저장장치의 구조">7. 저장장치의 구조</a></li><li><a href=#8-%ec%a0%80%ec%9e%a5%ec%9e%a5%ec%b9%98%ec%9d%98-%ea%b3%84%ec%b8%b5-%ea%b5%ac%ec%a1%b0 aria-label="8. 저장장치의 계층 구조">8. 저장장치의 계층 구조</a></li><li><a href=#9-%ed%95%98%eb%93%9c%ec%9b%a8%ec%96%b4%ec%9d%98-%eb%b3%b4%ec%95%88 aria-label="9. 하드웨어의 보안">9. 하드웨어의 보안</a></li><li><a href=#10-%eb%a9%94%eb%aa%a8%eb%a6%ac-%eb%b3%b4%ec%95%88 aria-label="10. 메모리 보안">10. 메모리 보안</a></li><li><a href=#11-cpu-%eb%b3%b4%ed%98%b8 aria-label="11. CPU 보호">11. CPU 보호</a></li><li><a href=#12-%ec%8b%9c%ec%8a%a4%ed%85%9c-%ec%bd%9c%ec%9d%84-%ec%9d%b4%ec%9a%a9%ed%95%9c-%ec%9e%85%ec%b6%9c%eb%a0%a5-%ec%88%98%ed%96%89 aria-label="12. 시스템 콜을 이용한 입출력 수행">12. 시스템 콜을 이용한 입출력 수행</a></li><li><a href=#reference aria-label=Reference>Reference</a></li></ul></div></details></div><div class=post-content><h1 id=0-introduction>0. Introduction<a hidden class=anchor aria-hidden=true href=#0-introduction>#</a></h1><ul><li>해당 내용은 <a href="http://www.kyobobook.co.kr/product/detailViewKor.laf?ejkGb=KOR&mallGb=KOR&barcode=9791158903589&orderClick=LAG&Kc=">운영체제와 정보기술의 원리 -반효경 지음-</a> 와 <a href="http://www.kocw.net/home/cview.do?lid=3dd1117c48123b8e">kocw 이화여자대학교 운영체제 - 반효경 교수 -</a>를 보고 정리한 내용입니다.</li><li>정확하지 않은 내용이 있다면 말씀해주시면 감사하겠습니다.</li></ul><p> </p><hr><h1 id=5-입출력-구조>5. 입출력 구조<a hidden class=anchor aria-hidden=true href=#5-입출력-구조>#</a></h1><ul><li>CPU의 명령 수행 속도는 빠르지만, 입출력 연산은 매우 느리다.</li><li>이 입출력 방식에는 <strong><em>동기식 입출력</em></strong> 과 <strong><em>비동기식 입출력</em></strong> 이 있다.</li></ul><h2 id=51-동기식-입출력synchronous-io>5.1 동기식 입출력(Synchronous I/O)<a hidden class=anchor aria-hidden=true href=#51-동기식-입출력synchronous-io>#</a></h2><ul><li><p>일반적으로 사용하는 방식으로 어떤 프로그램이 입출력했을 때, <strong><em>입출력 작업이 완료된 후에야</em></strong> 그 프로그램이 후속 작업을 수행할 수 있는 방식이다.</p><ul><li>예) 프로그램이 CPU를 점유한 상태에서 디스크에 정보를 읽어오라는 요청을 했다. 디스크 입출력이 완료되기까지 어느 정도의 시간이 소요된다. 이 때 <strong><em>동기식은 입출력 작업이 완료될 때까지 다음 명령을 수행하지 않고 기다린다</em></strong>. 그러다가 입출력이 완료되면 인터럽트를 통해 이 사실을 대기하고 있던 CPU에게 전달하고, CPU의 제어권이 프로그램에게 넘어가서 다음 명령을 수행할 수 있다.</li></ul></li><li><p><strong><em>동기식 입출력 과정</em></strong></p><p>A process가 code 실행 중에 I/O 요청이 필요한 명령을 만나서 I/O 요청을 한다<br>→ A는 CPU에게 system call이라는 SW interrupt를 발생<br>→ CPU는 프로그램 A의 코드를 실행하던 일을 멈추고, 현재 상태를 프로그램의 PCB에 저장한다<br>→ CPU의 제어권이 운영체제에게 넘어간다<br>→ A가 입출력 연산을 요청했으므로, 운영체제가 프로세스 A를 봉쇄상태로 표시 그리고, 운영체제는 인터럽트 처리루틴 수행<br>→ CPU는 컨트롤러에게 입출력 연산을 요청<br>→ 컨트롤러는 A가 요청한 데이터를 디스크로부터 자신의 로컬 버퍼로 읽어온다.</p><blockquote><p><strong><em>A가 직접 입출력 작업을 하는 건 아니지만, A의 요청에 의해서 하는 것이므로, 이 과정을 프로세스 A가 입출력 작업을 수행 중이라 언급한다.</em></strong></p></blockquote><p>→ 컨트롤러가 읽어오는 동안 CPU를 다른 프로그램 B에 할당해 계속 CPU가 일을 할 수 있도록 한다<br>→ 원하는 정보가 로컬버퍼로 다 들어오면 컨트롤러는 CPU에게 입출력이 완료되었다는 사실을 인터럽트를 발생시켜 알린다. 이 때 발생시킨 인터럽트는 하드웨어 인터럽트다</p><blockquote><p><strong><em>프로세스 A가 입출력 작업을 완료했다고 언급한다.</em></strong></p></blockquote><p>→ 프로그램 B를 수행 중이던 CPU는 수행하던 지점 및 상태를 process B의 PCB에 저장하고, 인터럽트를 처리<br>→ 인터럽트 처리 루틴은 로컬 버퍼에 있는 A가 요청한 데이터를 A의 메모리 영역으로 읽어오고 A의 봉쇄 상태를 해제시킨다.<br>→ A는 CPU를 기다리는 줄에 다시 선다<br>→ 다시 B로 돌아와 업무를 중단한 지점부터 계속 진행<br>→ A는 CPU를 큐에서 기다리다가 자신의 차례가 되면 CPU를 할당받고 입출력 연산 이후의 작업을 수행</p></li></ul><p> </p><h3 id=511-입출력-연산-동안-cpu를-다른-process에게-할당하는-이유>5.1.1 입출력 연산 동안 CPU를 다른 process에게 할당하는 이유<a hidden class=anchor aria-hidden=true href=#511-입출력-연산-동안-cpu를-다른-process에게-할당하는-이유>#</a></h3><ul><li><p><strong><em>기본지식</em></strong></p><ul><li>입출력 연산 속도는 CPU 연산 속도보다 매우 느리다.</li><li>매 시점 시스템 내에서는 하나의 입출력만 수행할 수 있다. 하지만, 동기화는 자동적으로 이뤄진다.</li></ul></li><li><p><strong><em>이유: CPU 낭비 방지를 위해서</em></strong></p><ul><li><em>입출력 연산 속도는 매우 느려서 이를 수행하고 있는 프로그램이 CPU를 계속 점유하면, 프로그램의 입출력 연산이 끝날 때까지 CPU는 인터럽트를 기다리며 아무런 일을 하지 못한다. 그래서 일반적으로 프로그램이 입출력을 수행 중인 경우, CPU를 다른 프로그램에게 이양해 CPU가 쉬지 않고 일하도록 관리한다.</em></li></ul></li><li><p><strong><em>입출력 작업을 수행 중인 프로세스에게 CPU를 할당해도 명령을 수행하지 못하는 이유</em></strong></p><ul><li>입출력 중인 프로그램의 상태를 <strong><em>봉쇄 상태(Bblocked state)</em></strong> 로 전환하기 때문</li><li>봉쇄 상태의 프로그램에게는 CPU를 할당하지 않고, CPU 할당 시 곧바로 명령을 수행할 수 있는 프로그램에만 CPU를 할당한다.</li><li>인터럽트를 보내면 프로그램의 상태를 봉쇄 상태로부터 해제시킨다.</li></ul></li></ul><p> </p><h3 id=512-봉쇄-해제-후-ready-상태로-큐에서-기다리는-이유>5.1.2 봉쇄 해제 후, ready 상태로 큐에서 기다리는 이유<a hidden class=anchor aria-hidden=true href=#512-봉쇄-해제-후-ready-상태로-큐에서-기다리는-이유>#</a></h3><ul><li><p><strong><em>이유: 동기성 보장 = 동기화를 위해서</em></strong></p><ul><li><em>입출력 수행 중일 때 다른 프로그램에게 CPU를 양도하면, 다수의 입출력 연산이 동시에 요청되거나 처리되어 동기화에 문제가 발생할 수 있다.</em></li><li><em>그래서 입출력 요청의 동기화를 위해 장치별로 큐(queue)를 두어 요청한 순서대로 처리할 수 있도록 한다.</em></li></ul></li><li><p><strong><em>예시</em></strong></p><ul><li>프로그램 A가 먼저 요청했으면 이를 먼저 큐에 넣고, 그 후에 발생한 B의 요청을 A 요청 뒤에 삽입한다. 디스크 차원에서는 큐에 있는 순서대로 처리하여 동기화 문제를 해결할 수 있다.</li></ul></li></ul><p> </p><h3 id=513-summary>5.1.3 Summary<a hidden class=anchor aria-hidden=true href=#513-summary>#</a></h3><ul><li>동기식 입출력을 요청한 프로그램은 입출력이 완료될 때까지 다음 명령을 수행할 수 없어 CPU가 낭비된다.</li><li>그러나, CPU의 효율적인 사용을 위해 입출력이 수행하는 동안 다른 프로그램에게 CPU를 양도하면 동시에 다수의 입출력 연산이 일어날 수 있다.</li><li>그래서 다수의 프로그램이 동시에 입출력 연산을 요청하는 경우 동기성(synchronization)을 보장하기 위해 장치마다 큐를 두어 요청된 순서대로 처리할 수 있도록 한다.</li></ul><p> </p><h2 id=52-비동기식-입출력asynchronous-io>5.2 비동기식 입출력(Asynchronous I/O)<a hidden class=anchor aria-hidden=true href=#52-비동기식-입출력asynchronous-io>#</a></h2><ul><li>I/O가 시작된 후, 입출력 작업이 끝나기를 기다리지 않고 즉시 제어가 사용자 프로그램에 넘어간다.</li><li>그래서 입출력 연산과 무관한 처리 가능한 작업부터 처리한다.</li></ul><p> </p><hr><h1 id=6-dma>6. DMA<a hidden class=anchor aria-hidden=true href=#6-dma>#</a></h1><blockquote><p><strong><em>Direct Memory Access의 약어로, CPU의 중재 없이 device controller가 device의 buffer storage에 읽어오면 CPU를 대신하여 읽어온 내용을 메모리에 block 단위로 직접 복사한 후, CPU에게 interrupt를 발생시키는 장치</em></strong></p></blockquote><ul><li><strong><em>왜 DMA가 필요한가???</em></strong><ul><li>문제점: CPU가 interrupt로 많은 방해를 받아 효율이 많이 떨어진다.<ul><li>Interrupt가 발생하면 CPU는 controller의 local buffer와 memory 사이에서 데이터를 옮기는 일을 수행하는데, 만약 사용자 프로그램이 CPU를 사용하는 중에 I/O 장치가 interrupt를 많이 걸면, CPU가 많은 방해를 받아 CPU 효율이 많이 떨어진다.</li></ul></li><li>해결책: DMA가 CPU를 대신하여 local buffer에서 메모리로 읽어오는 작업을 수행한다.<ul><li>CPU는 바이트(byte) 단위로 읽어오지만, DMA는 <strong>byte가 아닌 block이라는 큰 단위로 정보를 메모리로 읽어온 후에</strong> CPU에게 인터럽트를 발생시켜 해당 작업의 완료를 알리기 때문에, <strong>인터럽트의 빈도를 줄인다.</strong></li></ul></li><li>결과: <strong><em>DMA를 통해 CPU를 효율적으로 관리하고, 입출력 연산을 빠르게 수행 가능</em></strong></li></ul></li></ul><blockquote><p><strong><em>메모리에는 CPU 뿐만 아니라 DMA도 접근할 수 있다는 걸 알 수 있다.</em></strong></p></blockquote><p> </p><hr><h1 id=7-저장장치의-구조>7. 저장장치의 구조<a hidden class=anchor aria-hidden=true href=#7-저장장치의-구조>#</a></h1><ul><li><strong><em>저장장치</em></strong> = 주기억장치 + 보조기억장치</li><li><strong><em>주기억장치</em></strong> = 메모리 = RAM with 휘발성(volatile)</li><li><strong><em>보조기억장치</em></strong> = 마그네틱 디스크 with 비휘발성(non-volatile)<ul><li>ex) 마그네틱 디스크(하드디스크), 플래시 메모리, CD, 마그네틱 테이프</li><li>보조기억장치의 용도 = file system용 + swap area용<ul><li>file system용:<ul><li>비휘발성 성질을 이용하여 전원이 나가도 유지해야할 정보를 파일형태로 저장하는 용도</li></ul></li><li><strong>swap area</strong>용:<ul><li>메모리 한계로 메모리 연장 용도로 사용.</li><li>프로그램 수행에 필요한 부분만 메모리에 올려놓고(process), 그렇지 않은 부분은 swap area에 내려놓는다.</li><li>swap area에 내려놓는 일을 <strong>swap out(스왑 아웃)</strong> 이라 한다.</li><li>비휘발성으로 사용되는 file system용과 구분</li></ul></li></ul></li></ul></li><li><strong><em>하드디스크의 물리적 구조</em></strong><ul><li>여러 개의 <strong>마그네틱 원판</strong>들이 회전축에 붙어있고,</li><li>원판의 표면은 <strong>track</strong>으로 나눠지고,</li><li>각 track은 <strong>sector</strong>로 나눠지며, 이 sector에 <strong>최소한의 단위 정보</strong>가 저장된다.</li><li>Arm assembly에 연결된 arm이 움직이면서 head가 저장된 데이터를 읽고 쓴다.</li></ul></li></ul><p> </p><hr><h1 id=8-저장장치의-계층-구조>8. 저장장치의 계층 구조<a hidden class=anchor aria-hidden=true href=#8-저장장치의-계층-구조>#</a></h1><ul><li>컴퓨터 시스템의 저장장치 계층 구조는 다음과 같다.<ul><li>위로 올라갈수록 속도는 빨라지고, 가격은 비싸지고, 용량은 적어진다.</li></ul></li></ul><p><img loading=lazy src="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FdPTp8O%2Fbtrp5zc8nw9%2FjmnWtXtTRsEsMEIexcbwy1%2Fimg.png" alt=image></p><ul><li><strong><em>저장장치 = Primary(주기억장치) + Secondary(보조기억장치)</em></strong></li><li><strong><em>Primary</em></strong><ul><li>적은 용량, 빠른 속도, 비싼 가격<ul><li>CPU는 한 clock 당 한 instruction이 걸리지만, Main memory는 10 clock 당 한 instruction이 걸린다. 그래서 그 중간의 완충으로 cache memory를 둔다.</li></ul></li><li>당장 필요한 정보를 저장</li><li>구성: 휘발성 저장장치로 구성되어, 전원이 나가면 그 내용이 사라진다.<ul><li>최상위 CPU 내부에 존재하는 register부터 cache memory, main memory 등</li><li>regsiter: CPU 내부에 존재하는 작은 저장 장소</li><li>cache memory: CPU 내부에 있는 메모리로써, CPU와 main memory 간 속도 차이를 줄이기 위해 사용</li></ul></li></ul></li><li><strong><em>Secondary</em></strong><ul><li>많은 용량, 느린 속도, 저렴한 가격</li><li>당장 필요하지 않은 정보</li><li>구성: 비휘발성 저장장치로 구성되어, 전원이 나가도 지워지지 않는다.</li></ul></li><li><strong><em>Caching</em></strong>: copying information into faster storage system<ul><li>상대적으로 용량이 적은 빠른 저장장치를 이용해 느린 저장장치의 성능을 향상하는 총체적인 기법</li><li>상대적으로 ‘느린 저장장치’ 에 있는 내용 중 당장 필요한 것만 ‘빠른 저장장치’ 에 <strong><em>선별적으로 복사 저장</em></strong> 하여 두 저장장치의 속도를 완충시킨다.</li><li>프로그램을 구성하는 모든 부분이 균일하게 사용되는 게 아니라, 일부분만 집중적으로 사용되기 때문에 적은 용량으로도 효과를 거둔다.</li></ul></li></ul><h1 id=9-하드웨어의-보안>9. 하드웨어의 보안<a hidden class=anchor aria-hidden=true href=#9-하드웨어의-보안>#</a></h1><ul><li><em>하드웨어의 보안이 필요한 이유??</em><ul><li>OS는 multi-programming 환경에서 동작하기 때문에, 프로그램 간에 충돌이나, 다른 프로그램의 실행을 방해할 수 있기 때문.</li></ul></li><li><em>Solution: 보조 장치 Mode bit 사용</em><ul><li><strong>Mode bit</strong> 을 통해 하드웨어적으로 두 가지 모드의 <strong>operation</strong> 지원</li><li><em>Mode bit == 0: kernel mode</em><ul><li>운영체제가 CPU를 수행하는 mode</li><li><strong>모든 종류의 명령</strong> 실행 가능</li><li>보안을 해칠 수 있는 중요 명령어는 <code>특권명령</code> 으로 규정</li><li>모든 I/O 명령은 <code>특권명령</code>이므로, kernel mode에서 실행</li><li>interrupt가 들어오면 mode bit는 0으로 setting</li></ul></li><li><em>Mode bit == 1: user mode</em><ul><li>사용자 프로그램이 CPU를 수행하는 mode</li><li>자신의 메모리 영역 주소만 보고 수행하여, 모든 기계어 실행을 막는다.</li><li>사용자가 무한 루프로 CPU를 사용할 경우에도 timer가 있기 때문에 CPU 독점 사용 방지가능</li><li>운영체제가 CPU 제어권을 사용자 프로그램에게 넘길 때 mode bit를 1로 세팅하여 넘긴다.</li></ul></li></ul></li><li><em>전환 mechanism</em><ul><li>CPU는 보안 관련 명령을 수행하기 전에는 항상 mode bit가 0인지 확인한다.</li><li>입출력도 보안 관련 명령이므로, 사용자 프로그램이 입출력을 직접 할 수 없고, 운영체제가 한다.</li><li>그래서, 사용자 프로그램이 입출력을 하고 싶으면 sw interrupt인 system call을 CPU에 걸어서 운영체제가 CPU를 할당 받고, interrupt vector가 가리키는 위치를 통해 interrupt service routine으로 이동한다.</li><li>sw interrupt를 거는 순간 mode bit 는 1에서 0으로 세팅되어 입출력 명령을 수행할 수 있다.</li></ul></li></ul><p><img loading=lazy src=https://user-images.githubusercontent.com/78094972/163322482-5e78c22d-f94e-4022-9839-b6c826446b73.PNG alt=image></p><p> </p><hr><h1 id=10-메모리-보안>10. 메모리 보안<a hidden class=anchor aria-hidden=true href=#10-메모리-보안>#</a></h1><ul><li>메모리 보안이 필요한 이유??<ul><li>메모리에 여러 프로그램들이 동시에 올라와 실행되기 때문에, 한 사용자 프로그램이 다른 사용자 프로그램이나 운영체제가 위치한 메모리 영역을 침범할 수 있기 때문이다.</li><li>그래서 프로세스가 합법적인 메모리 범위에 있는지 체크하는 방법을 사용한다.</li></ul></li><li><strong><em>Solution: 기준 레지스터(base register) + 한계 레지스터(limit register)</em></strong><ul><li><strong>기준 레지스터(base register)</strong><ul><li>어떤 프로그램이 수행하는 동안 그 프로그램이 합법적으로 접근할 수 있는 메모리 상의 가장 작은 주소를 보관한다.</li></ul></li><li><strong>한계 레지스터(limit register)</strong><ul><li>프로그램이 기준 레지스터값부터 접근할 수 있는 메모리의 범위를 보관</li></ul></li></ul></li><li><strong><em>이 Solution을 어떻게 사용하는가???</em></strong><ul><li>사용자 프로그램이 base register + limit register 값을 벗어나는 주소에 접근하면 <strong>불법적인 메모리 접근이므로, SW interrupt인 exception을 발생</strong>시킨다.</li><li>그래서 CPU의 제어권을 해당 프로그램으로부터 운영체제로 이양시키고, 예외상황을 발생시킨 프로그램을 강제로 종료시킨다.</li></ul></li><li>메모리 보안에서 특권명령<ul><li>기준 레지스터와 한계 레지스터의 <strong>값을 세팅하는 연산</strong>은 <strong>특권명령</strong>으로 규정.</li><li><strong>메모리 접근 연산</strong>은 사용자 프로그램이 CPU를 가지고 있는 동안 수행되므로 특권명령이 아니다.</li></ul></li><li>kernel mode와 user mode의 메모리 접근 차이<ul><li>kernel mode: 메모리에 무제한 접근 가능</li><li>user mode: base register와 limit register를 사용해서 메모리를 보호</li></ul></li></ul><p><img loading=lazy src=https://images.velog.io/images/jehjong/post/2393e5ae-7318-4b41-8879-da6d2cfc0df1/image.png alt=image></p><p> </p><hr><h1 id=11-cpu-보호>11. CPU 보호<a hidden class=anchor aria-hidden=true href=#11-cpu-보호>#</a></h1><ul><li>CPU의 독점 사용을 방지하기 위해 <strong>Timer(타이머) 라는 하드웨어</strong>를 사용한다.<ul><li>사용자 프로그램이 CPU를 보유하고 있다가 정해진 시간이 흐른 뒤, 운영체제에게 제어권이 넘어가도록 interrupt를 발생시키는 하드웨어</li><li>매 clock tick 때마다 1씩 감소하다가, 0이 되면 interrupt가 발생한다.</li></ul></li><li>timer의 값을 setting하는 명령을 <strong><em>load timer</em></strong> 라 하며, <code>특권 명령</code> 이다.</li><li>timer는 시분할 시스템을 구현하기 위해서도 사용된다.</li></ul><p> </p><hr><h1 id=12-시스템-콜을-이용한-입출력-수행>12. 시스템 콜을 이용한 입출력 수행<a hidden class=anchor aria-hidden=true href=#12-시스템-콜을-이용한-입출력-수행>#</a></h1><ul><li>모든 입출력(I/O) 명령은 특권 명령(kernel 영역)에 해당한다.</li><li>그러면 사용자 프로그램은 어떻게 I/O를 하는가??<ul><li>system call이라는 SW interrupt를 통하여 운영체제에게 I/O 서비스 대행 요청을 한다.</li><li>그러면 제어권이 사용자 프로그램에서 운영체제로 넘어간다.</li><li>그리고, 운영체제는 인터럽트 처리 루틴을 실행한다.</li><li>입출력 완료 시, 제어권을 사용자 프로그램에게 넘긴다.</li></ul></li></ul><p> </p><hr><h1 id=reference>Reference<a hidden class=anchor aria-hidden=true href=#reference>#</a></h1><ul><li><a href="http://www.kyobobook.co.kr/product/detailViewKor.laf?ejkGb=KOR&mallGb=KOR&barcode=9791158903589&orderClick=LAG&Kc=">운영체제와 정보기술의 원리</a></li><li><a href="http://www.kocw.net/home/cview.do?lid=3dd1117c48123b8e">kocw 이화여자대학교 운영체제 - 반효경 교수 -</a></li></ul></div><footer class=post-footer><ul class=post-tags><li><a href=http://jeha00.github.io/tags/til/>TIL</a></li><li><a href=http://jeha00.github.io/tags/os/>OS</a></li></ul><nav class=paginav><a class=prev href=http://jeha00.github.io/post/os/os_chapter_04_%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%A8%EC%9D%98%EA%B5%AC%EC%A1%B0%EC%99%80%EC%8B%A4%ED%96%89/><span class=title>« Prev Page</span><br><span>[TIL] Chapter 04: 프로그램의 구조와 실행</span></a>
<a class=next href=http://jeha00.github.io/post/os/os_chapter_03_%EC%BB%B4%ED%93%A8%ED%84%B0%EC%8B%9C%EC%8A%A4%ED%85%9C%EC%9D%98%EB%8F%99%EC%9E%91%EC%9B%90%EB%A6%AC_1/><span class=title>Next Page »</span><br><span>[TIL] Chapter 03: 컴퓨터 시스템의 동작원리 1</span></a></nav><div class=share-buttons><a target=_blank rel="noopener noreferrer" aria-label="share [TIL] Chapter 03: 컴퓨터 시스템의 동작원리 2 on twitter" href="https://twitter.com/intent/tweet/?text=%5bTIL%5d%20Chapter%2003%3a%20%ec%bb%b4%ed%93%a8%ed%84%b0%20%ec%8b%9c%ec%8a%a4%ed%85%9c%ec%9d%98%20%eb%8f%99%ec%9e%91%ec%9b%90%eb%a6%ac%202&url=http%3a%2f%2fjeha00.github.io%2fpost%2fos%2fos_chapter_03_%25EC%25BB%25B4%25ED%2593%25A8%25ED%2584%25B0%25EC%258B%259C%25EC%258A%25A4%25ED%2585%259C%25EC%259D%2598%25EB%258F%2599%25EC%259E%2591%25EC%259B%2590%25EB%25A6%25AC_2%2f&hashtags=TIL%2cOS"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM195.519 424.544c135.939.0 210.268-112.643 210.268-210.268.0-3.218.0-6.437-.153-9.502 14.406-10.421 26.973-23.448 36.935-38.314-13.18 5.824-27.433 9.809-42.452 11.648 15.326-9.196 26.973-23.602 32.49-40.92-14.252 8.429-30.038 14.56-46.896 17.931-13.487-14.406-32.644-23.295-53.946-23.295-40.767.0-73.87 33.104-73.87 73.87.0 5.824.613 11.494 1.992 16.858-61.456-3.065-115.862-32.49-152.337-77.241-6.284 10.881-9.962 23.601-9.962 37.088.0 25.594 13.027 48.276 32.95 61.456-12.107-.307-23.448-3.678-33.41-9.196v.92c0 35.862 25.441 65.594 59.311 72.49-6.13 1.686-12.72 2.606-19.464 2.606-4.751.0-9.348-.46-13.946-1.38 9.349 29.426 36.628 50.728 68.965 51.341-25.287 19.771-57.164 31.571-91.8 31.571-5.977.0-11.801-.306-17.625-1.073 32.337 21.15 71.264 33.41 112.95 33.41z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share [TIL] Chapter 03: 컴퓨터 시스템의 동작원리 2 on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&url=http%3a%2f%2fjeha00.github.io%2fpost%2fos%2fos_chapter_03_%25EC%25BB%25B4%25ED%2593%25A8%25ED%2584%25B0%25EC%258B%259C%25EC%258A%25A4%25ED%2585%259C%25EC%259D%2598%25EB%258F%2599%25EC%259E%2591%25EC%259B%2590%25EB%25A6%25AC_2%2f&title=%5bTIL%5d%20Chapter%2003%3a%20%ec%bb%b4%ed%93%a8%ed%84%b0%20%ec%8b%9c%ec%8a%a4%ed%85%9c%ec%9d%98%20%eb%8f%99%ec%9e%91%ec%9b%90%eb%a6%ac%202&summary=%5bTIL%5d%20Chapter%2003%3a%20%ec%bb%b4%ed%93%a8%ed%84%b0%20%ec%8b%9c%ec%8a%a4%ed%85%9c%ec%9d%98%20%eb%8f%99%ec%9e%91%ec%9b%90%eb%a6%ac%202&source=http%3a%2f%2fjeha00.github.io%2fpost%2fos%2fos_chapter_03_%25EC%25BB%25B4%25ED%2593%25A8%25ED%2584%25B0%25EC%258B%259C%25EC%258A%25A4%25ED%2585%259C%25EC%259D%2598%25EB%258F%2599%25EC%259E%2591%25EC%259B%2590%25EB%25A6%25AC_2%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share [TIL] Chapter 03: 컴퓨터 시스템의 동작원리 2 on reddit" href="https://reddit.com/submit?url=http%3a%2f%2fjeha00.github.io%2fpost%2fos%2fos_chapter_03_%25EC%25BB%25B4%25ED%2593%25A8%25ED%2584%25B0%25EC%258B%259C%25EC%258A%25A4%25ED%2585%259C%25EC%259D%2598%25EB%258F%2599%25EC%259E%2591%25EC%259B%2590%25EB%25A6%25AC_2%2f&title=%5bTIL%5d%20Chapter%2003%3a%20%ec%bb%b4%ed%93%a8%ed%84%b0%20%ec%8b%9c%ec%8a%a4%ed%85%9c%ec%9d%98%20%eb%8f%99%ec%9e%91%ec%9b%90%eb%a6%ac%202"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share [TIL] Chapter 03: 컴퓨터 시스템의 동작원리 2 on facebook" href="https://facebook.com/sharer/sharer.php?u=http%3a%2f%2fjeha00.github.io%2fpost%2fos%2fos_chapter_03_%25EC%25BB%25B4%25ED%2593%25A8%25ED%2584%25B0%25EC%258B%259C%25EC%258A%25A4%25ED%2585%259C%25EC%259D%2598%25EB%258F%2599%25EC%259E%2591%25EC%259B%2590%25EB%25A6%25AC_2%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share [TIL] Chapter 03: 컴퓨터 시스템의 동작원리 2 on whatsapp" href="https://api.whatsapp.com/send?text=%5bTIL%5d%20Chapter%2003%3a%20%ec%bb%b4%ed%93%a8%ed%84%b0%20%ec%8b%9c%ec%8a%a4%ed%85%9c%ec%9d%98%20%eb%8f%99%ec%9e%91%ec%9b%90%eb%a6%ac%202%20-%20http%3a%2f%2fjeha00.github.io%2fpost%2fos%2fos_chapter_03_%25EC%25BB%25B4%25ED%2593%25A8%25ED%2584%25B0%25EC%258B%259C%25EC%258A%25A4%25ED%2585%259C%25EC%259D%2598%25EB%258F%2599%25EC%259E%2591%25EC%259B%2590%25EB%25A6%25AC_2%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share [TIL] Chapter 03: 컴퓨터 시스템의 동작원리 2 on telegram" href="https://telegram.me/share/url?text=%5bTIL%5d%20Chapter%2003%3a%20%ec%bb%b4%ed%93%a8%ed%84%b0%20%ec%8b%9c%ec%8a%a4%ed%85%9c%ec%9d%98%20%eb%8f%99%ec%9e%91%ec%9b%90%eb%a6%ac%202&url=http%3a%2f%2fjeha00.github.io%2fpost%2fos%2fos_chapter_03_%25EC%25BB%25B4%25ED%2593%25A8%25ED%2584%25B0%25EC%258B%259C%25EC%258A%25A4%25ED%2585%259C%25EC%259D%2598%25EB%258F%2599%25EC%259E%2591%25EC%259B%2590%25EB%25A6%25AC_2%2f"><svg viewBox="2 2 28 28"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></div></footer></article></main><footer class=footer><span>&copy; 2024 <a href=http://jeha00.github.io/>Jeha DevLog</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerText="copy";function s(){t.innerText="copied!",setTimeout(()=>{t.innerText="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>