<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>[TIL] OS Chapter 07: 메모리 관리 2 | Jeha DevLog</title><meta name=keywords content="TIL,OS"><meta name=description content="불연속 할당 방법인 pagin 기법, segmentation 기법, paged segmentation 기법에 대해 알아본다."><meta name=author content><link rel=canonical href=http://jeha00.github.io/post/os/os_chapter_07_%EB%A9%94%EB%AA%A8%EB%A6%AC%EA%B4%80%EB%A6%AC_2/><meta name=google-site-verification content="XYZabc"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.min.1e44d58192cbf6d7a4eb649bc43dbc3d4cc432677e5d8adc69b08c34cbe461ac.css integrity="sha256-HkTVgZLL9tek62SbxD28PUzEMmd+XYrcabCMNMvkYaw=" rel="preload stylesheet" as=style><link rel=icon href=http://jeha00.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=http://jeha00.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=http://jeha00.github.io/favicon-32x32.png><link rel=apple-touch-icon href=http://jeha00.github.io/apple-touch-icon.png><link rel=mask-icon href=http://jeha00.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><meta name=generator content="Hugo 0.101.0"><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><script type=application/javascript>var doNotTrack=!1;doNotTrack||(function(e,t,n,s,o,i,a){e.GoogleAnalyticsObject=o,e[o]=e[o]||function(){(e[o].q=e[o].q||[]).push(arguments)},e[o].l=1*new Date,i=t.createElement(n),a=t.getElementsByTagName(n)[0],i.async=1,i.src=s,a.parentNode.insertBefore(i,a)}(window,document,"script","https://www.google-analytics.com/analytics.js","ga"),ga("create","UA-123-45","auto"),ga("send","pageview"))</script><meta property="og:title" content="[TIL] OS Chapter 07: 메모리 관리 2"><meta property="og:description" content="불연속 할당 방법인 pagin 기법, segmentation 기법, paged segmentation 기법에 대해 알아본다."><meta property="og:type" content="article"><meta property="og:url" content="http://jeha00.github.io/post/os/os_chapter_07_%EB%A9%94%EB%AA%A8%EB%A6%AC%EA%B4%80%EB%A6%AC_2/"><meta property="og:image" content="http://jeha00.github.io/47"><meta property="article:section" content="post"><meta property="article:published_time" content="2022-04-28T16:13:57+09:00"><meta property="article:modified_time" content="2022-04-28T16:13:57+09:00"><meta property="og:site_name" content="JeHa00 DevLog"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="http://jeha00.github.io/47"><meta name=twitter:title content="[TIL] OS Chapter 07: 메모리 관리 2"><meta name=twitter:description content="불연속 할당 방법인 pagin 기법, segmentation 기법, paged segmentation 기법에 대해 알아본다."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"http://jeha00.github.io/post/"},{"@type":"ListItem","position":2,"name":"[TIL] OS Chapter 07: 메모리 관리 2","item":"http://jeha00.github.io/post/os/os_chapter_07_%EB%A9%94%EB%AA%A8%EB%A6%AC%EA%B4%80%EB%A6%AC_2/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"[TIL] OS Chapter 07: 메모리 관리 2","name":"[TIL] OS Chapter 07: 메모리 관리 2","description":"불연속 할당 방법인 pagin 기법, segmentation 기법, paged segmentation 기법에 대해 알아본다.","keywords":["TIL","OS"],"articleBody":"0. Introduction 해당 내용은 운영체제와 정보기술의 원리 -반효경 지음- 와 kocw 이화여자대학교 운영체제 - 반효경 교수 -를 보고 정리한 내용이다. 정확하지 않은 내용이 있다면 말씀해주시면 감사하겠습니다. 이번 chapter 내용인 메모리 관리는 물리적인 메모리 관리로, 주요 내용은 address binding이다. address binding에서의 OS의 역할은 없고, 다 HW가 해야한다. address binding을 할 때마다 OS에게 CPU 제어권을 양도해도, 결국 물리적 메모리에 instruction을 실행하는 건 CPU다. 그래서 HW가 해야한다. 4. 페이징 기법 프로세스의 주소 공간을 동일한 크기의 페이지 단위로 나누어, 물리적 메모리의 서로 다른 위치에 불연속적으로 페이지들을 저장하는 방식\n각 프로세스의 주소 공간 전체를 물리적 메모리에 한꺼번에 올릴 필요 없이, 스와핑을 사용하여 일부만 메모리에 올릴 수 있다.\n또한, 이 메모리는 페이지와 동일한 크기의 프레임(frame) 으로 미리 나누어둔다.\n그래서 빈 프레임이 있으면 메모리의 어떤 위치이든 사용될 수 있다. 이 특징으로 연속할당에서의 동적 메모리 할당 문제와 외부조각 문제가 발생하지 않는다. 그러나, 프로그램의 크기가 항상 페이지 크기의 배수라는 보장이 없기 때문에 내부조각이 발생할 가능성은 있다. Problem 01\n물리적 메모리의 불연속적인 위치에 각 페이지를 올리기 때문에, 논리적 주소에서 물리적 주소로 변환하는 작업이 복잡하다. Solution 01\n위 문제에 대한 해결책으로 페이지 테이블(page table) 을 가진다. page table이 사용하는 주소 변환기법에 대해 알아보자. 4.1 주소 변환(address translation) 기법 page table에는 각 page마다 frame 주소가 mapping되어 있다.\nlogical address에서 physical address로 변환하는 구체적인 과정은 다음과 같다.\np = 페이지 번호: page table 접근 시 인덱스(index)로 사용 d = 페이지 offset\n-\u003e 각 index의 항목(entry)에는 그 페이지의 물리적 메모리상의 기준 주소(base address)인 시작위치가 저장되어 있다.\n-\u003e page table에서 위에서 p 번째를 찾으면 frame 번호(f)가 나온다.\n-\u003e 이렇게 해서 logical address에서 physical address로 바뀐다. 4.2 페이지 테이블의 구현 page table이란? paging 기법에서 주소 변환을 하기 위한 자료 구조로, 물리적 메모리에 위치한다. page table에 접근하기 위해 2개의 레지스터를 사용한다. page table에 접근하기 위한 2개의 레지스터는 다음과 같다.\n페이지 테이블 기준 레지스터(page-table base register, PTBR): 물리적 메모리 내에서의 페이지 테이블의 시작 위치 페이지 테이블 길이 레지스터(page-table length register, PTLR): 페이지 테이블의 크기를 보관 Problem\n페이징 기법에서 메모리 접근 연산은 총 두 번 이뤄진다. 첫 번째: 주소 변환을 위해 메모리에 있는 페이지 테이블에 접근하기 두 번째: 변환된 주소로 실제 데이터에 접근하기 즉, 두 번 접근해야 하는 오버헤드가 뒤따른다. Solution: TLB\nTLB란? Translation Look-aside Buffer 의 약어로, 테이블 접근 오버헤드를 줄이고, 메모리 접근 속도를 높이기 위한, 고속 주소 변환용 하드웨어 캐시 page table에서 빈번히 찾는 일부 entry를 저장하고 있다. TLB mechanism CPU가 논리적인 주소를 주면 page table보다 먼저 TLB를 검색한다. TLB 저장된 정보를 통해서 주소 변환이 가능한지 확인한다. TLB에 저장되어 있다면 TLB를 통해서 바로 주소 변환을 한다. 이 경우, 메모리에 한 번만 접근한다. 저장되어 있지 않다면 page table을 통해서 일반적인 주소 변환을 실행한다. TLB의 문제점\npage table의 경우 page 번호만큼 떨어진 항목에 곧바로 접근해 대응되는 프레임 번호를 얻는다. 하지만, TLB의 경우 해당 페이지에 대한 주소 변환 정보가 TLB에 있는지 확인하기 위해 TLB의 모든 항목을 다 찾아봐야 하는 오버헤드가 발생한다. Associative register(연관 레지스터)\n위의 언급한 오버헤드를 줄이기 위해 병렬 탐색(parallel search)이 가능한 연관 레지스터(associative register)를 사용한다. Parallel search: TLB 내의 모든 항목을 동시에 탐색할 수 있는 기능 page table은 각 process마다 논리적인 주소 체계가 달라서, 각 프로세스마다 존재한다.\n그래서, TLB도 각 process마다 다르게 존재한다. 4.3 계층적 페이징 2개 이상의 page table을 통해서 물리적 메모리에 접근하는 기법으로, 각 페이지를 다시 페이지화시키는 기법\n4.3.1 Twp-level page table이란??? 2단계 페이징 기법(Two-level page table)은 outer-page table과 inner-page table을 통해서 Physical memory에 접근한다. 4.3.2 Two-level page table을 사용하는 이유 현대의 컴퓨터는 address space가 매우 큰 프로그램을 지원한다.\n컴퓨터 시스템에서의 K, M, G\nK = 2^(10) = Kilo M = 2^(20) = Mega G = 2^(30) = Giga 32 bit address 사용 시: 2^(32) byte (= 4G byte)의 주소 공간\n페이지의 크기가 4KB일 때, 4GB / 4KB = 1M 개의 page table entry(항목)이 필요\n페이지의 항목이 4 byte 라면 한 프로세스 당 페이지 테이블을 위해 1M x 4byte = 4MB 크기의 메모리 공간이 필요하다.\n이런 상황에서 왜 2단계 페이징 기법을 사용하는가??\npage table이 2개라서 공간 낭비일 것 같지만, 다음과 같은 이유로 효과가 더 크기 때문에 사용한다. 프로그램의 대부분은 방어용 코드로 주로 사용하는 페이지 수는 적다. 그래서, 사용되지 않는 주소 공간에 대해서는 outer page table의 항목을 NULL로 설정하며, 여기에 대응하는 inner page table을 생성하지 않는다. 그 결과, page table의 공간을 줄일 수 있기 때문에, 속도가 느려도 사용한다. 사용하지 않는 주소 공간에 대해서 outer page table에 생성하는 이유는 page table의 자료구조 특성상 index로 작용하기 때문이다. 4.3.3 Two-level page table의 구성과 갯수, 크기 계산 logical address의 구성\ntwo level 이므로, 두 종류의 페이지 번호(P1,P2) 페이지 오프셋(d) P1: outer page table의 index P2: inner page table의 index outer page table의 entry 하나 당 inner page table이 하나 만들어진다.\ninner page table 하나의 크기가 page 크기와 동일하다.\npage table entry 하나의 크기가 4 byte 라고 했는데, 그러면 entry 갯수는 1K 개다.\npage 크기가 4KB 이고, 32bit 주소체계라고할 때, page number와 page offset의 크기는 다음과 같다.\npage 크기가 4K = 2^(12) 이므로, 한 페이지를 구분하기 위해서는 page offset은 12bit 가 필요하다. page table entry가 4byte이므로, 내부 페이지 테이블은 1KB = 2^(10) 개의 항목을 가진다. 2^(10)개를 구분하기 위해서는 P2는 10bit 가 필요하다. 그러면 총 32bit 주소체계에서 22bit를 사용했으므로, P1에는 10bit 가 할당된다. P1 P2 Page offset 10bit 10bit 12bit 다음과 같은 순서로 찾는다.\n첫 번째 outer page table로부터 P1만큼 떨어진 위치에서 inner page table의 주소 를 얻는다. inner page table은 여러개가 있다. outer page table의 한 entry당 하나의 inner page table이 만들어진다. 두 번째 innter page table로부터 P2만큼 떨어진 위치에서 요청된 페이지가 존재하는 프레임의 위치 를 얻는다. 세 번째 해당 프레임으로부터 d 만큼 떨어진 곳에서 원하는 정보에 접근한다. 4.3.4 multi-level page의 문제점과 해결책 Problem\nprocess의 address space가 커질수록 page table의 크기도 커지므로, 주소 변환을 위한 메모리 공간 낭비 점점 심각해지기 때문에, 다단계 페이지 테이블이 필요.\n이에 따라 공간은 절약할 수 있지만 메모리 접근시간이 크게 늘어나는 문제가 발생.\nSolution: TLB\nTLB 와 함께 사용하여 메모리 접근 시간을 줄일 수 있고, 다단계 page table을 사용하여 메모리 공간의 효율적 사용 효과는 매우 크다. 4.4 메모리 보호(Memory Protection) 메모리 보호를 위해 page table의 각 entry마다 보호 비트(protection bit)와 유효-무효 비트(valid-invalid bit)를 둔다.\n보호 비트(Protection bit): 각 page에 대한 연산 접근 권한을 설정하는데 사용\nread / write / read-only 유효-무효 비트(Valid-Invalid bit): 해당 페이지의 내용에 접근을 허용하는지 결정\nvalid 로 세팅: 해당 메모리 프레임에 그 페이지가 존재 -\u003e 접근 허용 invalid 로 세팅 -\u003e 유효한 접근 권한 X 첫 번재 경우, 프로세스가 그 주소 부분을 사용 X 두 번째 경우, 해당 페이지가 물리적 메모리에 올라있지 않고, 백킹스토어에 존재 4.5 역페이지 테이블(Inverted page table) page table이 매우 큰 이유\n모든 process 별로 그 logical address에 대응하는 모든 page에 대해 page table entry를 다 구성해야 하기 때문이다. 대응하는 page가 메모리에 존재하든 안하든 page table에는 entry로 존재 Inverted page table\nlogical address에 대해 page table을 만드는 것이 아닌, physical address에 대해 page table을 만드는 것\n시스템 전체에(system-wide) page table을 하나만 두는 방법\nphysical address는 1개이기 때문에, physical address에 대해 page table을 만든다는 건 하나만 만드는 걸 의미한다. 각 프로세스마다 page table을 두는 게 아니다. page table entry 수 = Physical memory의 page frame 수\nPhysical memory의 page frame 하나당 page table에 하나의 entry를 둔 것 page table entry 수 =! process의 page 갯수 각 page table entry는 각각의 물리적 메모리의 page frame이 담고 있는 내용 표시\nprocess의 id(pid), logical address(p) 어떤 process의 p번째 페이지인지를 확인하기 위해 pid를 저장해야 한다. 단점: 테이블 전체를 탐색해야 한다.\n역페이지 테이블에 주소 변환 요청이 들어오면, 그 주소를 담은 페이지가 물리적 메모리에 존재하는지 여부를 판단하기 위해, 페이지 테이블 전체를 다 탐색해야한다. physical address를 보고 logical address로 바꾸는 것이기 때문에, 목적에 맞지 않다.\n그러면 이 table을 통해서 어떻게 전환할 것인가??\n논리주소에 해당되는 P가 물리적 메모리 어디에 올라가는지를 찾을라면 이 entry를 다 찾아서 해당되는 P가 F 번째에 나오면, f번째에 있는 물리적 프레임에 있다는 걸로 파악한다. table의 장점인 index를 통해서 찾을 수 있는 장점이 없다. 그래서 시간이 아닌 단지 공간을 줄이기 위해서 사용되는 것이다.\n해결책: associative register 사용한다.\n연관 레지스터를 사용하여 병렬탐색을 하여 시간적 효율성을 높인다. 단, 비용이 비싸다. 4.6 공유 페이지(Shared page) shared code(공유 코드)를 담고 있는 페이지\nshared code란??\n메모리 공간의 효율적인 사용을 위해, 여러 프로세스에서 공통으로 사용되도록 작성된 코드 재진입 가능코드 (re-entrant code) 또는 순수 코드(pure code)라 한다. read-only 특성을 가진다. -shared memory 기법에서는 read - write다. 프로세스 간 공유 페이지이므로 물리적 메모리에 하나만 적재하여 효율적으로 사용한다.\n하지만, 이 특성으로 모든 프로세스의 logical address space 의 동일한 위치에 존재해야하는 제약점이 있다.\n왜냐하면 logical address에서 실행 시작하여 physical address에 올라갈 때, logical address에 연결되기 때문이다. Address binding 내용에서 이미지를 참고하자. private page(사유 페이지)\n공유 페이지와 대비되는 개념으로, 프로세스끼리 공유하지 않고 독자적으로 사용하는 페이지 사유 페이지는 해당 프로세스의 논리적 주소 공간 중 어더한 위치에 있어도 무방하다. 5. 세그먼테이션 프로세스 가상 메모리를 의미 단위인 segment로 나눠서 물리적 메모리에 올리는 기법\n프로세스의 주소 공간을 크기 단위가 아닌 의미 단위(logical unit)로 나눈 것이기 때문에, 크기가 균일하지 않다.\nmain (), function, global variables, stack… 그래서 부가적인 관리 오버헤드가 뒤따른다.\nsegment 크기 기준\n프로그램은 의미 단위인 여러 개의 segment로 구성한다. 작게는 프로그램을 구성하는 함수 하나 하나를 segment로 정의한다. 크게는 프로그램 전체를 하나의 세그먼트로 정의한다. 일반적으로는 code, data, stack 부분이 하나씩의 segment로 정의된다. 5.1 Segmentation Architecture 5.1.1 Logical address 두 가지 [s: segment-number, d: offset]로 구성\n5.1.2 Segment table Segmentation에서 주소 변환을 위해 사용하는 table\n이 table은 기준점(base) 와 한계점(limit) 을 가진다.\n기준점: 물리적 메모리에서 각 세그먼트의 시작위치를 의미. 한계점: 각 세그먼트의 길이를 의미. 페이징 기법과는 달리 각 segment의 길이가 균일하지 않기 때문이다. segment의 갯수에 따라 table entry 수가 결정된다.\nCPU 안에 주소 변환을 위한 2개의 레지스터\nSegment Table Base Register(STBR) : 물리적 메모리에서의 segment table의 시작위치\nSegment Table Length Register(STLR) : 프로세스의 segment의 길이와 갯수\nLogical address를 physical address로 변환하기 위한 두 가지 사항\n첫 번째: segment number(s)가 STLR에 저장된 값보다 작은 값인지 확인 아니라면 trap 발생시키기 두 번째: 논리적 주소의 오프셋 값(d)이 세그먼트의 길이보다 작은 값인지 확인 세그먼트 테이블의 한계점과 요청된 논리적 주소의 오프셋값을 비교해 확인한다. d가 더 크다면 trap 발생시키기 균일하지 않은 segment로 인한 paging과의 차이점들\n첫 번째 차이 paging 기법에서는 크기가 균일하기 때문에, offset의 크기가 page 크기에 의해서 결정된다. segment 기법에서는 offset 크기가 segment 크기를 제한하는 요소다. 두 번째 차이 paging 기법에서는 크기가 균일하기 때문에, 시작 주소가 frame 번호다. segment 기법에서는 크기가 다르기 때문에, 이 segment가 어디서 시작되는지 정확한 byte 단위 주소로 알려줘야 한다. 장점: paging과 달리 의미 단위라서 segment의 갯수가 상대적으로 많이 적다.\n그래서 table로 인한 메모리 낭비를 비교하자면 일반적인 시스템에서는 적다. 5.2 세그먼테이션에서의 보호비트와 유효비트 보호 비트(protection bit): 각 세그먼트 별로 가지고 있어서 각각에 대해 읽기/쓰기/실행 등의 권한이 있는지 나타낸다. 유효 비트(valid bit): 각 세그먼트의 주소 변환 정보가 유효한지, 즉 해당 세그먼트가 현재 물리적 메모리에 적재되어 있는지 나타낸다. valid bit = 0 : illegal segment 5.3 공유 세그먼트(shared segment) 공유 세그먼트(shared segment)\n여러 프로세스가 특정 세그먼트를 공유해 사용한다. 이 세그먼트를 공유하는 모든 프로세스의 주소 공간에서 동일한 논리적 주소에 위치 해야 한다. 장점: 공유(sharing)와 보안(protection) 측면에서 세그먼테이션\n의미 단위로 나눠져 있어서 페이징 기법보다 훨씬 효과적이다. -\u003e 5.2 와 연결하기 왜냐하면 크기 단위로 나누다 보면 공유 코드와 사유 데이터 영역이 동일 페이지에 공존하는 경우가 발생할 수 있기 때문이다. 그래서 어떤 권한을 줘야할지 결정하기가 어렵다. 5.4 세그먼트 할당 방식 세그먼트를 가용 공간에 할당하는 방식 세그먼트 크기가 균일하지 않기 때문에, 외부 조각 같은 문제점이 발생한다. 내부 조각은 없다는 장점 paging은 fragmentation이 발생하지 않는다. 그래서 동적 메모리 할당 문제가 존재한다. 이 문제에 대해서는 first-fit 방식과 best-fit 방식을 사용한다. 6. 페이지드 세그먼테이션 segmentation을 기반으로, 각 segmentation을 크기가 동일한 page로 구성\n6.1 pure segmentaton과의 차이점 segment-table entry 가 segment의 base address 를 가지고 있는 것이 아닌, segment를 구성하는 page table 의 base address 를 가지고 있다. 6.2 Paged segmentation의 logical address 두 가지 [s: segment-number, d: offset]로 구성 6.3 Paged segmentation의 특징과 장점 물리적 메모리에 적재하는 단위: page\naddress binding을 위해 외부의 segment table과 내부의 page table을 이용한다.\n장점: segmentation에서의 외부조각 문제와 paging 기법의 접근 권한 보호 문제를 해결\n6.4 address binding 과정 설명 첫 번째\n논리적 주소의 상위 비트인 segment number(s)로 segment table의 해당 항목에 접근 두 번째\n이 segment table entry = segment 길이 + segment의 page table 시작 주소 세 번째\n세그먼트 길이를 넘어서는 메모리 접근 시도인지 여부를 체크하기 위해, segment length와 logical address의 하위 비트 offset(d) 값과 비교.\nIf segment lenth \u003c offset: 유효 X -\u003e trap 발생.\nIf segment lenth \u003e offset: offset 값을 다시 상위 하위 비트로 나눔.\n나눠진 상위비트(p): 그 segment 내에서 page number를 의미. 나눠진 하위비트(d’): page 내에서의 변위를 의미. 네 번째\nsegment table entry에 있는 segment의 page-table base를 기준으로, p만큼 떨어진 page table entry로부터 물리적 메모리의 page frame 위치(f)를 얻음. 다섯 번째\n이 얻어진 위치에서 d’만큼 떨어진 곳 = 물리적 메모리 주소. page table for segment s 의 entry 갯수는 segment table의 segment 길이를 보면 알 수 있다.\nReference 운영체제와 정보기술의 원리 kocw 이화여자대학교 운영체제 - 반효경 교수 - ","wordCount":"2023","inLanguage":"en","datePublished":"2022-04-28T16:13:57+09:00","dateModified":"2022-04-28T16:13:57+09:00","mainEntityOfPage":{"@type":"WebPage","@id":"http://jeha00.github.io/post/os/os_chapter_07_%EB%A9%94%EB%AA%A8%EB%A6%AC%EA%B4%80%EB%A6%AC_2/"},"publisher":{"@type":"Organization","name":"Jeha DevLog","logo":{"@type":"ImageObject","url":"http://jeha00.github.io/favicon.ico"}}}</script></head><body class=dark id=top><script>localStorage.getItem("pref-theme")==="light"&&document.body.classList.remove("dark")</script><header class=header><nav class=nav><div class=logo><a href=http://jeha00.github.io/ accesskey=h title="@Jeha00 (Alt + H)">@Jeha00</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></span></div><ul id=menu><li><a href=http://jeha00.github.io/me/ title=About><span>About</span></a></li><li><a href=http://jeha00.github.io/archives/ title=Archive><span>Archive</span></a></li><li><a href=http://jeha00.github.io/categories/ title=Categories><span>Categories</span></a></li><li><a href=http://jeha00.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=http://jeha00.github.io/>Home</a>&nbsp;»&nbsp;<a href=http://jeha00.github.io/post/>Posts</a></div><h1 class=post-title>[TIL] OS Chapter 07: 메모리 관리 2</h1><div class=post-meta><span title='2022-04-28 16:13:57 +0900 KST'>April 28, 2022</span>&nbsp;|&nbsp;<a href=https://github.com/JeHa00/blog/content/post/OS/OS_Chapter_07_%eb%a9%94%eb%aa%a8%eb%a6%ac%ea%b4%80%eb%a6%ac_2.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#0-introduction aria-label="0. Introduction">0. Introduction</a></li><li><a href=#4-%ed%8e%98%ec%9d%b4%ec%a7%95-%ea%b8%b0%eb%b2%95 aria-label="4. 페이징 기법">4. 페이징 기법</a><ul><li><a href=#41-%ec%a3%bc%ec%86%8c-%eb%b3%80%ed%99%98address-translation-%ea%b8%b0%eb%b2%95 aria-label="4.1 주소 변환(address translation) 기법">4.1 주소 변환(address translation) 기법</a></li><li><a href=#42-%ed%8e%98%ec%9d%b4%ec%a7%80-%ed%85%8c%ec%9d%b4%eb%b8%94%ec%9d%98-%ea%b5%ac%ed%98%84 aria-label="4.2 페이지 테이블의 구현">4.2 페이지 테이블의 구현</a></li><li><a href=#43-%ea%b3%84%ec%b8%b5%ec%a0%81-%ed%8e%98%ec%9d%b4%ec%a7%95 aria-label="4.3 계층적 페이징">4.3 계층적 페이징</a><ul><li><a href=#431-twp-level-page-table%ec%9d%b4%eb%9e%80 aria-label="4.3.1 Twp-level page table이란???">4.3.1 Twp-level page table이란???</a></li><li><a href=#432-two-level-page-table%ec%9d%84-%ec%82%ac%ec%9a%a9%ed%95%98%eb%8a%94-%ec%9d%b4%ec%9c%a0 aria-label="4.3.2 Two-level page table을 사용하는 이유">4.3.2 Two-level page table을 사용하는 이유</a></li><li><a href=#433-two-level-page-table%ec%9d%98-%ea%b5%ac%ec%84%b1%ea%b3%bc-%ea%b0%af%ec%88%98-%ed%81%ac%ea%b8%b0-%ea%b3%84%ec%82%b0 aria-label="4.3.3 Two-level page table의 구성과 갯수, 크기 계산">4.3.3 Two-level page table의 구성과 갯수, 크기 계산</a></li><li><a href=#434-multi-level-page%ec%9d%98-%eb%ac%b8%ec%a0%9c%ec%a0%90%ea%b3%bc-%ed%95%b4%ea%b2%b0%ec%b1%85 aria-label="4.3.4 multi-level page의 문제점과 해결책">4.3.4 multi-level page의 문제점과 해결책</a></li></ul></li><li><a href=#44-%eb%a9%94%eb%aa%a8%eb%a6%ac-%eb%b3%b4%ed%98%b8memory-protection aria-label="4.4 메모리 보호(Memory Protection)">4.4 메모리 보호(Memory Protection)</a></li><li><a href=#45-%ec%97%ad%ed%8e%98%ec%9d%b4%ec%a7%80-%ed%85%8c%ec%9d%b4%eb%b8%94inverted-page-table aria-label="4.5 역페이지 테이블(Inverted page table)">4.5 역페이지 테이블(Inverted page table)</a></li><li><a href=#46-%ea%b3%b5%ec%9c%a0-%ed%8e%98%ec%9d%b4%ec%a7%80shared-page aria-label="4.6 공유 페이지(Shared page)">4.6 공유 페이지(Shared page)</a></li></ul></li><li><a href=#5-%ec%84%b8%ea%b7%b8%eb%a8%bc%ed%85%8c%ec%9d%b4%ec%85%98 aria-label="5. 세그먼테이션">5. 세그먼테이션</a><ul><li><a href=#51-segmentation-architecture aria-label="5.1 Segmentation Architecture">5.1 Segmentation Architecture</a><ul><li><a href=#511-logical-address aria-label="5.1.1 Logical address">5.1.1 Logical address</a></li><li><a href=#512-segment-table aria-label="5.1.2 Segment table">5.1.2 Segment table</a></li></ul></li><li><a href=#52-%ec%84%b8%ea%b7%b8%eb%a8%bc%ed%85%8c%ec%9d%b4%ec%85%98%ec%97%90%ec%84%9c%ec%9d%98-%eb%b3%b4%ed%98%b8%eb%b9%84%ed%8a%b8%ec%99%80-%ec%9c%a0%ed%9a%a8%eb%b9%84%ed%8a%b8 aria-label="5.2 세그먼테이션에서의 보호비트와 유효비트">5.2 세그먼테이션에서의 보호비트와 유효비트</a></li><li><a href=#53-%ea%b3%b5%ec%9c%a0-%ec%84%b8%ea%b7%b8%eb%a8%bc%ed%8a%b8shared-segment aria-label="5.3 공유 세그먼트(shared segment)">5.3 공유 세그먼트(shared segment)</a></li><li><a href=#54-%ec%84%b8%ea%b7%b8%eb%a8%bc%ed%8a%b8-%ed%95%a0%eb%8b%b9-%eb%b0%a9%ec%8b%9d aria-label="5.4 세그먼트 할당 방식">5.4 세그먼트 할당 방식</a></li></ul></li><li><a href=#6-%ed%8e%98%ec%9d%b4%ec%a7%80%eb%93%9c-%ec%84%b8%ea%b7%b8%eb%a8%bc%ed%85%8c%ec%9d%b4%ec%85%98 aria-label="6. 페이지드 세그먼테이션">6. 페이지드 세그먼테이션</a><ul><li><a href=#61-pure-segmentaton%ea%b3%bc%ec%9d%98-%ec%b0%a8%ec%9d%b4%ec%a0%90 aria-label="6.1 pure segmentaton과의 차이점">6.1 pure segmentaton과의 차이점</a></li><li><a href=#62-paged-segmentation%ec%9d%98-logical-address aria-label="6.2 Paged segmentation의 logical address">6.2 Paged segmentation의 logical address</a></li><li><a href=#63-paged-segmentation%ec%9d%98-%ed%8a%b9%ec%a7%95%ea%b3%bc-%ec%9e%a5%ec%a0%90 aria-label="6.3 Paged segmentation의 특징과 장점">6.3 Paged segmentation의 특징과 장점</a></li><li><a href=#64-address-binding-%ea%b3%bc%ec%a0%95-%ec%84%a4%eb%aa%85 aria-label="6.4 address binding 과정 설명">6.4 address binding 과정 설명</a></li></ul></li><li><a href=#reference aria-label=Reference>Reference</a></li></ul></div></details></div><div class=post-content><h1 id=0-introduction>0. Introduction<a hidden class=anchor aria-hidden=true href=#0-introduction>#</a></h1><ul><li>해당 내용은 <a href="http://www.kyobobook.co.kr/product/detailViewKor.laf?ejkGb=KOR&mallGb=KOR&barcode=9791158903589&orderClick=LAG&Kc=">운영체제와 정보기술의 원리 -반효경 지음-</a> 와 <a href="http://www.kocw.net/home/cview.do?lid=3dd1117c48123b8e">kocw 이화여자대학교 운영체제 - 반효경 교수 -</a>를 보고 정리한 내용이다.</li><li>정확하지 않은 내용이 있다면 말씀해주시면 감사하겠습니다.</li></ul><p> </p><ul><li>이번 chapter 내용인 메모리 관리는 물리적인 메모리 관리로, 주요 내용은 address binding이다.</li><li>address binding에서의 OS의 역할은 없고, 다 HW가 해야한다.</li><li>address binding을 할 때마다 OS에게 CPU 제어권을 양도해도, 결국 물리적 메모리에 instruction을 실행하는 건 CPU다. 그래서 HW가 해야한다.</li></ul><p> </p><hr><h1 id=4-페이징-기법>4. 페이징 기법<a hidden class=anchor aria-hidden=true href=#4-페이징-기법>#</a></h1><blockquote><p>프로세스의 주소 공간을 동일한 크기의 <strong>페이지 단위</strong>로 나누어, 물리적 메모리의 서로 다른 위치에 <strong>불연속적으로</strong> 페이지들을 저장하는 방식</p></blockquote><ul><li><p><strong>각 프로세스의 주소 공간 전체를 물리적 메모리에 한꺼번에 올릴 필요 없이, 스와핑을 사용하여 일부만 메모리에 올릴 수 있다.</strong></p></li><li><p><strong>또한, 이 메모리는 페이지와 동일한 크기의 <em>프레임(frame)</em> 으로 미리 나누어둔다.</strong></p><ul><li>그래서 빈 프레임이 있으면 <em>메모리의 어떤 위치이든</em> 사용될 수 있다.</li><li>이 특징으로 연속할당에서의 동적 메모리 할당 문제와 외부조각 문제가 발생하지 않는다.</li><li>그러나, 프로그램의 크기가 항상 페이지 크기의 배수라는 보장이 없기 때문에 내부조각이 발생할 가능성은 있다.</li></ul></li><li><p><strong>Problem 01</strong></p><ul><li>물리적 메모리의 불연속적인 위치에 각 페이지를 올리기 때문에, 논리적 주소에서 물리적 주소로 변환하는 작업이 복잡하다.</li></ul></li><li><p><strong>Solution 01</strong></p><ul><li>위 문제에 대한 해결책으로 <strong>페이지 테이블(page table)</strong> 을 가진다.</li><li>page table이 사용하는 주소 변환기법에 대해 알아보자.</li></ul></li></ul><p> </p><h2 id=41-주소-변환address-translation-기법>4.1 주소 변환(address translation) 기법<a hidden class=anchor aria-hidden=true href=#41-주소-변환address-translation-기법>#</a></h2><p><img loading=lazy src=https://user-images.githubusercontent.com/78094972/165469969-3e44f3d0-df6b-48ac-bc15-5eefd902cdeb.PNG alt=image></p><ul><li><p>page table에는 각 page마다 frame 주소가 mapping되어 있다.</p></li><li><p>logical address에서 physical address로 변환하는 구체적인 과정은 다음과 같다.</p></li></ul><p><img loading=lazy src=https://user-images.githubusercontent.com/78094972/210475914-916c4f71-e6fb-4d2f-8445-3eada254bdc5.jpeg alt=image></p><ul><li>p = 페이지 번호: page table 접근 시 인덱스(index)로 사용</li><li>d = 페이지 offset<br>-> 각 index의 항목(entry)에는 그 페이지의 물리적 메모리상의 기준 주소(base address)인 시작위치가 저장되어 있다.<br>-> page table에서 위에서 p 번째를 찾으면 frame 번호(f)가 나온다.<br>-> 이렇게 해서 logical address에서 physical address로 바뀐다.</li></ul><p> </p><h2 id=42-페이지-테이블의-구현>4.2 페이지 테이블의 구현<a hidden class=anchor aria-hidden=true href=#42-페이지-테이블의-구현>#</a></h2><blockquote><ul><li><strong>page table이란? paging 기법에서 주소 변환을 하기 위한 자료 구조로, 물리적 메모리에 위치한다.</strong></li><li><strong>page table에 접근하기 위해 2개의 레지스터를 사용한다.</strong></li></ul></blockquote><ul><li><p><strong>page table에 접근하기 위한 2개의 레지스터는 다음과 같다.</strong></p><ul><li>페이지 테이블 기준 레지스터(page-table base register, PTBR): 물리적 메모리 내에서의 페이지 테이블의 시작 위치</li><li>페이지 테이블 길이 레지스터(page-table length register, PTLR): 페이지 테이블의 크기를 보관</li></ul></li><li><p><strong>Problem</strong></p><ul><li>페이징 기법에서 메모리 접근 연산은 <strong>총 두 번</strong> 이뤄진다.<ul><li>첫 번째: 주소 변환을 위해 메모리에 있는 페이지 테이블에 접근하기</li><li>두 번째: 변환된 주소로 실제 데이터에 접근하기</li></ul></li><li>즉, 두 번 접근해야 하는 오버헤드가 뒤따른다.</li></ul></li></ul><p><img loading=lazy src=https://user-images.githubusercontent.com/78094972/165494535-8f3e85d0-620a-4bf1-84b7-bb3b804e4708.PNG alt=image></p><ul><li><p><strong>Solution: TLB</strong></p><ul><li>TLB란?<ul><li>Translation Look-aside Buffer 의 약어로,</li><li>테이블 접근 오버헤드를 줄이고, 메모리 접근 속도를 높이기 위한,</li><li>고속 주소 변환용 하드웨어 캐시</li><li>page table에서 빈번히 찾는 일부 entry를 저장하고 있다.</li></ul></li><li>TLB mechanism<ul><li>CPU가 논리적인 주소를 주면 page table보다 먼저 TLB를 검색한다.</li><li>TLB 저장된 정보를 통해서 주소 변환이 가능한지 확인한다.<ul><li>TLB에 저장되어 있다면 TLB를 통해서 바로 주소 변환을 한다.</li><li>이 경우, 메모리에 한 번만 접근한다.</li><li>저장되어 있지 않다면 page table을 통해서 일반적인 주소 변환을 실행한다.</li></ul></li></ul></li></ul></li><li><p><strong>TLB의 문제점</strong></p><ul><li>page table의 경우<ul><li>page 번호만큼 떨어진 항목에 곧바로 접근해 대응되는 프레임 번호를 얻는다.</li></ul></li><li>하지만, TLB의 경우<ul><li>해당 페이지에 대한 주소 변환 정보가 TLB에 있는지 확인하기 위해 TLB의 <em>모든 항목을 다 찾아봐야 하는</em> 오버헤드가 발생한다.</li></ul></li></ul></li><li><p><strong>Associative register(연관 레지스터)</strong></p><ul><li>위의 언급한 오버헤드를 줄이기 위해 병렬 탐색(parallel search)이 가능한 연관 레지스터(associative register)를 사용한다.<ul><li>Parallel search: TLB 내의 모든 항목을 동시에 탐색할 수 있는 기능</li></ul></li></ul></li><li><p>page table은 각 process마다 논리적인 주소 체계가 달라서, 각 프로세스마다 존재한다.</p><ul><li>그래서, TLB도 각 process마다 다르게 존재한다.</li></ul></li></ul><p> </p><h2 id=43-계층적-페이징>4.3 계층적 페이징<a hidden class=anchor aria-hidden=true href=#43-계층적-페이징>#</a></h2><blockquote><p><strong>2개 이상의 page table을 통해서 물리적 메모리에 접근하는 기법으로, 각 페이지를 다시 페이지화시키는 기법</strong></p></blockquote><p> </p><h3 id=431-twp-level-page-table이란>4.3.1 Twp-level page table이란???<a hidden class=anchor aria-hidden=true href=#431-twp-level-page-table이란>#</a></h3><ul><li><strong>2단계 페이징 기법(Two-level page table)은 outer-page table과 inner-page table을 통해서 Physical memory에 접근한다.</strong></li></ul><p> </p><h3 id=432-two-level-page-table을-사용하는-이유>4.3.2 Two-level page table을 사용하는 이유<a hidden class=anchor aria-hidden=true href=#432-two-level-page-table을-사용하는-이유>#</a></h3><ul><li><p><strong>현대의 컴퓨터는 address space가 매우 큰 프로그램을 지원한다.</strong></p><ul><li><p>컴퓨터 시스템에서의 K, M, G</p><ul><li>K = 2^(10) = Kilo</li><li>M = 2^(20) = Mega</li><li>G = 2^(30) = Giga</li></ul></li><li><p>32 bit address 사용 시: 2^(32) byte (= 4G byte)의 주소 공간</p></li><li><p>페이지의 크기가 4KB일 때, 4GB / 4KB = 1M 개의 page table entry(항목)이 필요</p></li><li><p>페이지의 항목이 4 byte 라면 한 프로세스 당 페이지 테이블을 위해 1M x 4byte = 4MB 크기의 메모리 공간이 필요하다.</p></li></ul></li><li><p><strong>이런 상황에서 왜 2단계 페이징 기법을 사용하는가??</strong></p><ul><li>page table이 2개라서 공간 낭비일 것 같지만, 다음과 같은 이유로 효과가 더 크기 때문에 사용한다.</li><li>프로그램의 대부분은 방어용 코드로 주로 사용하는 페이지 수는 적다.</li><li>그래서, 사용되지 않는 주소 공간에 대해서는 outer page table의 항목을 NULL로 설정하며, 여기에 대응하는 inner page table을 생성하지 않는다.</li><li>그 결과, page table의 공간을 줄일 수 있기 때문에, 속도가 느려도 사용한다.</li><li>사용하지 않는 주소 공간에 대해서 outer page table에 생성하는 이유는 page table의 자료구조 특성상 index로 작용하기 때문이다.</li></ul></li></ul><p><img loading=lazy src=https://user-images.githubusercontent.com/78094972/165732044-6ce1d363-0a50-484b-bc9a-2bfbc16e9bd6.PNG alt=image></p><p> </p><h3 id=433-two-level-page-table의-구성과-갯수-크기-계산>4.3.3 Two-level page table의 구성과 갯수, 크기 계산<a hidden class=anchor aria-hidden=true href=#433-two-level-page-table의-구성과-갯수-크기-계산>#</a></h3><p><img loading=lazy src=https://user-images.githubusercontent.com/78094972/165677100-dcb70c52-30a2-478e-a463-52344bdf835c.jpg alt=image></p><ul><li><p><strong>logical address의 구성</strong></p><ul><li>two level 이므로, 두 종류의 페이지 번호(P1,P2)</li><li>페이지 오프셋(d)</li><li>P1: outer page table의 index</li><li>P2: inner page table의 index</li></ul></li><li><p>outer page table의 entry 하나 당 inner page table이 하나 만들어진다.</p></li><li><p>inner page table 하나의 크기가 page 크기와 동일하다.</p></li><li><p>page table entry 하나의 크기가 <strong><em>4 byte</em></strong> 라고 했는데, 그러면 entry 갯수는 <strong><em>1K</em></strong> 개다.</p></li><li><p>page 크기가 <strong><em>4KB</em></strong> 이고, <strong><em>32bit</em></strong> 주소체계라고할 때, page number와 page offset의 크기는 다음과 같다.</p><ul><li>page 크기가 4K = 2^(12) 이므로, 한 페이지를 구분하기 위해서는 page offset은 <strong><em>12bit</em></strong> 가 필요하다.</li><li>page table entry가 4byte이므로, 내부 페이지 테이블은 1KB = 2^(10) 개의 항목을 가진다.</li><li>2^(10)개를 구분하기 위해서는 P2는 <strong><em>10bit</em></strong> 가 필요하다.</li><li>그러면 총 32bit 주소체계에서 22bit를 사용했으므로, P1에는 <strong><em>10bit</em></strong> 가 할당된다.<table><thead><tr><th>P1</th><th>P2</th><th>Page offset</th></tr></thead><tbody><tr><td>10bit</td><td>10bit</td><td>12bit</td></tr></tbody></table></li></ul></li><li><p><strong>다음과 같은 순서로 찾는다.</strong></p><ul><li>첫 번째<ul><li>outer page table로부터 P1만큼 떨어진 위치에서 <em>inner page table의 주소</em> 를 얻는다.</li><li>inner page table은 여러개가 있다. outer page table의 한 entry당 하나의 inner page table이 만들어진다.</li></ul></li><li>두 번째<ul><li>innter page table로부터 P2만큼 떨어진 위치에서 요청된 페이지가 존재하는 <em>프레임의 위치</em> 를 얻는다.</li></ul></li><li>세 번째<ul><li>해당 프레임으로부터 d 만큼 떨어진 곳에서 원하는 정보에 접근한다.</li></ul></li></ul></li></ul><p> </p><h3 id=434-multi-level-page의-문제점과-해결책>4.3.4 multi-level page의 문제점과 해결책<a hidden class=anchor aria-hidden=true href=#434-multi-level-page의-문제점과-해결책>#</a></h3><ul><li><p><strong>Problem</strong></p><ul><li><p>process의 address space가 커질수록 page table의 크기도 커지므로, 주소 변환을 위한 메모리 공간 낭비 점점 심각해지기 때문에, 다단계 페이지 테이블이 필요.</p></li><li><p>이에 따라 공간은 절약할 수 있지만 메모리 접근시간이 크게 늘어나는 문제가 발생.</p></li></ul></li><li><p><strong>Solution: TLB</strong></p><ul><li>TLB 와 함께 사용하여 메모리 접근 시간을 줄일 수 있고, 다단계 page table을 사용하여 메모리 공간의 효율적 사용 효과는 매우 크다.</li></ul></li></ul><p> </p><h2 id=44-메모리-보호memory-protection>4.4 메모리 보호(Memory Protection)<a hidden class=anchor aria-hidden=true href=#44-메모리-보호memory-protection>#</a></h2><blockquote><p><strong>메모리 보호를 위해 page table의 각 entry마다 보호 비트(protection bit)와 유효-무효 비트(valid-invalid bit)를 둔다.</strong></p></blockquote><ul><li><p><strong>보호 비트(Protection bit)</strong>: 각 page에 대한 연산 접근 권한을 설정하는데 사용</p><ul><li>read / write / read-only</li></ul></li><li><p><strong>유효-무효 비트(Valid-Invalid bit)</strong>: 해당 페이지의 내용에 접근을 허용하는지 결정</p><ul><li><code>valid</code> 로 세팅: 해당 메모리 프레임에 그 페이지가 존재 -> 접근 허용</li><li><code>invalid</code> 로 세팅 -> 유효한 접근 권한 X<ul><li>첫 번재 경우, 프로세스가 그 주소 부분을 사용 X</li><li>두 번째 경우, 해당 페이지가 물리적 메모리에 올라있지 않고, 백킹스토어에 존재</li></ul></li></ul></li></ul><p> </p><h2 id=45-역페이지-테이블inverted-page-table>4.5 역페이지 테이블(Inverted page table)<a hidden class=anchor aria-hidden=true href=#45-역페이지-테이블inverted-page-table>#</a></h2><ul><li><p><strong>page table이 매우 큰 이유</strong></p><ul><li>모든 process 별로 그 logical address에 대응하는 모든 page에 대해 page table entry를 다 구성해야 하기 때문이다.</li><li>대응하는 page가 메모리에 존재하든 안하든 page table에는 entry로 존재</li></ul></li><li><p><strong>Inverted page table</strong></p></li></ul><blockquote><p><strong>logical address에 대해 page table을 만드는 것이 아닌, physical address에 대해 page table을 만드는 것</strong></p></blockquote><ul><li><p><strong>시스템 전체에(system-wide) page table을 하나만 두는 방법</strong></p><ul><li>physical address는 1개이기 때문에, physical address에 대해 page table을 만든다는 건 하나만 만드는 걸 의미한다.</li><li>각 프로세스마다 page table을 두는 게 아니다.</li></ul></li><li><p><strong>page table entry 수 = Physical memory의 page frame 수</strong></p><ul><li>Physical memory의 page frame 하나당 page table에 하나의 entry를 둔 것</li><li>page table entry 수 =! process의 page 갯수</li></ul></li><li><p><strong>각 page table entry는 각각의 물리적 메모리의 page frame이 담고 있는 내용 표시</strong></p><ul><li>process의 id(pid), logical address(p)</li><li>어떤 process의 p번째 페이지인지를 확인하기 위해 pid를 저장해야 한다.</li></ul></li><li><p><strong>단점: 테이블 전체를 탐색해야 한다.</strong></p><ul><li>역페이지 테이블에 주소 변환 요청이 들어오면, 그 주소를 담은 페이지가 물리적 메모리에 존재하는지 여부를 판단하기 위해, 페이지 테이블 전체를 다 탐색해야한다.</li></ul></li></ul><p><img loading=lazy src=https://user-images.githubusercontent.com/78094972/165745426-e37842f5-596e-4d6d-95b1-87f80a05315a.PNG alt=image></p><ul><li><p>physical address를 보고 logical address로 바꾸는 것이기 때문에, 목적에 맞지 않다.</p></li><li><p>그러면 이 table을 통해서 어떻게 전환할 것인가??</p><ul><li>논리주소에 해당되는 P가 물리적 메모리 어디에 올라가는지를 찾을라면 이 entry를 다 찾아서 해당되는 P가 F 번째에 나오면, f번째에 있는 물리적 프레임에 있다는 걸로 파악한다.</li><li>table의 장점인 index를 통해서 찾을 수 있는 장점이 없다.</li></ul></li><li><p>그래서 시간이 아닌 단지 공간을 줄이기 위해서 사용되는 것이다.</p></li><li><p><strong>해결책: associative register 사용한다.</strong></p><ul><li>연관 레지스터를 사용하여 병렬탐색을 하여 시간적 효율성을 높인다.</li><li>단, 비용이 비싸다.</li></ul></li></ul><p> </p><h2 id=46-공유-페이지shared-page>4.6 공유 페이지(Shared page)<a hidden class=anchor aria-hidden=true href=#46-공유-페이지shared-page>#</a></h2><blockquote><p><strong>shared code(공유 코드)를 담고 있는 페이지</strong></p></blockquote><ul><li><p><strong>shared code란??</strong></p><ul><li>메모리 공간의 효율적인 사용을 위해, 여러 프로세스에서 공통으로 사용되도록 작성된 코드</li><li>재진입 가능코드 (re-entrant code) 또는 순수 코드(pure code)라 한다.</li><li>read-only 특성을 가진다.
-shared memory 기법에서는 read - write다.</li></ul></li><li><p><strong>프로세스 간 공유 페이지이므로 물리적 메모리에 하나만 적재하여 효율적으로 사용한다.</strong></p></li><li><p><strong>하지만, 이 특성으로 모든 프로세스의 <em>logical address space</em> 의 동일한 위치에 존재해야하는 제약점이 있다.</strong></p><ul><li>왜냐하면 logical address에서 실행 시작하여 physical address에 올라갈 때, logical address에 연결되기 때문이다.</li><li>Address binding 내용에서 이미지를 참고하자.</li></ul></li><li><p><strong>private page(사유 페이지)</strong></p><ul><li>공유 페이지와 대비되는 개념으로, 프로세스끼리 공유하지 않고 독자적으로 사용하는 페이지</li><li>사유 페이지는 해당 프로세스의 논리적 주소 공간 중 어더한 위치에 있어도 무방하다.</li></ul></li></ul><p><img loading=lazy src=https://user-images.githubusercontent.com/78094972/165756401-a43070d6-6222-47ea-8f59-e9d181db0d42.PNG alt=image></p><p> </p><hr><h1 id=5-세그먼테이션>5. 세그먼테이션<a hidden class=anchor aria-hidden=true href=#5-세그먼테이션>#</a></h1><blockquote><p>프로세스 가상 메모리를 의미 단위인 segment로 나눠서 물리적 메모리에 올리는 기법</p></blockquote><ul><li><p><strong>프로세스의 주소 공간을 크기 단위가 아닌 의미 단위(logical unit)로 나눈 것이기 때문에, 크기가 균일하지 않다.</strong></p><ul><li>main (), function, global variables, stack&mldr;</li></ul></li><li><p><strong>그래서 부가적인 관리 오버헤드가 뒤따른다.</strong></p></li><li><p><strong>segment 크기 기준</strong></p><ul><li>프로그램은 의미 단위인 여러 개의 segment로 구성한다.</li><li>작게는 프로그램을 구성하는 함수 하나 하나를 segment로 정의한다.</li><li>크게는 프로그램 전체를 하나의 세그먼트로 정의한다.</li><li>일반적으로는 code, data, stack 부분이 하나씩의 segment로 정의된다.</li></ul></li></ul><p> </p><h2 id=51-segmentation-architecture>5.1 Segmentation Architecture<a hidden class=anchor aria-hidden=true href=#51-segmentation-architecture>#</a></h2><h3 id=511-logical-address>5.1.1 Logical address<a hidden class=anchor aria-hidden=true href=#511-logical-address>#</a></h3><blockquote><p>두 가지 [s: segment-number, d: offset]로 구성</p></blockquote><p> </p><h3 id=512-segment-table>5.1.2 Segment table<a hidden class=anchor aria-hidden=true href=#512-segment-table>#</a></h3><blockquote><p>Segmentation에서 주소 변환을 위해 사용하는 table</p></blockquote><ul><li><p>이 table은 <strong>기준점(base)</strong> 와 <strong>한계점(limit)</strong> 을 가진다.</p><ul><li>기준점:<ul><li>물리적 메모리에서 각 세그먼트의 시작위치를 의미.</li></ul></li><li>한계점:<ul><li>각 세그먼트의 길이를 의미.</li><li>페이징 기법과는 달리 각 segment의 길이가 균일하지 않기 때문이다.</li></ul></li></ul></li><li><p>segment의 갯수에 따라 table entry 수가 결정된다.</p></li></ul><p><img loading=lazy src=https://user-images.githubusercontent.com/78094972/165777227-608c1f88-9365-41d8-adaa-1c4113b57e24.PNG alt=image></p><ul><li><p><strong>CPU 안에 주소 변환을 위한 2개의 레지스터</strong></p><ul><li><p><strong>Segment Table Base Register(STBR)</strong> : 물리적 메모리에서의 segment table의 시작위치</p></li><li><p><strong>Segment Table Length Register(STLR)</strong> : 프로세스의 segment의 길이와 갯수</p></li></ul></li><li><p><strong>Logical address를 physical address로 변환하기 위한 두 가지 사항</strong></p><ul><li>첫 번째: segment number(s)가 STLR에 저장된 값보다 작은 값인지 확인<ul><li>아니라면 trap 발생시키기</li></ul></li><li>두 번째: 논리적 주소의 오프셋 값(d)이 세그먼트의 길이보다 작은 값인지 확인<ul><li>세그먼트 테이블의 한계점과 요청된 논리적 주소의 오프셋값을 비교해 확인한다.</li><li>d가 더 크다면 trap 발생시키기</li></ul></li></ul></li><li><p><strong>균일하지 않은 segment로 인한 paging과의 차이점들</strong></p><ul><li>첫 번째 차이<ul><li>paging 기법에서는 크기가 균일하기 때문에, offset의 크기가 page 크기에 의해서 결정된다.</li><li>segment 기법에서는 offset 크기가 segment 크기를 제한하는 요소다.</li></ul></li><li>두 번째 차이<ul><li>paging 기법에서는 크기가 균일하기 때문에, 시작 주소가 frame 번호다.</li><li>segment 기법에서는 크기가 다르기 때문에, 이 segment가 어디서 시작되는지 정확한 byte 단위 주소로 알려줘야 한다.</li></ul></li></ul></li><li><p><strong>장점: paging과 달리 의미 단위라서 segment의 갯수가 상대적으로 많이 적다.</strong></p><ul><li>그래서 table로 인한 메모리 낭비를 비교하자면 일반적인 시스템에서는 적다.</li></ul></li></ul><p><img loading=lazy src=https://user-images.githubusercontent.com/78094972/165791144-186c1785-f254-4097-8e25-8ca186fd6a71.PNG alt=image></p><p> </p><h2 id=52-세그먼테이션에서의-보호비트와-유효비트>5.2 세그먼테이션에서의 보호비트와 유효비트<a hidden class=anchor aria-hidden=true href=#52-세그먼테이션에서의-보호비트와-유효비트>#</a></h2><ul><li>보호 비트(protection bit): 각 세그먼트 별로 가지고 있어서 각각에 대해 읽기/쓰기/실행 등의 권한이 있는지 나타낸다.</li><li>유효 비트(valid bit): 각 세그먼트의 주소 변환 정보가 유효한지, 즉 해당 세그먼트가 현재 물리적 메모리에 적재되어 있는지 나타낸다.<ul><li>valid bit = 0 : illegal segment</li></ul></li></ul><p> </p><h2 id=53-공유-세그먼트shared-segment>5.3 공유 세그먼트(shared segment)<a hidden class=anchor aria-hidden=true href=#53-공유-세그먼트shared-segment>#</a></h2><ul><li><p><strong>공유 세그먼트(shared segment)</strong></p><ul><li>여러 프로세스가 특정 세그먼트를 공유해 사용한다.</li><li>이 세그먼트를 공유하는 모든 프로세스의 주소 공간에서 <em>동일한 논리적 주소에 위치</em> 해야 한다.</li></ul></li><li><p><strong>장점: 공유(sharing)와 보안(protection) 측면에서 세그먼테이션</strong></p><ul><li>의미 단위로 나눠져 있어서 페이징 기법보다 훨씬 효과적이다. -> 5.2 와 연결하기</li><li>왜냐하면 크기 단위로 나누다 보면 공유 코드와 사유 데이터 영역이 동일 페이지에 공존하는 경우가 발생할 수 있기 때문이다.</li><li>그래서 어떤 권한을 줘야할지 결정하기가 어렵다.</li></ul></li></ul><p> </p><h2 id=54-세그먼트-할당-방식>5.4 세그먼트 할당 방식<a hidden class=anchor aria-hidden=true href=#54-세그먼트-할당-방식>#</a></h2><ul><li><strong>세그먼트를 가용 공간에 할당하는 방식</strong><ul><li>세그먼트 크기가 균일하지 않기 때문에, 외부 조각 같은 문제점이 발생한다.<ul><li>내부 조각은 없다는 장점</li><li>paging은 fragmentation이 발생하지 않는다.</li></ul></li><li>그래서 동적 메모리 할당 문제가 존재한다.</li><li>이 문제에 대해서는 first-fit 방식과 best-fit 방식을 사용한다.</li></ul></li></ul><p> </p><hr><h1 id=6-페이지드-세그먼테이션>6. 페이지드 세그먼테이션<a hidden class=anchor aria-hidden=true href=#6-페이지드-세그먼테이션>#</a></h1><blockquote><p>segmentation을 기반으로, 각 segmentation을 크기가 동일한 page로 구성</p></blockquote><h2 id=61-pure-segmentaton과의-차이점>6.1 pure segmentaton과의 차이점<a hidden class=anchor aria-hidden=true href=#61-pure-segmentaton과의-차이점>#</a></h2><ul><li><strong><em>segment-table entry</em></strong> 가 segment의 <strong><em>base address</em></strong> 를 가지고 있는 것이 아닌, segment를 구성하는 <strong><em>page table</em></strong> 의 <strong><em>base address</em></strong> 를 가지고 있다.</li></ul><p> </p><h2 id=62-paged-segmentation의-logical-address>6.2 Paged segmentation의 logical address<a hidden class=anchor aria-hidden=true href=#62-paged-segmentation의-logical-address>#</a></h2><ul><li>두 가지 [s: segment-number, d: offset]로 구성</li></ul><p> </p><h2 id=63-paged-segmentation의-특징과-장점>6.3 Paged segmentation의 특징과 장점<a hidden class=anchor aria-hidden=true href=#63-paged-segmentation의-특징과-장점>#</a></h2><ul><li><p><strong>물리적 메모리에 적재하는 단위: page</strong></p></li><li><p><strong>address binding을 위해 외부의 segment table과 내부의 page table을 이용한다.</strong></p></li><li><p><strong>장점: segmentation에서의 외부조각 문제와 paging 기법의 접근 권한 보호 문제를 해결</strong></p></li></ul><p> </p><h2 id=64-address-binding-과정-설명>6.4 address binding 과정 설명<a hidden class=anchor aria-hidden=true href=#64-address-binding-과정-설명>#</a></h2><p><img loading=lazy src=https://user-images.githubusercontent.com/78094972/165794299-d37ff422-11c8-4111-9667-486737368314.PNG alt=image></p><ul><li><p><strong>첫 번째</strong></p><ul><li>논리적 주소의 상위 비트인 segment number(s)로 segment table의 해당 항목에 접근</li></ul></li><li><p><strong>두 번째</strong></p><ul><li>이 segment table entry = segment 길이 + segment의 page table 시작 주소</li></ul></li><li><p><strong>세 번째</strong></p><ul><li><p>세그먼트 길이를 넘어서는 메모리 접근 시도인지 여부를 체크하기 위해, segment length와 logical address의 하위 비트 offset(d) 값과 비교.</p><ul><li><p>If segment lenth &lt; offset: 유효 X -> trap 발생.</p></li><li><p>If segment lenth > offset: offset 값을 다시 상위 하위 비트로 나눔.</p><ul><li>나눠진 상위비트(p): 그 segment 내에서 page number를 의미.</li><li>나눠진 하위비트(d&rsquo;): page 내에서의 변위를 의미.</li></ul></li></ul></li></ul></li><li><p><strong>네 번째</strong></p><ul><li>segment table entry에 있는 segment의 page-table base를 기준으로, p만큼 떨어진 page table entry로부터 물리적 메모리의 page frame 위치(f)를 얻음.</li></ul></li><li><p><strong>다섯 번째</strong></p><ul><li>이 얻어진 위치에서 d&rsquo;만큼 떨어진 곳 = 물리적 메모리 주소.</li></ul></li><li><p><strong>page table for segment s 의 entry 갯수는 segment table의 segment 길이를 보면 알 수 있다.</strong></p></li></ul><p> </p><hr><h1 id=reference>Reference<a hidden class=anchor aria-hidden=true href=#reference>#</a></h1><ul><li><a href="http://www.kyobobook.co.kr/product/detailViewKor.laf?ejkGb=KOR&mallGb=KOR&barcode=9791158903589&orderClick=LAG&Kc=">운영체제와 정보기술의 원리</a></li><li><a href="http://www.kocw.net/home/cview.do?lid=3dd1117c48123b8e">kocw 이화여자대학교 운영체제 - 반효경 교수 -</a></li></ul></div><footer class=post-footer><ul class=post-tags><li><a href=http://jeha00.github.io/tags/til/>TIL</a></li><li><a href=http://jeha00.github.io/tags/os/>OS</a></li></ul><nav class=paginav><a class=prev href=http://jeha00.github.io/post/os/os_chapter_08_%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4_%EB%8F%99%EA%B8%B0%ED%99%94_1/><span class=title>« Prev Page</span><br><span>[TIL] OS Chapter 08: 프로세스 동기화 1</span></a>
<a class=next href=http://jeha00.github.io/post/os/os_chapter_07_%EB%A9%94%EB%AA%A8%EB%A6%AC%EA%B4%80%EB%A6%AC_1/><span class=title>Next Page »</span><br><span>[TIL] OS Chapter 07: 메모리 관리 1</span></a></nav><div class=share-buttons><a target=_blank rel="noopener noreferrer" aria-label="share [TIL] OS Chapter 07: 메모리 관리 2 on twitter" href="https://twitter.com/intent/tweet/?text=%5bTIL%5d%20OS%20Chapter%2007%3a%20%eb%a9%94%eb%aa%a8%eb%a6%ac%20%ea%b4%80%eb%a6%ac%202&url=http%3a%2f%2fjeha00.github.io%2fpost%2fos%2fos_chapter_07_%25EB%25A9%2594%25EB%25AA%25A8%25EB%25A6%25AC%25EA%25B4%2580%25EB%25A6%25AC_2%2f&hashtags=TIL%2cOS"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM195.519 424.544c135.939.0 210.268-112.643 210.268-210.268.0-3.218.0-6.437-.153-9.502 14.406-10.421 26.973-23.448 36.935-38.314-13.18 5.824-27.433 9.809-42.452 11.648 15.326-9.196 26.973-23.602 32.49-40.92-14.252 8.429-30.038 14.56-46.896 17.931-13.487-14.406-32.644-23.295-53.946-23.295-40.767.0-73.87 33.104-73.87 73.87.0 5.824.613 11.494 1.992 16.858-61.456-3.065-115.862-32.49-152.337-77.241-6.284 10.881-9.962 23.601-9.962 37.088.0 25.594 13.027 48.276 32.95 61.456-12.107-.307-23.448-3.678-33.41-9.196v.92c0 35.862 25.441 65.594 59.311 72.49-6.13 1.686-12.72 2.606-19.464 2.606-4.751.0-9.348-.46-13.946-1.38 9.349 29.426 36.628 50.728 68.965 51.341-25.287 19.771-57.164 31.571-91.8 31.571-5.977.0-11.801-.306-17.625-1.073 32.337 21.15 71.264 33.41 112.95 33.41z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share [TIL] OS Chapter 07: 메모리 관리 2 on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&url=http%3a%2f%2fjeha00.github.io%2fpost%2fos%2fos_chapter_07_%25EB%25A9%2594%25EB%25AA%25A8%25EB%25A6%25AC%25EA%25B4%2580%25EB%25A6%25AC_2%2f&title=%5bTIL%5d%20OS%20Chapter%2007%3a%20%eb%a9%94%eb%aa%a8%eb%a6%ac%20%ea%b4%80%eb%a6%ac%202&summary=%5bTIL%5d%20OS%20Chapter%2007%3a%20%eb%a9%94%eb%aa%a8%eb%a6%ac%20%ea%b4%80%eb%a6%ac%202&source=http%3a%2f%2fjeha00.github.io%2fpost%2fos%2fos_chapter_07_%25EB%25A9%2594%25EB%25AA%25A8%25EB%25A6%25AC%25EA%25B4%2580%25EB%25A6%25AC_2%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share [TIL] OS Chapter 07: 메모리 관리 2 on reddit" href="https://reddit.com/submit?url=http%3a%2f%2fjeha00.github.io%2fpost%2fos%2fos_chapter_07_%25EB%25A9%2594%25EB%25AA%25A8%25EB%25A6%25AC%25EA%25B4%2580%25EB%25A6%25AC_2%2f&title=%5bTIL%5d%20OS%20Chapter%2007%3a%20%eb%a9%94%eb%aa%a8%eb%a6%ac%20%ea%b4%80%eb%a6%ac%202"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share [TIL] OS Chapter 07: 메모리 관리 2 on facebook" href="https://facebook.com/sharer/sharer.php?u=http%3a%2f%2fjeha00.github.io%2fpost%2fos%2fos_chapter_07_%25EB%25A9%2594%25EB%25AA%25A8%25EB%25A6%25AC%25EA%25B4%2580%25EB%25A6%25AC_2%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share [TIL] OS Chapter 07: 메모리 관리 2 on whatsapp" href="https://api.whatsapp.com/send?text=%5bTIL%5d%20OS%20Chapter%2007%3a%20%eb%a9%94%eb%aa%a8%eb%a6%ac%20%ea%b4%80%eb%a6%ac%202%20-%20http%3a%2f%2fjeha00.github.io%2fpost%2fos%2fos_chapter_07_%25EB%25A9%2594%25EB%25AA%25A8%25EB%25A6%25AC%25EA%25B4%2580%25EB%25A6%25AC_2%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share [TIL] OS Chapter 07: 메모리 관리 2 on telegram" href="https://telegram.me/share/url?text=%5bTIL%5d%20OS%20Chapter%2007%3a%20%eb%a9%94%eb%aa%a8%eb%a6%ac%20%ea%b4%80%eb%a6%ac%202&url=http%3a%2f%2fjeha00.github.io%2fpost%2fos%2fos_chapter_07_%25EB%25A9%2594%25EB%25AA%25A8%25EB%25A6%25AC%25EA%25B4%2580%25EB%25A6%25AC_2%2f"><svg viewBox="2 2 28 28"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></div></footer></article></main><footer class=footer><span>&copy; 2023 <a href=http://jeha00.github.io/>Jeha DevLog</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerText="copy";function s(){t.innerText="copied!",setTimeout(()=>{t.innerText="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>