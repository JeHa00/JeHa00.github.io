<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>[TIL] OS Chapter 08: 프로세스 동기화 2 | Jeha00 DevLog</title><meta name=keywords content="TIL,OS"><meta name=description content="프로세스 동기화의 전통적인 문제 3가지와 semaphore를 개선한 방법인 monitor에 대해 알아본다."><meta name=author content="Jeha00"><link rel=canonical href=http://jeha00.github.io/post/os/os_chapter_08_%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4_%EB%8F%99%EA%B8%B0%ED%99%94_2/><meta name=google-site-verification content="XYZabc"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.min.1e44d58192cbf6d7a4eb649bc43dbc3d4cc432677e5d8adc69b08c34cbe461ac.css integrity="sha256-HkTVgZLL9tek62SbxD28PUzEMmd+XYrcabCMNMvkYaw=" rel="preload stylesheet" as=style><link rel=icon href=http://jeha00.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=http://jeha00.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=http://jeha00.github.io/favicon-32x32.png><link rel=apple-touch-icon href=http://jeha00.github.io/apple-touch-icon.png><link rel=mask-icon href=http://jeha00.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><meta name=generator content="Hugo 0.98.0"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script type=application/javascript>var doNotTrack=!1;doNotTrack||(function(e,o,i,a,t,n,s){e.GoogleAnalyticsObject=t,e[t]=e[t]||function(){(e[t].q=e[t].q||[]).push(arguments)},e[t].l=1*new Date,n=o.createElement(i),s=o.getElementsByTagName(i)[0],n.async=1,n.src=a,s.parentNode.insertBefore(n,s)}(window,document,"script","https://www.google-analytics.com/analytics.js","ga"),ga("create","UA-123-45","auto"),ga("send","pageview"))</script><meta property="og:title" content="[TIL] OS Chapter 08: 프로세스 동기화 2"><meta property="og:description" content="프로세스 동기화의 전통적인 문제 3가지와 semaphore를 개선한 방법인 monitor에 대해 알아본다."><meta property="og:type" content="article"><meta property="og:url" content="http://jeha00.github.io/post/os/os_chapter_08_%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4_%EB%8F%99%EA%B8%B0%ED%99%94_2/"><meta property="og:image" content="http://jeha00.github.io/47"><meta property="article:section" content="post"><meta property="article:published_time" content="2022-05-10T20:38:04+09:00"><meta property="article:modified_time" content="2022-05-10T20:38:04+09:00"><meta property="og:site_name" content="JeHa00 DevLog"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="http://jeha00.github.io/47"><meta name=twitter:title content="[TIL] OS Chapter 08: 프로세스 동기화 2"><meta name=twitter:description content="프로세스 동기화의 전통적인 문제 3가지와 semaphore를 개선한 방법인 monitor에 대해 알아본다."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"http://jeha00.github.io/post/"},{"@type":"ListItem","position":2,"name":"[TIL] OS Chapter 08: 프로세스 동기화 2","item":"http://jeha00.github.io/post/os/os_chapter_08_%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4_%EB%8F%99%EA%B8%B0%ED%99%94_2/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"[TIL] OS Chapter 08: 프로세스 동기화 2","name":"[TIL] OS Chapter 08: 프로세스 동기화 2","description":"프로세스 동기화의 전통적인 문제 3가지와 semaphore를 개선한 방법인 monitor에 대해 알아본다.","keywords":["TIL","OS"],"articleBody":"0. Introduction  해당 내용은 kocw 이화여자대학교 운영체제 - 반효경 교수 - 강의만 보고 정리한 내용이다. 운영체제와 정보기술의 원리 -반효경 지음- 책에는 있지 않은 내용이다. 정확하지 않은 내용이 있다면 말씀해주시면 감사하겠습니다.   6. 프로세스 동기화의 첫 번째 문제  **Bounded-buffer problem (producer-consumber problem)**으로서, 생산자와 소비자가 공유 buffer에 도착했을 경우, 동기화되지 않는 문제\n   buffer: 임시로 데이터를 저장하는 공간\n  두 종류의 process\n Producer: 생산자 process로서, 공유 buffer에다가 데이터를 만들어서 집어넣는 역할 Consumer: 소비자 process로서, 공유 buffer에서 데이터를 꺼내는 역할    Bounded-buffer로 인한 문제점\n To producer  buffer가 가득 차고, 소비자가 안오는 상황이라면 data를 더 이상 생산할 수 없다는 문제가 발생된다.   To consumer  소비자 process는 소비할 수 있는 buffer가 없으면 문제가 발생된다. 생산자 process가 내용을 넣어줄 때까지 계속 기다린다.      Synchronization variable\n mutual exclusion: 공유 데이터의 상호 배제를 위해서 binary semaphore를 사용 resource count: 가용 buffer 수를 표시하기 위해서 counting semaphore를 사용    6.1 Semaphore로 문제 해결하기  Synchronization variable (= semaphore variable)  semaphore full = 0, empty = n, mutex = 1      Producer\n P(empty): 빈 buffer를 확인하고, 있으면 획득한다.  빈 buffer가 없으면 이 단계에서 대기한다. 소비자가 소비한 buffer는 producer에게는 자원이다.   P(mutex): buffer에 data를 넣기 위해 lock을 건다. V(mutex): buffer에 건 lock을 푼다. V(full): 내용이 들어가 있는 buffer의 갯수를 1 증가시키는 연산  내용이 들어가 있는 buffer는 소비자에게는 자원이다. 그리고, 소비자가 내용 있는 buffer가 없어서 대기하고 있으면 소비자를 wake up 해주는 연산      Consumer\n P(full): 내용이 있는 buffer 획득 P(mutex): 획득한 buffer에 lock을 건다. V(mutex): lock을 푼다. V(empty): 비어있는 buffer의 수를 1 증가시킨다. 그리고, 비어진 buffer는 생산자에게 자원이 된다.     7. 프로세스 동기화의 두 번째 문제  Readers and writers problem\n   Solution\n Writer가 DB에 접근 허가를 아직 얻지 못한 상태에서는 모든 대기 중인 Reader들을 다 DB에 접근하게 한다. Writer는 대기 중인 Reader가 하나도 없을 때, DB 접근이 허용된다. 일단 Writer가 DB에 접근 중이면 Reader들은 접근이 금지된다. Writer가 DB에 빠져나가야만 Reader의 접근이 허용된다. read는 동시에 여러 개가 접근해도 된다.    shared data\n DB 자체 readcount: 현대 DB에 접근 중인 reader의 수    Synchronization variables\n mutex: 공유 변수 readcount를 접근하는 코드(critical section)의 mutual exclusion 보장을 위해 사용 DB: reader와 writer가 공유 DB 자체를 올바르게 접근하는 역할      Writer\n P(db)가 DB에 lock을 걸고 쓰는 작업을 수행 이 작업이 끝나면 V(db)를 통해서 lock을 푼다. starvation 문제 발생  write가 reader들이 다 작업을 완료할 때까지 기다리는 중에, 또 다른 reader들이 들어오면 더 오래 기다려야 한다. 위 코드에서는 starvation에 대한 대책 코드는 나와있지 않는다.      Reader\n readcount는 공유 변수이기 때문에, race condition을 방지하기 위해서 mutex 변수를 사용한다. 그래서 P(mutex)에서 readcount 변수에 lock을 건다. readcount == 1: 자신이 최초의 reader라는 의미이고, DB에 lock을 건다. if readcount  1: 이미 최초의 reader가 DB에 lock을 걸었기 때문에, 추가로 DB에 lock을 걸지 않고 읽기만 한다. readcount - -: process가 다 읽고 빠져나가기 때문에, 1 감소된다. if readcount == 0: writer가 작성할 수 있다.     8. 프로세스 동기화의 세 번째 문제  Dinning-philosophers problem (식사하는 철학자 문제)\n   Deadlock 발생지점\n 모든 철학자가 동시에 배가 고파서 왼쪽 젓가락을 집어버린 경우    Solution\n 4명의 철학자만이 테이블에 동시에 앉을 수 있도록 한다. 젓가락을 두 개 모두 집을 수 있을 때에만 젓가락을 집을 수 있게 한다. 비대칭  짝수(홀수) 철학자는 왼쪽(오른쪽) 젓가락부터 집도록한다. Semaphore code        Synchronization variables\n  enum {thinking, hungry, eating} state [5]\n  semaphore self[5] = 0 or 1\n i 번째 철학자가 젓가락을 소유할 수 있는 권한 유무 0 - 권한 X 1 - 권한 O    semaphore mutex = 1\n 본인의 상태를 본인 뿐만 아니라, 다른 철학자가 바꿀 수 있음을 나타내는 것      Philosopher i: 5명의 철학자가 하는 일을 의미\n putdown: 젓가락 내려놓기 pickup: 젓가락 집기 test    밑 단원 monitor 개념을 이용한 식사하는 철학자 문제\n  - semaphore code와 비교하기   9. Monitor 9.1 Semaphore의 문제점  코딩하기 어렵다. 정확성 입증이 어렵다. 자발적 협력이 필요하다. 한 번의 실수가 모든 시스템에 치명적인 영향을 준다.  # Deadlock 발생 경우 P(mutex) Critical section P(mutex)  # Deadlock 발생하지 않는 경우 V(mutex) Critical section P(mutex) 9.2 Monitor  동시 수행 중인 프로세스 사이에서 abstract data type의 안전한 공유를 보장하기 위한 고수준의 동기화 구조체\n   Semaphore와의 차이점\n lock을 걸 필요가 없다. Monitor: 동시 접근 막는 것을 지원 semaphore: 자원을 얻기 위해서 프로그래머가 작성    monitor는 공유 데이터에 접근하기 위해서 monitor 라고 정의된 내부 procedure를 통해서만 접근이 가능하다.\n   이 monitor를 어떻게 지원할지는 프로그래밍 언어마다 다르다.  9.2.1 Monitor 내부 구조  shared data + shared data에 접근하는 operations + initialization code\n   Process\n shared data에 접근하고 싶으면 밑에 operations (process) 들을 통해서만 가능하다. process들은 동시에 실행되지 않고, 한 번에 한 process만 실행되도록 설정하므로, lock이 불필요하다. 그래서 개발자가 별도로 lock을 구현할 필요가 없다. (semaphore와의 차이점 이유) monitor 안에 하나의 process만 활성화되기 때문에, 나머지 process는 이에 entry queue에 줄서서 기다린다. monitor 안에 공유자원의 갯수가 없어서 기다려야 하면,  내용 있는 process를 기다리는 queue는 x이고, 내용 없는 process를 기다리는 queue는 y다.      semaphore에서는 resource의 갯수를 세는 개 필요하듯이 monitor도 그러하다.\n 자원이 있으면 접근 허용, 자원이 없으면 대기한다.    Condition variable\n monitor 안에서 process가 기다릴 수 있도록 하기 위해 condition variable을 사용한다.  semaphore 변수와 동일한 역할을 한다.   condition variable은 wait과 signal 연산에 의해서만 접근 가능하다.  x.wait(): x.wait()을 invoke한 process는 다른 프로세스가 x.signal을 invoke하기 전까지는 suspend 된다. x.signal(): x.signal을 정확하게 하나의 suspend된 프로세스를 resume 한다. suspend된 프로세스가 없으면 아무 일도 일어나지 않는다.      monitor가 lock이 필요없는 이유\n   monitor bounded_buffer  { int buffer[n];  condition full, empty;   void produce(int x)  { if there is no empty buffer  empty.wait();  add x to an empty buffer  full.signal ();  }   void consume(int *x)  { if there is no full buffer  full.wait();  remove an item from buffer and store it to *x  empty.signal();  }  }  full, empty 같은 condition var.을 가지지 않고, 자신의 queue에 process를 매달아서, sleep시키거나, queue에서 process를 깨우는 역할만 한다.  full: 내용이 들어 있는 buffer를 기다리면서 잠들게 하는 역할 empty: 내용이 없는 buffer를 기다리면서 잠들게 하는 역할   작업을 하기 위해서는 모니터 내부 코드를 실행해야 한다. 생산자 소비자 모두 하나의 프로세스 안에서 활성화되기 때문에, 락을 걸지 않아도 race condition 문제를 고려하지 않아도 된다. empty.wait()  생산자 입장에서는 빈 buffer가 필요한데, 그런 경우 empty wait을 통해서 빈 buffer에 줄 서서 기다린다.   full.signal()  내용이 들어 있는 buffer가 있으면 생산자를 깨운다.     Reference  kocw 이화여자대학교 운영체제 - 반효경 교수 -  ","wordCount":"960","inLanguage":"en","datePublished":"2022-05-10T20:38:04+09:00","dateModified":"2022-05-10T20:38:04+09:00","author":{"@type":"Person","name":"Jeha00"},"mainEntityOfPage":{"@type":"WebPage","@id":"http://jeha00.github.io/post/os/os_chapter_08_%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4_%EB%8F%99%EA%B8%B0%ED%99%94_2/"},"publisher":{"@type":"Organization","name":"Jeha00 DevLog","logo":{"@type":"ImageObject","url":"http://jeha00.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=http://jeha00.github.io/ accesskey=h title="Jeha00 (Alt + H)">Jeha00</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></span></div><ul id=menu><li><a href=http://jeha00.github.io/archives/ title=Archive><span>Archive</span></a></li><li><a href=http://jeha00.github.io/categories/ title=Categories><span>Categories</span></a></li><li><a href=http://jeha00.github.io/tags/ title=Tags><span>Tags</span></a></li><li><a href=http://jeha00.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=http://jeha00.github.io/>Home</a>&nbsp;»&nbsp;<a href=http://jeha00.github.io/post/>Posts</a></div><h1 class=post-title>[TIL] OS Chapter 08: 프로세스 동기화 2</h1><div class=post-meta><span title="2022-05-10 20:38:04 +0900 KST">May 10, 2022</span>&nbsp;·&nbsp;5 min&nbsp;·&nbsp;Jeha00&nbsp;|&nbsp;<a href=https://github.com/JeHa00/blog/content/post/OS/OS_Chapter_08_%ed%94%84%eb%a1%9c%ec%84%b8%ec%8a%a4_%eb%8f%99%ea%b8%b0%ed%99%94_2.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#0-introduction aria-label="0. Introduction">0. Introduction</a></li><li><a href=#6-%ed%94%84%eb%a1%9c%ec%84%b8%ec%8a%a4-%eb%8f%99%ea%b8%b0%ed%99%94%ec%9d%98-%ec%b2%ab-%eb%b2%88%ec%a7%b8-%eb%ac%b8%ec%a0%9c aria-label="6. 프로세스 동기화의 첫 번째 문제">6. 프로세스 동기화의 첫 번째 문제</a><ul><li><a href=#61-semaphore%eb%a1%9c-%eb%ac%b8%ec%a0%9c-%ed%95%b4%ea%b2%b0%ed%95%98%ea%b8%b0 aria-label="6.1 Semaphore로 문제 해결하기">6.1 Semaphore로 문제 해결하기</a></li></ul></li><li><a href=#7-%ed%94%84%eb%a1%9c%ec%84%b8%ec%8a%a4-%eb%8f%99%ea%b8%b0%ed%99%94%ec%9d%98-%eb%91%90-%eb%b2%88%ec%a7%b8-%eb%ac%b8%ec%a0%9c aria-label="7. 프로세스 동기화의 두 번째 문제">7. 프로세스 동기화의 두 번째 문제</a></li><li><a href=#8-%ed%94%84%eb%a1%9c%ec%84%b8%ec%8a%a4-%eb%8f%99%ea%b8%b0%ed%99%94%ec%9d%98-%ec%84%b8-%eb%b2%88%ec%a7%b8-%eb%ac%b8%ec%a0%9c aria-label="8. 프로세스 동기화의 세 번째 문제">8. 프로세스 동기화의 세 번째 문제</a></li><li><a href=#9-monitor aria-label="9. Monitor">9. Monitor</a><ul><li><a href=#91-semaphore%ec%9d%98-%eb%ac%b8%ec%a0%9c%ec%a0%90 aria-label="9.1 Semaphore의 문제점">9.1 Semaphore의 문제점</a></li><li><a href=#92-monitor aria-label="9.2 Monitor">9.2 Monitor</a><ul><li><a href=#921-monitor-%eb%82%b4%eb%b6%80-%ea%b5%ac%ec%a1%b0 aria-label="9.2.1 Monitor 내부 구조">9.2.1 Monitor 내부 구조</a></li></ul></li></ul></li><li><a href=#reference aria-label=Reference>Reference</a></li></ul></div></details></div><div class=post-content><h1 id=0-introduction>0. Introduction<a hidden class=anchor aria-hidden=true href=#0-introduction>#</a></h1><ul><li>해당 내용은 <a href="http://www.kocw.net/home/cview.do?lid=3dd1117c48123b8e">kocw 이화여자대학교 운영체제 - 반효경 교수 -</a> 강의만 보고 정리한 내용이다.</li><li><a href="http://www.kyobobook.co.kr/product/detailViewKor.laf?ejkGb=KOR&mallGb=KOR&barcode=9791158903589&orderClick=LAG&Kc=">운영체제와 정보기술의 원리 -반효경 지음-</a> 책에는 있지 않은 내용이다.</li><li>정확하지 않은 내용이 있다면 말씀해주시면 감사하겠습니다.</li></ul><hr><h1 id=6-프로세스-동기화의-첫-번째-문제>6. 프로세스 동기화의 첫 번째 문제<a hidden class=anchor aria-hidden=true href=#6-프로세스-동기화의-첫-번째-문제>#</a></h1><blockquote><p>**Bounded-buffer problem (producer-consumber problem)**으로서, <strong>생산자와 소비자가 공유 buffer에 도착했을 경우, 동기화되지 않는 문제</strong></p></blockquote><ul><li><p><strong>buffer: 임시로 데이터를 저장하는 공간</strong></p></li><li><p><strong>두 종류의 process</strong></p><ul><li>Producer: 생산자 process로서, 공유 buffer에다가 데이터를 만들어서 집어넣는 역할</li><li>Consumer: 소비자 process로서, 공유 buffer에서 데이터를 꺼내는 역할</li></ul></li><li><p><strong>Bounded-buffer로 인한 문제점</strong></p><ul><li>To producer<ul><li>buffer가 가득 차고, 소비자가 안오는 상황이라면 data를 더 이상 생산할 수 없다는 문제가 발생된다.</li></ul></li><li>To consumer<ul><li>소비자 process는 소비할 수 있는 buffer가 없으면 문제가 발생된다.</li><li>생산자 process가 내용을 넣어줄 때까지 계속 기다린다.</li></ul></li></ul></li><li><p><strong>Synchronization variable</strong></p><ul><li>mutual exclusion: 공유 데이터의 상호 배제를 위해서 <code>binary semaphore</code>를 사용</li><li>resource count: 가용 buffer 수를 표시하기 위해서 <code>counting semaphore</code>를 사용</li></ul></li></ul><p><img loading=lazy src=https://user-images.githubusercontent.com/78094972/166848937-b879d706-82f5-427b-8046-8d973224f2c7.PNG alt=image></p><h2 id=61-semaphore로-문제-해결하기>6.1 Semaphore로 문제 해결하기<a hidden class=anchor aria-hidden=true href=#61-semaphore로-문제-해결하기>#</a></h2><ul><li><strong>Synchronization variable (= semaphore variable)</strong><ul><li>semaphore full = 0, empty = n, mutex = 1</li></ul></li></ul><p><img loading=lazy src=https://user-images.githubusercontent.com/78094972/166849850-8daed179-abf7-4879-ba9a-049482a31c31.PNG alt=image></p><ul><li><p><strong>Producer</strong></p><ul><li>P(empty): 빈 buffer를 확인하고, 있으면 획득한다.<ul><li>빈 buffer가 없으면 이 단계에서 대기한다.</li><li>소비자가 소비한 buffer는 producer에게는 자원이다.</li></ul></li><li>P(mutex): buffer에 data를 넣기 위해 lock을 건다.</li><li>V(mutex): buffer에 건 lock을 푼다.</li><li>V(full): 내용이 들어가 있는 buffer의 갯수를 1 증가시키는 연산<ul><li>내용이 들어가 있는 buffer는 소비자에게는 자원이다. 그리고, 소비자가 내용 있는 buffer가 없어서 대기하고 있으면 소비자를 wake up 해주는 연산</li></ul></li></ul></li><li><p><strong>Consumer</strong></p><ul><li>P(full): 내용이 있는 buffer 획득</li><li>P(mutex): 획득한 buffer에 lock을 건다.</li><li>V(mutex): lock을 푼다.</li><li>V(empty): 비어있는 buffer의 수를 1 증가시킨다. 그리고, 비어진 buffer는 생산자에게 자원이 된다.</li></ul></li></ul><hr><h1 id=7-프로세스-동기화의-두-번째-문제>7. 프로세스 동기화의 두 번째 문제<a hidden class=anchor aria-hidden=true href=#7-프로세스-동기화의-두-번째-문제>#</a></h1><blockquote><p><strong>Readers and writers problem</strong></p></blockquote><ul><li><p><strong>Solution</strong></p><ul><li>Writer가 DB에 접근 허가를 아직 얻지 못한 상태에서는 모든 대기 중인 Reader들을 다 DB에 접근하게 한다.</li><li>Writer는 대기 중인 Reader가 하나도 없을 때, DB 접근이 허용된다.</li><li>일단 Writer가 DB에 접근 중이면 Reader들은 접근이 금지된다.</li><li>Writer가 DB에 빠져나가야만 Reader의 접근이 허용된다.</li><li>read는 동시에 여러 개가 접근해도 된다.</li></ul></li><li><p><strong>shared data</strong></p><ul><li>DB 자체</li><li>readcount: 현대 DB에 접근 중인 reader의 수</li></ul></li><li><p><strong>Synchronization variables</strong></p><ul><li>mutex: 공유 변수 readcount를 접근하는 코드(critical section)의 mutual exclusion 보장을 위해 사용</li><li>DB: reader와 writer가 공유 DB 자체를 올바르게 접근하는 역할</li></ul></li></ul><p><img loading=lazy src=https://user-images.githubusercontent.com/78094972/166869415-0175c2d0-9b29-4589-87f3-8a3c282db047.PNG alt=image></p><ul><li><p><strong>Writer</strong></p><ul><li>P(db)가 DB에 lock을 걸고 쓰는 작업을 수행</li><li>이 작업이 끝나면 V(db)를 통해서 lock을 푼다.</li><li>starvation 문제 발생<ul><li>write가 reader들이 다 작업을 완료할 때까지 기다리는 중에, 또 다른 reader들이 들어오면 더 오래 기다려야 한다.</li><li>위 코드에서는 starvation에 대한 대책 코드는 나와있지 않는다.</li></ul></li></ul></li><li><p><strong>Reader</strong></p><ul><li>readcount는 공유 변수이기 때문에, race condition을 방지하기 위해서 mutex 변수를 사용한다.</li><li>그래서 P(mutex)에서 readcount 변수에 lock을 건다.</li><li>readcount == 1: 자신이 최초의 reader라는 의미이고, DB에 lock을 건다.</li><li>if readcount > 1: 이미 최초의 reader가 DB에 lock을 걸었기 때문에, 추가로 DB에 lock을 걸지 않고 읽기만 한다.</li><li>readcount - -: process가 다 읽고 빠져나가기 때문에, 1 감소된다.</li><li>if readcount == 0: writer가 작성할 수 있다.</li></ul></li></ul><hr><h1 id=8-프로세스-동기화의-세-번째-문제>8. 프로세스 동기화의 세 번째 문제<a hidden class=anchor aria-hidden=true href=#8-프로세스-동기화의-세-번째-문제>#</a></h1><blockquote><p><strong>Dinning-philosophers problem (식사하는 철학자 문제)</strong></p></blockquote><ul><li><p><strong>Deadlock 발생지점</strong></p><ul><li>모든 철학자가 동시에 배가 고파서 왼쪽 젓가락을 집어버린 경우</li></ul></li><li><p><strong>Solution</strong></p><ul><li>4명의 철학자만이 테이블에 동시에 앉을 수 있도록 한다.</li><li>젓가락을 두 개 모두 집을 수 있을 때에만 젓가락을 집을 수 있게 한다.</li><li>비대칭<ul><li>짝수(홀수) 철학자는 왼쪽(오른쪽) 젓가락부터 집도록한다.</li><li>Semaphore code</li></ul></li></ul></li></ul><p><img loading=lazy src=https://user-images.githubusercontent.com/78094972/166869411-8d01e5ef-6226-4790-abaa-3f52a28a498e.PNG alt=image></p><ul><li><p><strong>Synchronization variables</strong></p><ul><li><p>enum {thinking, hungry, eating} state [5]</p></li><li><p>semaphore self[5] = 0 or 1</p><ul><li>i 번째 철학자가 젓가락을 소유할 수 있는 권한 유무</li><li>0 -> 권한 X</li><li>1 -> 권한 O</li></ul></li><li><p>semaphore mutex = 1</p><ul><li>본인의 상태를 본인 뿐만 아니라, 다른 철학자가 바꿀 수 있음을 나타내는 것</li></ul></li></ul></li><li><p>Philosopher i: 5명의 철학자가 하는 일을 의미</p><ul><li>putdown: 젓가락 내려놓기</li><li>pickup: 젓가락 집기</li><li>test</li></ul></li><li><p>밑 단원 monitor 개념을 이용한 식사하는 철학자 문제</p></li></ul><p><img loading=lazy src=https://user-images.githubusercontent.com/78094972/166918673-cd640e40-09ba-4899-af70-186e6602872f.PNG alt=image></p><pre><code>- semaphore code와 비교하기
</code></pre><hr><h1 id=9-monitor>9. Monitor<a hidden class=anchor aria-hidden=true href=#9-monitor>#</a></h1><h2 id=91-semaphore의-문제점>9.1 Semaphore의 문제점<a hidden class=anchor aria-hidden=true href=#91-semaphore의-문제점>#</a></h2><ul><li>코딩하기 어렵다.</li><li>정확성 입증이 어렵다.</li><li>자발적 협력이 필요하다.</li><li>한 번의 실수가 모든 시스템에 치명적인 영향을 준다.</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yml data-lang=yml><span style=display:flex><span><span style=color:#6272a4># Deadlock 발생 경우</span>
</span></span><span style=display:flex><span>P(mutex)
</span></span><span style=display:flex><span>Critical section
</span></span><span style=display:flex><span>P(mutex)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#6272a4># Deadlock 발생하지 않는 경우</span>
</span></span><span style=display:flex><span>V(mutex)
</span></span><span style=display:flex><span>Critical section
</span></span><span style=display:flex><span>P(mutex)
</span></span></code></pre></div><h2 id=92-monitor>9.2 Monitor<a hidden class=anchor aria-hidden=true href=#92-monitor>#</a></h2><blockquote><p><strong>동시 수행 중인 프로세스 사이에서 abstract data type의 안전한 공유를 보장하기 위한 고수준의 동기화 구조체</strong></p></blockquote><ul><li><p><strong>Semaphore와의 차이점</strong></p><ul><li>lock을 걸 필요가 없다.</li><li>Monitor: 동시 접근 막는 것을 지원</li><li>semaphore: 자원을 얻기 위해서 프로그래머가 작성</li></ul></li><li><p><strong>monitor는 공유 데이터에 접근하기 위해서 monitor 라고 정의된 내부 procedure를 통해서만 접근이 가능하다.</strong></p></li></ul><p><img loading=lazy src=https://user-images.githubusercontent.com/78094972/166883364-8f1bfcff-871b-4902-88e1-8f55bf210716.PNG alt=image></p><ul><li>이 monitor를 어떻게 지원할지는 프로그래밍 언어마다 다르다.</li></ul><h3 id=921-monitor-내부-구조>9.2.1 Monitor 내부 구조<a hidden class=anchor aria-hidden=true href=#921-monitor-내부-구조>#</a></h3><p><img loading=lazy src=https://user-images.githubusercontent.com/78094972/166883357-5f2c5c89-91c0-45d3-bef5-88bc15c00e86.PNG alt=image></p><blockquote><p><strong>shared data + shared data에 접근하는 operations + initialization code</strong></p></blockquote><ul><li><p><strong>Process</strong></p><ul><li>shared data에 접근하고 싶으면 밑에 operations (process) 들을 통해서만 가능하다.</li><li>process들은 동시에 실행되지 않고, 한 번에 한 process만 실행되도록 설정하므로, lock이 불필요하다. 그래서 개발자가 별도로 lock을 구현할 필요가 없다. (semaphore와의 차이점 이유)</li><li>monitor 안에 하나의 process만 활성화되기 때문에, 나머지 process는 이에 entry queue에 줄서서 기다린다.</li><li>monitor 안에 공유자원의 갯수가 없어서 기다려야 하면,<ul><li>내용 있는 process를 기다리는 queue는 x이고,</li><li>내용 없는 process를 기다리는 queue는 y다.</li></ul></li></ul></li><li><p><strong>semaphore에서는 resource의 갯수를 세는 개 필요하듯이 monitor도 그러하다.</strong></p><ul><li>자원이 있으면 접근 허용, 자원이 없으면 대기한다.</li></ul></li><li><p><strong>Condition variable</strong></p><ul><li>monitor 안에서 process가 기다릴 수 있도록 하기 위해 condition variable을 사용한다.<ul><li>semaphore 변수와 동일한 역할을 한다.</li></ul></li><li>condition variable은 wait과 signal 연산에 의해서만 접근 가능하다.<ul><li>x.wait(): x.wait()을 invoke한 process는 다른 프로세스가 x.signal을 invoke하기 전까지는 suspend 된다.</li><li>x.signal(): x.signal을 정확하게 하나의 suspend된 프로세스를 resume 한다. suspend된 프로세스가 없으면 아무 일도 일어나지 않는다.</li></ul></li></ul></li><li><p><strong>monitor가 lock이 필요없는 이유</strong></p></li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yml data-lang=yml><span style=display:flex><span>&gt; monitor bounded_buffer
</span></span><span style=display:flex><span>&gt; {   int buffer[n];
</span></span><span style=display:flex><span>&gt;   condition full, empty;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>&gt;   void produce(int x)
</span></span><span style=display:flex><span>&gt;   { if there is no empty buffer
</span></span><span style=display:flex><span>&gt;       empty.wait();
</span></span><span style=display:flex><span>&gt;     add x to an empty buffer
</span></span><span style=display:flex><span>&gt;       full.signal ();
</span></span><span style=display:flex><span>&gt;   }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>&gt;   void consume(int *x)
</span></span><span style=display:flex><span>&gt;   { if there is no full buffer
</span></span><span style=display:flex><span>&gt;       full.wait();
</span></span><span style=display:flex><span>&gt;     remove an item from buffer and store it to *x
</span></span><span style=display:flex><span>&gt;       empty.signal();
</span></span><span style=display:flex><span>&gt;   }
</span></span><span style=display:flex><span>&gt; }
</span></span></code></pre></div><ul><li>full, empty 같은 condition var.을 가지지 않고, 자신의 queue에 process를 매달아서, sleep시키거나, queue에서 process를 깨우는 역할만 한다.<ul><li>full: 내용이 들어 있는 buffer를 기다리면서 잠들게 하는 역할</li><li>empty: 내용이 없는 buffer를 기다리면서 잠들게 하는 역할</li></ul></li><li>작업을 하기 위해서는 모니터 내부 코드를 실행해야 한다.</li><li>생산자 소비자 모두 하나의 프로세스 안에서 활성화되기 때문에, 락을 걸지 않아도 race condition 문제를 고려하지 않아도 된다.</li><li>empty.wait()<ul><li>생산자 입장에서는 빈 buffer가 필요한데, 그런 경우 empty wait을 통해서 빈 buffer에 줄 서서 기다린다.</li></ul></li><li>full.signal()<ul><li>내용이 들어 있는 buffer가 있으면 생산자를 깨운다.</li></ul></li></ul><hr><h1 id=reference>Reference<a hidden class=anchor aria-hidden=true href=#reference>#</a></h1><ul><li><a href="http://www.kocw.net/home/cview.do?lid=3dd1117c48123b8e">kocw 이화여자대학교 운영체제 - 반효경 교수 -</a></li></ul></div><footer class=post-footer><ul class=post-tags><li><a href=http://jeha00.github.io/tags/til/>TIL</a></li><li><a href=http://jeha00.github.io/tags/os/>OS</a></li></ul><nav class=paginav><a class=prev href=http://jeha00.github.io/post/os/os_chapter_09_%EA%B5%90%EC%B0%A9%EC%83%81%ED%83%9C/><span class=title>« Prev Page</span><br><span>[TIL] OS Chapter 09: 교착 상태</span></a>
<a class=next href=http://jeha00.github.io/post/os/os_chapter_08_%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4_%EB%8F%99%EA%B8%B0%ED%99%94_1/><span class=title>Next Page »</span><br><span>[TIL] OS Chapter 08: 프로세스 동기화 1</span></a></nav><div class=share-buttons><a target=_blank rel="noopener noreferrer" aria-label="share [TIL] OS Chapter 08: 프로세스 동기화 2 on twitter" href="https://twitter.com/intent/tweet/?text=%5bTIL%5d%20OS%20Chapter%2008%3a%20%ed%94%84%eb%a1%9c%ec%84%b8%ec%8a%a4%20%eb%8f%99%ea%b8%b0%ed%99%94%202&url=http%3a%2f%2fjeha00.github.io%2fpost%2fos%2fos_chapter_08_%25ED%2594%2584%25EB%25A1%259C%25EC%2584%25B8%25EC%258A%25A4_%25EB%258F%2599%25EA%25B8%25B0%25ED%2599%2594_2%2f&hashtags=TIL%2cOS"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM195.519 424.544c135.939.0 210.268-112.643 210.268-210.268.0-3.218.0-6.437-.153-9.502 14.406-10.421 26.973-23.448 36.935-38.314-13.18 5.824-27.433 9.809-42.452 11.648 15.326-9.196 26.973-23.602 32.49-40.92-14.252 8.429-30.038 14.56-46.896 17.931-13.487-14.406-32.644-23.295-53.946-23.295-40.767.0-73.87 33.104-73.87 73.87.0 5.824.613 11.494 1.992 16.858-61.456-3.065-115.862-32.49-152.337-77.241-6.284 10.881-9.962 23.601-9.962 37.088.0 25.594 13.027 48.276 32.95 61.456-12.107-.307-23.448-3.678-33.41-9.196v.92c0 35.862 25.441 65.594 59.311 72.49-6.13 1.686-12.72 2.606-19.464 2.606-4.751.0-9.348-.46-13.946-1.38 9.349 29.426 36.628 50.728 68.965 51.341-25.287 19.771-57.164 31.571-91.8 31.571-5.977.0-11.801-.306-17.625-1.073 32.337 21.15 71.264 33.41 112.95 33.41z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share [TIL] OS Chapter 08: 프로세스 동기화 2 on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&url=http%3a%2f%2fjeha00.github.io%2fpost%2fos%2fos_chapter_08_%25ED%2594%2584%25EB%25A1%259C%25EC%2584%25B8%25EC%258A%25A4_%25EB%258F%2599%25EA%25B8%25B0%25ED%2599%2594_2%2f&title=%5bTIL%5d%20OS%20Chapter%2008%3a%20%ed%94%84%eb%a1%9c%ec%84%b8%ec%8a%a4%20%eb%8f%99%ea%b8%b0%ed%99%94%202&summary=%5bTIL%5d%20OS%20Chapter%2008%3a%20%ed%94%84%eb%a1%9c%ec%84%b8%ec%8a%a4%20%eb%8f%99%ea%b8%b0%ed%99%94%202&source=http%3a%2f%2fjeha00.github.io%2fpost%2fos%2fos_chapter_08_%25ED%2594%2584%25EB%25A1%259C%25EC%2584%25B8%25EC%258A%25A4_%25EB%258F%2599%25EA%25B8%25B0%25ED%2599%2594_2%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share [TIL] OS Chapter 08: 프로세스 동기화 2 on reddit" href="https://reddit.com/submit?url=http%3a%2f%2fjeha00.github.io%2fpost%2fos%2fos_chapter_08_%25ED%2594%2584%25EB%25A1%259C%25EC%2584%25B8%25EC%258A%25A4_%25EB%258F%2599%25EA%25B8%25B0%25ED%2599%2594_2%2f&title=%5bTIL%5d%20OS%20Chapter%2008%3a%20%ed%94%84%eb%a1%9c%ec%84%b8%ec%8a%a4%20%eb%8f%99%ea%b8%b0%ed%99%94%202"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share [TIL] OS Chapter 08: 프로세스 동기화 2 on facebook" href="https://facebook.com/sharer/sharer.php?u=http%3a%2f%2fjeha00.github.io%2fpost%2fos%2fos_chapter_08_%25ED%2594%2584%25EB%25A1%259C%25EC%2584%25B8%25EC%258A%25A4_%25EB%258F%2599%25EA%25B8%25B0%25ED%2599%2594_2%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share [TIL] OS Chapter 08: 프로세스 동기화 2 on whatsapp" href="https://api.whatsapp.com/send?text=%5bTIL%5d%20OS%20Chapter%2008%3a%20%ed%94%84%eb%a1%9c%ec%84%b8%ec%8a%a4%20%eb%8f%99%ea%b8%b0%ed%99%94%202%20-%20http%3a%2f%2fjeha00.github.io%2fpost%2fos%2fos_chapter_08_%25ED%2594%2584%25EB%25A1%259C%25EC%2584%25B8%25EC%258A%25A4_%25EB%258F%2599%25EA%25B8%25B0%25ED%2599%2594_2%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share [TIL] OS Chapter 08: 프로세스 동기화 2 on telegram" href="https://telegram.me/share/url?text=%5bTIL%5d%20OS%20Chapter%2008%3a%20%ed%94%84%eb%a1%9c%ec%84%b8%ec%8a%a4%20%eb%8f%99%ea%b8%b0%ed%99%94%202&url=http%3a%2f%2fjeha00.github.io%2fpost%2fos%2fos_chapter_08_%25ED%2594%2584%25EB%25A1%259C%25EC%2584%25B8%25EC%258A%25A4_%25EB%258F%2599%25EA%25B8%25B0%25ED%2599%2594_2%2f"><svg viewBox="2 2 28 28"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></div></footer><script src=https://utteranc.es/client.js repo=JeHa00/blog-comments issue-term=pathname theme=github-dark crossorigin=anonymous async></script></article></main><footer class=footer><span>&copy; 2022 <a href=http://jeha00.github.io/>Jeha00 DevLog</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(t){t.preventDefault();var e=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(e)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(e)}']`).scrollIntoView({behavior:"smooth"}),e==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${e}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>