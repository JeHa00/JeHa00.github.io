<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>[TIL] OS Chapter 08: 프로세스 동기화 1 | Jeha00 DevLog</title><meta name=keywords content="TIL,OS"><meta name=description content="Race condition이란 무엇이고, 이 race condition은 OS에서 언제 발생되며, 이를 해결하기 위한 방법으로 SW 방법과 SW 방법에는 무엇이 있는지를 배운다. 또한, Semaphore가 무엇인지 알아본다."><meta name=author content="Jeha00"><link rel=canonical href=http://jeha00.github.io/post/os/os_chapter_08_%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4_%EB%8F%99%EA%B8%B0%ED%99%94_1/><meta name=google-site-verification content="XYZabc"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.min.1e44d58192cbf6d7a4eb649bc43dbc3d4cc432677e5d8adc69b08c34cbe461ac.css integrity="sha256-HkTVgZLL9tek62SbxD28PUzEMmd+XYrcabCMNMvkYaw=" rel="preload stylesheet" as=style><link rel=icon href=http://jeha00.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=http://jeha00.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=http://jeha00.github.io/favicon-32x32.png><link rel=apple-touch-icon href=http://jeha00.github.io/apple-touch-icon.png><link rel=mask-icon href=http://jeha00.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><meta name=generator content="Hugo 0.101.0"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script type=application/javascript>var doNotTrack=!1;doNotTrack||(function(e,t,n,s,o,i,a){e.GoogleAnalyticsObject=o,e[o]=e[o]||function(){(e[o].q=e[o].q||[]).push(arguments)},e[o].l=1*new Date,i=t.createElement(n),a=t.getElementsByTagName(n)[0],i.async=1,i.src=s,a.parentNode.insertBefore(i,a)}(window,document,"script","https://www.google-analytics.com/analytics.js","ga"),ga("create","UA-123-45","auto"),ga("send","pageview"))</script><meta property="og:title" content="[TIL] OS Chapter 08: 프로세스 동기화 1"><meta property="og:description" content="Race condition이란 무엇이고, 이 race condition은 OS에서 언제 발생되며, 이를 해결하기 위한 방법으로 SW 방법과 SW 방법에는 무엇이 있는지를 배운다. 또한, Semaphore가 무엇인지 알아본다."><meta property="og:type" content="article"><meta property="og:url" content="http://jeha00.github.io/post/os/os_chapter_08_%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4_%EB%8F%99%EA%B8%B0%ED%99%94_1/"><meta property="og:image" content="http://jeha00.github.io/47"><meta property="article:section" content="post"><meta property="article:published_time" content="2022-05-04T20:53:38+09:00"><meta property="article:modified_time" content="2022-05-04T20:53:38+09:00"><meta property="og:site_name" content="JeHa00 DevLog"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="http://jeha00.github.io/47"><meta name=twitter:title content="[TIL] OS Chapter 08: 프로세스 동기화 1"><meta name=twitter:description content="Race condition이란 무엇이고, 이 race condition은 OS에서 언제 발생되며, 이를 해결하기 위한 방법으로 SW 방법과 SW 방법에는 무엇이 있는지를 배운다. 또한, Semaphore가 무엇인지 알아본다."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"http://jeha00.github.io/post/"},{"@type":"ListItem","position":2,"name":"[TIL] OS Chapter 08: 프로세스 동기화 1","item":"http://jeha00.github.io/post/os/os_chapter_08_%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4_%EB%8F%99%EA%B8%B0%ED%99%94_1/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"[TIL] OS Chapter 08: 프로세스 동기화 1","name":"[TIL] OS Chapter 08: 프로세스 동기화 1","description":"Race condition이란 무엇이고, 이 race condition은 OS에서 언제 발생되며, 이를 해결하기 위한 방법으로 SW 방법과 SW 방법에는 무엇이 있는지를 배운다. 또한, Semaphore가 무엇인지 알아본다.","keywords":["TIL","OS"],"articleBody":"0. Introduction 해당 내용은 운영체제와 정보기술의 원리 -반효경 지음- 책에는 있지 않고, kocw 이화여자대학교 운영체제 - 반효경 교수 - 강의만 보고 정리한 내용입니다. 정확하지 않은 내용이 있다면 말씀해주시면 감사하겠습니다. 1. 데이터 저장과 연산 순서 storage로부터 data를 가져와 연산한 후, 다시 storage에 저장한다. 각 box 예시 E-box S-box CPU Memory 컴퓨터 내부 디uy7스크 프로세스 그 프로세스의 주소 공간 2. Race condition 2.1 Race condition이란?? 여러 프로세스/스레드가 동시에 shared data를 조작할 때, 한 연산자가 stroage에서 가져와 작업 중인데, 작업 중인 data를 다른 연산자가 가져가서 작업하여 동기화되지 않는 현상\n2.2 Race condition 발생 배경과 원인 공유 데이터(shared data)의 동시 접근(concurrent access) -\u003e 데이터의 불일치(inconsistency) 발생\n그래서 concurrent process는 동기화가 필요하다.\n일관성(consistency) 유지를 위해 협력 프로세스(cooperating process) 간의 실행 순서(oderly execution)을 정해주는 메커니즘이 필요하다. 데이터 불일치가 발생하는 상황들\nMultiprocessor system (Memory ~ CPU) shared memory를 사용하는 process들 (address space ~ process) kernel 내부 data를 접근하는 routine들 간 발생 3. OS에서의 race condition 3가지 원인: kernel address space를 공유할 때, race condition이 발생한다.\n3.1 Interrupt handler vs kernel 연산 과정\n첫 번째: load 메모리에 있는 값을 CPU 내의 register로 불러들인다. 두 번째: Increase 불러들인 값을 증가시킨다. 세 번째: Store memory에 저장시킨다. Race condition 발생\nLoad 후, interrupt가 들어왔을 경우 -\u003e Count++ 작업을 중단한 후, interrupt service routine으로 넘어간다. -\u003e interrupt handler 이기 때문에, kernel address space를 공유한다. -\u003e 이 상황에서 Count --를 실행하여, 완료하면 interrupt 당한 작업으로 돌아온다. -\u003e 돌아와서 interrupt handler 작업을 완료한 context 부터 작업을 실행해야 하지만, interrupt 당하기 전 load 한 context부터 실행된다. 즉, count--는 실행이 안된 것과 동일하다. Solution: 먼저 하던 작업을 끝낸 후, 넘긴다.\n중요한 변수값을 건드리는 동안에는 인터럽트가 들어와도 인터럽트 처리 루틴으로 바로 넘어가지 않는다. 인터럽트를 disable 시켰다가, 작업이 다 끝난 다음에 interrupt service routine으로 넘긴다. 3.2 Preempt a process running in kernel 한 프로세스의 system call을 통한 mode 전환 이미지 kernel mode로 실행 중 system call로 인한 CPU 선점 두 프로세스의 address space 간에는 data sharing이 없다. 그러나 ‘Pa의 CPU 할당시간 만료’로, Pa는 kernel mode로 실행 중 Pb에게 ‘CPU를 선점’당한다. system call을 하는 동안, kernel address space의 data에 접근한다. 이로 인해 race condition이 발생한다. Solution 첫 번째: kernel mode에서 수행 중일 때는 CPU를 빼앗지 않는다. 두 번째: kernel mode에서 user mode로 돌아갈 때 CPU를 빼앗는다. 3.3 Multi-processor Problem\nmulti-processor인 경우, interrupt enable 과 disable로 해결되지 않는다. CPU 한 쪽의 interrupt를 막았어도, 다른 CPU가 남아있기 때문이다. Solution\n해결책 1: 한 번에 하나의 CPU만이 kernel에 들어갈 수 있도록 하는 방법 해결책 2: shared data in kernel에 접근할 때마다 이 데이터에 대해 lock 과 unlcok을 하는 방법 kernel 전체를 하나의 lock으로 막고, kernel에서 나올 때는 unlock 한다. 4. Critical section problem 4.1 Critical section(임계구역)이란?? 각 process가 shared data에 접근하기 위해 가지고 있는 code\n4.2 Critical section problem이란 무엇인가?? Problem 2개 이상의 process가 shard data를 동시에 사용하기를 원하는 경우, 각 프로세스의 critical section을 통해서 접근해야 한다. A process가 critical section에 있을 때 = 공유 데이터에 접근하는 코드를 실행하고 있을 때, A process의 CPU 할당 시간이 끝나서 다른 process에게 CPU를 넘겼다. 하지만, A process가 critical section에 있기 때문에, 다른 process가 CPU를 받아도 critical section에 들어갈 수 없고, 대기해야 한다. 이를 Critical section problem 이라 한다. 4.3 SW 해결법의 충족 조건 3가지(requirements) 가정(Assumption)\n모든 process의 수행 속도는 0보다 크다. process들 간의 상대적인 수행 속도는 가정하지 않는다. 첫 번째 requirement: Mutual Exclusion\nprocess P_i가 critical section 부분을 수행 중이면 다른 모든 process들은 그들의 critical section에 들어가면 안된다. 두 번째 requirement: Progress\n아무도 critical section에 있지 않은 상태에서 critical section에 들어가고자 하는 process가 있으면 critical section에 들어가도록 해야한다. 첫 번째 requirement의 부작용으로 critical section에 어떤 process도 들어가지 않은 상황이 발생한다. 세 번째 requirement: Bounded waiting\nProcess가 critical section에 들어가려고 요청한 순간부터 그 요청이 허용될 때까지 다른 process들이 critical section에 들어가는 횟수에 한계가 있어야 한다. 횟수 한계가 없으면 starvation 문제가 발생한다. 4.4 위 조건을 해결하기 위한 SW solution: Peterson’s Algorithum SW 방법으로 해결하기 위한 code의 일반적인 구조 do { entry section # 다른 process는 못 들어오게 shared data를 lock 하는 code critical section # shared data에 접근하려는 코드 exit section # 다 처리 후, 다른 process가 들어오도록 unlock하는 코드 remainder section # 못 들어온 process를 의미하는 코드 } while(1) process들은 수행의 동기화(synchronization)을 위해 몇 몇 변수를 공유할 수 있다.\nsynchronization varible Algorithum이 필요한 이유\n고급 언어는 단일 instruction이 아니기 때문에, instruction 수행 중 CPU를 빼앗길 수 있기 때문이다. 그래서 이를 방지하고자 알고리즘으로 구현한다. Synchronization variables(동기화 변수)\nboolean flag [2] # process 0과 1의 flag initially flag [모두] = false; # no one is in Critical Section Process Pi가 CPU를 잡고 있는 상황 do { flag [i] = true; # critical section에 들어가겠다는 의미 turn = j; # turn을 상대방 turn을 바꾼다. # 상대방이 깃발을 들고 있고, 이번이 상대방 차례인 조건을 만족하면 기다린다. while (flag [j] \u0026\u0026 turn == j) critical section flag [i] = false; # 깃발을 내린다. remainder section } while (1) 모든 요구 조건들을 만족하지만, 그래도 문제점이 존재한다. busy waiting (= spin lock): 계속 CPU와 memory의 할당 시간을 쓰면서 기다리는 현상 while 문을 돌면서( spin ) 계속 lock 을 걸어서 상대방이 못 들어온다. A process가 critical section에 들어가 있는 상태에서 B process가 CPU를 받아서 작동할 때, B process의 CPU 할당 시간 동안 while문이 만족되는지 체크한다. 하지만, A process가 CPU를 잡아서 조건을 바꿔줘야 B process가 들어올 수 있다. 그래서 이를 busy waiting이라 한다. 4.5 위 조건을 해결하기 위한 HW solution Synchronization HW\nHW 적으로 Test \u0026 modify 를 atomic 하게 수행할 수 있도록 지원하는 경우, 앞의 문제는 간단히 해결된다.\nHW 적으로 lock을 읽고 setting하는 작업을 말한다. atomic instruction이란??\n실행 중간에 간섭받거나 중단되지 않는다. 같은 메모리 영역에 대해 동시에 실행되지 않는다. Test_and_set (a)\na라는 데이터를 읽은 후, 1로 쓰는 Instruction 읽는 작업과 쓰는 작업을 동시에 지원하는 HW가 있다면 쉽게 해결할 수 있다. Mutual exclusion with Test \u0026 Set\nSynchronization variable: boolean lock = false; # 다른 process가 lock이 걸려 있는지 확인 Process Pi do { while(Test_and_Set(lock)); critical section lock = false; # lock에 0 할당 remainder section } lock = false : critical section에 아무도 안들어간 상태 들어가고 나서, Test_and_Set에 의해 lock = True로 바뀌면서 lock 이 걸린다. lock = true: critical section에 프로세스가 들어간 상태 들어가지 못 하고, 계속 while문을 돈다. critical section에서 나오면서 lock = false로 재설정하여 while문에서 돌고 있는 process가 들어오게 한다. 5. Semaphores 5.1 Semaphores 란?? 공유자원을 얻고 반납하는 작업을 위해서 lock \u0026 unlock 작업을 도와주는 추상 자료형\n추상화\n세부 구현으로부터 분리하여 개념을 일반화시키는 것 what은 정의하지만, 언어를 사용하여 어떻게 구현할지 How는 정의하지 않는다. 추상 자료형\n추상화를 통해 얻어낸 자료형 구성: object + operation operation의 구현은 system 마다 다르다. atomic instruction이란??\n실행 중간에 간섭받거나 중단되지 않는다. 같은 메모리 영역에 대해 동시에 실행되지 않는다. Semaphores S\n위 SW와 HW 알고리즘들 방식을 추상화시켜, 보다 효율적으로 관리한다.\ninteger variable (=Semaphore variable)\nsemaphore variable = 자원의 갯수 ex) semaphore variable = 5: 자원의 갯수가 5개라는 의미 자원을 획득하는 연산을 사용하면 자원의 갯수는 감소 자원을 반납하는 연산을 사용하면 자원의 갯수는 증가 정의된 2가지 atomic operation: P, V\nSemaphore variable을 가지고 수행하는 연산\nP(S) operation: 공유 데이터 자원을 획득하고 lock을 거는 연산\n// S가 음수라는 건 자원이 없다는 걸 의미한다. // 자원이 없기 때문에, while문에서 계속 반복하며 기다린다. while(S \u003c= 0) do no-op; // 자원을 획득하여 P 연산을 시작하므로, S 값을 1 감소시킨다. S--; V(S) operation: 공유 데이터 자원을 다 사용하고 나서 반납하고, unlock하는 연산\n// operation 사용이 끝나면 V 연산을 하여 S 값을 1 증가시킨다. S++ Semaphore의 문제점\nwhile문에서 계속 기다리기 때문에 busy \u0026 wait 문제가 존재한다. 5.2 Criticall section of n process critical section에 semaphore 사용하기\nmutex = mutual exclusion Synchronization variable semaphore mutex: # initally 1 Process Pi: do { # 진입할 때 사용하는 연산. 이 조건에 만족하면 critical section에 진입하고 semaphore 감소, 그렇지 않으면 대기. P(mutex): critical section V(mutex): # 빠져나올 때 사용하는 연산으로, semaphore 증가 remainder section } while(1) busy-wait(spin lock) 방식은 CPU를 할당받았지만, while문에서 대기하는 걸로 할당시간을 낭비하기 때문에 효율적이지 못하다. 그래서 block \u0026 wake up (=sleep lock) 방식으로 구현한다. shared data를 쓰고 있는 process가 criticial section 실행을 완료할 때까지, 대기 중인 process는 block 상태에 있어서 CPU를 얻지 못하고, 사용 중이던 process가 데이터를 내놓으면 block 상태에 있는 process는 wake up 하여 ready queue에 들어와서 대기하는 방식 5.3 Block \u0026 Wakeup implementation Semaphore 정의 typeef struct { int value; # semaphore를 의미 struct process *L; # queue for process wait } semaphore; Block \u0026 Wakeup\nBlock kernel은 block을 호출한 process를 suspend 시킨다. 이 process의 PCB를 semaphore에 대한 wait queue에 넣는다. Wake up block state인 process P를 wake up 이 process의 PCB를 ready queue로 옮긴다. 정의된 Semaphore 연산\nS: semaphore variable\nP(S): resource 획득 연산\nS.value --; # 자원을 획득하기 때문에 감소 if (S.value \u003c 0 ) # 음수이면 들어가지 못 한다. { # 음수면 이 프로세스를 queue에서 대기하도록 추가한다. 그 후, block로 둔다. add this process to S.L; block } V(S): resource 반납 연산과 이 자원을 기다리면 잠든 프로세스를 깨우는 연산 S.value ++; # 자원을 내놓았는데도 0이거나 음수라는 건, 어떤 프로세스가 P 연산에 의해 block 상태임을 의미 if (S.value \u003c= 0 ) { # queue에서 제거한다. remove this process to S.L; wake(P); } 5.4 Busy-wait VS Block \u0026 wake-up critical section의 길이에 따라 달라진다.\ncritical section의 길이가 긴 경우\nblock / wakeup이 필수 오랫 동안 풀지 않은 lock을 풀기 위해 CPU를 얻어도 계속 while문에서 대기하는 게 길기 때문이다. critical section의 길이가 짧은 경우\nblock/wakeup overhead가 busy-wait overhead보다 더 커질 수 있다. 일반적으로는 block/wakeup 방식이 더 좋다. 5.5 Two types of semaphores Counting semaphores and Binary semaphores (=mutext)\nAttribute Counting semaphore Binary semaphore resource resource \u003e= 0 resource = 1 purpose resource counting mutext(lock / unlock) 5.5 Semaphore 주의사항: Deadlock and Starvation 5.5.1 Deadlock 둘 이상의 process가 서로 상대방에 의해 충족될 수 있는 event를 무한히 기다리는 현상\n어떤 일을 하기 위해서, S와 Q를 모두 획득해야지만 일할 수 있고, S, Q를 모두 반환한다. S와 Q: 서로 배타적으로 사용할 수 있는, 1로 초기화된 semaphore - Process 모두 하나씩 차지한 상황 - P0가 S를 먼저 작업하다가 CPU를 빼앗겨 P1이 CPU와 Q semaphore 를 얻어 작업한다. - 그런데, 상대방의 것을 서로 요구한다. - 하지만, 서로 가지고 있기 때문에, 영원히 기다려야 한다. - 왜냐하면 다 사용하고 나서 반환하기 때문이다. - 이 문제를 `Deadlock` 이라 한다. Solution - 서로 다른 프로세스여도 같은 순서로 정한다. - Q를 획득하려면 S를 먼저 획득하라는 의미 5.5.2 Starvation infinite blocking이라 하며, process가 suspend된 이유에 해당하는 semaphore queue에서 빠져나갈 수 없는 현상\n특정 process 자원을 독점하여 나머지 프로세스가 자원을 얻지 못하고 무한히 기다리는 현상으로 Deadlock과 유사하지만, 다르다. Reference kocw 이화여자대학교 운영체제 - 반효경 교수 - ","wordCount":"1678","inLanguage":"en","datePublished":"2022-05-04T20:53:38+09:00","dateModified":"2022-05-04T20:53:38+09:00","author":{"@type":"Person","name":"Jeha00"},"mainEntityOfPage":{"@type":"WebPage","@id":"http://jeha00.github.io/post/os/os_chapter_08_%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4_%EB%8F%99%EA%B8%B0%ED%99%94_1/"},"publisher":{"@type":"Organization","name":"Jeha00 DevLog","logo":{"@type":"ImageObject","url":"http://jeha00.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=http://jeha00.github.io/ accesskey=h title="Jeha00 (Alt + H)">Jeha00</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></span></div><ul id=menu><li><a href=http://jeha00.github.io/archives/ title=Archive><span>Archive</span></a></li><li><a href=http://jeha00.github.io/categories/ title=Categories><span>Categories</span></a></li><li><a href=http://jeha00.github.io/tags/ title=Tags><span>Tags</span></a></li><li><a href=http://jeha00.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=http://jeha00.github.io/>Home</a>&nbsp;»&nbsp;<a href=http://jeha00.github.io/post/>Posts</a></div><h1 class=post-title>[TIL] OS Chapter 08: 프로세스 동기화 1</h1><div class=post-meta><span title='2022-05-04 20:53:38 +0900 KST'>May 4, 2022</span>&nbsp;·&nbsp;8 min&nbsp;·&nbsp;Jeha00&nbsp;|&nbsp;<a href=https://github.com/JeHa00/blog/content/post/OS/OS_Chapter_08_%ed%94%84%eb%a1%9c%ec%84%b8%ec%8a%a4_%eb%8f%99%ea%b8%b0%ed%99%94_1.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#0-introduction aria-label="0. Introduction">0. Introduction</a></li><li><a href=#1-%eb%8d%b0%ec%9d%b4%ed%84%b0-%ec%a0%80%ec%9e%a5%ea%b3%bc-%ec%97%b0%ec%82%b0-%ec%88%9c%ec%84%9c aria-label="1. 데이터 저장과 연산 순서">1. 데이터 저장과 연산 순서</a></li><li><a href=#2-race-condition aria-label="2. Race condition">2. Race condition</a><ul><li><a href=#21-race-condition%ec%9d%b4%eb%9e%80 aria-label="2.1 Race condition이란??">2.1 Race condition이란??</a></li><li><a href=#22-race-condition-%eb%b0%9c%ec%83%9d-%eb%b0%b0%ea%b2%bd%ea%b3%bc-%ec%9b%90%ec%9d%b8 aria-label="2.2 Race condition 발생 배경과 원인">2.2 Race condition 발생 배경과 원인</a></li></ul></li><li><a href=#3-os%ec%97%90%ec%84%9c%ec%9d%98-race-condition-3%ea%b0%80%ec%a7%80 aria-label="3. OS에서의 race condition 3가지">3. OS에서의 race condition 3가지</a><ul><li><a href=#31-interrupt-handler-vs-kernel aria-label="3.1 Interrupt handler vs kernel">3.1 Interrupt handler vs kernel</a></li><li><a href=#32-preempt-a-process-running-in-kernel aria-label="3.2 Preempt a process running in kernel">3.2 Preempt a process running in kernel</a></li><li><a href=#33-multi-processor aria-label="3.3 Multi-processor">3.3 Multi-processor</a></li></ul></li><li><a href=#4-critical-section-problem aria-label="4. Critical section problem">4. Critical section problem</a><ul><li><a href=#41-critical-section%ec%9e%84%ea%b3%84%ea%b5%ac%ec%97%ad%ec%9d%b4%eb%9e%80 aria-label="4.1 Critical section(임계구역)이란??">4.1 Critical section(임계구역)이란??</a></li><li><a href=#42-critical-section-problem%ec%9d%b4%eb%9e%80-%eb%ac%b4%ec%97%87%ec%9d%b8%ea%b0%80 aria-label="4.2 Critical section problem이란 무엇인가??">4.2 Critical section problem이란 무엇인가??</a></li><li><a href=#43-sw-%ed%95%b4%ea%b2%b0%eb%b2%95%ec%9d%98-%ec%b6%a9%ec%a1%b1-%ec%a1%b0%ea%b1%b4-3%ea%b0%80%ec%a7%80requirements aria-label="4.3 SW 해결법의 충족 조건 3가지(requirements)">4.3 SW 해결법의 충족 조건 3가지(requirements)</a></li><li><a href=#44-%ec%9c%84-%ec%a1%b0%ea%b1%b4%ec%9d%84-%ed%95%b4%ea%b2%b0%ed%95%98%ea%b8%b0-%ec%9c%84%ed%95%9c-sw-solution-petersons-algorithum aria-label="4.4 위 조건을 해결하기 위한 SW solution: Peterson&amp;rsquo;s Algorithum">4.4 위 조건을 해결하기 위한 SW solution: Peterson&rsquo;s Algorithum</a></li><li><a href=#45-%ec%9c%84-%ec%a1%b0%ea%b1%b4%ec%9d%84-%ed%95%b4%ea%b2%b0%ed%95%98%ea%b8%b0-%ec%9c%84%ed%95%9c-hw-solution aria-label="4.5 위 조건을 해결하기 위한 HW solution">4.5 위 조건을 해결하기 위한 HW solution</a></li></ul></li><li><a href=#5-semaphores aria-label="5. Semaphores">5. Semaphores</a><ul><li><a href=#51-semaphores-%eb%9e%80 aria-label="5.1 Semaphores 란??">5.1 Semaphores 란??</a></li><li><a href=#52-criticall-section-of-n-process aria-label="5.2 Criticall section of n process">5.2 Criticall section of n process</a></li><li><a href=#53-block--wakeup-implementation aria-label="5.3 Block &amp;amp; Wakeup implementation">5.3 Block & Wakeup implementation</a></li><li><a href=#54-busy-wait-vs-block--wake-up aria-label="5.4 Busy-wait VS Block &amp;amp; wake-up">5.4 Busy-wait VS Block & wake-up</a></li><li><a href=#55-two-types-of-semaphores aria-label="5.5 Two types of semaphores">5.5 Two types of semaphores</a></li><li><a href=#55-semaphore-%ec%a3%bc%ec%9d%98%ec%82%ac%ed%95%ad-deadlock-and-starvation aria-label="5.5 Semaphore 주의사항: Deadlock and Starvation">5.5 Semaphore 주의사항: Deadlock and Starvation</a><ul><li><a href=#551-deadlock aria-label="5.5.1 Deadlock">5.5.1 Deadlock</a></li><li><a href=#552-starvation aria-label="5.5.2 Starvation">5.5.2 Starvation</a></li></ul></li></ul></li><li><a href=#reference aria-label=Reference>Reference</a></li></ul></div></details></div><div class=post-content><h1 id=0-introduction>0. Introduction<a hidden class=anchor aria-hidden=true href=#0-introduction>#</a></h1><ul><li>해당 내용은 <a href="http://www.kyobobook.co.kr/product/detailViewKor.laf?ejkGb=KOR&mallGb=KOR&barcode=9791158903589&orderClick=LAG&Kc=">운영체제와 정보기술의 원리 -반효경 지음-</a> 책에는 있지 않고, <a href="http://www.kocw.net/home/cview.do?lid=3dd1117c48123b8e">kocw 이화여자대학교 운영체제 - 반효경 교수 -</a> 강의만 보고 정리한 내용입니다.</li><li>정확하지 않은 내용이 있다면 말씀해주시면 감사하겠습니다.</li></ul><hr><h1 id=1-데이터-저장과-연산-순서>1. 데이터 저장과 연산 순서<a hidden class=anchor aria-hidden=true href=#1-데이터-저장과-연산-순서>#</a></h1><ul><li>storage로부터 data를 가져와 연산한 후, 다시 storage에 저장한다.</li></ul><p><img loading=lazy src=https://user-images.githubusercontent.com/78094972/166150665-b6be593e-349a-45ac-b456-ca7012b1c258.PNG alt=image></p><ul><li>각 box 예시<table><thead><tr><th>E-box</th><th>S-box</th></tr></thead><tbody><tr><td>CPU</td><td>Memory</td></tr><tr><td>컴퓨터 내부</td><td>디uy7스크</td></tr><tr><td>프로세스</td><td>그 프로세스의 주소 공간</td></tr></tbody></table></li></ul><hr><h1 id=2-race-condition>2. Race condition<a hidden class=anchor aria-hidden=true href=#2-race-condition>#</a></h1><h2 id=21-race-condition이란>2.1 Race condition이란??<a hidden class=anchor aria-hidden=true href=#21-race-condition이란>#</a></h2><blockquote><p><strong>여러 프로세스/스레드가 동시에 shared data를 조작할 때, 한 연산자가 stroage에서 가져와 작업 중인데, 작업 중인 data를 다른 연산자가 가져가서 작업하여 동기화되지 않는 현상</strong></p></blockquote><h2 id=22-race-condition-발생-배경과-원인>2.2 Race condition 발생 배경과 원인<a hidden class=anchor aria-hidden=true href=#22-race-condition-발생-배경과-원인>#</a></h2><ul><li><p><strong>공유 데이터(shared data)의 동시 접근(concurrent access) -> 데이터의 불일치(inconsistency) 발생</strong></p></li><li><p><strong>그래서 concurrent process는 동기화가 필요하다.</strong></p><ul><li>일관성(consistency) 유지를 위해 협력 프로세스(cooperating process) 간의 실행 순서(oderly execution)을 정해주는 메커니즘이 필요하다.</li></ul></li><li><p><strong>데이터 불일치가 발생하는 상황들</strong></p><ul><li>Multiprocessor system (Memory ~ CPU)</li><li>shared memory를 사용하는 process들 (address space ~ process)</li><li>kernel 내부 data를 접근하는 routine들 간 발생</li></ul></li></ul><hr><h1 id=3-os에서의-race-condition-3가지>3. OS에서의 race condition 3가지<a hidden class=anchor aria-hidden=true href=#3-os에서의-race-condition-3가지>#</a></h1><blockquote><p>원인: kernel address space를 공유할 때, race condition이 발생한다.</p></blockquote><h2 id=31-interrupt-handler-vs-kernel>3.1 Interrupt handler vs kernel<a hidden class=anchor aria-hidden=true href=#31-interrupt-handler-vs-kernel>#</a></h2><p><img loading=lazy src=https://user-images.githubusercontent.com/78094972/166150669-f384805c-84d2-47ff-988d-2d7f1c78fc13.PNG alt=image></p><ul><li><p><strong>연산 과정</strong></p><ul><li>첫 번째: load<ul><li>메모리에 있는 값을 CPU 내의 register로 불러들인다.</li></ul></li><li>두 번째: Increase<ul><li>불러들인 값을 증가시킨다.</li></ul></li><li>세 번째: Store<ul><li>memory에 저장시킨다.</li></ul></li></ul></li><li><p><strong>Race condition 발생</strong></p><ul><li>Load 후, interrupt가 들어왔을 경우 -></li><li><code>Count++</code> 작업을 중단한 후, interrupt service routine으로 넘어간다. -></li><li>interrupt handler 이기 때문에, <code>kernel address space</code>를 공유한다. -></li><li>이 상황에서 <code>Count --</code>를 실행하여, 완료하면 interrupt 당한 작업으로 돌아온다. -></li><li>돌아와서 interrupt handler 작업을 완료한 context 부터 작업을 실행해야 하지만, interrupt 당하기 전 load 한 context부터 실행된다.</li><li>즉, <code>count--</code>는 실행이 안된 것과 동일하다.</li></ul></li><li><p><strong>Solution: 먼저 하던 작업을 끝낸 후, 넘긴다.</strong></p><ul><li>중요한 변수값을 건드리는 동안에는 인터럽트가 들어와도 인터럽트 처리 루틴으로 바로 넘어가지 않는다.</li><li>인터럽트를 <code>disable</code> 시켰다가, 작업이 다 끝난 다음에 interrupt service routine으로 넘긴다.</li></ul></li></ul><h2 id=32-preempt-a-process-running-in-kernel>3.2 Preempt a process running in kernel<a hidden class=anchor aria-hidden=true href=#32-preempt-a-process-running-in-kernel>#</a></h2><ul><li><strong>한 프로세스의 system call을 통한 mode 전환 이미지</strong></li></ul><p><img loading=lazy src=https://user-images.githubusercontent.com/78094972/166150673-e2cc077e-d9c6-4e5f-aa27-a5f5c9d9cb76.PNG alt=image></p><ul><li><strong>kernel mode로 실행 중 system call로 인한 CPU 선점</strong><ul><li>두 프로세스의 address space 간에는 data sharing이 없다.<ul><li>그러나 &lsquo;Pa의 CPU 할당시간 만료&rsquo;로, Pa는 kernel mode로 실행 중 Pb에게 &lsquo;CPU를 선점&rsquo;당한다.</li></ul></li><li>system call을 하는 동안, kernel address space의 data에 접근한다.</li><li>이로 인해 <code>race condition</code>이 발생한다.</li></ul></li></ul><p><img loading=lazy src=https://user-images.githubusercontent.com/78094972/166150674-b4f63a05-e17a-4a1c-9696-5a94efd2da9f.PNG alt=image></p><ul><li><strong>Solution</strong><ul><li>첫 번째: kernel mode에서 수행 중일 때는 CPU를 빼앗지 않는다.</li><li>두 번째: kernel mode에서 user mode로 돌아갈 때 CPU를 빼앗는다.</li></ul></li></ul><h2 id=33-multi-processor>3.3 Multi-processor<a hidden class=anchor aria-hidden=true href=#33-multi-processor>#</a></h2><p><img loading=lazy src=https://user-images.githubusercontent.com/78094972/166150667-a0483412-2fc6-488c-a463-98f43ea5c353.PNG alt=image></p><ul><li><p><strong>Problem</strong></p><ul><li>multi-processor인 경우, interrupt enable 과 disable로 해결되지 않는다.</li><li>CPU 한 쪽의 interrupt를 막았어도, 다른 CPU가 남아있기 때문이다.</li></ul></li><li><p><strong>Solution</strong></p><ul><li>해결책 1: 한 번에 하나의 CPU만이 kernel에 들어갈 수 있도록 하는 방법</li><li>해결책 2: shared data in kernel에 접근할 때마다 이 데이터에 대해 lock 과 unlcok을 하는 방법<ul><li>kernel 전체를 하나의 lock으로 막고, kernel에서 나올 때는 unlock 한다.</li></ul></li></ul></li></ul><hr><h1 id=4-critical-section-problem>4. Critical section problem<a hidden class=anchor aria-hidden=true href=#4-critical-section-problem>#</a></h1><h2 id=41-critical-section임계구역이란>4.1 Critical section(임계구역)이란??<a hidden class=anchor aria-hidden=true href=#41-critical-section임계구역이란>#</a></h2><blockquote><p>각 process가 shared data에 접근하기 위해 가지고 있는 code</p></blockquote><h2 id=42-critical-section-problem이란-무엇인가>4.2 Critical section problem이란 무엇인가??<a hidden class=anchor aria-hidden=true href=#42-critical-section-problem이란-무엇인가>#</a></h2><p><img loading=lazy src=https://user-images.githubusercontent.com/78094972/166150661-dec4d572-8875-4297-ab31-3a4d3f25cb4f.PNG alt=image></p><ul><li><strong>Problem</strong><ul><li>2개 이상의 process가 shard data를 동시에 사용하기를 원하는 경우, 각 프로세스의 critical section을 통해서 접근해야 한다.</li><li>A process가 critical section에 있을 때 = 공유 데이터에 접근하는 코드를 실행하고 있을 때, A process의 CPU 할당 시간이 끝나서 다른 process에게 CPU를 넘겼다.</li><li>하지만, A process가 critical section에 있기 때문에, 다른 process가 CPU를 받아도 critical section에 들어갈 수 없고, 대기해야 한다.</li><li>이를 <code>Critical section problem</code> 이라 한다.</li></ul></li></ul><h2 id=43-sw-해결법의-충족-조건-3가지requirements>4.3 SW 해결법의 충족 조건 3가지(requirements)<a hidden class=anchor aria-hidden=true href=#43-sw-해결법의-충족-조건-3가지requirements>#</a></h2><ul><li><p><strong>가정(Assumption)</strong></p><ul><li>모든 process의 수행 속도는 0보다 크다.</li><li>process들 간의 상대적인 수행 속도는 가정하지 않는다.</li></ul></li><li><p><strong>첫 번째 requirement: Mutual Exclusion</strong></p><ul><li>process P_i가 critical section 부분을 수행 중이면 다른 모든 process들은 그들의 critical section에 들어가면 안된다.</li></ul></li><li><p><strong>두 번째 requirement: Progress</strong></p><ul><li>아무도 critical section에 있지 않은 상태에서 critical section에 들어가고자 하는 process가 있으면 critical section에 들어가도록 해야한다.<ul><li>첫 번째 requirement의 부작용으로 critical section에 어떤 process도 들어가지 않은 상황이 발생한다.</li></ul></li></ul></li><li><p><strong>세 번째 requirement: Bounded waiting</strong></p><ul><li>Process가 critical section에 들어가려고 요청한 순간부터 그 요청이 허용될 때까지 다른 process들이 critical section에 들어가는 횟수에 한계가 있어야 한다.<ul><li>횟수 한계가 없으면 <code>starvation</code> 문제가 발생한다.</li></ul></li></ul></li></ul><h2 id=44-위-조건을-해결하기-위한-sw-solution-petersons-algorithum>4.4 위 조건을 해결하기 위한 SW solution: Peterson&rsquo;s Algorithum<a hidden class=anchor aria-hidden=true href=#44-위-조건을-해결하기-위한-sw-solution-petersons-algorithum>#</a></h2><ul><li><strong>SW 방법으로 해결하기 위한 code의 일반적인 구조</strong></li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yml data-lang=yml><span style=display:flex><span>do {
</span></span><span style=display:flex><span>    entry section  <span style=color:#6272a4># 다른 process는 못 들어오게 shared data를 lock 하는 code</span>
</span></span><span style=display:flex><span>    critical section  <span style=color:#6272a4># shared data에 접근하려는 코드</span>
</span></span><span style=display:flex><span>    exit section   <span style=color:#6272a4># 다 처리 후, 다른 process가 들어오도록 unlock하는 코드</span>
</span></span><span style=display:flex><span>    remainder section  <span style=color:#6272a4># 못 들어온 process를 의미하는 코드</span>
</span></span><span style=display:flex><span>}  while(1)
</span></span></code></pre></div><ul><li><p><strong>process들은 수행의 동기화(synchronization)을 위해 몇 몇 변수를 공유할 수 있다.</strong></p><ul><li>synchronization varible</li></ul></li><li><p><strong>Algorithum이 필요한 이유</strong></p><ul><li>고급 언어는 단일 instruction이 아니기 때문에, instruction 수행 중 CPU를 빼앗길 수 있기 때문이다.</li><li>그래서 이를 방지하고자 알고리즘으로 구현한다.</li></ul></li><li><p><strong>Synchronization variables(동기화 변수)</strong></p></li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yml data-lang=yml><span style=display:flex><span>boolean flag [2]  <span style=color:#6272a4># process 0과 1의 flag</span>
</span></span><span style=display:flex><span>initially flag [모두] = false; <span style=color:#6272a4># no one is in Critical Section</span>
</span></span></code></pre></div><ul><li><strong>Process Pi가 CPU를 잡고 있는 상황</strong></li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yml data-lang=yml><span style=display:flex><span>do {
</span></span><span style=display:flex><span>    flag [i] = true; <span style=color:#6272a4># critical section에 들어가겠다는 의미</span>
</span></span><span style=display:flex><span>    turn = j;  <span style=color:#6272a4># turn을 상대방 turn을 바꾼다.</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#6272a4># 상대방이 깃발을 들고 있고, 이번이 상대방 차례인 조건을 만족하면 기다린다.</span>
</span></span><span style=display:flex><span>    while (flag [j] &amp;&amp; turn == j)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    critical section
</span></span><span style=display:flex><span>    flag [i] = false; <span style=color:#6272a4># 깃발을 내린다.</span>
</span></span><span style=display:flex><span>    remainder section
</span></span><span style=display:flex><span>} while (1)
</span></span></code></pre></div><ul><li><strong>모든 요구 조건들을 만족하지만, 그래도 문제점이 존재한다.</strong><ul><li><code>busy waiting</code> (= spin lock): 계속 CPU와 memory의 할당 시간을 쓰면서 기다리는 현상<ul><li>while 문을 돌면서( <strong>spin</strong> ) 계속 <strong>lock</strong> 을 걸어서 상대방이 못 들어온다.</li><li>A process가 critical section에 들어가 있는 상태에서 B process가 CPU를 받아서 작동할 때, B process의 CPU 할당 시간 동안 while문이 만족되는지 체크한다.</li><li>하지만, A process가 CPU를 잡아서 조건을 바꿔줘야 B process가 들어올 수 있다.</li><li>그래서 이를 busy waiting이라 한다.</li></ul></li></ul></li></ul><h2 id=45-위-조건을-해결하기-위한-hw-solution>4.5 위 조건을 해결하기 위한 HW solution<a hidden class=anchor aria-hidden=true href=#45-위-조건을-해결하기-위한-hw-solution>#</a></h2><ul><li><p><strong>Synchronization HW</strong></p><ul><li><p><strong><em>HW 적으로 Test & modify</em></strong> 를 <strong><em>atomic</em></strong> 하게 수행할 수 있도록 지원하는 경우, 앞의 문제는 간단히 해결된다.</p><ul><li>HW 적으로 lock을 읽고 setting하는 작업을 말한다.</li></ul></li></ul></li></ul><p><img loading=lazy src=https://user-images.githubusercontent.com/78094972/166150660-e4eec628-47df-4643-8a27-79146c253c1e.PNG alt=image></p><ul><li><p><strong><em>atomic</em></strong> instruction이란??</p><ul><li>실행 중간에 간섭받거나 중단되지 않는다.</li><li>같은 메모리 영역에 대해 동시에 실행되지 않는다.</li></ul></li><li><p>Test_and_set (a)</p><ul><li>a라는 데이터를 읽은 후, 1로 쓰는 Instruction</li><li>읽는 작업과 쓰는 작업을 동시에 지원하는 HW가 있다면 쉽게 해결할 수 있다.</li></ul></li><li><p>Mutual exclusion with Test & Set</p></li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yml data-lang=yml><span style=display:flex><span><span style=color:#ff79c6>Synchronization variable</span>:
</span></span><span style=display:flex><span>        boolean lock = false; <span style=color:#6272a4># 다른 process가 lock이 걸려 있는지 확인</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Process Pi
</span></span><span style=display:flex><span>        do {
</span></span><span style=display:flex><span>            while(Test_and_Set(lock));
</span></span><span style=display:flex><span>            critical section
</span></span><span style=display:flex><span>            lock = false; <span style=color:#6272a4># lock에 0 할당</span>
</span></span><span style=display:flex><span>            remainder section
</span></span><span style=display:flex><span>        }
</span></span></code></pre></div><ul><li>lock = false : critical section에 아무도 안들어간 상태<ul><li>들어가고 나서, Test_and_Set에 의해 lock = True로 바뀌면서 lock 이 걸린다.</li></ul></li><li>lock = true: critical section에 프로세스가 들어간 상태<ul><li>들어가지 못 하고, 계속 while문을 돈다.</li><li>critical section에서 나오면서 lock = false로 재설정하여 while문에서 돌고 있는 process가 들어오게 한다.</li></ul></li></ul><hr><h1 id=5-semaphores>5. Semaphores<a hidden class=anchor aria-hidden=true href=#5-semaphores>#</a></h1><h2 id=51-semaphores-란>5.1 Semaphores 란??<a hidden class=anchor aria-hidden=true href=#51-semaphores-란>#</a></h2><blockquote><p><strong>공유자원을 얻고 반납하는 작업을 위해서 lock & unlock 작업을 도와주는 추상 자료형</strong></p></blockquote><ul><li><p><strong>추상화</strong></p><ul><li>세부 구현으로부터 분리하여 개념을 일반화시키는 것</li><li>what은 정의하지만, 언어를 사용하여 어떻게 구현할지 How는 정의하지 않는다.</li></ul></li><li><p><strong>추상 자료형</strong></p><ul><li>추상화를 통해 얻어낸 자료형</li><li>구성: object + operation<ul><li>operation의 구현은 system 마다 다르다.</li></ul></li></ul></li><li><p><strong><em>atomic</em></strong> instruction이란??</p><ul><li>실행 중간에 간섭받거나 중단되지 않는다.</li><li>같은 메모리 영역에 대해 동시에 실행되지 않는다.</li></ul></li><li><p><strong>Semaphores S</strong></p><ul><li><p>위 SW와 HW 알고리즘들 방식을 추상화시켜, 보다 효율적으로 관리한다.</p></li><li><p>integer variable (=Semaphore variable)</p><ul><li>semaphore variable = 자원의 갯수<ul><li>ex) semaphore variable = 5: 자원의 갯수가 5개라는 의미</li></ul></li><li>자원을 획득하는 연산을 사용하면 자원의 갯수는 감소</li><li>자원을 반납하는 연산을 사용하면 자원의 갯수는 증가</li></ul></li><li><p>정의된 2가지 <strong><em>atomic</em></strong> operation: P, V</p><ul><li><p>Semaphore variable을 가지고 수행하는 연산</p></li><li><p>P(S) operation: 공유 데이터 자원을 획득하고 lock을 거는 연산</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yml data-lang=yml><span style=display:flex><span>// S가 음수라는 건 자원이 없다는 걸 의미한다.
</span></span><span style=display:flex><span>// 자원이 없기 때문에, while문에서 계속 반복하며 기다린다.
</span></span><span style=display:flex><span>while(S &lt;= 0) do no-op;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>// 자원을 획득하여 P 연산을 시작하므로, S 값을 1 감소시킨다.
</span></span><span style=display:flex><span>S--;
</span></span></code></pre></div></li><li><p>V(S) operation: 공유 데이터 자원을 다 사용하고 나서 반납하고, unlock하는 연산</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yml data-lang=yml><span style=display:flex><span>// operation 사용이 끝나면 V 연산을 하여 S 값을 1 증가시킨다.
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>S++
</span></span></code></pre></div></li></ul></li></ul></li><li><p><strong>Semaphore의 문제점</strong></p><ul><li>while문에서 계속 기다리기 때문에 <code>busy & wait</code> 문제가 존재한다.</li></ul></li></ul><h2 id=52-criticall-section-of-n-process>5.2 Criticall section of n process<a hidden class=anchor aria-hidden=true href=#52-criticall-section-of-n-process>#</a></h2><blockquote><p>critical section에 semaphore 사용하기</p></blockquote><ul><li><strong>mutex = mutual exclusion</strong></li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yml data-lang=yml><span style=display:flex><span>Synchronization variable
</span></span><span style=display:flex><span><span style=color:#ff79c6>semaphore mutex</span>: <span style=color:#6272a4># initally 1</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#ff79c6>Process Pi</span>:
</span></span><span style=display:flex><span>do {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#6272a4># 진입할 때 사용하는 연산. 이 조건에 만족하면 critical section에 진입하고 semaphore 감소, 그렇지 않으면 대기.</span>
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>P(mutex)</span>:
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    critical section
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>V(mutex)</span>: <span style=color:#6272a4># 빠져나올 때 사용하는 연산으로, semaphore 증가</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    remainder section
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>} while(1)
</span></span></code></pre></div><ul><li><strong>busy-wait(spin lock) 방식은</strong> CPU를 할당받았지만, while문에서 대기하는 걸로 할당시간을 낭비하기 때문에 <strong>효율적이지 못하다</strong>.</li><li>그래서 <strong>block & wake up (=sleep lock)</strong> 방식으로 구현한다.<ul><li>shared data를 쓰고 있는 process가 criticial section 실행을 완료할 때까지, 대기 중인 process는 <code>block</code> 상태에 있어서 CPU를 얻지 못하고,</li><li>사용 중이던 process가 데이터를 내놓으면 <code>block</code> 상태에 있는 process는 <code>wake up</code> 하여 ready queue에 들어와서 대기하는 방식</li></ul></li></ul><h2 id=53-block--wakeup-implementation>5.3 Block & Wakeup implementation<a hidden class=anchor aria-hidden=true href=#53-block--wakeup-implementation>#</a></h2><ul><li><strong>Semaphore 정의</strong></li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yml data-lang=yml><span style=display:flex><span>typeef struct
</span></span><span style=display:flex><span>{ int value; <span style=color:#6272a4># semaphore를 의미</span>
</span></span><span style=display:flex><span>  struct process *L;  <span style=color:#6272a4># queue for process wait</span>
</span></span><span style=display:flex><span>} semaphore;
</span></span></code></pre></div><ul><li><p><strong>Block & Wakeup</strong></p><ul><li>Block<ul><li>kernel은 block을 호출한 process를 suspend 시킨다.</li><li>이 process의 PCB를 semaphore에 대한 wait queue에 넣는다.</li></ul></li><li>Wake up<ul><li>block state인 process P를 wake up</li><li>이 process의 PCB를 ready queue로 옮긴다.</li></ul></li></ul></li><li><p><strong>정의된 Semaphore 연산</strong></p><ul><li><p>S: semaphore variable</p></li><li><p><strong>P(S)</strong>: resource 획득 연산</p></li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yml data-lang=yml><span style=display:flex><span>S.value --; <span style=color:#6272a4># 자원을 획득하기 때문에 감소</span>
</span></span><span style=display:flex><span>if (S.value &lt; 0 ) <span style=color:#6272a4># 음수이면 들어가지 못 한다.</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#6272a4># 음수면 이 프로세스를 queue에서 대기하도록 추가한다. 그 후, block로 둔다.</span>
</span></span><span style=display:flex><span>    add this process to S.L;
</span></span><span style=display:flex><span>    block
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ul><li><strong>V(S)</strong>: resource 반납 연산과 이 자원을 기다리면 잠든 프로세스를 깨우는 연산</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yml data-lang=yml><span style=display:flex><span>S.value ++;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#6272a4># 자원을 내놓았는데도 0이거나 음수라는 건, 어떤 프로세스가 P 연산에 의해  block 상태임을 의미</span>
</span></span><span style=display:flex><span>if (S.value &lt;= 0 )
</span></span><span style=display:flex><span>{   <span style=color:#6272a4># queue에서 제거한다.</span>
</span></span><span style=display:flex><span>    remove this process to S.L;
</span></span><span style=display:flex><span>    wake(P);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></li></ul><h2 id=54-busy-wait-vs-block--wake-up>5.4 Busy-wait VS Block & wake-up<a hidden class=anchor aria-hidden=true href=#54-busy-wait-vs-block--wake-up>#</a></h2><blockquote><p>critical section의 길이에 따라 달라진다.</p></blockquote><ul><li><p><strong>critical section의 길이가 긴 경우</strong></p><ul><li>block / wakeup이 필수<ul><li>오랫 동안 풀지 않은 lock을 풀기 위해 CPU를 얻어도 계속 while문에서 대기하는 게 길기 때문이다.</li></ul></li></ul></li><li><p><strong>critical section의 길이가 짧은 경우</strong></p><ul><li>block/wakeup overhead가 busy-wait overhead보다 더 커질 수 있다.</li><li>일반적으로는 block/wakeup 방식이 더 좋다.</li></ul></li></ul><h2 id=55-two-types-of-semaphores>5.5 Two types of semaphores<a hidden class=anchor aria-hidden=true href=#55-two-types-of-semaphores>#</a></h2><blockquote><p>Counting semaphores and Binary semaphores (=mutext)</p></blockquote><table><thead><tr><th>Attribute</th><th>Counting semaphore</th><th>Binary semaphore</th></tr></thead><tbody><tr><td>resource</td><td>resource >= 0</td><td>resource = 1</td></tr><tr><td>purpose</td><td>resource counting</td><td>mutext(lock / unlock)</td></tr></tbody></table><h2 id=55-semaphore-주의사항-deadlock-and-starvation>5.5 Semaphore 주의사항: Deadlock and Starvation<a hidden class=anchor aria-hidden=true href=#55-semaphore-주의사항-deadlock-and-starvation>#</a></h2><h3 id=551-deadlock>5.5.1 Deadlock<a hidden class=anchor aria-hidden=true href=#551-deadlock>#</a></h3><blockquote><p>둘 이상의 process가 서로 상대방에 의해 충족될 수 있는 event를 무한히 기다리는 현상</p></blockquote><ul><li>어떤 일을 하기 위해서, S와 Q를 모두 획득해야지만 일할 수 있고, S, Q를 모두 반환한다.</li><li>S와 Q: 서로 배타적으로 사용할 수 있는, 1로 초기화된 semaphore</li></ul><p><img loading=lazy src=https://user-images.githubusercontent.com/78094972/166642365-7d72467b-bb72-4202-9deb-ade65d90868f.PNG alt=image></p><pre><code>- Process 모두 하나씩 차지한 상황

    - P0가 S를 먼저 작업하다가 CPU를 빼앗겨 P1이 CPU와 Q semaphore 를 얻어 작업한다.
    - 그런데, 상대방의 것을 서로 요구한다.
    - 하지만, 서로 가지고 있기 때문에, 영원히 기다려야 한다.
    - 왜냐하면 다 사용하고 나서 반환하기 때문이다.
    - 이 문제를 `Deadlock` 이라 한다.
</code></pre><ul><li><strong>Solution</strong></li></ul><p><img loading=lazy src=https://user-images.githubusercontent.com/78094972/166642369-2ede3e17-6535-4426-b629-e0fb499786ca.PNG alt=image></p><pre><code>- 서로 다른 프로세스여도 같은 순서로 정한다.
    - Q를 획득하려면 S를 먼저 획득하라는 의미
</code></pre><h3 id=552-starvation>5.5.2 Starvation<a hidden class=anchor aria-hidden=true href=#552-starvation>#</a></h3><blockquote><p><strong>infinite blocking이라 하며, process가 suspend된 이유에 해당하는 semaphore queue에서 빠져나갈 수 없는 현상</strong></p></blockquote><ul><li>특정 process 자원을 독점하여 나머지 프로세스가 자원을 얻지 못하고 무한히 기다리는 현상으로 Deadlock과 유사하지만, 다르다.</li></ul><hr><h1 id=reference>Reference<a hidden class=anchor aria-hidden=true href=#reference>#</a></h1><ul><li><a href="http://www.kocw.net/home/cview.do?lid=3dd1117c48123b8e">kocw 이화여자대학교 운영체제 - 반효경 교수 -</a></li></ul></div><footer class=post-footer><ul class=post-tags><li><a href=http://jeha00.github.io/tags/til/>TIL</a></li><li><a href=http://jeha00.github.io/tags/os/>OS</a></li></ul><nav class=paginav><a class=prev href=http://jeha00.github.io/post/os/os_chapter_08_%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4_%EB%8F%99%EA%B8%B0%ED%99%94_2/><span class=title>« Prev Page</span><br><span>[TIL] OS Chapter 08: 프로세스 동기화 2</span></a>
<a class=next href=http://jeha00.github.io/post/os/os_chapter_07_%EB%A9%94%EB%AA%A8%EB%A6%AC%EA%B4%80%EB%A6%AC_2/><span class=title>Next Page »</span><br><span>[TIL] OS Chapter 07: 메모리 관리 2</span></a></nav><div class=share-buttons><a target=_blank rel="noopener noreferrer" aria-label="share [TIL] OS Chapter 08: 프로세스 동기화 1 on twitter" href="https://twitter.com/intent/tweet/?text=%5bTIL%5d%20OS%20Chapter%2008%3a%20%ed%94%84%eb%a1%9c%ec%84%b8%ec%8a%a4%20%eb%8f%99%ea%b8%b0%ed%99%94%201&url=http%3a%2f%2fjeha00.github.io%2fpost%2fos%2fos_chapter_08_%25ED%2594%2584%25EB%25A1%259C%25EC%2584%25B8%25EC%258A%25A4_%25EB%258F%2599%25EA%25B8%25B0%25ED%2599%2594_1%2f&hashtags=TIL%2cOS"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM195.519 424.544c135.939.0 210.268-112.643 210.268-210.268.0-3.218.0-6.437-.153-9.502 14.406-10.421 26.973-23.448 36.935-38.314-13.18 5.824-27.433 9.809-42.452 11.648 15.326-9.196 26.973-23.602 32.49-40.92-14.252 8.429-30.038 14.56-46.896 17.931-13.487-14.406-32.644-23.295-53.946-23.295-40.767.0-73.87 33.104-73.87 73.87.0 5.824.613 11.494 1.992 16.858-61.456-3.065-115.862-32.49-152.337-77.241-6.284 10.881-9.962 23.601-9.962 37.088.0 25.594 13.027 48.276 32.95 61.456-12.107-.307-23.448-3.678-33.41-9.196v.92c0 35.862 25.441 65.594 59.311 72.49-6.13 1.686-12.72 2.606-19.464 2.606-4.751.0-9.348-.46-13.946-1.38 9.349 29.426 36.628 50.728 68.965 51.341-25.287 19.771-57.164 31.571-91.8 31.571-5.977.0-11.801-.306-17.625-1.073 32.337 21.15 71.264 33.41 112.95 33.41z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share [TIL] OS Chapter 08: 프로세스 동기화 1 on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&url=http%3a%2f%2fjeha00.github.io%2fpost%2fos%2fos_chapter_08_%25ED%2594%2584%25EB%25A1%259C%25EC%2584%25B8%25EC%258A%25A4_%25EB%258F%2599%25EA%25B8%25B0%25ED%2599%2594_1%2f&title=%5bTIL%5d%20OS%20Chapter%2008%3a%20%ed%94%84%eb%a1%9c%ec%84%b8%ec%8a%a4%20%eb%8f%99%ea%b8%b0%ed%99%94%201&summary=%5bTIL%5d%20OS%20Chapter%2008%3a%20%ed%94%84%eb%a1%9c%ec%84%b8%ec%8a%a4%20%eb%8f%99%ea%b8%b0%ed%99%94%201&source=http%3a%2f%2fjeha00.github.io%2fpost%2fos%2fos_chapter_08_%25ED%2594%2584%25EB%25A1%259C%25EC%2584%25B8%25EC%258A%25A4_%25EB%258F%2599%25EA%25B8%25B0%25ED%2599%2594_1%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share [TIL] OS Chapter 08: 프로세스 동기화 1 on reddit" href="https://reddit.com/submit?url=http%3a%2f%2fjeha00.github.io%2fpost%2fos%2fos_chapter_08_%25ED%2594%2584%25EB%25A1%259C%25EC%2584%25B8%25EC%258A%25A4_%25EB%258F%2599%25EA%25B8%25B0%25ED%2599%2594_1%2f&title=%5bTIL%5d%20OS%20Chapter%2008%3a%20%ed%94%84%eb%a1%9c%ec%84%b8%ec%8a%a4%20%eb%8f%99%ea%b8%b0%ed%99%94%201"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share [TIL] OS Chapter 08: 프로세스 동기화 1 on facebook" href="https://facebook.com/sharer/sharer.php?u=http%3a%2f%2fjeha00.github.io%2fpost%2fos%2fos_chapter_08_%25ED%2594%2584%25EB%25A1%259C%25EC%2584%25B8%25EC%258A%25A4_%25EB%258F%2599%25EA%25B8%25B0%25ED%2599%2594_1%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share [TIL] OS Chapter 08: 프로세스 동기화 1 on whatsapp" href="https://api.whatsapp.com/send?text=%5bTIL%5d%20OS%20Chapter%2008%3a%20%ed%94%84%eb%a1%9c%ec%84%b8%ec%8a%a4%20%eb%8f%99%ea%b8%b0%ed%99%94%201%20-%20http%3a%2f%2fjeha00.github.io%2fpost%2fos%2fos_chapter_08_%25ED%2594%2584%25EB%25A1%259C%25EC%2584%25B8%25EC%258A%25A4_%25EB%258F%2599%25EA%25B8%25B0%25ED%2599%2594_1%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share [TIL] OS Chapter 08: 프로세스 동기화 1 on telegram" href="https://telegram.me/share/url?text=%5bTIL%5d%20OS%20Chapter%2008%3a%20%ed%94%84%eb%a1%9c%ec%84%b8%ec%8a%a4%20%eb%8f%99%ea%b8%b0%ed%99%94%201&url=http%3a%2f%2fjeha00.github.io%2fpost%2fos%2fos_chapter_08_%25ED%2594%2584%25EB%25A1%259C%25EC%2584%25B8%25EC%258A%25A4_%25EB%258F%2599%25EA%25B8%25B0%25ED%2599%2594_1%2f"><svg viewBox="2 2 28 28"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></div></footer><script src=https://utteranc.es/client.js repo=JeHa00/blog-comments issue-term=pathname theme=github-dark crossorigin=anonymous async></script></article></main><footer class=footer><span>&copy; 2022 <a href=http://jeha00.github.io/>Jeha00 DevLog</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>