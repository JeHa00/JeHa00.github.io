<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>[TIL] OS Chapter 10: 가상 메모리 | Jeha DevLog</title><meta name=keywords content="TIL,OS"><meta name=description content="가상 메모리를 관리하기 위한 방법으로 demanding paging에 대해 알아본다. 그리고, 페이지 교체는 어떠한 순서로 이뤄지는지, 프로세스에 프레임은 어떤 알고리즘을 통해서 할당되는지, 전역 교체와 지역교체는 무엇인지 마지막으로 thrashing 상황과 MPD 개념에 대해 알아본다."><meta name=author content><link rel=canonical href=http://jeha00.github.io/post/os/os_chapter_10_%EA%B0%80%EC%83%81%EB%A9%94%EB%AA%A8%EB%A6%AC/><meta name=google-site-verification content="XYZabc"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.min.268b216eea772711d318d156ce02a8190962367a0bf469fa9a959114ea6b9ca3.css integrity="sha256-Joshbup3JxHTGNFWzgKoGQliNnoL9Gn6mpWRFOprnKM=" rel="preload stylesheet" as=style><link rel=icon href=http://jeha00.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=http://jeha00.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=http://jeha00.github.io/favicon-32x32.png><link rel=apple-touch-icon href=http://jeha00.github.io/apple-touch-icon.png><link rel=mask-icon href=http://jeha00.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><meta name=generator content="Hugo 0.101.0"><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><script type=application/javascript>var doNotTrack=!1;doNotTrack||(function(e,t,n,s,o,i,a){e.GoogleAnalyticsObject=o,e[o]=e[o]||function(){(e[o].q=e[o].q||[]).push(arguments)},e[o].l=1*new Date,i=t.createElement(n),a=t.getElementsByTagName(n)[0],i.async=1,i.src=s,a.parentNode.insertBefore(i,a)}(window,document,"script","https://www.google-analytics.com/analytics.js","ga"),ga("create","UA-123-45","auto"),ga("send","pageview"))</script><meta property="og:title" content="[TIL] OS Chapter 10: 가상 메모리"><meta property="og:description" content="가상 메모리를 관리하기 위한 방법으로 demanding paging에 대해 알아본다. 그리고, 페이지 교체는 어떠한 순서로 이뤄지는지, 프로세스에 프레임은 어떤 알고리즘을 통해서 할당되는지, 전역 교체와 지역교체는 무엇인지 마지막으로 thrashing 상황과 MPD 개념에 대해 알아본다."><meta property="og:type" content="article"><meta property="og:url" content="http://jeha00.github.io/post/os/os_chapter_10_%EA%B0%80%EC%83%81%EB%A9%94%EB%AA%A8%EB%A6%AC/"><meta property="og:image" content="http://jeha00.github.io/47"><meta property="article:section" content="post"><meta property="article:published_time" content="2022-05-23T21:50:30+09:00"><meta property="article:modified_time" content="2022-05-23T21:50:30+09:00"><meta property="og:site_name" content="JeHa00 DevLog"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="http://jeha00.github.io/47"><meta name=twitter:title content="[TIL] OS Chapter 10: 가상 메모리"><meta name=twitter:description content="가상 메모리를 관리하기 위한 방법으로 demanding paging에 대해 알아본다. 그리고, 페이지 교체는 어떠한 순서로 이뤄지는지, 프로세스에 프레임은 어떤 알고리즘을 통해서 할당되는지, 전역 교체와 지역교체는 무엇인지 마지막으로 thrashing 상황과 MPD 개념에 대해 알아본다."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"http://jeha00.github.io/post/"},{"@type":"ListItem","position":2,"name":"[TIL] OS Chapter 10: 가상 메모리","item":"http://jeha00.github.io/post/os/os_chapter_10_%EA%B0%80%EC%83%81%EB%A9%94%EB%AA%A8%EB%A6%AC/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"[TIL] OS Chapter 10: 가상 메모리","name":"[TIL] OS Chapter 10: 가상 메모리","description":"가상 메모리를 관리하기 위한 방법으로 demanding paging에 대해 알아본다. 그리고, 페이지 교체는 어떠한 순서로 이뤄지는지, 프로세스에 프레임은 어떤 알고리즘을 통해서 할당되는지, 전역 교체와 지역교체는 무엇인지 마지막으로 thrashing 상황과 MPD 개념에 대해 알아본다.","keywords":["TIL","OS"],"articleBody":"0. Introduction 해당 내용은 운영체제와 정보기술의 원리 -반효경 지음- 와 kocw 이화여자대학교 운영체제 - 반효경 교수 -를 보고 정리한 내용이다. 정확하지 않은 내용이 있다면 말씀해주시면 감사하겠습니다. 운영체제는 보통 모든 프로그램들에 공평하게 같은 크기의 메모리를 할당하기보다는 몇몇 프로그램들에게 집중적으로 메모리를 할당한 후, 시간이 흐르면 이들로부터 메모리를 회수해서 다른 프로그램들에게 다시 집중적으로 메모리를 할당하는 방식을 채택한다.\n왜냐하면 프로세스의 빠른 수행을 위해 프로그램마다 최소한 확보해야하는 메모리 크기가 존재 하기 때문이다.\n하지만 그렇다고 프로세스의 주소 공간 전체가 메모리에 올라와 있어야 하는 것은 아니다. 운영체제는 CPU에서 당장 수행할 부분만을 메모리에 올려놓고, 그렇지 않은 부분은 disk의 swap area에 내려놓았다가 다시 필요해지면 메모리에 올라가 있는 부분과 교체하는 방식을 사용한다.\n또한, 프로그램은 0번지부터 시작하는 자기 자신만의 메모리 공간을 가정한다. 이러한 공간을 Virtual memory(가상 메모리) 이라 한다. 이 가상 공간 중 일부가 swap area에존재하고, 일부는 물리적 메모리에 존재하는 것이다.\n이 가상 메모리를 적재하는 단위에 따라 요구 페이징 또는 요구 세그먼테이션 방식으로 나눠진다. 전자는 대부분의 경우에 사용되며, 세부적인 구현에 특히 사용된다. 후자는 paged segmentation 기법을 사용하는 경우를 말한다.\n그러면 요구 페이징에 대해 먼저 알아보자.\n1. 요구 페이징 프로그램 실행 시 프로세스를 구성하는 모든 페이지를 한꺼번에 메모리에 올리는 게 아닌, 당장 사용될 페이지만을 올리는 방식\n특정 페이지에 대한 CPU 요청이 들어온 후에야 해당 페이지를 메모리에 적재한다.\n비유: 매 끼니마다 필요한 분량만큼 재료를 구입해서 보관하는 방식\n냉장고: 물리적 메모리 식재료: 프로세스를구성하는 페이지 보관 행위: 페이지를 메모리에 적재 장점\n필요한 부분만을 적재하기 때문에, 메모리 사용량 감소, I/O 양 감소 -\u003e 응답시간 단축 프로세스 전체를 메모리에 올리는데 소요되는 입출력 오버헤드 감소 더 많은 프로세스 수용 물리적 메모리 용량 제약에서 벗어남 Problem\n가상 메모리 중 어떤 페이지가 메모리에 존재하는지 유무를 구별하기 위한 방안 필요 Solution\n유효-무효(Valid - Invalid bit)를 두어 page가 각 memory에 존재하는지 표시 모든 page에 대해 존재해야 하므로, page table의각 항목별로 저장 Valid - Invalid bit\n기본 bit 값: invalid bit\n특정 페이지가 참조되어 메모리에 적재 → Valid bit → 적재된 page가 swap area로 쫓겨남 → Invalid bit\nInvalid bit 는 언제일 때를 말하는가?\n해당 페이지가 물리적 메모리에 없는 경우 페이지가 속한 주소 영역을 프로세스가 사용하지 않은 경우 물리적 메모리에 A,C,G가 올라가 있기 때문에, 이에 해당하는 page table의 0, 2, 6이 valid라는 걸 확인할 수 있다. Page fault CPU가 한 페이지를 참조하려는데, 요청한 페이지가 메모리에 없어서 invalid bit인 경우를 말한다. 1.1 요구 페이징의 페이지 부재 처리 CPU가 무효 페이지에 접근 → 주소 변환 담당 MMU가 페이지 부재 트랩(page fault trap) 발생 → kernel mode로 전환 → OS의 페이지 부재 처리루틴(page fault handler)이 호출\nOS의 처리 과정\nOS는 프로세스의 해당 페이지에 대한 접근이 적법한지 먼저 체크 (reference)\n사용되지 않는 주소 영역에 속한 페이지에 접근하려거나, 해당 페이지에 대한 접근 권한 위반(protection violation)을 했을 경우, 해당 프로세스를 종료 protection violtaion: read-only file에 write 시도를 한 경우 → 적법 판정 → 물리적 메모리의 빈 frame을 할당받아 이 공간에 해당 페이지를 적재.\n빈 frame이 없다면, 물리적 메모리에 적재된 페이지 중 하나를 swap out → 요청한 페이지를 디스크로부터 물리적 메모리에 적재하기(disk I/O 작업을 의미)까지 오랜 시간이 걸리므로, CPU를 빼앗기고 봉쇄 상태(block state)가 됨\n현재까지 수행되던 프로세스는 CPU register state 및 PC value를 PCB에 저장하여, 나중에 이 프로세스를 재할당 시, 정확히 같은 상태에서 다음 instruction을 수행. → I/O 작업이 완료되어 interrupt가 발생하면 page table에서 해당 page의 valid-invalid bit를 valid bit로 설정 (reset page table)\n→ 봉쇄된 process를 ready queue로 이동\n→ 다시 CPU를 잡고 running 하며 아까 중단되었던 instruction을 재개한다.\n1.2요구 페이징의 성능 페이지 부재의 발생 빈도 페이지 부재로 인해 페이지 교체가 이뤄지는 과정에서 요청된 페이지를 디스크에서 메모리로 읽어오는 disk input/output 과 각종 overhead가 포함되어 시간이 오래 걸린다. 그래서 유효 접근 시간 이 짧을 수록 성능 향상 2. 페이지 교체 페이지 교체(page replacement)란?\n페이지 부재가 발생 시, 요청 페이지를 디스크에서 메모리로 불러오기 위에 메모리에 적재된 여러 페이지 중 하나를 swap out하여 요청된 페이지를 메모리에 적재하는 것 교체 알고리즘(replacement algoritum)\n페이지 교체 시, 어떤 프레임에 있는 페이지를 쫓아 낼지 결정하는 알고리즘 페이지 부재 발생비율(page-fault rate)을 최소화하는 것이 목표 평가 기준: 주어진 페이지 참조열에 대해 페이지 부재를 얼마나 내는지 조사 가까운 미래에 참조될 가능성이 적은 페이지를 내쫓는 것이 성능 향상 방안 페이지 참조열(page reference string)\n참조되는 페이지들의 번호를 시간 순서에 따라 나열한 것 예) 1,2,3,4,1,2,5,1,2,3,4,5 2.1 최적 페이지(Optimal Algorithum) 교체 Belady’s optimal algorithum (빌레디의 최적 알고리즘) = MIN, OPT\n페이지 부재율을 최소화하기 위해, 메모리에 존재하는 페이지 중 가까운 미래에 참조될 페이지를 쫓아내는 것 다른 알고리즘의 Upper bound\n어떠한 알고리즘보다도 가장 적은 페이지 부재율을 보장 하므로 다른 알고리즘 성능에 대한 상한선(Upper bound) 를 제공한다. 그래서 어떤 교체 알고리즘이 이 알고리즘과 유사하다면 더 이상의 알고리즘 연구가 필요하지 않음을 시사한다. 예시\n4 frames example 처음 페이지 참조 시에는 4회까지 페이지 부재가 불가피하다. 5, 6회는 이미 페이지가 존재하기 때문에 발생하지 않는다. 7회에서 페이지 5를 참조 시, 페이지 부재가 발생하여 디스크에서 메모리로 가져오는 작업이 필요하다. 이 때 페이지 교체를 해야 하는데, 가장 먼 미래에 참조될 페이지인 4번 페이지와 교체된다. 그래서 총 6번의 페이지 부재가 발생한다. Offline algorithum\n미래에 어떤 페이지가 참조될지 미리 알고 있다는 전제 이므로, 온라인에서 사용할 수 없어서 offline algorithum 이라 한다. 이 이후에 알고리즘은 미래를 모르는 알고리즘들이다.\n2.2 선입선출(FIFO:First In First Out) 알고리즘 물리적 메모리에 먼저 올라온 페이지를 우선적으로 내쫓는 알고리즘 향후 참조 가능성 고려 X 물리적 메모리에 들어온 순서대로 대상 선정 페이지 프레임을 늘린다고, page fault가 줄어드는 게 아니다.\n페이지 프레임 3개\n9번의 페이지 부재 페이지 프레임 4개\n10번의 페이지 부재 2.3 LRU(Least Recently Used) 알고리즘 교체 알고리즘으로 가장 많이 사용된다. 시간지역성(Temporal locality)이 낮은 페이지를 쫓아내는 알고리즘 시간 지역성: 최근에 참조된 페이지가 가까운 미래에 다시 참조될 가능성이 높은 성질 가장 오래 전에 참조된 것을 지워서, 참조 횟수는 고려하지 않는다. 2.4 LFU(Least Frequently used) 알고리즘 물리적 메모리 내에 존재하는 페이지 중 과거에 참조 횟수(reference count)가 가장 적은 페이지로 교체 페이지를 결정하는 알고리즘\n최저 참조 횟수를 가진 페이지가 여러 개일 경우, 상대적으로 더 오래전에 참조된 페이지를 쫓아낸다. 참조 횟수를 계산하는 방식에 따라 Incache-LFU 와 Perfect-LFU 로 나눠진다.\nIncache-LFU\npage가 물리적 메모리에 올라온 후부터의 참조 횟수를 카운트하는 방식 그래서 메모리에서 내려갔다가 다시 적재되면 참조 횟수는 초기화된다. Perfect-LFU\n메모리에 적재여부와 상관없이 그 페이지의 과거 총 참조 횟수를 카운트하는 방식 장점: 페이지의 참조 횟수를 정확히 반영 단점: 메모리에서 쫓겨난 페이지의 참조 기록까지 모두 보관하고 있어야 하므로, 오버헤드가 상대적으로 더 크다. 장단점\n장점: LFU 알고리즘은 LRU알고리즘보다 오랜 시간 참조 기록을 보기 때문에, 더 정확히 반영 가능 단점: 참조 시점의 최근성을 반영 X, LRU보다 구현 복잡 2.5 클럭(Clock) 알고리즘 하드웨어적 지원을 통해 알고리즘의 운영 오버헤드를 줄인 방식\n그래서 LRU 비해 페이지의 관리가 훨씬 빠르고 효율적으로 이뤄지기 때문에, 일반적으로 페이지 교체 알고리즘으로 클럭 알고리즘을 선택한다. LRU의 근사 알고리즘으로서, 다음과 같이 불린다. Second chance algorithum NUR(Not Used Recently) NRU(Not Recently Used) LRU는 가장 오래 전에 참조된 페이지를 교체하는 것에 비해 클럭 알고리즘은 오랫동안 참조되지 않은 페이지 중 하나를 교체하기 때문에, 가장 오래되었다는 건 보장하지 못한다. 그림 설명\n직사각형= 물리적 메모리 안에 있는 페이지(= 페이지 프레임)를 의미 교체할 페이지 선정을 위해 HW가 세팅한 페이지 프레임들의 참조 비트(reference bit) 를 순차적으로 OS가 조사한다.\npointer 이동 중에 reference bit 1은 모두 0으로 바꾼다. reference bit가 0인 것을 찾으면 그 페이지를 교체한다. 한 바퀴 되돌아와서도 (=second chance) 0 이면 그 때 교체된다. 자주 사용되는 페이지라면 second chance가 올 때 1 Clock algorithum의 개선\nHW가 bit를 setting reference bit = 0: 한 바퀴 도는 동안 이 페이지에 대한 참조가 없었다는 의미 reference bit = 1: 한 바퀴 도는 동안 적어도 한 번 참조된 페이지 modified bit = 1: 최근에 변경된 페이지(I/O를 동반하는 페이지) 3. 페이지 프레임의 할당(allocation) 프로세스 여러 개가 동시에 수행되는 상황에서 각 프로세스에 얼마만큼의 메모리 공간을 할당할 것인지 결정해야 한다. 이를 위한 알고리즘을 3가지로 나눌 수 있다.\n첫 번째, 균등할당(equal algorithum)\n모든 프로세스에게 페이지 프레임을 균일하게 할당하는 방식 두 번째, 비례할당(proportional allocation)\n프로세스의 크기에 비례해서 페이지 프레임을 할당하는 방식 세 번째, 우선순위 할당(priority allocation)\n프로세스의 우선순위에 따라 페이지 프레임을 다르게 할당하는 방식 당장 CPU에서 실행될 프로세스와 아닌 프로세스를 구분하여 전자 쪽에 더 많은 페이지 프레임을 할당하는 방식 할당 알고리즘만으로는 process의 페이지 아래의 참조 특성을 제대로 반영하지 못한다.\n첫 번째, 명령어 수행을 위해 최소한 할당되어야 하는 frame의 수가 존재 두 번째, Loop(반복문)를 구성하는 page들은 한꺼번에 할당되는게 유리하다. 최소한의 allocation이 없으면 매 loop마다 page fault 발생 세 번째, 프로세스에게 최소한으로 필요한 메모리의 양은 시간에 따라 다르다. 그래서, 종합적인 상황을 고려해서 각 프로세스에 할당되는 페이지 프레임의 수를 결정해야 한다.\n경우에 따라서는, 최소한의 메모리 요구량을 충족시키기 위해 일부 프로세스에게 메모리를 할당하지 않아야 한다.\n4. 전역교체와 지역교체 (Global vs. Local replacement) 교체할 페이지를 선정할 때, 교체 대상이 될 프레임의 범위에 따라 다음 2가지로 구분된다.\n전역 교체(global replacement)\n프로세스마다 미리 메모리를 할당하는 게 아닌, 전체 메모리를 공유해서 사용하고 교체 알고리즘에 근거해서 할당되는 메모리 양이 가변적으로 변하는 방법\n그래서 replace 시, 다른 process에게 할당된 frame도 빼앗아 올 수 있다. (경쟁)\n= 모든 페이지 프레임이 교체 대상 = Process 별 프레임 할당량을 조절하는 또 다른 방법 FIFO, LRU, LFU 등의 알고리즘을 사용하다보면 전체 시스템 차원에서 특정 페이지가 알아서 메모리에 올라가기 때문에 frame 할당량이 알아서 조절된다.\n다음 절의 working set, PFF 알고리즘의 경우, 프로그램이 최소한 필요로 하는 할당 효과가 있는 알고리즘이기 때문에, 전역교체 방법으로 사용될 수 있다.\n지역 교체(local replacement)\n프로세스마다 페이지 프레임을 미리 할당하는 것 현재 수행 중인 프로세스에게 할당된 frame 내에서만 빼앗아올 수 있는 방법 frame 할당 알고리즘은 균등할당, 비례할당, 우선순위 할당으로 프로세스에게 미리 할당한다. 프로세스가 FIFO, LRU, LFU 등의 알고리즘을 독자적으로 운영할 때, 사용되는 방법 5. 스레싱(thrashing) 프로세스가 원활히 수행되기 위한 일정 수준 이상의 페이지 프레임을 할당받지 못하여 page fault가 지나치게 발생하는 상황\nThrashinig의 자세한 발생 과정 프로세스에게 일정 수준 이상의 페이지 프레임 할당 X → 페이지 부재율이 크게 상승 → CPU 이용률이 급격히 하락\n→ 낮은 CPU 이용률 -\u003e OS가 메모리에 올라가는 프로세스의 수 증가 = 다중 프로그래밍의 정도(Multi-Programming Degree: MPD) 증가 →\nMPD를 OS가 높이는 이유는 OS에게 CPU 이용률이 낮다는 건, 프로세스의 수가 너무 적고, 프로세스가 모두 I/O 작업을 하여 ready queue가 비는 경우를 의미한다.\n→ 과도한 MPD 상승 -\u003e 프로세스 당 할당되는 메모리 양이 지나치게 감소 -\u003e 빈번한 페이지 부재 발생 → 페이지 교체하며 swap in \u0026 swap out이 지속적으로 발생 -\u003e CPU 이용률 다시 감소 → 2번 과정 다시 수행\nswap in \u0026 swap out 작업 과정\nI/O 작업을 수반 → 문맥교환을 통해 다른 프로세스에게 CPU 이양 → 다른 프로세스에게도 할당받은 메모리 양이 적으면 페이지 부재 발생 그래서 ready queue에 있는 모든 프로세스에게 CPU가 한 차례씩 할당되었는데도 모든 프로세스가 다 페이지 부재가 발생. 결국 낮은 처리량(low throughput)을 가진다.\n이렇게 1번에서 5번 과정이 계속 반복되는 것을 스레싱이라 한다.\nThrashing graph 위 과정을 그래프로 나타낸 것이 다음과 같다. 프로그램이 1개일 때는 메모리를 쓰다가 I/O 하는 동안 CPU가 쉰다.\n그래서 프로그램이 I/O 작업 시, 다른 프로세스에게 CPU 이양하여 CPU 이용률을 높인다.\n하지만, 프로세스의 수를 증가시키면 오히려 CPU 이용률이 뚝 떨어진다.\n왜냐하면 thrashing이 발생했기 때문이다.\n그래서 CPU 이용률을 최대한 높이면서 MPD를 조절하는 게 중요하다.\n이를 조절하는 알고리즘이 워킹셋(working-set algorithum) 과 페이지 부재 빈도 알고리즘(page-fault frequency scheme) 이 있다.\n5.1 워킹셋(working-set) 알고리즘 지역성 집합이 메모리에 동시 올라갈 수 있도록 보장하는 메모리 관리 알고리즘\nLocality of reference\n프로세스는 특정 시간 동안 일정 장소만을 집중적으로 참조하는 현상 Locality set(지역성 집합)\n집중적으로 참조되는 해당 page들의 집합 Working-set 이란?\n프로세스가 일정 시간 동안 원활히 수행되기 위해, 한꺼번에 메모리에 올라와 있어야 하는 페이지들의 집합 working-set에서의 locality set MPD 조절 방법\n프로세스의 워킹셋을 구성하는 페이지들이 한꺼번에 메모리에 올라갈 수 있는 경우에만, 그 프로세스에게 메모리를 할당 그렇지 않으면 프로세스에게 할당된 페이지 프레임들을 모두 반납한 후, 프로세스의 주소 공간 전체를 disk로 swap out한다. 5.1.1 Working-set algorithum 구현 Working Set(WS) 결정하기\nworking-set window를 사용한다. window의 크기: Δ time interval 사이에 참조된 서로 다른 페이지들의 집합 WS 크기는 변한다. working set 크기와 frame 수에 따른 MPD 제어\n워킹셋 크기 합 \u003e frame 수 → 일부 프로세스를 스왑 아웃 → 남은 프로세스의 워킹셋이 메모리에 모두 올라가는 것을 보장 ⇒ MPD 감소 효과 워킹셋 크기 합 \u003c frame 수 → swap out한 프로세스를 다시 메모리에 적재 → working set을 할당 → MPD를 증가 위 두 가지 방식으로 thrasing을 방지 window의 크기가 너무 작으면, 지역성 집합을 모두 수용 X window의 크기가 너무 크면, 여러 규모의 지역성 집합 수용 가능하지만, MPD가 감소 → CPU 이용률 감소 5.2 페이지 부재 빈도(page fault frequency: PFF) 알고리즘 프로세스의 페이지 부재율을 주기적으로 조사하고, 이 값에 근거해서 각 프로세스에 할당할 메모리 양을 조절하여 MPD를 조절하면서 CPU 이용률을 높이는 알고리즘\npage-fault rate의 상한값과 하한값을 둔다\nPage fault rate이 상한값을 넘으면 frame을 더 할당한다. Page fault rate이 하한값 이하이면 할당 frame 수를 줄인다. 빈 frame이 없으면 일부 프로세스를 swap out한다.\n모든 프로세스에게 프레임을 다 할당한 후에도 프레임이 남는 경우, 위의 swap out된 process에게 frame을 할당하여 MPD를 높인다.\nReference kocw 이화여자대학교 운영체제 - 반효경 교수 - 운영체제와 정보기술의 원리 - 반효경 지음 - ","wordCount":"1989","inLanguage":"en","datePublished":"2022-05-23T21:50:30+09:00","dateModified":"2022-05-23T21:50:30+09:00","mainEntityOfPage":{"@type":"WebPage","@id":"http://jeha00.github.io/post/os/os_chapter_10_%EA%B0%80%EC%83%81%EB%A9%94%EB%AA%A8%EB%A6%AC/"},"publisher":{"@type":"Organization","name":"Jeha DevLog","logo":{"@type":"ImageObject","url":"http://jeha00.github.io/favicon.ico"}}}</script></head><body class=dark id=top><script>localStorage.getItem("pref-theme")==="light"&&document.body.classList.remove("dark")</script><header class=header><nav class=nav><div class=logo><a href=http://jeha00.github.io/ accesskey=h title="@Jeha00 (Alt + H)">@Jeha00</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></span></div><ul id=menu><li><a href=http://jeha00.github.io/me/ title=About><span>About</span></a></li><li><a href=http://jeha00.github.io/archives/ title=Archive><span>Archive</span></a></li><li><a href=http://jeha00.github.io/categories/ title=Categories><span>Categories</span></a></li><li><a href=http://jeha00.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=http://jeha00.github.io/>Home</a>&nbsp;»&nbsp;<a href=http://jeha00.github.io/post/>Posts</a></div><h1 class=post-title>[TIL] OS Chapter 10: 가상 메모리</h1><div class=post-meta><span title='2022-05-23 21:50:30 +0900 KST'>May 23, 2022</span>&nbsp;|&nbsp;<a href=https://github.com/JeHa00/blog/content/post/OS/OS_Chapter_10_%ea%b0%80%ec%83%81%eb%a9%94%eb%aa%a8%eb%a6%ac.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#0-introduction aria-label="0. Introduction">0. Introduction</a></li><li><a href=#1-%ec%9a%94%ea%b5%ac-%ed%8e%98%ec%9d%b4%ec%a7%95 aria-label="1. 요구 페이징">1. 요구 페이징</a><ul><li><a href=#11-%ec%9a%94%ea%b5%ac-%ed%8e%98%ec%9d%b4%ec%a7%95%ec%9d%98-%ed%8e%98%ec%9d%b4%ec%a7%80-%eb%b6%80%ec%9e%ac-%ec%b2%98%eb%a6%ac aria-label="1.1 요구 페이징의 페이지 부재 처리">1.1 요구 페이징의 페이지 부재 처리</a></li><li><a href=#12%ec%9a%94%ea%b5%ac-%ed%8e%98%ec%9d%b4%ec%a7%95%ec%9d%98-%ec%84%b1%eb%8a%a5 aria-label="1.2요구 페이징의 성능">1.2요구 페이징의 성능</a></li></ul></li><li><a href=#2-%ed%8e%98%ec%9d%b4%ec%a7%80-%ea%b5%90%ec%b2%b4 aria-label="2. 페이지 교체">2. 페이지 교체</a><ul><li><a href=#21-%ec%b5%9c%ec%a0%81-%ed%8e%98%ec%9d%b4%ec%a7%80optimal-algorithum-%ea%b5%90%ec%b2%b4 aria-label="2.1 최적 페이지(Optimal Algorithum) 교체">2.1 최적 페이지(Optimal Algorithum) 교체</a></li><li><a href=#22-%ec%84%a0%ec%9e%85%ec%84%a0%ec%b6%9cfifofirst-in-first-out-%ec%95%8c%ea%b3%a0%eb%a6%ac%ec%a6%98 aria-label="2.2 선입선출(FIFO:First In First Out) 알고리즘">2.2 선입선출(FIFO:First In First Out) 알고리즘</a></li><li><a href=#23-lruleast-recently-used-%ec%95%8c%ea%b3%a0%eb%a6%ac%ec%a6%98 aria-label="2.3 LRU(Least Recently Used) 알고리즘">2.3 LRU(Least Recently Used) 알고리즘</a></li><li><a href=#24-lfuleast-frequently-used-%ec%95%8c%ea%b3%a0%eb%a6%ac%ec%a6%98 aria-label="2.4 LFU(Least Frequently used) 알고리즘">2.4 LFU(Least Frequently used) 알고리즘</a></li><li><a href=#25-%ed%81%b4%eb%9f%adclock-%ec%95%8c%ea%b3%a0%eb%a6%ac%ec%a6%98 aria-label="2.5 클럭(Clock) 알고리즘">2.5 클럭(Clock) 알고리즘</a></li></ul></li><li><a href=#3-%ed%8e%98%ec%9d%b4%ec%a7%80-%ed%94%84%eb%a0%88%ec%9e%84%ec%9d%98-%ed%95%a0%eb%8b%b9allocation aria-label="3. 페이지 프레임의 할당(allocation)">3. 페이지 프레임의 할당(allocation)</a></li><li><a href=#4-%ec%a0%84%ec%97%ad%ea%b5%90%ec%b2%b4%ec%99%80-%ec%a7%80%ec%97%ad%ea%b5%90%ec%b2%b4-global-vs-local-replacement aria-label="4. 전역교체와 지역교체 (Global vs. Local replacement)">4. 전역교체와 지역교체 (Global vs. Local replacement)</a></li><li><a href=#5-%ec%8a%a4%eb%a0%88%ec%8b%b1thrashing aria-label="5. 스레싱(thrashing)">5. 스레싱(thrashing)</a><ul><ul><li><a href=#thrashinig%ec%9d%98-%ec%9e%90%ec%84%b8%ed%95%9c-%eb%b0%9c%ec%83%9d-%ea%b3%bc%ec%a0%95 aria-label="Thrashinig의 자세한 발생 과정">Thrashinig의 자세한 발생 과정</a></li><li><a href=#thrashing-graph aria-label="Thrashing graph">Thrashing graph</a></li></ul><li><a href=#51-%ec%9b%8c%ed%82%b9%ec%85%8bworking-set-%ec%95%8c%ea%b3%a0%eb%a6%ac%ec%a6%98 aria-label="5.1 워킹셋(working-set) 알고리즘">5.1 워킹셋(working-set) 알고리즘</a><ul><li><a href=#511-working-set-algorithum-%ea%b5%ac%ed%98%84 aria-label="5.1.1 Working-set algorithum 구현">5.1.1 Working-set algorithum 구현</a></li></ul></li><li><a href=#52-%ed%8e%98%ec%9d%b4%ec%a7%80-%eb%b6%80%ec%9e%ac-%eb%b9%88%eb%8f%84page-fault-frequency-pff-%ec%95%8c%ea%b3%a0%eb%a6%ac%ec%a6%98 aria-label="5.2 페이지 부재 빈도(page fault frequency: PFF) 알고리즘">5.2 페이지 부재 빈도(page fault frequency: PFF) 알고리즘</a></li></ul></li><li><a href=#reference aria-label=Reference>Reference</a></li></ul></div></details></div><div class=post-content><h1 id=0-introduction>0. Introduction<a hidden class=anchor aria-hidden=true href=#0-introduction>#</a></h1><ul><li>해당 내용은 <a href="http://www.kyobobook.co.kr/product/detailViewKor.laf?ejkGb=KOR&mallGb=KOR&barcode=9791158903589&orderClick=LAG&Kc=">운영체제와 정보기술의 원리 -반효경 지음-</a> 와 <a href="http://www.kocw.net/home/cview.do?lid=3dd1117c48123b8e">kocw 이화여자대학교 운영체제 - 반효경 교수 -</a>를 보고 정리한 내용이다.</li><li>정확하지 않은 내용이 있다면 말씀해주시면 감사하겠습니다.</li></ul><hr><p> </p><ul><li><p>운영체제는 보통 모든 프로그램들에 공평하게 같은 크기의 메모리를 할당하기보다는 <strong><em>몇몇 프로그램들에게 집중적으로 메모리를 할당한 후</em></strong>, 시간이 흐르면 이들로부터 메모리를 회수해서 다른 프로그램들에게 다시 집중적으로 메모리를 할당하는 방식을 채택한다.</p></li><li><p>왜냐하면 프로세스의 빠른 수행을 위해 <strong><em>프로그램마다 최소한 확보해야하는 메모리 크기가 존재</em></strong> 하기 때문이다.</p></li><li><p>하지만 그렇다고 프로세스의 주소 공간 전체가 메모리에 올라와 있어야 하는 것은 아니다. 운영체제는 CPU에서 당장 수행할 부분만을 메모리에 올려놓고, 그렇지 않은 부분은 disk의 swap area에 내려놓았다가 다시 필요해지면 메모리에 올라가 있는 부분과 교체하는 방식을 사용한다.</p></li><li><p>또한, 프로그램은 0번지부터 시작하는 자기 자신만의 메모리 공간을 가정한다. 이러한 공간을 <code>Virtual memory(가상 메모리)</code> 이라 한다. 이 가상 공간 중 일부가 swap area에존재하고, 일부는 물리적 메모리에 존재하는 것이다.</p></li><li><p>이 가상 메모리를 적재하는 단위에 따라 <code>요구 페이징</code> 또는 <code>요구 세그먼테이션</code> 방식으로 나눠진다. 전자는 대부분의 경우에 사용되며, 세부적인 구현에 특히 사용된다. 후자는 <code>paged segmentation</code> 기법을 사용하는 경우를 말한다.</p></li><li><p>그러면 요구 페이징에 대해 먼저 알아보자.</p></li></ul><p> </p><hr><h1 id=1-요구-페이징>1. 요구 페이징<a hidden class=anchor aria-hidden=true href=#1-요구-페이징>#</a></h1><blockquote><p><strong><em>프로그램 실행 시 프로세스를 구성하는 모든 페이지를 한꺼번에 메모리에 올리는 게 아닌, 당장 사용될 페이지만을 올리는 방식</em></strong></p></blockquote><ul><li><p>특정 페이지에 대한 CPU 요청이 들어온 후에야 해당 페이지를 메모리에 적재한다.</p></li><li><p>비유: 매 끼니마다 필요한 분량만큼 재료를 구입해서 보관하는 방식</p><ul><li>냉장고: 물리적 메모리</li><li>식재료: 프로세스를구성하는 페이지</li><li>보관 행위: 페이지를 메모리에 적재</li></ul></li><li><p><strong>장점</strong></p><ul><li>필요한 부분만을 적재하기 때문에,<ul><li>메모리 사용량 감소, I/O 양 감소 -> 응답시간 단축</li><li>프로세스 전체를 메모리에 올리는데 소요되는 입출력 오버헤드 감소</li><li>더 많은 프로세스 수용</li><li>물리적 메모리 용량 제약에서 벗어남</li></ul></li></ul></li><li><p><strong>Problem</strong></p><ul><li>가상 메모리 중 어떤 페이지가 메모리에 존재하는지 유무를 구별하기 위한 방안 필요</li></ul></li><li><p><strong>Solution</strong></p><ul><li>유효-무효(Valid - Invalid bit)를 두어 page가 각 memory에 존재하는지 표시</li><li>모든 page에 대해 존재해야 하므로, page table의각 항목별로 저장</li></ul></li><li><p><strong>Valid - Invalid bit</strong></p><ul><li><p>기본 bit 값: invalid bit</p></li><li><p>특정 페이지가 참조되어 메모리에 적재 → Valid bit → 적재된 page가 swap area로 쫓겨남 → Invalid bit</p></li><li><p>Invalid bit 는 언제일 때를 말하는가?</p><ul><li>해당 페이지가 물리적 메모리에 없는 경우</li><li>페이지가 속한 주소 영역을 프로세스가 사용하지 않은 경우</li><li>물리적 메모리에 A,C,G가 올라가 있기 때문에, 이에 해당하는 page table의 0, 2, 6이 valid라는 걸 확인할 수 있다.</li></ul></li></ul></li></ul><p><img loading=lazy src=https://user-images.githubusercontent.com/78094972/169747385-16dcfa5e-ec31-4b22-9c6c-72db4df2731f.jpg alt=image></p><ul><li><strong>Page fault</strong><ul><li>CPU가 한 페이지를 참조하려는데, 요청한 페이지가 메모리에 없어서 invalid bit인 경우를 말한다.</li></ul></li></ul><p> </p><h2 id=11-요구-페이징의-페이지-부재-처리>1.1 요구 페이징의 페이지 부재 처리<a hidden class=anchor aria-hidden=true href=#11-요구-페이징의-페이지-부재-처리>#</a></h2><p><img loading=lazy src=https://user-images.githubusercontent.com/78094972/169749146-719b93f2-6b7c-46e6-9d93-2b3d72c0a245.PNG alt=image></p><ul><li><p><strong>CPU가 무효 페이지에 접근 → 주소 변환 담당 MMU가 페이지 부재 트랩(page fault trap) 발생 → kernel mode로 전환 → OS의 페이지 부재 처리루틴(page fault handler)이 호출</strong></p></li><li><p><strong>OS의 처리 과정</strong></p><ul><li><p>OS는 프로세스의 해당 페이지에 대한 접근이 적법한지 먼저 체크 (reference)</p><ul><li>사용되지 않는 주소 영역에 속한 페이지에 접근하려거나, 해당 페이지에 대한 접근 권한 위반(protection violation)을 했을 경우, 해당 프로세스를 종료</li><li>protection violtaion: read-only file에 write 시도를 한 경우</li></ul></li><li><p>→ 적법 판정 → 물리적 메모리의 빈 frame을 할당받아 이 공간에 해당 페이지를 적재.</p><ul><li>빈 frame이 없다면, 물리적 메모리에 적재된 페이지 중 하나를 swap out</li></ul></li><li><p>→ 요청한 페이지를 디스크로부터 물리적 메모리에 적재하기(disk I/O 작업을 의미)까지 오랜 시간이 걸리므로, CPU를 빼앗기고 봉쇄 상태(block state)가 됨</p><ul><li>현재까지 수행되던 프로세스는 CPU register state 및 PC value를 PCB에 저장하여, 나중에 이 프로세스를 재할당 시, 정확히 같은 상태에서 다음 instruction을 수행.</li></ul></li><li><p>→ I/O 작업이 완료되어 interrupt가 발생하면 page table에서 해당 page의 valid-invalid bit를 valid bit로 설정 (reset page table)</p></li><li><p>→ 봉쇄된 process를 ready queue로 이동</p></li><li><p>→ 다시 CPU를 잡고 running 하며 아까 중단되었던 instruction을 재개한다.</p></li></ul></li></ul><p> </p><h2 id=12요구-페이징의-성능>1.2요구 페이징의 성능<a hidden class=anchor aria-hidden=true href=#12요구-페이징의-성능>#</a></h2><ul><li><strong>페이지 부재의 발생 빈도</strong><ul><li>페이지 부재로 인해 페이지 교체가 이뤄지는 과정에서 요청된 페이지를 디스크에서 메모리로 읽어오는 disk input/output 과 각종 overhead가 포함되어 시간이 오래 걸린다.</li><li>그래서 <code>유효 접근 시간</code> 이 짧을 수록 성능 향상</li></ul></li></ul><p> </p><hr><h1 id=2-페이지-교체>2. 페이지 교체<a hidden class=anchor aria-hidden=true href=#2-페이지-교체>#</a></h1><p><img loading=lazy src=https://user-images.githubusercontent.com/78094972/169756458-0a11397e-6b89-4cc6-b077-00927712dbf5.jpg alt=image></p><ul><li><p><strong>페이지 교체(page replacement)란?</strong></p><ul><li>페이지 부재가 발생 시, 요청 페이지를 디스크에서 메모리로 불러오기 위에 메모리에 적재된 여러 페이지 중 하나를 swap out하여 요청된 페이지를 메모리에 적재하는 것</li></ul></li><li><p><strong>교체 알고리즘(replacement algoritum)</strong></p><ul><li>페이지 교체 시, 어떤 프레임에 있는 페이지를 쫓아 낼지 결정하는 알고리즘</li><li>페이지 부재 발생비율(page-fault rate)을 최소화하는 것이 목표</li><li>평가 기준: 주어진 페이지 참조열에 대해 페이지 부재를 얼마나 내는지 조사<ul><li>가까운 미래에 참조될 가능성이 적은 페이지를 내쫓는 것이 성능 향상 방안</li></ul></li></ul></li><li><p><strong>페이지 참조열(page reference string)</strong></p><ul><li>참조되는 페이지들의 번호를 시간 순서에 따라 나열한 것<ul><li>예) 1,2,3,4,1,2,5,1,2,3,4,5</li></ul></li></ul></li></ul><p> </p><h2 id=21-최적-페이지optimal-algorithum-교체>2.1 최적 페이지(Optimal Algorithum) 교체<a hidden class=anchor aria-hidden=true href=#21-최적-페이지optimal-algorithum-교체>#</a></h2><ul><li><p><strong>Belady’s optimal algorithum (빌레디의 최적 알고리즘) = MIN, OPT</strong></p><ul><li>페이지 부재율을 최소화하기 위해, 메모리에 존재하는 페이지 중 가까운 미래에 참조될 페이지를 쫓아내는 것</li></ul></li><li><p><strong>다른 알고리즘의 Upper bound</strong></p><ul><li>어떠한 알고리즘보다도 <strong><em>가장 적은 페이지 부재율을 보장</em></strong> 하므로 다른 알고리즘 성능에 대한 <strong><em>상한선(Upper bound)</em></strong> 를 제공한다.</li><li>그래서 어떤 교체 알고리즘이 이 알고리즘과 유사하다면 더 이상의 알고리즘 연구가 필요하지 않음을 시사한다.</li></ul></li></ul><p><img loading=lazy src=https://user-images.githubusercontent.com/78094972/169758640-915d6e19-2a0e-4417-baff-22f3462c8dab.PNG alt=image></p><ul><li><p><strong>예시</strong></p><ul><li>4 frames example</li><li>처음 페이지 참조 시에는 4회까지 페이지 부재가 불가피하다.</li><li>5, 6회는 이미 페이지가 존재하기 때문에 발생하지 않는다.</li><li>7회에서 페이지 5를 참조 시, 페이지 부재가 발생하여 디스크에서 메모리로 가져오는 작업이 필요하다. 이 때 페이지 교체를 해야 하는데, 가장 먼 미래에 참조될 페이지인 4번 페이지와 교체된다.</li><li>그래서 총 6번의 페이지 부재가 발생한다.</li></ul></li><li><p><strong>Offline algorithum</strong></p><ul><li><strong><em>미래에 어떤 페이지가 참조될지 미리 알고 있다는 전제</em></strong> 이므로, 온라인에서 사용할 수 없어서 offline algorithum 이라 한다.</li></ul></li><li><p>이 이후에 알고리즘은 미래를 모르는 알고리즘들이다.</p></li></ul><p> </p><h2 id=22-선입선출fifofirst-in-first-out-알고리즘>2.2 선입선출(FIFO:First In First Out) 알고리즘<a hidden class=anchor aria-hidden=true href=#22-선입선출fifofirst-in-first-out-알고리즘>#</a></h2><ul><li><strong>물리적 메모리에 먼저 올라온 페이지를 우선적으로 내쫓는 알고리즘</strong><ul><li>향후 참조 가능성 고려 X</li><li>물리적 메모리에 들어온 순서대로 대상 선정</li></ul></li></ul><p><img loading=lazy src=https://user-images.githubusercontent.com/78094972/169759701-aa50a0f4-17e0-407a-835a-6d2ada03a897.PNG alt=image></p><ul><li><p>페이지 프레임을 늘린다고, page fault가 줄어드는 게 아니다.</p><ul><li><p><strong>페이지 프레임 3개</strong></p><ul><li>9번의 페이지 부재</li></ul></li><li><p><strong>페이지 프레임 4개</strong></p><ul><li>10번의 페이지 부재</li></ul></li></ul></li></ul><p> </p><h2 id=23-lruleast-recently-used-알고리즘>2.3 LRU(Least Recently Used) 알고리즘<a hidden class=anchor aria-hidden=true href=#23-lruleast-recently-used-알고리즘>#</a></h2><ul><li><strong>교체 알고리즘으로 가장 많이 사용된다.</strong></li><li><strong>시간지역성(Temporal locality)이 낮은 페이지를 쫓아내는 알고리즘</strong><ul><li>시간 지역성: 최근에 참조된 페이지가 가까운 미래에 다시 참조될 가능성이 높은 성질</li><li>가장 오래 전에 참조된 것을 지워서, 참조 횟수는 고려하지 않는다.</li></ul></li></ul><p><img loading=lazy src=https://user-images.githubusercontent.com/78094972/169760585-bf523345-8b80-494a-9792-1dd7b3252481.PNG alt=image></p><p> </p><h2 id=24-lfuleast-frequently-used-알고리즘>2.4 LFU(Least Frequently used) 알고리즘<a hidden class=anchor aria-hidden=true href=#24-lfuleast-frequently-used-알고리즘>#</a></h2><ul><li><p><strong>물리적 메모리 내에 존재하는 페이지 중 과거에 참조 횟수(reference count)가 가장 적은 페이지로 교체 페이지를 결정하는 알고리즘</strong></p><ul><li>최저 참조 횟수를 가진 페이지가 여러 개일 경우, 상대적으로 더 오래전에 참조된 페이지를 쫓아낸다.</li></ul></li><li><p>참조 횟수를 계산하는 방식에 따라 <code>Incache-LFU</code> 와 <code>Perfect-LFU</code> 로 나눠진다.</p></li><li><p><strong>Incache-LFU</strong></p><ul><li>page가 물리적 메모리에 올라온 후부터의 참조 횟수를 카운트하는 방식</li><li>그래서 메모리에서 내려갔다가 다시 적재되면 참조 횟수는 초기화된다.</li></ul></li><li><p><strong>Perfect-LFU</strong></p><ul><li>메모리에 적재여부와 상관없이 그 페이지의 과거 총 참조 횟수를 카운트하는 방식</li><li>장점: 페이지의 참조 횟수를 정확히 반영</li><li>단점: 메모리에서 쫓겨난 페이지의 참조 기록까지 모두 보관하고 있어야 하므로, 오버헤드가 상대적으로 더 크다.</li></ul></li><li><p><strong>장단점</strong></p><ul><li>장점: LFU 알고리즘은 LRU알고리즘보다 오랜 시간 참조 기록을 보기 때문에, 더 정확히 반영 가능</li><li>단점: 참조 시점의 최근성을 반영 X, LRU보다 구현 복잡</li></ul></li></ul><p><img loading=lazy src=https://user-images.githubusercontent.com/78094972/169771182-b7d3e785-b479-45e0-955c-6dbf67c41cdd.PNG alt=image></p><p> </p><h2 id=25-클럭clock-알고리즘>2.5 클럭(Clock) 알고리즘<a hidden class=anchor aria-hidden=true href=#25-클럭clock-알고리즘>#</a></h2><blockquote><p>하드웨어적 지원을 통해 알고리즘의 운영 오버헤드를 줄인 방식</p></blockquote><ul><li>그래서 LRU 비해 페이지의 관리가 훨씬 빠르고 효율적으로 이뤄지기 때문에, 일반적으로 페이지 교체 알고리즘으로 클럭 알고리즘을 선택한다.</li><li>LRU의 근사 알고리즘으로서, 다음과 같이 불린다.<ul><li>Second chance algorithum</li><li>NUR(Not Used Recently)</li><li>NRU(Not Recently Used)</li></ul></li><li>LRU는 가장 오래 전에 참조된 페이지를 교체하는 것에 비해 클럭 알고리즘은 오랫동안 참조되지 않은 페이지 중 하나를 교체하기 때문에, 가장 오래되었다는 건 보장하지 못한다.</li></ul><p><img loading=lazy src=https://user-images.githubusercontent.com/78094972/169775921-d11e87f8-5f28-4094-820c-4c748581276b.PNG alt=image></p><ul><li><p><strong>그림 설명</strong></p><ul><li>직사각형= 물리적 메모리 안에 있는 페이지(= 페이지 프레임)를 의미</li></ul></li><li><p>교체할 페이지 선정을 위해 HW가 세팅한 <strong><em>페이지 프레임들의 참조 비트(reference bit)</em></strong> 를 순차적으로 OS가 조사한다.</p><ul><li>pointer 이동 중에 reference bit 1은 모두 0으로 바꾼다.</li><li>reference bit가 0인 것을 찾으면 그 페이지를 교체한다.</li><li>한 바퀴 되돌아와서도 (=second chance) 0 이면 그 때 교체된다.</li><li>자주 사용되는 페이지라면 second chance가 올 때 1</li></ul></li><li><p><strong>Clock algorithum의 개선</strong></p><ul><li>HW가 bit를 setting</li><li>reference bit = 0: 한 바퀴 도는 동안 이 페이지에 대한 참조가 없었다는 의미</li><li>reference bit = 1: 한 바퀴 도는 동안 적어도 한 번 참조된 페이지</li><li>modified bit = 1: 최근에 변경된 페이지(I/O를 동반하는 페이지)</li></ul></li></ul><p> </p><hr><h1 id=3-페이지-프레임의-할당allocation>3. 페이지 프레임의 할당(allocation)<a hidden class=anchor aria-hidden=true href=#3-페이지-프레임의-할당allocation>#</a></h1><p>프로세스 여러 개가 동시에 수행되는 상황에서 각 프로세스에 얼마만큼의 메모리 공간을 할당할 것인지 결정해야 한다. 이를 위한 알고리즘을 3가지로 나눌 수 있다.</p><ul><li><p><strong>첫 번째, 균등할당(equal algorithum)</strong></p><ul><li>모든 프로세스에게 페이지 프레임을 균일하게 할당하는 방식</li></ul></li><li><p><strong>두 번째, 비례할당(proportional allocation)</strong></p><ul><li>프로세스의 크기에 비례해서 페이지 프레임을 할당하는 방식</li></ul></li><li><p><strong>세 번째, 우선순위 할당(priority allocation)</strong></p><ul><li>프로세스의 우선순위에 따라 페이지 프레임을 다르게 할당하는 방식</li><li>당장 CPU에서 실행될 프로세스와 아닌 프로세스를 구분하여 전자 쪽에 더 많은 페이지 프레임을 할당하는 방식</li></ul></li></ul><p>할당 알고리즘만으로는 process의 페이지 아래의 참조 특성을 제대로 반영하지 못한다.</p><ul><li><strong>첫 번째, 명령어 수행을 위해 최소한 할당되어야 하는 frame의 수가 존재</strong></li><li><strong>두 번째, Loop(반복문)를 구성하는 page들은 한꺼번에 할당되는게 유리하다.</strong><ul><li>최소한의 allocation이 없으면 매 loop마다 page fault 발생</li></ul></li><li><strong>세 번째, 프로세스에게 최소한으로 필요한 메모리의 양은 시간에 따라 다르다.</strong></li></ul><p><strong><em>그래서, 종합적인 상황을 고려해서 각 프로세스에 할당되는 페이지 프레임의 수를 결정해야 한다.</em></strong></p><p>경우에 따라서는, 최소한의 메모리 요구량을 충족시키기 위해 일부 프로세스에게 메모리를 할당하지 않아야 한다.</p><p> </p><hr><h1 id=4-전역교체와-지역교체-global-vs-local-replacement>4. 전역교체와 지역교체 (Global vs. Local replacement)<a hidden class=anchor aria-hidden=true href=#4-전역교체와-지역교체-global-vs-local-replacement>#</a></h1><p>교체할 페이지를 선정할 때, 교체 대상이 될 프레임의 범위에 따라 다음 2가지로 구분된다.</p><ul><li><p><strong>전역 교체(global replacement)</strong></p><ul><li><p>프로세스마다 미리 메모리를 할당하는 게 아닌, <strong><em>전체 메모리를 공유해서 사용하고</em></strong> 교체 알고리즘에 근거해서 할당되는 메모리 양이 가변적으로 변하는 방법</p><ul><li>그래서 replace 시, <strong><em>다른 process에게</em></strong> 할당된 frame도 빼앗아 올 수 있다. (경쟁)<br>= 모든 페이지 프레임이 교체 대상
= Process 별 프레임 할당량을 조절하는 또 다른 방법</li></ul></li><li><p>FIFO, LRU, LFU 등의 알고리즘을 사용하다보면 <strong><em>전체 시스템 차원에서 특정 페이지가 알아서 메모리에 올라가기 때문에</em></strong> frame 할당량이 알아서 조절된다.</p></li><li><p>다음 절의 working set, PFF 알고리즘의 경우, 프로그램이 최소한 필요로 하는 할당 효과가 있는 알고리즘이기 때문에, 전역교체 방법으로 사용될 수 있다.</p></li></ul></li><li><p><strong>지역 교체(local replacement)</strong></p><ul><li>프로세스마다 페이지 프레임을 미리 할당하는 것</li><li>현재 수행 중인 프로세스에게 할당된 frame 내에서만 빼앗아올 수 있는 방법<ul><li>frame 할당 알고리즘은 균등할당, 비례할당, 우선순위 할당으로 프로세스에게 미리 할당한다.</li></ul></li><li>프로세스가 FIFO, LRU, LFU 등의 알고리즘을 독자적으로 운영할 때, 사용되는 방법</li></ul></li></ul><p> </p><hr><h1 id=5-스레싱thrashing>5. 스레싱(thrashing)<a hidden class=anchor aria-hidden=true href=#5-스레싱thrashing>#</a></h1><blockquote><p><strong><em>프로세스가 원활히 수행되기 위한 일정 수준 이상의 페이지 프레임을 할당받지 못하여 page fault가 지나치게 발생하는 상황</em></strong></p></blockquote><h3 id=thrashinig의-자세한-발생-과정>Thrashinig의 자세한 발생 과정<a hidden class=anchor aria-hidden=true href=#thrashinig의-자세한-발생-과정>#</a></h3><p>프로세스에게 일정 수준 이상의 페이지 프레임 할당 X → 페이지 부재율이 크게 상승 → CPU 이용률이 급격히 하락</p><p>→ 낮은 CPU 이용률 -> OS가 <em>메모리에 올라가는 프로세스의 수</em> 증가 = <code>다중 프로그래밍의 정도(Multi-Programming Degree: MPD)</code> 증가 →</p><blockquote><p>MPD를 OS가 높이는 이유는 OS에게 CPU 이용률이 낮다는 건, 프로세스의 수가 너무 적고, 프로세스가 모두 I/O 작업을 하여 ready queue가 비는 경우를 의미한다.</p></blockquote><p>→ 과도한 MPD 상승 -> 프로세스 당 할당되는 메모리 양이 지나치게 감소 -> 빈번한 페이지 부재 발생 → 페이지 교체하며 swap in & swap out이 지속적으로 발생 -> CPU 이용률 다시 감소 → 2번 과정 다시 수행</p><ul><li><p>swap in & swap out 작업 과정</p><ul><li>I/O 작업을 수반 → 문맥교환을 통해 다른 프로세스에게 CPU 이양 → 다른 프로세스에게도 할당받은 메모리 양이 적으면 페이지 부재 발생</li><li>그래서 ready queue에 있는 모든 프로세스에게 CPU가 한 차례씩 할당되었는데도 모든 프로세스가 다 페이지 부재가 발생.</li></ul></li><li><p>결국 낮은 처리량(low throughput)을 가진다.</p></li><li><p>이렇게 1번에서 5번 과정이 계속 반복되는 것을 스레싱이라 한다.</p></li></ul><h3 id=thrashing-graph>Thrashing graph<a hidden class=anchor aria-hidden=true href=#thrashing-graph>#</a></h3><ul><li>위 과정을 그래프로 나타낸 것이 다음과 같다.</li></ul><p><img loading=lazy src=https://user-images.githubusercontent.com/78094972/169810156-5b9690da-6130-4395-a00b-4564ec77414d.PNG alt=image></p><ul><li><p>프로그램이 1개일 때는 메모리를 쓰다가 I/O 하는 동안 CPU가 쉰다.</p></li><li><p>그래서 프로그램이 I/O 작업 시, 다른 프로세스에게 CPU 이양하여 CPU 이용률을 높인다.</p></li><li><p>하지만, 프로세스의 수를 증가시키면 오히려 CPU 이용률이 뚝 떨어진다.</p></li><li><p>왜냐하면 thrashing이 발생했기 때문이다.</p></li><li><p>그래서 CPU 이용률을 최대한 높이면서 MPD를 조절하는 게 중요하다.</p></li><li><p>이를 조절하는 알고리즘이 <strong><em>워킹셋(working-set algorithum)</em></strong> 과 <strong><em>페이지 부재 빈도 알고리즘(page-fault frequency scheme)</em></strong> 이 있다.</p></li></ul><p> </p><h2 id=51-워킹셋working-set-알고리즘>5.1 워킹셋(working-set) 알고리즘<a hidden class=anchor aria-hidden=true href=#51-워킹셋working-set-알고리즘>#</a></h2><blockquote><p><strong><em>지역성 집합이 메모리에 동시 올라갈 수 있도록 보장하는 메모리 관리 알고리즘</em></strong></p></blockquote><ul><li><p><strong>Locality of reference</strong></p><ul><li>프로세스는 특정 시간 동안 일정 장소만을 집중적으로 참조하는 현상</li></ul></li><li><p><strong>Locality set(지역성 집합)</strong></p><ul><li>집중적으로 참조되는 해당 page들의 집합</li></ul></li><li><p><strong>Working-set 이란?</strong></p><ul><li>프로세스가 일정 시간 동안 원활히 수행되기 위해, 한꺼번에 메모리에 올라와 있어야 하는 페이지들의 집합</li><li>working-set에서의 locality set</li></ul></li><li><p><strong>MPD 조절 방법</strong></p><ul><li>프로세스의 워킹셋을 구성하는 페이지들이 한꺼번에 메모리에 올라갈 수 있는 경우에만, 그 프로세스에게 메모리를 할당</li><li>그렇지 않으면 프로세스에게 할당된 페이지 프레임들을 모두 반납한 후, 프로세스의 주소 공간 전체를 disk로 swap out한다.</li></ul></li></ul><p><img loading=lazy src=https://user-images.githubusercontent.com/78094972/169816980-3f3efb0e-254f-42fb-b245-156f3a949183.PNG alt=image></p><p> </p><h3 id=511-working-set-algorithum-구현>5.1.1 Working-set algorithum 구현<a hidden class=anchor aria-hidden=true href=#511-working-set-algorithum-구현>#</a></h3><ul><li><p><strong>Working Set(WS) 결정하기</strong></p><ul><li>working-set window를 사용한다.</li><li>window의 크기: Δ</li><li>time interval 사이에 참조된 서로 다른 페이지들의 집합</li><li>WS 크기는 변한다.</li></ul></li><li><p><strong>working set 크기와 frame 수에 따른 MPD 제어</strong></p><ul><li>워킹셋 크기 합 > frame 수 → 일부 프로세스를 스왑 아웃 → 남은 프로세스의 워킹셋이 메모리에 모두 올라가는 것을 보장 ⇒ MPD 감소 효과</li><li>워킹셋 크기 합 &lt; frame 수 → swap out한 프로세스를 다시 메모리에 적재 → working set을 할당 → MPD를 증가</li><li>위 두 가지 방식으로 thrasing을 방지</li><li>window의 크기가 너무 작으면, 지역성 집합을 모두 수용 X</li><li>window의 크기가 너무 크면, 여러 규모의 지역성 집합 수용 가능하지만, MPD가 감소 → CPU 이용률 감소</li></ul></li></ul><p> </p><h2 id=52-페이지-부재-빈도page-fault-frequency-pff-알고리즘>5.2 페이지 부재 빈도(page fault frequency: PFF) 알고리즘<a hidden class=anchor aria-hidden=true href=#52-페이지-부재-빈도page-fault-frequency-pff-알고리즘>#</a></h2><blockquote><p><strong><em>프로세스의 페이지 부재율을 주기적으로 조사하고, 이 값에 근거해서 각 프로세스에 할당할 메모리 양을 조절하여 MPD를 조절하면서 CPU 이용률을 높이는 알고리즘</em></strong></p></blockquote><p><img loading=lazy src=https://user-images.githubusercontent.com/78094972/169821874-91842e06-116d-4725-bafc-fd32ba778712.PNG alt=image></p><ul><li><p><strong>page-fault rate의 상한값과 하한값을 둔다</strong></p><ul><li>Page fault rate이 상한값을 넘으면 frame을 더 할당한다.</li><li>Page fault rate이 하한값 이하이면 할당 frame 수를 줄인다.</li></ul></li><li><p>빈 frame이 없으면 일부 프로세스를 swap out한다.</p></li><li><p>모든 프로세스에게 프레임을 다 할당한 후에도 프레임이 남는 경우, 위의 swap out된 process에게 frame을 할당하여 MPD를 높인다.</p></li></ul><p> </p><hr><h1 id=reference>Reference<a hidden class=anchor aria-hidden=true href=#reference>#</a></h1><ul><li><a href="http://www.kocw.net/home/cview.do?lid=3dd1117c48123b8e">kocw 이화여자대학교 운영체제 - 반효경 교수 -</a></li><li><a href="http://www.kyobobook.co.kr/product/detailViewKor.laf?ejkGb=KOR&mallGb=KOR&barcode=9791158903589&orderClick=LAG&Kc=">운영체제와 정보기술의 원리 - 반효경 지음 -</a></li></ul></div><footer class=post-footer><ul class=post-tags><li><a href=http://jeha00.github.io/tags/til/>TIL</a></li><li><a href=http://jeha00.github.io/tags/os/>OS</a></li></ul><nav class=paginav><a class=prev href=http://jeha00.github.io/post/os/os_chapter_11_%EB%94%94%EC%8A%A4%ED%81%AC%EA%B4%80%EB%A6%AC/><span class=title>« Prev Page</span><br><span>[TIL] OS Chapter 11: 디스크 관리</span></a>
<a class=next href=http://jeha00.github.io/post/python/python_basic_46_metaclass/><span class=title>Next Page »</span><br><span>[TIL] Python basic 46: Metaclass</span></a></nav><div class=share-buttons><a target=_blank rel="noopener noreferrer" aria-label="share [TIL] OS Chapter 10: 가상 메모리 on twitter" href="https://twitter.com/intent/tweet/?text=%5bTIL%5d%20OS%20Chapter%2010%3a%20%ea%b0%80%ec%83%81%20%eb%a9%94%eb%aa%a8%eb%a6%ac&url=http%3a%2f%2fjeha00.github.io%2fpost%2fos%2fos_chapter_10_%25EA%25B0%2580%25EC%2583%2581%25EB%25A9%2594%25EB%25AA%25A8%25EB%25A6%25AC%2f&hashtags=TIL%2cOS"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM195.519 424.544c135.939.0 210.268-112.643 210.268-210.268.0-3.218.0-6.437-.153-9.502 14.406-10.421 26.973-23.448 36.935-38.314-13.18 5.824-27.433 9.809-42.452 11.648 15.326-9.196 26.973-23.602 32.49-40.92-14.252 8.429-30.038 14.56-46.896 17.931-13.487-14.406-32.644-23.295-53.946-23.295-40.767.0-73.87 33.104-73.87 73.87.0 5.824.613 11.494 1.992 16.858-61.456-3.065-115.862-32.49-152.337-77.241-6.284 10.881-9.962 23.601-9.962 37.088.0 25.594 13.027 48.276 32.95 61.456-12.107-.307-23.448-3.678-33.41-9.196v.92c0 35.862 25.441 65.594 59.311 72.49-6.13 1.686-12.72 2.606-19.464 2.606-4.751.0-9.348-.46-13.946-1.38 9.349 29.426 36.628 50.728 68.965 51.341-25.287 19.771-57.164 31.571-91.8 31.571-5.977.0-11.801-.306-17.625-1.073 32.337 21.15 71.264 33.41 112.95 33.41z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share [TIL] OS Chapter 10: 가상 메모리 on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&url=http%3a%2f%2fjeha00.github.io%2fpost%2fos%2fos_chapter_10_%25EA%25B0%2580%25EC%2583%2581%25EB%25A9%2594%25EB%25AA%25A8%25EB%25A6%25AC%2f&title=%5bTIL%5d%20OS%20Chapter%2010%3a%20%ea%b0%80%ec%83%81%20%eb%a9%94%eb%aa%a8%eb%a6%ac&summary=%5bTIL%5d%20OS%20Chapter%2010%3a%20%ea%b0%80%ec%83%81%20%eb%a9%94%eb%aa%a8%eb%a6%ac&source=http%3a%2f%2fjeha00.github.io%2fpost%2fos%2fos_chapter_10_%25EA%25B0%2580%25EC%2583%2581%25EB%25A9%2594%25EB%25AA%25A8%25EB%25A6%25AC%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share [TIL] OS Chapter 10: 가상 메모리 on reddit" href="https://reddit.com/submit?url=http%3a%2f%2fjeha00.github.io%2fpost%2fos%2fos_chapter_10_%25EA%25B0%2580%25EC%2583%2581%25EB%25A9%2594%25EB%25AA%25A8%25EB%25A6%25AC%2f&title=%5bTIL%5d%20OS%20Chapter%2010%3a%20%ea%b0%80%ec%83%81%20%eb%a9%94%eb%aa%a8%eb%a6%ac"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share [TIL] OS Chapter 10: 가상 메모리 on facebook" href="https://facebook.com/sharer/sharer.php?u=http%3a%2f%2fjeha00.github.io%2fpost%2fos%2fos_chapter_10_%25EA%25B0%2580%25EC%2583%2581%25EB%25A9%2594%25EB%25AA%25A8%25EB%25A6%25AC%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share [TIL] OS Chapter 10: 가상 메모리 on whatsapp" href="https://api.whatsapp.com/send?text=%5bTIL%5d%20OS%20Chapter%2010%3a%20%ea%b0%80%ec%83%81%20%eb%a9%94%eb%aa%a8%eb%a6%ac%20-%20http%3a%2f%2fjeha00.github.io%2fpost%2fos%2fos_chapter_10_%25EA%25B0%2580%25EC%2583%2581%25EB%25A9%2594%25EB%25AA%25A8%25EB%25A6%25AC%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share [TIL] OS Chapter 10: 가상 메모리 on telegram" href="https://telegram.me/share/url?text=%5bTIL%5d%20OS%20Chapter%2010%3a%20%ea%b0%80%ec%83%81%20%eb%a9%94%eb%aa%a8%eb%a6%ac&url=http%3a%2f%2fjeha00.github.io%2fpost%2fos%2fos_chapter_10_%25EA%25B0%2580%25EC%2583%2581%25EB%25A9%2594%25EB%25AA%25A8%25EB%25A6%25AC%2f"><svg viewBox="2 2 28 28"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></div></footer></article></main><footer class=footer><span>&copy; 2023 <a href=http://jeha00.github.io/>Jeha DevLog</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerText="copy";function s(){t.innerText="copied!",setTimeout(()=>{t.innerText="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>