<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>[TIL] OS Chapter 03: 컴퓨터 시스템의 동작원리 1 | Jeha00 DevLog</title><meta name=keywords content="TIL,OS"><meta name=description content="I/O 연산이 무엇이고, controller와 local buffer가 무엇이고, 입출력 연산이 Interrupt를 중심으로 어떻게 진행되는지를 알아본다."><meta name=author content><link rel=canonical href=http://jeha00.github.io/post/os/os_chapter_03_%EC%BB%B4%ED%93%A8%ED%84%B0%EC%8B%9C%EC%8A%A4%ED%85%9C%EC%9D%98%EB%8F%99%EC%9E%91%EC%9B%90%EB%A6%AC_1/><meta name=google-site-verification content="XYZabc"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.min.1e44d58192cbf6d7a4eb649bc43dbc3d4cc432677e5d8adc69b08c34cbe461ac.css integrity="sha256-HkTVgZLL9tek62SbxD28PUzEMmd+XYrcabCMNMvkYaw=" rel="preload stylesheet" as=style><link rel=icon href=http://jeha00.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=http://jeha00.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=http://jeha00.github.io/favicon-32x32.png><link rel=apple-touch-icon href=http://jeha00.github.io/apple-touch-icon.png><link rel=mask-icon href=http://jeha00.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><meta name=generator content="Hugo 0.101.0"><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><script type=application/javascript>var doNotTrack=!1;doNotTrack||(function(e,t,n,s,o,i,a){e.GoogleAnalyticsObject=o,e[o]=e[o]||function(){(e[o].q=e[o].q||[]).push(arguments)},e[o].l=1*new Date,i=t.createElement(n),a=t.getElementsByTagName(n)[0],i.async=1,i.src=s,a.parentNode.insertBefore(i,a)}(window,document,"script","https://www.google-analytics.com/analytics.js","ga"),ga("create","UA-123-45","auto"),ga("send","pageview"))</script><meta property="og:title" content="[TIL] OS Chapter 03: 컴퓨터 시스템의 동작원리 1"><meta property="og:description" content="I/O 연산이 무엇이고, controller와 local buffer가 무엇이고, 입출력 연산이 Interrupt를 중심으로 어떻게 진행되는지를 알아본다."><meta property="og:type" content="article"><meta property="og:url" content="http://jeha00.github.io/post/os/os_chapter_03_%EC%BB%B4%ED%93%A8%ED%84%B0%EC%8B%9C%EC%8A%A4%ED%85%9C%EC%9D%98%EB%8F%99%EC%9E%91%EC%9B%90%EB%A6%AC_1/"><meta property="og:image" content="http://jeha00.github.io/47"><meta property="article:section" content="post"><meta property="article:published_time" content="2022-04-13T13:55:26+09:00"><meta property="article:modified_time" content="2022-04-13T13:55:26+09:00"><meta property="og:site_name" content="JeHa00 DevLog"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="http://jeha00.github.io/47"><meta name=twitter:title content="[TIL] OS Chapter 03: 컴퓨터 시스템의 동작원리 1"><meta name=twitter:description content="I/O 연산이 무엇이고, controller와 local buffer가 무엇이고, 입출력 연산이 Interrupt를 중심으로 어떻게 진행되는지를 알아본다."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"http://jeha00.github.io/post/"},{"@type":"ListItem","position":2,"name":"[TIL] OS Chapter 03: 컴퓨터 시스템의 동작원리 1","item":"http://jeha00.github.io/post/os/os_chapter_03_%EC%BB%B4%ED%93%A8%ED%84%B0%EC%8B%9C%EC%8A%A4%ED%85%9C%EC%9D%98%EB%8F%99%EC%9E%91%EC%9B%90%EB%A6%AC_1/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"[TIL] OS Chapter 03: 컴퓨터 시스템의 동작원리 1","name":"[TIL] OS Chapter 03: 컴퓨터 시스템의 동작원리 1","description":"I/O 연산이 무엇이고, controller와 local buffer가 무엇이고, 입출력 연산이 Interrupt를 중심으로 어떻게 진행되는지를 알아본다.","keywords":["TIL","OS"],"articleBody":"0. Introduction 해당 내용은 운영체제와 정보기술의 원리 -반효경 지음- 와 kocw 이화여자대학교 운영체제 - 반효경 교수 -를 보고 정리한 내용입니다. 정확하지 않은 내용이 있다면 말씀해주시면 감사하겠습니다. 1. 컴퓨터 시스템의 구조 1.1 컴퓨터의 구조: 내부장치와 외부장치 컴퓨터 시스템의 구조 = 컴퓨터 내부장치 + 컴퓨터 외부장치 컴퓨터 내부장치 : CPU, Memory 컴퓨터 외부장치 : Disk, keyboard, mouse, monitor, network device 등 1.2 컴퓨터의 업무 처리 방식 컴퓨터 외부장치에서 내부장치로 데이터를 읽어와 각종 연산을 수행한 후, 연산 결과를 외부장치로 다시 내보내는 방식으로 업무를 처리한다. 이때, 업무의 각 부분을 다음과 같이 정의한다. 입력(input): 컴퓨터 내부로 데이터가 들어오는 것 출력(output): 컴퓨터 외부장치로 데이터가 나가는 것 입출력(Input-output: I/O): 컴퓨터 시스템이 컴퓨터 외부 입출력 장치들과 데이터를 주고 받는 것 예시) 키보드로부터 입력을 받아 컴퓨터가 연산을 한 후, 그 결과를 모니터에 출력 컴퓨터 외부장치인 디스크에서 내용을 읽어 컴퓨터 내부에 연산을 한 후, 디스크에 데이터를 저장. 1.3 Controller: 각 하드웨어 장치의 작은 CPU 컴퓨터 전체에 CPU(Cetnral Processing Unit)라는 중앙처리장치가 있듯이, 컴퓨터의 각 하드웨어 장치에는 이들을 제어하는 일종의 작은 CPU인 컨트롤러 가 있다. 예) 메모리를 제어하는 컨트롤러는 메모리 컨트롤러 디스크를 제어하는 컨트롤러는 디스크 컨트롤러 2. CPU 연산과 I/O 연산 2.1 연산 = CPU가 무언가를 한다 컴퓨터에서 연산을 한다 = CPU가 무언가 일을 한다 컴퓨터의 구성장치 관점에서 연산을 나눠 보자면 다음과 같이 담당한다. 입출력 장치들의 I/O 연산 → 입출력 컨트롤러가 담당 컴퓨터 내에서 수행되는 연산 → main CPU 이 때 입출력 장치와 main CPU는 일이 다른 곳에서 발생하므로 동시 수행이 가능하다. 2.2 Local Buffer(로컬 버퍼) 각 장치 컨트롤러는 장치로부터 오고 나가는 데이터를 임시 저장 하기 위한 작은 메모리인 로컬 버퍼(local buffer) 가 존재한다. 입력 장치로부터 데이터를 읽어오는 경우, 각 입력장치의 컨트롤러가 장치에서 로컬버퍼로 데이터를 읽어와서 저장 후, 컴퓨터 내부의 메모리에 전달한다. 2.3 CPU와 I/O 장치의 연산과정 프로그램에서 데이터를 읽어오라는 명령을 내린다 → 각 장치의 컨트롤러가 장치로부터 내용을 읽어 로컬버퍼에 저장한다 → 데이터를 읽는 작업을 완료했기 때문에, 메인 CPU에서 I/O 작업을 요청한 프로그램의 다음 일을 수행할 수 있다. HW 또는 SW는 CPU 옆에 인터룹트 라인(interrup line) 을 세팅하는 명령을 실행하여, 컨트롤러가 인터룹트(interrupt) 를 발생시켜 메인 CPU에게 I/O작업이 완료됨을 알린다 → 인터럽트란 컨트롤러들이 CPU의 서비스가 필요할 때 이를 통보하는 방법 CPU는 명령 하나를 수행할 때마다 인터룹트가 발생했는지 확인하는데, 인터럽트가 발생하면 자신이 하던 일을 멈추고, 인터럽트 처리를 먼저 한 후 멈춘 명령을 다시 수행한다. 3. 인터럽트의 일반적 기능 3.1 Interrupt(인터럽트)란?? 인터럽트(Interrupt)란 CPU의 제어권을 양도하라는 신호\n사용자 프로그램에게 CPU 제어권이 있어서, CPU를 사용하고 있다가 interrupt를 발생시키면 kernel에게 CPU가 이양된다.\n오늘날 운영체제가 CPU를 점유하는 건 인터럽트에 의하지 않고는 발생하지 않는다.\n운영체제는 단지 인터럽트가 발생할 때에만 CPU의 제어권을 획득할 수 있는데, 인터럽트가 발생하지 않으면 사용자 프로그램이 계속 CPU를 점유한다. 3.2 인터럽트 처리루틴이란??? 인터럽트를 당한 시점의 레지스터와 program counter를 저장한 후, CPU 제어를 인터럽트 처리 루틴에 넘긴다. 인터럽트 처리루틴(Interrupt Service Routine) 이란? 해당 인터럽트를 처리하는 커널 함수 인터럽트 핸들러(interrupt handler) 라고도 한다. 다양한 controller가 있는 만큼 interrupt의 종류도 다양하다. 그러므로 인터럽트 처리루틴의 종류도 다양하다. 인터럽트 벡터(interrupt vector) 해당 인터럽트의 처리 루틴 주소를 가리킨다. 인터럽트 처리루틴까지의 과정 컨트롤러가 인터럽트를 발생시키면 CPU는 인터럽트 라인을 통해 인터럽트 발생을 확인하고, 자신이 하던 일을 멈춘다.\n-\u003e 프로그램의 실행 상태를 PCB에 저장한 후, CPU의 제어권은 프로세스에서 운영체제로 넘어간다.\n-\u003e 그리고, 운영체제는 interrupt vector가 가리키는 곳으로 가서 인터럽트 처리루틴을 찾는다.\n-\u003e 인터럽트 처리루틴을 통해 해당하는 인터럽트 처리를 완료하고 나면, CPU는 PCB로부터 CPU 상에 복원하여 인터럽트 당하기 직전의 위치부터 계속 수행. 3.3 Interrupt line 특정 프로그램이 CPU를 독점하는 걸 방지하기 위해서 timer 라는 HW를 사용하여, timer의 시간이 다 되면 interrupt line 을 통해 interrupt를 건다. 또한, controller가 I/O 작업을 완료하면 interrupt line을 통해 interrupt를 건다. 3.4 인터럽트의 종류: HW interrupt 와 SW interrupt Interrupt = HW interrupt + SW interrupt HW interrupt HW가 발생시킨 인터럽트 HW 일꾼들이 CPU와 정보 교신을 위해서 거는 것 하드웨어 장치가 CPU의 interrupt line을 세팅한다. 통상적으로 불리는 interrupt의 의미가 HW interrupt다. SW interrupt (= 트랩(trap)) 사용자 프로그램이 운영체제에게 대행해달라고 요청하는 것 소프트웨어가 CPU의 interrupt line을 세팅한다. Trap의 종류: 예외 상황(exception) 과 시스템 콜(system call) HW interrupt와 SW interrupt의 공통점 CPU 옆 인터럽트 라인에 신호를 보내 인터럽트 발생유무를 알리는 방식은 동일하다. 3.5 Trap: exception 과 system call 3.5.1 예외 상황(exception) 비정상적인 작업 또는, 권한이 없는 작업을 시도할 때, 이에 대한 처리를 위해 발생시키는 인터럽트\n비정상적인 작업의 예: 사용자 프로그램이 0으로 나누는 연산을 실행 권한이 없는 작업의 예: 사용자 프로그램이 자신의 메모리 영역 바깥에 접근하려는 시도 3.5.2 시스템 콜(system call) 사용자 프로그램이 운영체제 내부에 정의된 코드를 실행할 때, 운영체제에게 서비스를 요청하는 trap\n사용자 프로그램의 코드는 사용자 프로그램이 CPU에 대한 제어권을 가지고 실행한다. 하지만, 커널 내부에 있는 코드를 사용자 프로그램이 실행하고자 할 때는 사용자 프로그램이 직접 접근할 수 있는 게 아니라, system call을 통해서 대행 요청 을 한다. system call 요청을 interrupt line 을 통해 CPU 제어권을 운영체제로 넘겨 커널 내부 코드를 실행한다. 4. 인터럽트 핸들링(Interrupt handling) 4.1 Interrupt handling 이란?? 인터럽트가 발생한 경우에 처리해야할 일의 절차\n프로그램 A가 실행되고 있을 때, 인터럽트가 발생하면 프로그램 A의 현재 상태를 먼저 저장 한다.\n현재 상태란? 현재 CPU에서 실행 중인 명령의 메모리 주소를 포함해 몇 가지 부가적인 정보들을 의미한다. 현재 상태를 먼저 저장하는 이유는??\nCPU에서 명령이 실행될 때 CPU 내부에 있는 임시 기억장치인 레지스터(register)에 데이터를 읽거나 쓰면서 작업을 한다. 그런데, 인터럽트가 발생해 새로운 명령을 실행하면 기존의 레지스터 값들이 지워지므로 , CPU 내의 이러한 상태를 저장해둬야 한다. 4.2 PCB(Process Control Block)이란?? OS가 현재 시스템 내에서 실행되는 프로그램들을 관리하기 위해 둔 자료구조로 PCB(Process Control Block, 프로세스 제어 블록)라 한다.\nPCB 는 각각의 프로그램마다 하나씩 존재 한다. 해당 프로그램의 어느 부분이 실행 중이었는지를 저장 한다. ex) 코드의 메모리 주소, 레지스터값, 하드웨어 상태 등 PCB 사용절차 Interrupt 발생 → CPU의 제어권을 넘기기 전에 프로그램의 실행 상태를 PCB에 저장 → CPU의 제어권이 OS로 넘어간다 → 운영체제는 인터럽트 벡터가 가리키는 곳으로 가서 인터럽트 처리루틴에 따라 인터럽트 처리를 수행→ 인터럽트 처리 완료 → 저장된 상태를 PCB로부터 CPU 상에 복원 → 인터럽트 당하기 직전 위치부터 재실행 Reference 운영체제와 정보기술의 원리 kocw 이화여자대학교 운영체제 - 반효경 교수 - ","wordCount":"931","inLanguage":"en","datePublished":"2022-04-13T13:55:26+09:00","dateModified":"2022-04-13T13:55:26+09:00","mainEntityOfPage":{"@type":"WebPage","@id":"http://jeha00.github.io/post/os/os_chapter_03_%EC%BB%B4%ED%93%A8%ED%84%B0%EC%8B%9C%EC%8A%A4%ED%85%9C%EC%9D%98%EB%8F%99%EC%9E%91%EC%9B%90%EB%A6%AC_1/"},"publisher":{"@type":"Organization","name":"Jeha00 DevLog","logo":{"@type":"ImageObject","url":"http://jeha00.github.io/favicon.ico"}}}</script></head><body class=dark id=top><script>localStorage.getItem("pref-theme")==="light"&&document.body.classList.remove("dark")</script><header class=header><nav class=nav><div class=logo><a href=http://jeha00.github.io/ accesskey=h title="Jeha00 (Alt + H)">Jeha00</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></span></div><ul id=menu><li><a href=http://jeha00.github.io/me/ title=About><span>About</span></a></li><li><a href=http://jeha00.github.io/archives/ title=Archive><span>Archive</span></a></li><li><a href=http://jeha00.github.io/categories/ title=Categories><span>Categories</span></a></li><li><a href=http://jeha00.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=http://jeha00.github.io/>Home</a>&nbsp;»&nbsp;<a href=http://jeha00.github.io/post/>Posts</a></div><h1 class=post-title>[TIL] OS Chapter 03: 컴퓨터 시스템의 동작원리 1</h1><div class=post-meta><span title='2022-04-13 13:55:26 +0900 KST'>April 13, 2022</span>&nbsp;|&nbsp;<a href=https://github.com/JeHa00/blog/content/post/OS/OS_Chapter_03_%ec%bb%b4%ed%93%a8%ed%84%b0%ec%8b%9c%ec%8a%a4%ed%85%9c%ec%9d%98%eb%8f%99%ec%9e%91%ec%9b%90%eb%a6%ac_1.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#0-introduction aria-label="0. Introduction">0. Introduction</a></li><li><a href=#1-%ec%bb%b4%ed%93%a8%ed%84%b0-%ec%8b%9c%ec%8a%a4%ed%85%9c%ec%9d%98-%ea%b5%ac%ec%a1%b0 aria-label="1. 컴퓨터 시스템의 구조">1. 컴퓨터 시스템의 구조</a><ul><li><a href=#11-%ec%bb%b4%ed%93%a8%ed%84%b0%ec%9d%98-%ea%b5%ac%ec%a1%b0-%eb%82%b4%eb%b6%80%ec%9e%a5%ec%b9%98%ec%99%80-%ec%99%b8%eb%b6%80%ec%9e%a5%ec%b9%98 aria-label="1.1 컴퓨터의 구조: 내부장치와 외부장치">1.1 컴퓨터의 구조: 내부장치와 외부장치</a></li><li><a href=#12-%ec%bb%b4%ed%93%a8%ed%84%b0%ec%9d%98-%ec%97%85%eb%ac%b4-%ec%b2%98%eb%a6%ac-%eb%b0%a9%ec%8b%9d aria-label="1.2 컴퓨터의 업무 처리 방식">1.2 컴퓨터의 업무 처리 방식</a></li><li><a href=#13-controller-%ea%b0%81-%ed%95%98%eb%93%9c%ec%9b%a8%ec%96%b4-%ec%9e%a5%ec%b9%98%ec%9d%98-%ec%9e%91%ec%9d%80-cpu aria-label="1.3 Controller: 각 하드웨어 장치의 작은 CPU">1.3 Controller: 각 하드웨어 장치의 작은 CPU</a></li></ul></li><li><a href=#2-cpu-%ec%97%b0%ec%82%b0%ea%b3%bc-io-%ec%97%b0%ec%82%b0 aria-label="2. CPU 연산과 I/O 연산">2. CPU 연산과 I/O 연산</a><ul><li><a href=#21-%ec%97%b0%ec%82%b0--cpu%ea%b0%80-%eb%ac%b4%ec%96%b8%ea%b0%80%eb%a5%bc-%ed%95%9c%eb%8b%a4 aria-label="2.1 연산 = CPU가 무언가를 한다">2.1 연산 = CPU가 무언가를 한다</a></li><li><a href=#22-local-buffer%eb%a1%9c%ec%bb%ac-%eb%b2%84%ed%8d%bc aria-label="2.2 Local Buffer(로컬 버퍼)">2.2 Local Buffer(로컬 버퍼)</a></li><li><a href=#23-cpu%ec%99%80-io-%ec%9e%a5%ec%b9%98%ec%9d%98-%ec%97%b0%ec%82%b0%ea%b3%bc%ec%a0%95 aria-label="2.3 CPU와 I/O 장치의 연산과정">2.3 CPU와 I/O 장치의 연산과정</a></li></ul></li><li><a href=#3-%ec%9d%b8%ed%84%b0%eb%9f%bd%ed%8a%b8%ec%9d%98-%ec%9d%bc%eb%b0%98%ec%a0%81-%ea%b8%b0%eb%8a%a5 aria-label="3. 인터럽트의 일반적 기능">3. 인터럽트의 일반적 기능</a><ul><li><a href=#31-interrupt%ec%9d%b8%ed%84%b0%eb%9f%bd%ed%8a%b8%eb%9e%80 aria-label="3.1 Interrupt(인터럽트)란??">3.1 Interrupt(인터럽트)란??</a></li><li><a href=#32-%ec%9d%b8%ed%84%b0%eb%9f%bd%ed%8a%b8-%ec%b2%98%eb%a6%ac%eb%a3%a8%ed%8b%b4%ec%9d%b4%eb%9e%80 aria-label="3.2 인터럽트 처리루틴이란???">3.2 인터럽트 처리루틴이란???</a></li><li><a href=#33-interrupt-line aria-label="3.3 Interrupt line">3.3 Interrupt line</a></li><li><a href=#34-%ec%9d%b8%ed%84%b0%eb%9f%bd%ed%8a%b8%ec%9d%98-%ec%a2%85%eb%a5%98-hw-interrupt-%ec%99%80-sw-interrupt aria-label="3.4 인터럽트의 종류: HW interrupt 와 SW interrupt">3.4 인터럽트의 종류: HW interrupt 와 SW interrupt</a></li><li><a href=#35-trap-exception-%ea%b3%bc-system-call aria-label="3.5 Trap: exception 과 system call">3.5 Trap: exception 과 system call</a><ul><li><a href=#351-%ec%98%88%ec%99%b8-%ec%83%81%ed%99%a9exception aria-label="3.5.1 예외 상황(exception)">3.5.1 예외 상황(exception)</a></li><li><a href=#352-%ec%8b%9c%ec%8a%a4%ed%85%9c-%ec%bd%9csystem-call aria-label="3.5.2 시스템 콜(system call)">3.5.2 시스템 콜(system call)</a></li></ul></li></ul></li><li><a href=#4-%ec%9d%b8%ed%84%b0%eb%9f%bd%ed%8a%b8-%ed%95%b8%eb%93%a4%eb%a7%81interrupt-handling aria-label="4. 인터럽트 핸들링(Interrupt handling)">4. 인터럽트 핸들링(Interrupt handling)</a><ul><li><a href=#41-interrupt-handling-%ec%9d%b4%eb%9e%80 aria-label="4.1 Interrupt handling 이란??">4.1 Interrupt handling 이란??</a></li><li><a href=#42-pcbprocess-control-block%ec%9d%b4%eb%9e%80 aria-label="4.2 PCB(Process Control Block)이란??">4.2 PCB(Process Control Block)이란??</a></li></ul></li><li><a href=#reference aria-label=Reference>Reference</a></li></ul></div></details></div><div class=post-content><h1 id=0-introduction>0. Introduction<a hidden class=anchor aria-hidden=true href=#0-introduction>#</a></h1><ul><li>해당 내용은 <a href="http://www.kyobobook.co.kr/product/detailViewKor.laf?ejkGb=KOR&mallGb=KOR&barcode=9791158903589&orderClick=LAG&Kc=">운영체제와 정보기술의 원리 -반효경 지음-</a> 와 <a href="http://www.kocw.net/home/cview.do?lid=3dd1117c48123b8e">kocw 이화여자대학교 운영체제 - 반효경 교수 -</a>를 보고 정리한 내용입니다.</li><li>정확하지 않은 내용이 있다면 말씀해주시면 감사하겠습니다.</li></ul><hr><h1 id=1-컴퓨터-시스템의-구조>1. 컴퓨터 시스템의 구조<a hidden class=anchor aria-hidden=true href=#1-컴퓨터-시스템의-구조>#</a></h1><h2 id=11-컴퓨터의-구조-내부장치와-외부장치>1.1 컴퓨터의 구조: 내부장치와 외부장치<a hidden class=anchor aria-hidden=true href=#11-컴퓨터의-구조-내부장치와-외부장치>#</a></h2><ul><li>컴퓨터 시스템의 구조 = <strong><em>컴퓨터 내부장치</em></strong> + <strong><em>컴퓨터 외부장치</em></strong><ul><li><strong><em>컴퓨터 내부장치</em></strong> : CPU, Memory</li><li><strong><em>컴퓨터 외부장치</em></strong> : Disk, keyboard, mouse, monitor, network device 등</li></ul></li></ul><h2 id=12-컴퓨터의-업무-처리-방식>1.2 컴퓨터의 업무 처리 방식<a hidden class=anchor aria-hidden=true href=#12-컴퓨터의-업무-처리-방식>#</a></h2><ul><li>컴퓨터 외부장치에서 내부장치로 데이터를 읽어와 각종 연산을 수행한 후, 연산 결과를 외부장치로 다시 내보내는 방식으로 업무를 처리한다.</li><li>이때, 업무의 각 부분을 다음과 같이 정의한다.<ul><li><strong><em>입력(input):</em></strong> 컴퓨터 내부로 데이터가 들어오는 것</li><li><strong><em>출력(output):</em></strong> 컴퓨터 외부장치로 데이터가 나가는 것<ul><li><strong><em>입출력(Input-output: I/O): 컴퓨터 시스템이 컴퓨터 외부 입출력 장치들과 데이터를 주고 받는 것</em></strong></li></ul></li><li>예시)<ul><li>키보드로부터 입력을 받아 컴퓨터가 연산을 한 후, 그 결과를 모니터에 출력</li><li>컴퓨터 외부장치인 디스크에서 내용을 읽어 컴퓨터 내부에 연산을 한 후, 디스크에 데이터를 저장.</li></ul></li></ul></li></ul><h2 id=13-controller-각-하드웨어-장치의-작은-cpu>1.3 Controller: 각 하드웨어 장치의 작은 CPU<a hidden class=anchor aria-hidden=true href=#13-controller-각-하드웨어-장치의-작은-cpu>#</a></h2><ul><li>컴퓨터 전체에 CPU(Cetnral Processing Unit)라는 중앙처리장치가 있듯이, 컴퓨터의 각 하드웨어 장치에는 이들을 제어하는 일종의 작은 CPU인 <strong><em>컨트롤러</em></strong> 가 있다.</li><li>예)<ul><li>메모리를 제어하는 컨트롤러는 메모리 컨트롤러</li><li>디스크를 제어하는 컨트롤러는 디스크 컨트롤러</li></ul></li></ul><hr><h1 id=2-cpu-연산과-io-연산>2. CPU 연산과 I/O 연산<a hidden class=anchor aria-hidden=true href=#2-cpu-연산과-io-연산>#</a></h1><h2 id=21-연산--cpu가-무언가를-한다>2.1 연산 = CPU가 무언가를 한다<a hidden class=anchor aria-hidden=true href=#21-연산--cpu가-무언가를-한다>#</a></h2><ul><li>컴퓨터에서 <strong>연산</strong>을 한다 = <strong><em>CPU가 무언가 일을 한다</em></strong></li><li>컴퓨터의 구성장치 관점에서 연산을 나눠 보자면 다음과 같이 담당한다.<ul><li>입출력 장치들의 I/O 연산 → 입출력 컨트롤러가 담당</li><li>컴퓨터 내에서 수행되는 연산 → main CPU</li><li>이 때 입출력 장치와 main CPU는 일이 다른 곳에서 발생하므로 동시 수행이 가능하다.</li></ul></li></ul><h2 id=22-local-buffer로컬-버퍼>2.2 Local Buffer(로컬 버퍼)<a hidden class=anchor aria-hidden=true href=#22-local-buffer로컬-버퍼>#</a></h2><ul><li>각 장치 컨트롤러는 장치로부터 오고 나가는 데이터를 <strong>임시 저장</strong> 하기 위한 작은 메모리인 <strong><em>로컬 버퍼(local buffer)</em></strong> 가 존재한다.</li><li>입력 장치로부터 데이터를 읽어오는 경우, 각 입력장치의 컨트롤러가 장치에서 로컬버퍼로 데이터를 읽어와서 저장 후, 컴퓨터 내부의 메모리에 전달한다.</li></ul><h2 id=23-cpu와-io-장치의-연산과정>2.3 CPU와 I/O 장치의 연산과정<a hidden class=anchor aria-hidden=true href=#23-cpu와-io-장치의-연산과정>#</a></h2><ol><li>프로그램에서 데이터를 읽어오라는 명령을 내린다 →</li><li>각 장치의 컨트롤러가 장치로부터 내용을 읽어 로컬버퍼에 저장한다 →</li><li>데이터를 읽는 작업을 완료했기 때문에, 메인 CPU에서 I/O 작업을 요청한 프로그램의 다음 일을 수행할 수 있다. HW 또는 SW는 CPU 옆에 <strong><em>인터룹트 라인(interrup line)</em></strong> 을 세팅하는 명령을 실행하여, 컨트롤러가 <strong><em>인터룹트(interrupt)</em></strong> 를 발생시켜 메인 CPU에게 I/O작업이 완료됨을 알린다 →</li></ol><ul><li>인터럽트란 컨트롤러들이 CPU의 서비스가 필요할 때 이를 통보하는 방법</li></ul><ol start=4><li>CPU는 <strong><em>명령 하나를 수행할 때마다</em></strong> 인터룹트가 발생했는지 확인하는데, 인터럽트가 발생하면 자신이 하던 일을 멈추고, <strong><em>인터럽트 처리를 먼저 한 후</em></strong> 멈춘 명령을 다시 수행한다.</li></ol><hr><h1 id=3-인터럽트의-일반적-기능>3. 인터럽트의 일반적 기능<a hidden class=anchor aria-hidden=true href=#3-인터럽트의-일반적-기능>#</a></h1><h2 id=31-interrupt인터럽트란>3.1 Interrupt(인터럽트)란??<a hidden class=anchor aria-hidden=true href=#31-interrupt인터럽트란>#</a></h2><ul><li><p>인터럽트(Interrupt)란 <strong>CPU의 제어권을 양도하라는 신호</strong></p></li><li><p>사용자 프로그램에게 CPU 제어권이 있어서, CPU를 사용하고 있다가 interrupt를 발생시키면 kernel에게 CPU가 이양된다.</p></li><li><p>오늘날 <strong><em>운영체제가 CPU를 점유하는 건 인터럽트에 의하지 않고는 발생하지 않는다.</em></strong></p><ul><li>운영체제는 단지 인터럽트가 발생할 때에만 CPU의 제어권을 획득할 수 있는데,</li><li>인터럽트가 발생하지 않으면 사용자 프로그램이 계속 CPU를 점유한다.</li></ul></li></ul><h2 id=32-인터럽트-처리루틴이란>3.2 인터럽트 처리루틴이란???<a hidden class=anchor aria-hidden=true href=#32-인터럽트-처리루틴이란>#</a></h2><ul><li>인터럽트를 당한 시점의 레지스터와 program counter를 저장한 후, CPU 제어를 인터럽트 처리 루틴에 넘긴다.</li><li><strong><em>인터럽트 처리루틴(Interrupt Service Routine)</em></strong> 이란?<ul><li><strong><em>해당 인터럽트를 처리하는 커널 함수</em></strong></li><li>인터럽트 핸들러(interrupt handler) 라고도 한다.</li><li>다양한 controller가 있는 만큼 interrupt의 종류도 다양하다.</li><li>그러므로 인터럽트 처리루틴의 종류도 다양하다.</li></ul></li><li><strong><em>인터럽트 벡터(interrupt vector)</em></strong><ul><li><strong><em>해당 인터럽트의 처리 루틴 주소를 가리킨다.</em></strong></li></ul></li><li>인터럽트 처리루틴까지의 과정<ul><li>컨트롤러가 인터럽트를 발생시키면 CPU는 인터럽트 라인을 통해 인터럽트 발생을 확인하고, 자신이 하던 일을 멈춘다.<br>-> 프로그램의 실행 상태를 PCB에 저장한 후, CPU의 제어권은 프로세스에서 운영체제로 넘어간다.<br>-> 그리고, 운영체제는 interrupt vector가 가리키는 곳으로 가서 인터럽트 처리루틴을 찾는다.<br>-> 인터럽트 처리루틴을 통해 해당하는 인터럽트 처리를 완료하고 나면, CPU는 PCB로부터 CPU 상에 복원하여 인터럽트 당하기 직전의 위치부터 계속 수행.</li></ul></li></ul><h2 id=33-interrupt-line>3.3 Interrupt line<a hidden class=anchor aria-hidden=true href=#33-interrupt-line>#</a></h2><ul><li>특정 프로그램이 CPU를 독점하는 걸 방지하기 위해서 <strong><em>timer</em></strong> 라는 HW를 사용하여, timer의 시간이 다 되면 <strong><em>interrupt line</em></strong> 을 통해 interrupt를 건다.</li><li>또한, controller가 I/O 작업을 완료하면 interrupt line을 통해 interrupt를 건다.</li></ul><h2 id=34-인터럽트의-종류-hw-interrupt-와-sw-interrupt>3.4 인터럽트의 종류: HW interrupt 와 SW interrupt<a hidden class=anchor aria-hidden=true href=#34-인터럽트의-종류-hw-interrupt-와-sw-interrupt>#</a></h2><ul><li>Interrupt = HW interrupt + SW interrupt</li><li>HW interrupt<ul><li>HW가 발생시킨 인터럽트</li><li>HW 일꾼들이 CPU와 정보 교신을 위해서 거는 것</li><li><strong>하드웨어 장치</strong>가 CPU의 interrupt line을 세팅한다.</li><li>통상적으로 불리는 interrupt의 의미가 HW interrupt다.</li></ul></li><li>SW interrupt (= <strong><em>트랩(trap)</em></strong>)<ul><li>사용자 프로그램이 운영체제에게 대행해달라고 요청하는 것</li><li><strong>소프트웨어</strong>가 CPU의 interrupt line을 세팅한다.</li><li>Trap의 종류: <strong><em>예외 상황(exception)</em></strong> 과 <strong><em>시스템 콜(system call)</em></strong></li></ul></li><li>HW interrupt와 SW interrupt의 공통점<ul><li>CPU 옆 인터럽트 라인에 신호를 보내 인터럽트 발생유무를 알리는 방식은 동일하다.</li></ul></li></ul><h2 id=35-trap-exception-과-system-call>3.5 Trap: exception 과 system call<a hidden class=anchor aria-hidden=true href=#35-trap-exception-과-system-call>#</a></h2><h3 id=351-예외-상황exception>3.5.1 예외 상황(exception)<a hidden class=anchor aria-hidden=true href=#351-예외-상황exception>#</a></h3><blockquote><p><strong><em>비정상적인 작업 또는, 권한이 없는 작업을 시도할 때, 이에 대한 처리를 위해 발생시키는 인터럽트</em></strong></p></blockquote><ul><li>비정상적인 작업의 예: 사용자 프로그램이 0으로 나누는 연산을 실행</li><li>권한이 없는 작업의 예: 사용자 프로그램이 자신의 메모리 영역 바깥에 접근하려는 시도</li></ul><h3 id=352-시스템-콜system-call>3.5.2 시스템 콜(system call)<a hidden class=anchor aria-hidden=true href=#352-시스템-콜system-call>#</a></h3><blockquote><p><strong><em>사용자 프로그램이 운영체제 내부에 정의된 코드를 실행할 때, 운영체제에게 서비스를 요청하는 trap</em></strong></p></blockquote><ul><li>사용자 프로그램의 코드는 사용자 프로그램이 CPU에 대한 제어권을 가지고 실행한다.</li><li>하지만, 커널 내부에 있는 코드를 사용자 프로그램이 실행하고자 할 때는 사용자 프로그램이 직접 접근할 수 있는 게 아니라, system call을 통해서 <strong><em>대행 요청</em></strong> 을 한다.</li><li>system call 요청을 interrupt line 을 통해 CPU 제어권을 운영체제로 넘겨 커널 내부 코드를 실행한다.</li></ul><hr><h1 id=4-인터럽트-핸들링interrupt-handling>4. 인터럽트 핸들링(Interrupt handling)<a hidden class=anchor aria-hidden=true href=#4-인터럽트-핸들링interrupt-handling>#</a></h1><h2 id=41-interrupt-handling-이란>4.1 Interrupt handling 이란??<a hidden class=anchor aria-hidden=true href=#41-interrupt-handling-이란>#</a></h2><blockquote><p><strong><em>인터럽트가 발생한 경우에 처리해야할 일의 절차</em></strong></p></blockquote><ul><li><p>프로그램 A가 실행되고 있을 때, 인터럽트가 발생하면 <strong><em>프로그램 A의 현재 상태를 먼저 저장</em></strong> 한다.</p><ul><li>현재 상태란? 현재 CPU에서 실행 중인 명령의 메모리 주소를 포함해 몇 가지 부가적인 정보들을 의미한다.</li></ul></li><li><p>현재 상태를 먼저 저장하는 이유는??</p><ul><li>CPU에서 명령이 실행될 때 CPU 내부에 있는 임시 기억장치인 레지스터(register)에 데이터를 읽거나 쓰면서 작업을 한다.</li><li>그런데, <strong><em>인터럽트가 발생해 새로운 명령을 실행하면 기존의 레지스터 값들이 지워지므로</em></strong> , CPU 내의 이러한 상태를 저장해둬야 한다.</li></ul></li></ul><h2 id=42-pcbprocess-control-block이란>4.2 PCB(Process Control Block)이란??<a hidden class=anchor aria-hidden=true href=#42-pcbprocess-control-block이란>#</a></h2><blockquote><p><strong><em>OS가 현재 시스템 내에서 실행되는 프로그램들을 관리하기 위해 둔 자료구조로 PCB(Process Control Block, 프로세스 제어 블록)라 한다.</em></strong></p></blockquote><ul><li><strong><em>PCB</em></strong> 는<ul><li>각각의 <strong><em>프로그램마다 하나씩 존재</em></strong> 한다.</li><li><strong><em>해당 프로그램의 어느 부분이 실행 중이었는지를 저장</em></strong> 한다.<ul><li>ex) 코드의 메모리 주소, 레지스터값, 하드웨어 상태 등</li></ul></li></ul></li><li><strong><em>PCB 사용절차</em></strong><ul><li>Interrupt 발생 → <strong><em>CPU의 제어권을 넘기기 전에 프로그램의 실행 상태를 PCB에 저장</em></strong> → CPU의 제어권이 OS로 넘어간다 → 운영체제는 인터럽트 벡터가 가리키는 곳으로 가서 인터럽트 처리루틴에 따라 인터럽트 처리를 수행→ 인터럽트 처리 완료 → 저장된 상태를 PCB로부터 CPU 상에 복원 → 인터럽트 당하기 직전 위치부터 재실행</li></ul></li></ul><hr><h1 id=reference>Reference<a hidden class=anchor aria-hidden=true href=#reference>#</a></h1><ul><li><a href="http://www.kyobobook.co.kr/product/detailViewKor.laf?ejkGb=KOR&mallGb=KOR&barcode=9791158903589&orderClick=LAG&Kc=">운영체제와 정보기술의 원리</a></li><li><a href="http://www.kocw.net/home/cview.do?lid=3dd1117c48123b8e">kocw 이화여자대학교 운영체제 - 반효경 교수 -</a></li></ul></div><footer class=post-footer><ul class=post-tags><li><a href=http://jeha00.github.io/tags/til/>TIL</a></li><li><a href=http://jeha00.github.io/tags/os/>OS</a></li></ul><nav class=paginav><a class=prev href=http://jeha00.github.io/post/os/os_chapter_03_%EC%BB%B4%ED%93%A8%ED%84%B0%EC%8B%9C%EC%8A%A4%ED%85%9C%EC%9D%98%EB%8F%99%EC%9E%91%EC%9B%90%EB%A6%AC_2/><span class=title>« Prev Page</span><br><span>[TIL] OS Chapter 03: 컴퓨터 시스템의 동작원리 2</span></a>
<a class=next href=http://jeha00.github.io/post/python/python_basic_42_contextmanager/><span class=title>Next Page »</span><br><span>[TIL] Python basic 42: Context manager</span></a></nav><div class=share-buttons><a target=_blank rel="noopener noreferrer" aria-label="share [TIL] OS Chapter 03: 컴퓨터 시스템의 동작원리 1 on twitter" href="https://twitter.com/intent/tweet/?text=%5bTIL%5d%20OS%20Chapter%2003%3a%20%ec%bb%b4%ed%93%a8%ed%84%b0%20%ec%8b%9c%ec%8a%a4%ed%85%9c%ec%9d%98%20%eb%8f%99%ec%9e%91%ec%9b%90%eb%a6%ac%201&url=http%3a%2f%2fjeha00.github.io%2fpost%2fos%2fos_chapter_03_%25EC%25BB%25B4%25ED%2593%25A8%25ED%2584%25B0%25EC%258B%259C%25EC%258A%25A4%25ED%2585%259C%25EC%259D%2598%25EB%258F%2599%25EC%259E%2591%25EC%259B%2590%25EB%25A6%25AC_1%2f&hashtags=TIL%2cOS"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM195.519 424.544c135.939.0 210.268-112.643 210.268-210.268.0-3.218.0-6.437-.153-9.502 14.406-10.421 26.973-23.448 36.935-38.314-13.18 5.824-27.433 9.809-42.452 11.648 15.326-9.196 26.973-23.602 32.49-40.92-14.252 8.429-30.038 14.56-46.896 17.931-13.487-14.406-32.644-23.295-53.946-23.295-40.767.0-73.87 33.104-73.87 73.87.0 5.824.613 11.494 1.992 16.858-61.456-3.065-115.862-32.49-152.337-77.241-6.284 10.881-9.962 23.601-9.962 37.088.0 25.594 13.027 48.276 32.95 61.456-12.107-.307-23.448-3.678-33.41-9.196v.92c0 35.862 25.441 65.594 59.311 72.49-6.13 1.686-12.72 2.606-19.464 2.606-4.751.0-9.348-.46-13.946-1.38 9.349 29.426 36.628 50.728 68.965 51.341-25.287 19.771-57.164 31.571-91.8 31.571-5.977.0-11.801-.306-17.625-1.073 32.337 21.15 71.264 33.41 112.95 33.41z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share [TIL] OS Chapter 03: 컴퓨터 시스템의 동작원리 1 on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&url=http%3a%2f%2fjeha00.github.io%2fpost%2fos%2fos_chapter_03_%25EC%25BB%25B4%25ED%2593%25A8%25ED%2584%25B0%25EC%258B%259C%25EC%258A%25A4%25ED%2585%259C%25EC%259D%2598%25EB%258F%2599%25EC%259E%2591%25EC%259B%2590%25EB%25A6%25AC_1%2f&title=%5bTIL%5d%20OS%20Chapter%2003%3a%20%ec%bb%b4%ed%93%a8%ed%84%b0%20%ec%8b%9c%ec%8a%a4%ed%85%9c%ec%9d%98%20%eb%8f%99%ec%9e%91%ec%9b%90%eb%a6%ac%201&summary=%5bTIL%5d%20OS%20Chapter%2003%3a%20%ec%bb%b4%ed%93%a8%ed%84%b0%20%ec%8b%9c%ec%8a%a4%ed%85%9c%ec%9d%98%20%eb%8f%99%ec%9e%91%ec%9b%90%eb%a6%ac%201&source=http%3a%2f%2fjeha00.github.io%2fpost%2fos%2fos_chapter_03_%25EC%25BB%25B4%25ED%2593%25A8%25ED%2584%25B0%25EC%258B%259C%25EC%258A%25A4%25ED%2585%259C%25EC%259D%2598%25EB%258F%2599%25EC%259E%2591%25EC%259B%2590%25EB%25A6%25AC_1%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share [TIL] OS Chapter 03: 컴퓨터 시스템의 동작원리 1 on reddit" href="https://reddit.com/submit?url=http%3a%2f%2fjeha00.github.io%2fpost%2fos%2fos_chapter_03_%25EC%25BB%25B4%25ED%2593%25A8%25ED%2584%25B0%25EC%258B%259C%25EC%258A%25A4%25ED%2585%259C%25EC%259D%2598%25EB%258F%2599%25EC%259E%2591%25EC%259B%2590%25EB%25A6%25AC_1%2f&title=%5bTIL%5d%20OS%20Chapter%2003%3a%20%ec%bb%b4%ed%93%a8%ed%84%b0%20%ec%8b%9c%ec%8a%a4%ed%85%9c%ec%9d%98%20%eb%8f%99%ec%9e%91%ec%9b%90%eb%a6%ac%201"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share [TIL] OS Chapter 03: 컴퓨터 시스템의 동작원리 1 on facebook" href="https://facebook.com/sharer/sharer.php?u=http%3a%2f%2fjeha00.github.io%2fpost%2fos%2fos_chapter_03_%25EC%25BB%25B4%25ED%2593%25A8%25ED%2584%25B0%25EC%258B%259C%25EC%258A%25A4%25ED%2585%259C%25EC%259D%2598%25EB%258F%2599%25EC%259E%2591%25EC%259B%2590%25EB%25A6%25AC_1%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share [TIL] OS Chapter 03: 컴퓨터 시스템의 동작원리 1 on whatsapp" href="https://api.whatsapp.com/send?text=%5bTIL%5d%20OS%20Chapter%2003%3a%20%ec%bb%b4%ed%93%a8%ed%84%b0%20%ec%8b%9c%ec%8a%a4%ed%85%9c%ec%9d%98%20%eb%8f%99%ec%9e%91%ec%9b%90%eb%a6%ac%201%20-%20http%3a%2f%2fjeha00.github.io%2fpost%2fos%2fos_chapter_03_%25EC%25BB%25B4%25ED%2593%25A8%25ED%2584%25B0%25EC%258B%259C%25EC%258A%25A4%25ED%2585%259C%25EC%259D%2598%25EB%258F%2599%25EC%259E%2591%25EC%259B%2590%25EB%25A6%25AC_1%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share [TIL] OS Chapter 03: 컴퓨터 시스템의 동작원리 1 on telegram" href="https://telegram.me/share/url?text=%5bTIL%5d%20OS%20Chapter%2003%3a%20%ec%bb%b4%ed%93%a8%ed%84%b0%20%ec%8b%9c%ec%8a%a4%ed%85%9c%ec%9d%98%20%eb%8f%99%ec%9e%91%ec%9b%90%eb%a6%ac%201&url=http%3a%2f%2fjeha00.github.io%2fpost%2fos%2fos_chapter_03_%25EC%25BB%25B4%25ED%2593%25A8%25ED%2584%25B0%25EC%258B%259C%25EC%258A%25A4%25ED%2585%259C%25EC%259D%2598%25EB%258F%2599%25EC%259E%2591%25EC%259B%2590%25EB%25A6%25AC_1%2f"><svg viewBox="2 2 28 28"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></div></footer></article></main><footer class=footer><span>&copy; 2022 <a href=http://jeha00.github.io/>Jeha00 DevLog</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerText="copy";function s(){t.innerText="copied!",setTimeout(()=>{t.innerText="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>