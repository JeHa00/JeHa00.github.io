<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>[TIL] OS Chapter 04: 프로그램의 구조와 실행 | Jeha00 DevLog</title><meta name=keywords content="TIL,OS"><meta name=description content="프로그램의 구조와 실행에 대해 설명한다. 예를 들어 프로그램의 주소영역, PCB, Program counter, 일반 명령과 특권 명령, Virtual memory, kernel mode와 user mode 등등을 알아본다."><meta name=author content><link rel=canonical href=http://jeha00.github.io/post/os/os_chapter_04_%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%A8%EC%9D%98%EA%B5%AC%EC%A1%B0%EC%99%80%EC%8B%A4%ED%96%89/><meta name=google-site-verification content="XYZabc"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.min.1e44d58192cbf6d7a4eb649bc43dbc3d4cc432677e5d8adc69b08c34cbe461ac.css integrity="sha256-HkTVgZLL9tek62SbxD28PUzEMmd+XYrcabCMNMvkYaw=" rel="preload stylesheet" as=style><link rel=icon href=http://jeha00.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=http://jeha00.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=http://jeha00.github.io/favicon-32x32.png><link rel=apple-touch-icon href=http://jeha00.github.io/apple-touch-icon.png><link rel=mask-icon href=http://jeha00.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><meta name=generator content="Hugo 0.101.0"><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><script type=application/javascript>var doNotTrack=!1;doNotTrack||(function(e,t,n,s,o,i,a){e.GoogleAnalyticsObject=o,e[o]=e[o]||function(){(e[o].q=e[o].q||[]).push(arguments)},e[o].l=1*new Date,i=t.createElement(n),a=t.getElementsByTagName(n)[0],i.async=1,i.src=s,a.parentNode.insertBefore(i,a)}(window,document,"script","https://www.google-analytics.com/analytics.js","ga"),ga("create","UA-123-45","auto"),ga("send","pageview"))</script><meta property="og:title" content="[TIL] OS Chapter 04: 프로그램의 구조와 실행"><meta property="og:description" content="프로그램의 구조와 실행에 대해 설명한다. 예를 들어 프로그램의 주소영역, PCB, Program counter, 일반 명령과 특권 명령, Virtual memory, kernel mode와 user mode 등등을 알아본다."><meta property="og:type" content="article"><meta property="og:url" content="http://jeha00.github.io/post/os/os_chapter_04_%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%A8%EC%9D%98%EA%B5%AC%EC%A1%B0%EC%99%80%EC%8B%A4%ED%96%89/"><meta property="og:image" content="http://jeha00.github.io/47"><meta property="article:section" content="post"><meta property="article:published_time" content="2022-04-15T00:27:39+09:00"><meta property="article:modified_time" content="2022-04-15T00:27:39+09:00"><meta property="og:site_name" content="JeHa00 DevLog"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="http://jeha00.github.io/47"><meta name=twitter:title content="[TIL] OS Chapter 04: 프로그램의 구조와 실행"><meta name=twitter:description content="프로그램의 구조와 실행에 대해 설명한다. 예를 들어 프로그램의 주소영역, PCB, Program counter, 일반 명령과 특권 명령, Virtual memory, kernel mode와 user mode 등등을 알아본다."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"http://jeha00.github.io/post/"},{"@type":"ListItem","position":2,"name":"[TIL] OS Chapter 04: 프로그램의 구조와 실행","item":"http://jeha00.github.io/post/os/os_chapter_04_%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%A8%EC%9D%98%EA%B5%AC%EC%A1%B0%EC%99%80%EC%8B%A4%ED%96%89/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"[TIL] OS Chapter 04: 프로그램의 구조와 실행","name":"[TIL] OS Chapter 04: 프로그램의 구조와 실행","description":"프로그램의 구조와 실행에 대해 설명한다. 예를 들어 프로그램의 주소영역, PCB, Program counter, 일반 명령과 특권 명령, Virtual memory, kernel mode와 user mode 등등을 알아본다.","keywords":["TIL","OS"],"articleBody":"0. Introduction 해당 내용은 운영체제와 정보기술의 원리 -반효경 지음- 와 kocw 이화여자대학교 운영체제 - 반효경 교수 -를 보고 정리한 내용입니다. 정확하지 않은 내용이 있다면 말씀해주시면 감사하겠습니다. 1. 프로그램의 구조와 인터럽트 프로그램이 CPU에서 명령을 수행하기 위해서는 명령을 담은 프로그램의 주소 영역이 메모리에 올라가 있어야 한다. 왜냐하면 CPU는 메모리에 있는 instruction만을 보고 실행하기 때문이다. 1.1 프로그램의 주소 영역 프로그램의 주소영역 = Code + Data + Stack 영역 Code 영역 작성한 함수의 코드가 CPU에서 수행하는 기계어 형태로 변환되어 저장 되는 공간 Data 영역 전역 변수(global variable) 등 프로그램이 사용하는 데이터를 저장 하는 공간 Stack 영역 프로그램 내의 함수 호출 시의 복귀 주소 및 데이터를 저장 하는 공간 예) 프로그램 내의 X 함수 수행 → 프로그램 내의 Y 함수 호출 → 이 때 X 함수에서 Y 함수를 호출하는 지점을 stack 영역에 저장 → Y 함수가 호출되어 실행할 명령의 메모리 위치가 바뀜 → Y 함수 수행 완료 → stack에 저장된 X 함수의 주소 위치로 돌아와 코드를 계속 수행 1.2 PCB: 프로그램 수행의 복귀 위치 인터럽트가 발생할 경우 복귀 위치: PCB(Process Control block)에 저장한다. interrupt가 발생한 시점에서 프로그램의 어느 부분까지 수행했는지를 PCB에 저장 과정 A 프로그램이 CPU를 할당받아 명령을 수행 → interrupt 발생 → 현재 수행 중인 명령 위치를 PCB에 저장 → CPU 제어권을 OS에게 양도 → 인터럽트 처리 완료 후, PCB에 저장된 작업 지점으로 돌아와 계속 수행 2. 컴퓨터 시스템의 작동 개요 컴퓨터 시스템의 작동 CPU에서 명령을 수행하는 부분 + 컴퓨터 외부장치와 입출력이 이루어지는 부분 2.1 프로그램 카운터(Program Counter(PC)) PC = Program Counter = CPU가 수행해야할 메모리 주소를 담고 있는 레지스터 CPU는 빠른 속도의 연산 능력은 가지고 있지만, 결정 능력을 가지고 있지 않다. 단지 매번 프로그램 카운터가 가리키는 메모리 위치의 명령을 처리한다. 통상 프로그램 카운터가 다음 명령어를 가리키어 CPU 명령은 순차적으로 수행된다. 반복문이나 함수 호출 등으로 바로 다음 주소가 아닌 명령을 수행할 수도 있다. Program Counter 가 OS가 존재하는 메모리 위치 를 가리키면 CPU가 ‘kernel mode’ 에서 수행 중 사용자 프로그램의 메모리 위치 를 가리키면 CPU가 ‘user mode’ 에서 수행 중 2.2 일반 명령과 특권 명령 일반 명령 메모리에서 자료를 읽어와 CPU에서 연산을 하고, 그 결과를 메모리에 쓰는 명령 모든 프로그램이 수행 가능 mode bit가 1일 때 특권 명령 보안이 필요한 명령 각종 장치에 접근하는 명령 운영체제만이 수행 mode bite가 0일 때 운영체제를 향한 사용자 프로그램의 대행 요청: system call 사용자 프로그램이 특권 명령을 사용하고자 할 때, 사용자 프로그램이 특권 명령을 수행할 수 없으므로 운영체제에게 대행 요청 system call 을 한다. 그러면 CPU의 제어권이 운영체제에게 넘어가서 특권 명령을 수행한다. 2.3 인터럽트 라인을 세팅하는 이유 Problem CPU는 프로그램 카운터가 가리키는 메모리 위치의 명령만 계속 수행하여, 주변장치의 상태를 지속적으로 파악할 수 없다. Solution 주변 장치들이 CPU의 도움이 필요할 때 인터럽트 라인(interrupt line)을 세팅한다. CPU는 매번 명령을 수행한 후, 인터럽트 라인을 체크하여 요청 유무를 확인한다. 또한, 인터럽트의 원인이 다양하기 때문에, 인터럽트 라인을 다르게 해서 구분한다. 3. 프로그램의 실행 “프로그램이 실행(program execution)되고 있다” = disk에 존재하던 실행 파일이 메모리에 적재된다 = program이 CPU를 할당받고 instruction을 수행하고 있는 상태 “프로그램이 동시에 실행된다” = 여러 프로그램이 짧은 시간 단위로 CPU를 나누어 사용한다. = 프로그램이 메모리에 동시에 적재되어 있을 수 있으므로 3.1 가상 메모리(Virtual Memory) 프로그램은 실행 파일 형태로 하드 디스크에 저장한다.\n이 때는 프로그램은 주소 영역을 가지고 있다고 한다. 하지만, 실행되는 순간 프로세스가 되며 프로그램의 주소 영역은 프로세스의 주소 공간이 되는 것이다. 파일 실행 → 가상 메모리(Virtual Memory) 생성 → Address transition → 물리적 메모리(Physical Memory) 에 올라감\n가상 메모리(address space, logical memory) : 프로세스마다 가지는 독자적인 주소 공간 물리적 메모리(Physical Memory) : 0번지부터 시작 Address transition : 가상 메모리 주소를 물리적 메모리 주소로 변환하는 것으로, 하드웨어 장치가 수행 Virtual memory = 주소 공간 = Address space = code + data + stack\nOS의 주소 공간\nkernel의 code 자원 관리를 위한 부분 사용자에게 편리한 인터페이스를 제공하기 위한 부분 system call 및 interrup를 처리하기 위한 부분 kernel의 data 하드웨어와 소프트웨어(ex: 사용자 프로그램)를 포함하는 시스템 내의 모든 자원을 관리하기 위한 자료구조를 유지 ex) PCB kernel의 stack 현재 수행 중인 프로세스마다 별도의 스택을 두어 관리. Reason 1: system call로 특권 명령 대행을 요청한 후, 운영체제가 system call 내부의 다른 함수를 호출할 경우 복귀 주소는 커널 내의 주소가 되기 때문에 Reason 2: kernel은 일종의 공유 코드로서, 모든 프로세스가 system call을 통해 kernel 함수를 접근할 수 있으므로, 각 프로세스마다 커널 내에 별도의 스택을 둔다. 함수 호출 복귀 시 저장 장소\n'____' 코드 수행 중 이루어지는 함수 호출로 인한 복귀 주소 유지는 '____' 을 사용 process → 자신의 address space 내의 stack kernel → kernel stack 여기서 유의사항은 CPU 수행 주체가 OS로 바뀔 때 직전 수행 프로그램의 복귀 정보는 stack이 아닌 PCB에 저장한다는 사실이다. 3.2 Swap area Problem 프로그램이 프로세스가 되었을 때 생성되는 address space를 물리적 메모리에 다 올리지 않는다. Why?? 다 올리면 메모리 낭비가 심하기 때문 Solution 바로 필요한 코드 부분만 memory에 올린다. 그 외 부분은 보조기억장치에 놔두는데, 이 영역을 swap area라 한다. swap area는 메모리 용량 한계로 메모리 연장 용도로 사용한다. 하지만, 프로그램이 파일 형태로 저장되는 보조기억장치의 disk 영역은 비휘발성 용도로 저장한다. 4. 사용자 프로그램이 사용하는 함수 프로그램이 사용하는 함수의 종류 사용자 정의 함수: 프로그래머 본인이 직접 작성한 함수 라이브러리 함수: 자신의 프로그램에서 정의하지 않고 가져다 쓴 함수로, 자신의 프로그램의 실행 파일에 포함되어 있다. 커널 함수: kernel의 코드에 정의된 함수 = system call 함수 + interrupt 처리 함수 system call 함수: 사용자 프로그램이 운영체제의 서비스를 요청하기 위해 호출함수 interrupt 처리 함수: 각종 HW 및 SW가 CPU의 서비스를 요청하기 위한 함수 kernel의 address space에 code가 정의되기 때문에, system call로 kernel mode로 바꿔야 실행 가능하다. 사용자 정의 함수와 라이브러리 함수 는 프로그램의 코드 영역에 기계어 명령 형태로 존재 → 프로그램 실행 시, 해당 프로세스의 address space에 포함 프로세스 내의 함수 호출 시에도, 프로세스의 address space에 있는 stack 영역을 사용 프로세스의 address space의 code 영역 안에서 메모리 상의 점프를 한다. user mode에서 실행된다. 5. 인터럽트 5.1 Interrupt 작동 순서 복습 CPU는 프로그램 카운터가 가리키는 명령만 쉬지 않고 수행하기 때문에, 다른 명령을 수행하기 위해서는 interrupt를 걸어야 한다. CPU는 program counter가 가리키는 명령을 하나씩 수행한 후, interrupt line이 세팅되었는지 확인한다. interrupt line setting을 통해 interrupt가 발생했으면 현재 수행하던 process를 멈추고, 운영체제의 인터럽트 처리 루틴으로 이동하여, 인터럽트 처리를 수행한다. 인터럽트 처리를 마치면 인터럽트 발생 직전의 프로세스에게 CPU 제어권이 넘어간다. 5.2 Interrupt의 서로 다른 중요도 인터럽트 처리 중, 또 다른 인터럽트가 발생한 경우에는 어떻게 처리되는가??? 중요도를 비교한다. 현재 처리 중인 인터럽트의 중요도가 상대적으로 낮으면, 처리 중인 인터럽트 코드의 수행 지점을 저장한다. 그 다음, 중요도가 더 높은 인터럽트를 처리한다. 인터럽트 처리가 끝나면 저장 주소로 복귀해 이전에 수행하던 인터럽트 처리 코드를 마저 수행한다. 6. 시스템 콜 system call 사용의 예\nprocess가 CPU에서 명령을 수행하던 중 I/O 작업이 필요한 경우, sw interrupt인 system call을 통해 kernel 함수를 호출한다.\n→ kernel 함수는 사용자 프로그램이 수행할 수 없으므로, CPU 제어권을 OS에게 넘겨야 하는데,\n→ OS에게 넘기기 위해서 인터럽트 라인을 세팅하는 명령을 실행하여, CPU에게 interrupt가 발생했다는 걸 알린다.\n→ CPU는 program counter가 가리키는 명령을 하나씩 실행한 후, interrupt line을 체크하여 interrupt 발생을 확인한다.\n→ interrupt를 확인한 CPU는 현재 실행 중인 process를 멈춘 후, process의 실행 상태를 PCB에 저장한다.\n→ OS는 interrupt line을 통해서 어느 종류의 interrupt인지 확인한 후, interrupt vector가 가리키는 interrut service routine을 찾아 실행하여, 요청한 I/O에 해당하는 device controller에게 I/O 명령을 한다.\n→ I/O 요청이 수행되는 동안, 해당 process는 데이터가 없어서 다음 명령을 수행할 수 없으므로, CPU를 다른 process에게 이양한다.\n→ 다른 process의 작업을 CPU가 작업하는 도중에, I/O 작업이 완료되면 device controller가 CPU에게 interrupt를 발생시켜 I/O 작업 완료를 알린다. 이 때 발생한 interrupt는 HW interrupt다.\n→ interrupt 처리 내용으로 device controller가 device로부터 읽어와서 local buffer에 저장한 내용을 메모리로 복사해온다.\n→ 복사 후, I/O 작업을 요청했던 process에게 다시 CPU를 얻을 수 있는 권한을 준다.\n→ 그러면 I/O 작업을 이제 완료한 process는 CPU를 기다리는 큐에 삽입되고, CPU의 제어권은 interrupt를 당한 process에게 넘어가서 하던 작업을 계속 수행한다. process가 CPU를 빼앗기는 경우: 2가지\nTimer의 CPU 할당 시간이 만료된 경우, interrupt가 발생 time sharing system의 필수적인 요소 한 process가 CPU를 독점하는 걸 방지 process가 I/O 작업 같은 kernel code 수행이 필요한 경우 sw interrupt인 system call 하는 경우 시간이 오래 걸리는 I/O 작업이 수행하는 동안, CPU를 다른 process에게 할당한다. 그 이유는??? 입출력 작업을 요청한 process에게 CPU를 할당해도 파일 데이터가 있어야 당장 다음 명령을 수행할 수 있는데, I/O 연산 속도는 CPU 연산 속도보다 매우 느리기 때문에, 긴 기다리는 시간 동안 CPU가 일을 할 수 없어 비효율적이기 때문이다. 7. 프로세스의 두 가지 실행 상태 프로세스의 실행 상태 두 가지: user mode running(사용자 모드에서의 실행 상태) 와 kernel mode running(커널 모드에서의 실행 상태) 프로그램 자신의 주소 공간에서 정의된 코드를 실행 ↔ user mode running ex) 사용자 정의 함수 와 라이브러리 함수를 호출 kernel의 system call 함수 (kernel 주소 공간에 정의된 함수) 를 실행 ↔ kernel mode running system call 실행이 끝나면 다시 user mode로 복귀 또한, 프로그램 실행이 끝날 때에는 kernel mode로 진입해 프로그램을 종료한다. process 가 kernel mode에서 실행 중이란 의미는??? process A가 system call 을 통해 OS에게 대행 요청을 하여 kernel code를 실행 중이다 = process A가 kernel mode에서 실행 중 os가 kernel code를 수행하고 있을 지라도, os는 process A를 대신하여 수행 중이기 때문에, process A가 실행 상태인 걸로 간주한다. Reference 운영체제와 정보기술의 원리 kocw 이화여자대학교 운영체제 - 반효경 교수 - ","wordCount":"1449","inLanguage":"en","datePublished":"2022-04-15T00:27:39+09:00","dateModified":"2022-04-15T00:27:39+09:00","mainEntityOfPage":{"@type":"WebPage","@id":"http://jeha00.github.io/post/os/os_chapter_04_%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%A8%EC%9D%98%EA%B5%AC%EC%A1%B0%EC%99%80%EC%8B%A4%ED%96%89/"},"publisher":{"@type":"Organization","name":"Jeha00 DevLog","logo":{"@type":"ImageObject","url":"http://jeha00.github.io/favicon.ico"}}}</script></head><body class=dark id=top><script>localStorage.getItem("pref-theme")==="light"&&document.body.classList.remove("dark")</script><header class=header><nav class=nav><div class=logo><a href=http://jeha00.github.io/ accesskey=h title="Jeha00 (Alt + H)">Jeha00</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></span></div><ul id=menu><li><a href=http://jeha00.github.io/me/ title=About><span>About</span></a></li><li><a href=http://jeha00.github.io/archives/ title=Archive><span>Archive</span></a></li><li><a href=http://jeha00.github.io/categories/ title=Categories><span>Categories</span></a></li><li><a href=http://jeha00.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=http://jeha00.github.io/>Home</a>&nbsp;»&nbsp;<a href=http://jeha00.github.io/post/>Posts</a></div><h1 class=post-title>[TIL] OS Chapter 04: 프로그램의 구조와 실행</h1><div class=post-meta><span title='2022-04-15 00:27:39 +0900 KST'>April 15, 2022</span>&nbsp;|&nbsp;<a href=https://github.com/JeHa00/blog/content/post/OS/OS_Chapter_04_%ed%94%84%eb%a1%9c%ea%b7%b8%eb%9e%a8%ec%9d%98%ea%b5%ac%ec%a1%b0%ec%99%80%ec%8b%a4%ed%96%89.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#0-introduction aria-label="0. Introduction">0. Introduction</a></li><li><a href=#1-%ed%94%84%eb%a1%9c%ea%b7%b8%eb%9e%a8%ec%9d%98-%ea%b5%ac%ec%a1%b0%ec%99%80-%ec%9d%b8%ed%84%b0%eb%9f%bd%ed%8a%b8 aria-label="1. 프로그램의 구조와 인터럽트">1. 프로그램의 구조와 인터럽트</a><ul><li><a href=#11-%ed%94%84%eb%a1%9c%ea%b7%b8%eb%9e%a8%ec%9d%98-%ec%a3%bc%ec%86%8c-%ec%98%81%ec%97%ad aria-label="1.1 프로그램의 주소 영역">1.1 프로그램의 주소 영역</a></li><li><a href=#12-pcb-%ed%94%84%eb%a1%9c%ea%b7%b8%eb%9e%a8-%ec%88%98%ed%96%89%ec%9d%98-%eb%b3%b5%ea%b7%80-%ec%9c%84%ec%b9%98 aria-label="1.2 PCB: 프로그램 수행의 복귀 위치">1.2 PCB: 프로그램 수행의 복귀 위치</a></li></ul></li><li><a href=#2-%ec%bb%b4%ed%93%a8%ed%84%b0-%ec%8b%9c%ec%8a%a4%ed%85%9c%ec%9d%98-%ec%9e%91%eb%8f%99-%ea%b0%9c%ec%9a%94 aria-label="2. 컴퓨터 시스템의 작동 개요">2. 컴퓨터 시스템의 작동 개요</a><ul><li><a href=#21-%ed%94%84%eb%a1%9c%ea%b7%b8%eb%9e%a8-%ec%b9%b4%ec%9a%b4%ed%84%b0program-counterpc aria-label="2.1 프로그램 카운터(Program Counter(PC))">2.1 프로그램 카운터(Program Counter(PC))</a></li><li><a href=#22-%ec%9d%bc%eb%b0%98-%eb%aa%85%eb%a0%b9%ea%b3%bc-%ed%8a%b9%ea%b6%8c-%eb%aa%85%eb%a0%b9 aria-label="2.2 일반 명령과 특권 명령">2.2 일반 명령과 특권 명령</a></li><li><a href=#23-%ec%9d%b8%ed%84%b0%eb%9f%bd%ed%8a%b8-%eb%9d%bc%ec%9d%b8%ec%9d%84-%ec%84%b8%ed%8c%85%ed%95%98%eb%8a%94-%ec%9d%b4%ec%9c%a0 aria-label="2.3 인터럽트 라인을 세팅하는 이유">2.3 인터럽트 라인을 세팅하는 이유</a></li></ul></li><li><a href=#3-%ed%94%84%eb%a1%9c%ea%b7%b8%eb%9e%a8%ec%9d%98-%ec%8b%a4%ed%96%89 aria-label="3. 프로그램의 실행">3. 프로그램의 실행</a><ul><li><a href=#31-%ea%b0%80%ec%83%81-%eb%a9%94%eb%aa%a8%eb%a6%acvirtual-memory aria-label="3.1 가상 메모리(Virtual Memory)">3.1 가상 메모리(Virtual Memory)</a></li><li><a href=#32-swap-area aria-label="3.2 Swap area">3.2 Swap area</a></li></ul></li><li><a href=#4-%ec%82%ac%ec%9a%a9%ec%9e%90-%ed%94%84%eb%a1%9c%ea%b7%b8%eb%9e%a8%ec%9d%b4-%ec%82%ac%ec%9a%a9%ed%95%98%eb%8a%94-%ed%95%a8%ec%88%98 aria-label="4. 사용자 프로그램이 사용하는 함수">4. 사용자 프로그램이 사용하는 함수</a></li><li><a href=#5-%ec%9d%b8%ed%84%b0%eb%9f%bd%ed%8a%b8 aria-label="5. 인터럽트">5. 인터럽트</a><ul><li><a href=#51-interrupt-%ec%9e%91%eb%8f%99-%ec%88%9c%ec%84%9c-%eb%b3%b5%ec%8a%b5 aria-label="5.1 Interrupt 작동 순서 복습">5.1 Interrupt 작동 순서 복습</a></li><li><a href=#52-interrupt%ec%9d%98-%ec%84%9c%eb%a1%9c-%eb%8b%a4%eb%a5%b8-%ec%a4%91%ec%9a%94%eb%8f%84 aria-label="5.2 Interrupt의 서로 다른 중요도">5.2 Interrupt의 서로 다른 중요도</a></li></ul></li><li><a href=#6-%ec%8b%9c%ec%8a%a4%ed%85%9c-%ec%bd%9c aria-label="6. 시스템 콜">6. 시스템 콜</a></li><li><a href=#7-%ed%94%84%eb%a1%9c%ec%84%b8%ec%8a%a4%ec%9d%98-%eb%91%90-%ea%b0%80%ec%a7%80-%ec%8b%a4%ed%96%89-%ec%83%81%ed%83%9c aria-label="7. 프로세스의 두 가지 실행 상태">7. 프로세스의 두 가지 실행 상태</a></li><li><a href=#reference aria-label=Reference>Reference</a></li></ul></div></details></div><div class=post-content><h1 id=0-introduction>0. Introduction<a hidden class=anchor aria-hidden=true href=#0-introduction>#</a></h1><ul><li>해당 내용은 <a href="http://www.kyobobook.co.kr/product/detailViewKor.laf?ejkGb=KOR&mallGb=KOR&barcode=9791158903589&orderClick=LAG&Kc=">운영체제와 정보기술의 원리 -반효경 지음-</a> 와 <a href="http://www.kocw.net/home/cview.do?lid=3dd1117c48123b8e">kocw 이화여자대학교 운영체제 - 반효경 교수 -</a>를 보고 정리한 내용입니다.</li><li>정확하지 않은 내용이 있다면 말씀해주시면 감사하겠습니다.</li></ul><p> </p><hr><h1 id=1-프로그램의-구조와-인터럽트>1. 프로그램의 구조와 인터럽트<a hidden class=anchor aria-hidden=true href=#1-프로그램의-구조와-인터럽트>#</a></h1><ul><li>프로그램이 CPU에서 명령을 수행하기 위해서는 명령을 담은 프로그램의 주소 영역이 메모리에 올라가 있어야 한다.</li><li>왜냐하면 CPU는 메모리에 있는 instruction만을 보고 실행하기 때문이다.</li></ul><h2 id=11-프로그램의-주소-영역>1.1 프로그램의 주소 영역<a hidden class=anchor aria-hidden=true href=#11-프로그램의-주소-영역>#</a></h2><ul><li><em>프로그램의 주소영역 = Code + Data + Stack 영역</em></li><li>Code 영역<ul><li>작성한 함수의 코드가 CPU에서 수행하는 <strong>기계어 형태로 변환되어 저장</strong> 되는 공간</li></ul></li><li>Data 영역<ul><li>전역 변수(global variable) 등 <strong>프로그램이 사용하는 데이터를 저장</strong> 하는 공간</li></ul></li><li>Stack 영역<ul><li>프로그램 내의 함수 호출 시의 <strong>복귀 주소 및 데이터를 저장</strong> 하는 공간</li><li>예)<ul><li>프로그램 내의 X 함수 수행 → 프로그램 내의 Y 함수 호출 → 이 때 X 함수에서 Y 함수를 호출하는 지점을 stack 영역에 저장 → Y 함수가 호출되어 실행할 명령의 메모리 위치가 바뀜 → Y 함수 수행 완료 → stack에 저장된 X 함수의 주소 위치로 돌아와 코드를 계속 수행</li></ul></li></ul></li></ul><h2 id=12-pcb-프로그램-수행의-복귀-위치>1.2 PCB: 프로그램 수행의 복귀 위치<a hidden class=anchor aria-hidden=true href=#12-pcb-프로그램-수행의-복귀-위치>#</a></h2><ul><li><strong><em>인터럽트가 발생할 경우 복귀 위치: PCB(Process Control block)에 저장한다.</em></strong></li><li>interrupt가 발생한 시점에서 프로그램의 어느 부분까지 수행했는지를 PCB에 저장</li><li>과정<ul><li>A 프로그램이 CPU를 할당받아 명령을 수행 → interrupt 발생 → 현재 수행 중인 명령 위치를 PCB에 저장 → CPU 제어권을 OS에게 양도 → 인터럽트 처리 완료 후, PCB에 저장된 작업 지점으로 돌아와 계속 수행</li></ul></li></ul><p> </p><hr><h1 id=2-컴퓨터-시스템의-작동-개요>2. 컴퓨터 시스템의 작동 개요<a hidden class=anchor aria-hidden=true href=#2-컴퓨터-시스템의-작동-개요>#</a></h1><ul><li>컴퓨터 시스템의 작동<ul><li>CPU에서 명령을 수행하는 부분 + 컴퓨터 외부장치와 입출력이 이루어지는 부분</li></ul></li></ul><h2 id=21-프로그램-카운터program-counterpc>2.1 프로그램 카운터(Program Counter(PC))<a hidden class=anchor aria-hidden=true href=#21-프로그램-카운터program-counterpc>#</a></h2><ul><li><strong><em>PC = Program Counter = CPU가 수행해야할 메모리 주소를 담고 있는 레지스터</em></strong><ul><li>CPU는<ul><li>빠른 속도의 연산 능력은 가지고 있지만, 결정 능력을 가지고 있지 않다.</li><li>단지 매번 프로그램 카운터가 가리키는 메모리 위치의 명령을 처리한다.</li></ul></li><li>통상 프로그램 카운터가 다음 명령어를 가리키어 CPU 명령은 순차적으로 수행된다.<ul><li>반복문이나 함수 호출 등으로 바로 다음 주소가 아닌 명령을 수행할 수도 있다.</li></ul></li></ul></li><li><strong><em>Program Counter</em></strong> 가<ul><li><strong>OS가 존재하는 메모리 위치</strong> 를 가리키면 <strong>CPU가 &lsquo;kernel mode&rsquo; 에서 수행 중</strong></li><li><strong>사용자 프로그램의 메모리 위치</strong> 를 가리키면 <strong>CPU가 &lsquo;user mode&rsquo; 에서 수행 중</strong></li></ul></li></ul><h2 id=22-일반-명령과-특권-명령>2.2 일반 명령과 특권 명령<a hidden class=anchor aria-hidden=true href=#22-일반-명령과-특권-명령>#</a></h2><ul><li><strong>일반 명령</strong><ul><li>메모리에서 자료를 읽어와 CPU에서 연산을 하고, 그 결과를 메모리에 쓰는 명령</li><li>모든 프로그램이 수행 가능</li><li>mode bit가 1일 때</li></ul></li><li><strong>특권 명령</strong><ul><li>보안이 필요한 명령</li><li>각종 장치에 접근하는 명령</li><li>운영체제만이 수행</li><li>mode bite가 0일 때</li></ul></li><li><strong>운영체제를 향한 사용자 프로그램의 대행 요청: system call</strong><ul><li>사용자 프로그램이 특권 명령을 사용하고자 할 때, 사용자 프로그램이 특권 명령을 수행할 수 없으므로 운영체제에게 대행 요청 <strong>system call</strong> 을 한다.</li><li>그러면 CPU의 제어권이 운영체제에게 넘어가서 특권 명령을 수행한다.</li></ul></li></ul><h2 id=23-인터럽트-라인을-세팅하는-이유>2.3 인터럽트 라인을 세팅하는 이유<a hidden class=anchor aria-hidden=true href=#23-인터럽트-라인을-세팅하는-이유>#</a></h2><ul><li>Problem<ul><li>CPU는 프로그램 카운터가 가리키는 메모리 위치의 명령만 계속 수행하여, <strong><em>주변장치의 상태를 지속적으로 파악할 수 없다.</em></strong></li></ul></li><li>Solution<ul><li>주변 장치들이 CPU의 도움이 필요할 때 <strong><em>인터럽트 라인(interrupt line)을 세팅한다.</em></strong><ul><li>CPU는 매번 명령을 수행한 후, 인터럽트 라인을 체크하여 요청 유무를 확인한다.</li><li>또한, 인터럽트의 원인이 다양하기 때문에, <strong>인터럽트 라인을 다르게 해서 구분</strong>한다.</li></ul></li></ul></li></ul><p> </p><hr><h1 id=3-프로그램의-실행>3. 프로그램의 실행<a hidden class=anchor aria-hidden=true href=#3-프로그램의-실행>#</a></h1><ul><li><strong>“프로그램이 실행(program execution)되고 있다”</strong><ul><li>= disk에 존재하던 실행 파일이 메모리에 적재된다</li><li>= program이 CPU를 할당받고 instruction을 수행하고 있는 상태</li></ul></li><li><strong>“프로그램이 동시에 실행된다”</strong><ul><li>= 여러 프로그램이 짧은 시간 단위로 CPU를 나누어 사용한다.</li><li>= 프로그램이 메모리에 동시에 적재되어 있을 수 있으므로</li></ul></li></ul><h2 id=31-가상-메모리virtual-memory>3.1 가상 메모리(Virtual Memory)<a hidden class=anchor aria-hidden=true href=#31-가상-메모리virtual-memory>#</a></h2><ul><li><p>프로그램은 <strong>실행 파일 형태</strong>로 하드 디스크에 저장한다.</p><ul><li>이 때는 프로그램은 주소 영역을 가지고 있다고 한다.</li><li>하지만, 실행되는 순간 프로세스가 되며 프로그램의 주소 영역은 프로세스의 주소 공간이 되는 것이다.</li></ul></li><li><p><strong>파일 실행 → <code>가상 메모리(Virtual Memory)</code> 생성 → <code>Address transition</code> → <code>물리적 메모리(Physical Memory)</code> 에 올라감</strong></p><ul><li><code>가상 메모리(address space, logical memory)</code> : 프로세스마다 가지는 독자적인 주소 공간</li><li><code>물리적 메모리(Physical Memory)</code> : 0번지부터 시작</li><li><code>Address transition</code> : 가상 메모리 주소를 물리적 메모리 주소로 변환하는 것으로, 하드웨어 장치가 수행
<img loading=lazy src=https://woovictory.github.io/img/address_translation.png alt=image></li></ul></li><li><p><strong>Virtual memory = 주소 공간 = Address space = code + data + stack</strong></p></li><li><p><strong>OS의 주소 공간</strong></p><ul><li>kernel의 code<ol><li><strong>자원 관리</strong>를 위한 부분</li><li>사용자에게 <strong>편리한 인터페이스를 제공</strong>하기 위한 부분</li><li><strong>system call 및 interrup를 처리</strong>하기 위한 부분</li></ol></li><li>kernel의 data<ul><li>하드웨어와 소프트웨어(ex: 사용자 프로그램)를 포함하는 시스템 내의 모든 자원을 관리하기 위한 자료구조를 유지 ex) PCB</li></ul></li><li>kernel의 stack<ul><li>현재 수행 중인 프로세스마다 별도의 스택을 두어 관리.<ul><li>Reason 1: system call로 특권 명령 대행을 요청한 후, 운영체제가 system call 내부의 다른 함수를 호출할 경우 복귀 주소는 커널 내의 주소가 되기 때문에</li><li>Reason 2: kernel은 일종의 공유 코드로서, 모든 프로세스가 system call을 통해 kernel 함수를 접근할 수 있으므로, 각 프로세스마다 커널 내에 별도의 스택을 둔다.</li></ul></li></ul></li></ul></li><li><p><strong>함수 호출 복귀 시 저장 장소</strong></p><ul><li><code>'____'</code> 코드 수행 중 이루어지는 함수 호출로 인한 복귀 주소 유지는 <code>'____'</code> 을 사용<ul><li>process → <strong>자신의 address space 내의 stack</strong></li><li>kernel → <strong>kernel stack</strong></li></ul></li><li>여기서 유의사항은 CPU 수행 주체가 OS로 바뀔 때 직전 수행 프로그램의 복귀 정보는 stack이 아닌 <code>PCB</code>에 저장한다는 사실이다.</li></ul></li></ul><p><img loading=lazy src=https://woovictory.github.io/img/address_structure_of_os.png alt=image></p><h2 id=32-swap-area>3.2 Swap area<a hidden class=anchor aria-hidden=true href=#32-swap-area>#</a></h2><ul><li>Problem<ul><li>프로그램이 프로세스가 되었을 때 생성되는 address space를 물리적 메모리에 다 올리지 않는다.</li><li>Why?? 다 올리면 메모리 낭비가 심하기 때문</li></ul></li><li>Solution<ul><li>바로 필요한 코드 부분만 memory에 올린다.</li><li>그 외 부분은 보조기억장치에 놔두는데, 이 영역을 <code>swap area</code>라 한다.</li><li>swap area는 메모리 용량 한계로 메모리 연장 용도로 사용한다.</li><li>하지만, 프로그램이 파일 형태로 저장되는 보조기억장치의 disk 영역은 비휘발성 용도로 저장한다.</li></ul></li></ul><p> </p><hr><h1 id=4-사용자-프로그램이-사용하는-함수>4. 사용자 프로그램이 사용하는 함수<a hidden class=anchor aria-hidden=true href=#4-사용자-프로그램이-사용하는-함수>#</a></h1><ul><li><strong><em>프로그램이 사용하는 함수의 종류</em></strong><ul><li><strong>사용자 정의 함수</strong>: 프로그래머 본인이 직접 작성한 함수</li><li><strong>라이브러리 함수</strong>: 자신의 프로그램에서 정의하지 않고 가져다 쓴 함수로, 자신의 프로그램의 실행 파일에 포함되어 있다.</li><li><strong>커널 함수</strong>: kernel의 코드에 정의된 함수 = system call 함수 + interrupt 처리 함수<ol><li>system call 함수: 사용자 프로그램이 운영체제의 서비스를 요청하기 위해 호출함수</li><li>interrupt 처리 함수: 각종 HW 및 SW가 CPU의 서비스를 요청하기 위한 함수<ul><li>kernel의 address space에 code가 정의되기 때문에, system call로 kernel mode로 바꿔야 실행 가능하다.</li></ul></li></ol></li></ul></li><li><strong><em>사용자 정의 함수와 라이브러리 함수</em></strong> 는<ul><li>프로그램의 코드 영역에 기계어 명령 형태로 존재 → 프로그램 실행 시, 해당 프로세스의 address space에 포함</li><li>프로세스 내의 함수 호출 시에도, 프로세스의 address space에 있는 stack 영역을 사용</li><li>프로세스의 address space의 code 영역 안에서 메모리 상의 점프를 한다.</li><li>user mode에서 실행된다.</li></ul></li></ul><p> </p><hr><h1 id=5-인터럽트>5. 인터럽트<a hidden class=anchor aria-hidden=true href=#5-인터럽트>#</a></h1><h2 id=51-interrupt-작동-순서-복습>5.1 Interrupt 작동 순서 복습<a hidden class=anchor aria-hidden=true href=#51-interrupt-작동-순서-복습>#</a></h2><ul><li>CPU는 프로그램 카운터가 가리키는 명령만 쉬지 않고 수행하기 때문에, 다른 명령을 수행하기 위해서는 interrupt를 걸어야 한다.</li><li>CPU는 program counter가 가리키는 명령을 하나씩 수행한 후, interrupt line이 세팅되었는지 확인한다.</li><li>interrupt line setting을 통해 interrupt가 발생했으면 현재 수행하던 process를 멈추고, 운영체제의 인터럽트 처리 루틴으로 이동하여, 인터럽트 처리를 수행한다.</li><li>인터럽트 처리를 마치면 인터럽트 발생 직전의 프로세스에게 CPU 제어권이 넘어간다.</li></ul><h2 id=52-interrupt의-서로-다른-중요도>5.2 Interrupt의 서로 다른 중요도<a hidden class=anchor aria-hidden=true href=#52-interrupt의-서로-다른-중요도>#</a></h2><ul><li>인터럽트 처리 중, 또 다른 인터럽트가 발생한 경우에는 어떻게 처리되는가???<ul><li>중요도를 비교한다.</li><li>현재 처리 중인 인터럽트의 중요도가 상대적으로 낮으면, 처리 중인 인터럽트 코드의 수행 지점을 저장한다.</li><li>그 다음, 중요도가 더 높은 인터럽트를 처리한다.</li><li>인터럽트 처리가 끝나면 저장 주소로 복귀해 이전에 수행하던 인터럽트 처리 코드를 마저 수행한다.</li></ul></li></ul><p> </p><hr><h1 id=6-시스템-콜>6. 시스템 콜<a hidden class=anchor aria-hidden=true href=#6-시스템-콜>#</a></h1><ul><li><p>system call 사용의 예</p><ul><li>process가 CPU에서 명령을 수행하던 중 I/O 작업이 필요한 경우, <strong>sw interrupt인 system call</strong>을 통해 kernel 함수를 호출한다.<br>→ kernel 함수는 사용자 프로그램이 수행할 수 없으므로, CPU 제어권을 OS에게 넘겨야 하는데,<br>→ OS에게 넘기기 위해서 인터럽트 라인을 세팅하는 명령을 실행하여, CPU에게 interrupt가 발생했다는 걸 알린다.<br>→ CPU는 program counter가 가리키는 명령을 하나씩 실행한 후, interrupt line을 체크하여 interrupt 발생을 확인한다.<br>→ interrupt를 확인한 CPU는 현재 실행 중인 process를 멈춘 후, process의 실행 상태를 PCB에 저장한다.<br>→ OS는 interrupt line을 통해서 어느 종류의 interrupt인지 확인한 후, interrupt vector가 가리키는 interrut service routine을 찾아 실행하여, 요청한 I/O에 해당하는 device controller에게 I/O 명령을 한다.<br>→ I/O 요청이 수행되는 동안, 해당 process는 데이터가 없어서 다음 명령을 수행할 수 없으므로, CPU를 다른 process에게 이양한다.<br>→ 다른 process의 작업을 CPU가 작업하는 도중에, I/O 작업이 완료되면 device controller가 CPU에게 interrupt를 발생시켜 I/O 작업 완료를 알린다. 이 때 발생한 interrupt는 HW interrupt다.<br>→ interrupt 처리 내용으로 device controller가 device로부터 읽어와서 local buffer에 저장한 내용을 메모리로 복사해온다.<br>→ 복사 후, I/O 작업을 요청했던 process에게 다시 CPU를 얻을 수 있는 권한을 준다.<br>→ 그러면 I/O 작업을 이제 완료한 process는 CPU를 기다리는 큐에 삽입되고, CPU의 제어권은 interrupt를 당한 process에게 넘어가서 하던 작업을 계속 수행한다.</li></ul></li><li><p><strong>process가 CPU를 빼앗기는 경우: 2가지</strong></p><ul><li><strong>Timer의 CPU 할당 시간이 만료된 경우, interrupt가 발생</strong><ul><li>time sharing system의 필수적인 요소</li><li>한 process가 CPU를 독점하는 걸 방지</li></ul></li><li><strong>process가 I/O 작업 같은 kernel code 수행이 필요한 경우 sw interrupt인 system call 하는 경우</strong><ul><li>시간이 오래 걸리는 I/O 작업이 수행하는 동안, CPU를 다른 process에게 할당한다.<ul><li>그 이유는???<ul><li>입출력 작업을 요청한 process에게 CPU를 할당해도 파일 데이터가 있어야 당장 다음 명령을 수행할 수 있는데,</li><li>I/O 연산 속도는 CPU 연산 속도보다 매우 느리기 때문에, 긴 기다리는 시간 동안 CPU가 일을 할 수 없어 비효율적이기 때문이다.</li></ul></li></ul></li></ul></li></ul></li></ul><p> </p><hr><h1 id=7-프로세스의-두-가지-실행-상태>7. 프로세스의 두 가지 실행 상태<a hidden class=anchor aria-hidden=true href=#7-프로세스의-두-가지-실행-상태>#</a></h1><ul><li>프로세스의 실행 상태 두 가지: <strong><em>user mode running(사용자 모드에서의 실행 상태) 와 kernel mode running(커널 모드에서의 실행 상태)</em></strong></li><li><strong>프로그램 자신의 주소 공간에서 정의된 코드</strong>를 실행 ↔ <strong><em>user mode running</em></strong><ul><li>ex) 사용자 정의 함수 와 라이브러리 함수를 호출</li></ul></li><li>kernel의 system call 함수 (<strong>kernel 주소 공간에 정의된 함수</strong>) 를 실행 ↔ <strong><em>kernel mode running</em></strong><ul><li>system call 실행이 끝나면 다시 user mode로 복귀</li><li>또한, 프로그램 실행이 끝날 때에는 kernel mode로 진입해 프로그램을 종료한다.</li></ul></li><li><strong><em>process 가 kernel mode에서 실행 중이란 의미는???</em></strong><ul><li>process A가 system call 을 통해 OS에게 대행 요청을 하여 kernel code를 실행 중이다 = process A가 kernel mode에서 실행 중</li><li>os가 kernel code를 수행하고 있을 지라도, os는 process A를 대신하여 수행 중이기 때문에, process A가 실행 상태인 걸로 간주한다.</li></ul></li></ul><p> </p><hr><h1 id=reference>Reference<a hidden class=anchor aria-hidden=true href=#reference>#</a></h1><ul><li><a href="http://www.kyobobook.co.kr/product/detailViewKor.laf?ejkGb=KOR&mallGb=KOR&barcode=9791158903589&orderClick=LAG&Kc=">운영체제와 정보기술의 원리</a></li><li><a href="http://www.kocw.net/home/cview.do?lid=3dd1117c48123b8e">kocw 이화여자대학교 운영체제 - 반효경 교수 -</a></li></ul></div><footer class=post-footer><ul class=post-tags><li><a href=http://jeha00.github.io/tags/til/>TIL</a></li><li><a href=http://jeha00.github.io/tags/os/>OS</a></li></ul><nav class=paginav><a class=prev href=http://jeha00.github.io/post/os/os_chapter_05_%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4_%EA%B4%80%EB%A6%AC/><span class=title>« Prev Page</span><br><span>[TIL] OS Chapter 05: 프로세스 관리</span></a>
<a class=next href=http://jeha00.github.io/post/os/os_chapter_03_%EC%BB%B4%ED%93%A8%ED%84%B0%EC%8B%9C%EC%8A%A4%ED%85%9C%EC%9D%98%EB%8F%99%EC%9E%91%EC%9B%90%EB%A6%AC_2/><span class=title>Next Page »</span><br><span>[TIL] OS Chapter 03: 컴퓨터 시스템의 동작원리 2</span></a></nav><div class=share-buttons><a target=_blank rel="noopener noreferrer" aria-label="share [TIL] OS Chapter 04: 프로그램의 구조와 실행 on twitter" href="https://twitter.com/intent/tweet/?text=%5bTIL%5d%20OS%20Chapter%2004%3a%20%ed%94%84%eb%a1%9c%ea%b7%b8%eb%9e%a8%ec%9d%98%20%ea%b5%ac%ec%a1%b0%ec%99%80%20%ec%8b%a4%ed%96%89&url=http%3a%2f%2fjeha00.github.io%2fpost%2fos%2fos_chapter_04_%25ED%2594%2584%25EB%25A1%259C%25EA%25B7%25B8%25EB%259E%25A8%25EC%259D%2598%25EA%25B5%25AC%25EC%25A1%25B0%25EC%2599%2580%25EC%258B%25A4%25ED%2596%2589%2f&hashtags=TIL%2cOS"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM195.519 424.544c135.939.0 210.268-112.643 210.268-210.268.0-3.218.0-6.437-.153-9.502 14.406-10.421 26.973-23.448 36.935-38.314-13.18 5.824-27.433 9.809-42.452 11.648 15.326-9.196 26.973-23.602 32.49-40.92-14.252 8.429-30.038 14.56-46.896 17.931-13.487-14.406-32.644-23.295-53.946-23.295-40.767.0-73.87 33.104-73.87 73.87.0 5.824.613 11.494 1.992 16.858-61.456-3.065-115.862-32.49-152.337-77.241-6.284 10.881-9.962 23.601-9.962 37.088.0 25.594 13.027 48.276 32.95 61.456-12.107-.307-23.448-3.678-33.41-9.196v.92c0 35.862 25.441 65.594 59.311 72.49-6.13 1.686-12.72 2.606-19.464 2.606-4.751.0-9.348-.46-13.946-1.38 9.349 29.426 36.628 50.728 68.965 51.341-25.287 19.771-57.164 31.571-91.8 31.571-5.977.0-11.801-.306-17.625-1.073 32.337 21.15 71.264 33.41 112.95 33.41z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share [TIL] OS Chapter 04: 프로그램의 구조와 실행 on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&url=http%3a%2f%2fjeha00.github.io%2fpost%2fos%2fos_chapter_04_%25ED%2594%2584%25EB%25A1%259C%25EA%25B7%25B8%25EB%259E%25A8%25EC%259D%2598%25EA%25B5%25AC%25EC%25A1%25B0%25EC%2599%2580%25EC%258B%25A4%25ED%2596%2589%2f&title=%5bTIL%5d%20OS%20Chapter%2004%3a%20%ed%94%84%eb%a1%9c%ea%b7%b8%eb%9e%a8%ec%9d%98%20%ea%b5%ac%ec%a1%b0%ec%99%80%20%ec%8b%a4%ed%96%89&summary=%5bTIL%5d%20OS%20Chapter%2004%3a%20%ed%94%84%eb%a1%9c%ea%b7%b8%eb%9e%a8%ec%9d%98%20%ea%b5%ac%ec%a1%b0%ec%99%80%20%ec%8b%a4%ed%96%89&source=http%3a%2f%2fjeha00.github.io%2fpost%2fos%2fos_chapter_04_%25ED%2594%2584%25EB%25A1%259C%25EA%25B7%25B8%25EB%259E%25A8%25EC%259D%2598%25EA%25B5%25AC%25EC%25A1%25B0%25EC%2599%2580%25EC%258B%25A4%25ED%2596%2589%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share [TIL] OS Chapter 04: 프로그램의 구조와 실행 on reddit" href="https://reddit.com/submit?url=http%3a%2f%2fjeha00.github.io%2fpost%2fos%2fos_chapter_04_%25ED%2594%2584%25EB%25A1%259C%25EA%25B7%25B8%25EB%259E%25A8%25EC%259D%2598%25EA%25B5%25AC%25EC%25A1%25B0%25EC%2599%2580%25EC%258B%25A4%25ED%2596%2589%2f&title=%5bTIL%5d%20OS%20Chapter%2004%3a%20%ed%94%84%eb%a1%9c%ea%b7%b8%eb%9e%a8%ec%9d%98%20%ea%b5%ac%ec%a1%b0%ec%99%80%20%ec%8b%a4%ed%96%89"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share [TIL] OS Chapter 04: 프로그램의 구조와 실행 on facebook" href="https://facebook.com/sharer/sharer.php?u=http%3a%2f%2fjeha00.github.io%2fpost%2fos%2fos_chapter_04_%25ED%2594%2584%25EB%25A1%259C%25EA%25B7%25B8%25EB%259E%25A8%25EC%259D%2598%25EA%25B5%25AC%25EC%25A1%25B0%25EC%2599%2580%25EC%258B%25A4%25ED%2596%2589%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share [TIL] OS Chapter 04: 프로그램의 구조와 실행 on whatsapp" href="https://api.whatsapp.com/send?text=%5bTIL%5d%20OS%20Chapter%2004%3a%20%ed%94%84%eb%a1%9c%ea%b7%b8%eb%9e%a8%ec%9d%98%20%ea%b5%ac%ec%a1%b0%ec%99%80%20%ec%8b%a4%ed%96%89%20-%20http%3a%2f%2fjeha00.github.io%2fpost%2fos%2fos_chapter_04_%25ED%2594%2584%25EB%25A1%259C%25EA%25B7%25B8%25EB%259E%25A8%25EC%259D%2598%25EA%25B5%25AC%25EC%25A1%25B0%25EC%2599%2580%25EC%258B%25A4%25ED%2596%2589%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share [TIL] OS Chapter 04: 프로그램의 구조와 실행 on telegram" href="https://telegram.me/share/url?text=%5bTIL%5d%20OS%20Chapter%2004%3a%20%ed%94%84%eb%a1%9c%ea%b7%b8%eb%9e%a8%ec%9d%98%20%ea%b5%ac%ec%a1%b0%ec%99%80%20%ec%8b%a4%ed%96%89&url=http%3a%2f%2fjeha00.github.io%2fpost%2fos%2fos_chapter_04_%25ED%2594%2584%25EB%25A1%259C%25EA%25B7%25B8%25EB%259E%25A8%25EC%259D%2598%25EA%25B5%25AC%25EC%25A1%25B0%25EC%2599%2580%25EC%258B%25A4%25ED%2596%2589%2f"><svg viewBox="2 2 28 28"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></div></footer></article></main><footer class=footer><span>&copy; 2023 <a href=http://jeha00.github.io/>Jeha00 DevLog</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerText="copy";function s(){t.innerText="copied!",setTimeout(()=>{t.innerText="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>