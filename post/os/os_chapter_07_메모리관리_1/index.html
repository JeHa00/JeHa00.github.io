<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>[TIL] OS Chapter 07: 메모리 관리 1 | Jeha DevLog</title><meta name=keywords content="TIL,OS"><meta name=description content="logical address와 physical address를 어떻게 mapping하는지, 메모리 관리와 관련된 용어 4가지에 대해 알아보고, 물리적 메모리의 할당 방식 연속할당과 불연속할당 방식 중 연속할당에 대해 알아본다."><meta name=author content><link rel=canonical href=http://jeha00.github.io/post/os/os_chapter_07_%EB%A9%94%EB%AA%A8%EB%A6%AC%EA%B4%80%EB%A6%AC_1/><meta name=google-site-verification content="XYZabc"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.min.1e44d58192cbf6d7a4eb649bc43dbc3d4cc432677e5d8adc69b08c34cbe461ac.css integrity="sha256-HkTVgZLL9tek62SbxD28PUzEMmd+XYrcabCMNMvkYaw=" rel="preload stylesheet" as=style><link rel=icon href=http://jeha00.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=http://jeha00.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=http://jeha00.github.io/favicon-32x32.png><link rel=apple-touch-icon href=http://jeha00.github.io/apple-touch-icon.png><link rel=mask-icon href=http://jeha00.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><meta name=generator content="Hugo 0.101.0"><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><script type=application/javascript>var doNotTrack=!1;doNotTrack||(function(e,t,n,s,o,i,a){e.GoogleAnalyticsObject=o,e[o]=e[o]||function(){(e[o].q=e[o].q||[]).push(arguments)},e[o].l=1*new Date,i=t.createElement(n),a=t.getElementsByTagName(n)[0],i.async=1,i.src=s,a.parentNode.insertBefore(i,a)}(window,document,"script","https://www.google-analytics.com/analytics.js","ga"),ga("create","UA-123-45","auto"),ga("send","pageview"))</script><meta property="og:title" content="[TIL] OS Chapter 07: 메모리 관리 1"><meta property="og:description" content="logical address와 physical address를 어떻게 mapping하는지, 메모리 관리와 관련된 용어 4가지에 대해 알아보고, 물리적 메모리의 할당 방식 연속할당과 불연속할당 방식 중 연속할당에 대해 알아본다."><meta property="og:type" content="article"><meta property="og:url" content="http://jeha00.github.io/post/os/os_chapter_07_%EB%A9%94%EB%AA%A8%EB%A6%AC%EA%B4%80%EB%A6%AC_1/"><meta property="og:image" content="http://jeha00.github.io/47"><meta property="article:section" content="post"><meta property="article:published_time" content="2022-04-28T16:13:46+09:00"><meta property="article:modified_time" content="2022-04-28T16:13:46+09:00"><meta property="og:site_name" content="JeHa00 DevLog"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="http://jeha00.github.io/47"><meta name=twitter:title content="[TIL] OS Chapter 07: 메모리 관리 1"><meta name=twitter:description content="logical address와 physical address를 어떻게 mapping하는지, 메모리 관리와 관련된 용어 4가지에 대해 알아보고, 물리적 메모리의 할당 방식 연속할당과 불연속할당 방식 중 연속할당에 대해 알아본다."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"http://jeha00.github.io/post/"},{"@type":"ListItem","position":2,"name":"[TIL] OS Chapter 07: 메모리 관리 1","item":"http://jeha00.github.io/post/os/os_chapter_07_%EB%A9%94%EB%AA%A8%EB%A6%AC%EA%B4%80%EB%A6%AC_1/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"[TIL] OS Chapter 07: 메모리 관리 1","name":"[TIL] OS Chapter 07: 메모리 관리 1","description":"logical address와 physical address를 어떻게 mapping하는지, 메모리 관리와 관련된 용어 4가지에 대해 알아보고, 물리적 메모리의 할당 방식 연속할당과 불연속할당 방식 중 연속할당에 대해 알아본다.","keywords":["TIL","OS"],"articleBody":"0. Introduction 해당 내용은 운영체제와 정보기술의 원리 -반효경 지음- 와 kocw 이화여자대학교 운영체제 - 반효경 교수 -를 보고 정리한 내용이다. 정확하지 않은 내용이 있다면 말씀해주시면 감사하겠습니다. 이번 chapter 내용인 메모리 관리는 물리적인 메모리 관리로, 주요 내용은 address binding이다. address binding에서의 OS의 역할은 없고, 다 HW가 해야한다. address binding을 할 때마다 OS에게 CPU 제어권을 양도해도, 결국 물리적 메모리에 instruction을 실행하는 건 CPU다. 그래서 HW가 해야한다. 1. 주소(address) 바인딩 1.1 주소란?? 서로 다른 위치를 구분하기 위해 사용하는 일련의 숫자 크게 논리적 주소와 물리적 주소로 나뉠 수 있다. Memory는 주소를 통해 접근하는 저장장치다. 컴퓨터 시스템은 32bit 혹은 64bit의 주소체계를 사용하는데, 32bit는 2^(32) 가지, 64bit는 2^(64) 가지의 서로 다른 메모리 위치를 구분할 수 있다. byte 단위로 메모리 주소를 부여한다. 1.2 논리적 주소, 물리적 주소 논리적 주소(logical address, virtual address)란?\n프로세스마다 독립적으로 가지는 주소 공간 각 프로세스마다 0번지부터 시작 CPU가 보는 주소는 logical address Why? 물리적 메모리에 올라오는 위치는 달라도 코드 상의 내용은 compile 시 내용. 물리적 주소(physical address)란?\n메모리에 실제로 올라가는 위치 물리적 주소의 낮은 주소 영역에는 kernel이 올라간다. 물리적 주소의 높은 주소 영역에는 user process들이 올라간다. 프로세스가 실행되기 위해서\n해당 프로그램이 물리적 메모리에 올라가 있어야 한다. 해당 논리적 주소가 물리적 메모리의 어느 위치에 매핑되는지 확인해야 한다. 1.3 주소 바인딩(address binding) logical address를 physical address로 연결시켜서, physical address를 결정하는 작업\nSymbolic address –(compile)–\u003e Logical address –(address binding)–\u003e Physical address 주소 바인딩 방식 3가지: 물리적 메모리 주소가 결정되는 시기에 따라 분류된다.\n컴파일 타임 바인딩(compile time binding) 로드 타임 바인딩(load time binding) 실행시간 바인딩(execution time binding or run time binding) 방식 이름 compile time binding load time binding run time binding 시기 컴파일 시 프로그램 실행이 시작 시 (변경 가능 X) 프로그램 실행이 시작 시, (변경 가능 O) swapping 효과 좋지 않음 좋지 않음 좋음 Compile time binding\n컴파일 시, 논리적인 주소와 물리적인 주소 다 생성된다. compiler는 절대 코드 를 생성한다. 그래서 program이 올라가 있는 물리적 메모리의 시작위치를 변경할려면 컴파일을 다시 해야 한다. 물리적 주소의 0번지부터 시작한다. 현대의 시분할 컴퓨터 환경에서는 잘 사용하지 않는 기법 Load time binding\n컴파일 시에는 논리적인 주소만 결정된다. 이를 실행하고 나서, 메모리가 비어있는 곳부터 올린다. 로더(loader)의 책임 하에 물리적 메모리 주소 부여 Loader: user program을 memory에 적재시키는 프로그램 compiler가 재배치 가능 코드 를 생성한 경우 가능 Run time binding\nLoad time binding 처럼 실행 시, physical address가 생성된다. 실행을 시작한 후에도 물리적 메모리상의 위치(물리적 주소)를 옮길 수 있는 방식 CPU가 주소 참조 시, address mapping table을 이용해 원하는 데이터가 물리적 메모리의 어느 위치에 존재하는지 확인한다. MMU(Memory Management Unit) 라는 하드웨어적 지원이 필요 1.4 MMU 기법(MMU scheme) 기준 레지스터를 사용하여 logical에서 physical address로 mapping해주는 HW device\n가정\n프로그램의 주소 공간이 메모리의 한 장소에 연속적으로 적재되는 걸 가정한다. MMU scheme\n사용자 프로세스가 CPU에서 수행되여 생성해내는 모든 논리적 주소값에 대해 base register(= relocation register) 의 값을 더하여 물리적 주소값을 얻어낸다. base register = CPU가 사용하려는 프로세스의 물리적 메모리 시작 주소 user program\nlogical address 만을 다룬다. 실제 physical address 를 볼 수 없으며, 알 필요가 없다. 예시\nCPU가 논리적 주소: 123번지 정보를 요청 기준 레지스터(=재배치 레지스터): 23000 물리적 주소 = 123 + 23000 = 23123 물리적 주소 23123번지에서 CPU가 요청한 정보를 찾는다. 논리적 주소란 기준 레지스터로부터 얼마나 떨어져 있는지를 나타내는 것 동일한 논리적 주소\n프로세스는 각 자신만의 고유한 주소 공간을 가진다. 그래서 동일한 논리적 주소라고 할 지라도, 서로 다른 내용을 담는다. MMU 기법에서 프로세스가 바뀔 때마다 기준 레지스터의 값을 바뀌는 프로세스에 해당되는 값으로 재설정한다. 메모리 보안\nProblem 가상 메모리에 기준 레지스터를 더했을 때, 해당 프로세스의 주소 공간을 벗어나는 경우, 다른 프로세스 영역에 침범하거나, kernel 영역을 변경해 치명적인 결과를 초래할 수 있다. Solution 한계 레지스터(limit register) 를 사용하여, 프로세스 자신의 주소 공간을 넘어서는 메모리 참조를 하는지 확인한다. 한계 레지스터(limit register): 논리적 주소의 범위 벗어날 경우, trap을 발생시켜 해당 프로세스를 강제종료시킨다. 2. 메모리 관리와 관련된 용어 2.1 동적 로딩(Dynamic loading) 다중 프로그래밍 환경에서 메모리를 효율적으로 사용하기 위한 기법 프로세스의 주소 공간 전체를 메모리에 다 올려놓는 게 아닌, 해당 부분이 불릴 때에마다 그 부분만 메모리에 적재하는 방식: 연속 할당에 해당되지 않는다. loading: 물리적 메모리로 올리는 것 부분적으로만 올리는 이유 실제 프로그램의 코드 중 상당 부분 = 가끔씩 사용하는 방어용 코드 -\u003e 주소 공간 전체 loading -\u003e 메모리 낭비 초래 동적 로딩 -\u003e 더 많은 프로그램 로딩 가능 -\u003e 메모리 이용 효율성 향상 운영체제 지원 없이 개발자가 코드로 구현 가능하고, OS는 라이브러리를 통해 지원 가능 2.2 중첩(overlays) 메모리보다 큰 프로세스를 실행하기 위해서, 프로세스의 주소 공간을 분할해 실제 필요한 부분만을 메모리에 적재하는 기법\n중첩과 동적 로딩의 차이점: 목적 동적 로딩의 목적: 메모리에 multi-process를 실행하기 위한 용도 중첩의 목적: single-process를 실행하기 위한 환경에서 메모리 용량보다 큰 프로세스를 실행하기 위한 용도 운영체제의 지원 없이 프로그래머가 직접 구현해야 한다. 2.3 스와핑(Swapping) 프로세스의 주소 공간 전체를 메모리에서 backing store로 쫓아내는 것\n스왑 영역(Swap area)란??\n다른 말로 백킹 스토어(backing store) 라고 한다. 디스크 내의 파일 시스템과는 별도로 존재하는 일정 영역으로, 파일 시스템 은 전원이 나가도 유지되어야 하는 비휘발성 저장공간이지만, 스왑 영역 은 프로세스가 수행 중인 동안에만 디스크에 일시적으로 저장하는 휘발성 영역이다. 프로세스 실행이 종료되면 메모리에서 디스크로 내려놓는다. (swap out) 그리고, 다음과 같은 특징을 가져야 한다. 다수의 사용자 프로세스를 담을 수 있을 만큼 충분히 큰 저장 공간이다. 어느 정도의 접근 속도가 보장되야 한다. Swap in \u0026 out\nSwap in: disk -\u003e memory 올리는 작업 Swap out: memory -\u003e disk 내리는 작업 스와핑이 일어나는 과정\n첫 번째: Swapper라 불리는 중기 스케쥴러 에 의해 swap out할 process를 선정.\n선정 기준: priority priority가 낮은 프로세스를 swap out priority가 높은 프로세스를 swap in 두 번째: 선정된 process를 메모리에 올라간 주소 공간 전체 내용을 disk swap area로 아웃시켜서 메모리의 프로세스 수를 조절한다.\n즉, Swapper로 멀티 프로그래밍 정도(degree of multi-programming)를 조절한다.\n메모리에 많은 프로그램이 올라오면 할당되는 메모리 양이 지나치게 적어져, 시스템 전체 성능이 감소되기 때문이다.\nSwap time\nSwap time: swapping에 소요되는 시간 Transfer time: 데이터를 읽고 쓰는 전송 시간 Swap time은 디스크를 탐색하는 것보다 disk sector에서 transfer time이 대부분을 차지한다. 즉, transfer time 은 swap 되는 양에 비례 address binding에 따른 swapping\ncompile time binding \u0026 load time binding: 다시 swap in 시, 원래 존재하던 메모리 위치로 다시 올라가야 해서 swapping의 효과가 좋지 않다. runtime binding은 추후 빈 메모리 영역 아무 곳에나 프로세스를 올리기 때문에, swapping으로 인한 효과가 좋다. 2.4 동적 연결(Dynamic linking) 연결(linking)이란??\n목적 파일(object file)과 이미 컴파일된 라이브러리 파일을 묶어서 하나의 실행파일을 생성하는 과정 Object file: 프로그래머가 작성한 source code를 컴파일하여 생성된 파일 정적 연결(static linking)과 동적 연결(dynamic linking)의 차이: 첫 번째\n정적 연결: 프로그래머가 작성한 코드와 라이브러리가 모두 합쳐진 상태에서 실행파일이 생성되는 방식으로, 연결된 상태에서 실행파일을 생성하는 방식\n라이브러리가 프로그램의 실행 파일 코드에 포함되어, 실행파일의 크기가 상대적으로 크다. 동적 연결 : 라이브러리를 포함하지 않는 생성된 실행 파일이 라이브버리 호출 시 , 연결이 이뤄지는 방식\n그래서 라이브러리의 위치를 찾기 위해 라이브러리 호출 부분에 stub 이라는 작은 코드를 둔다. 이 stub을 통해 해당 라이브러리 루틴이 메모리에 이미 존재하는지 먼저 살펴본다. 메모리에 이미 존재 -\u003e 그 메모리 위치에서 직접 참조 메모리에 없음 -\u003e 디스크에서 읽어옴 정적 연결(static linking)과 동적 연결(dynamic linking)의 차이: 두 번째\n정적 연결: 첫 번째 차이점으로 인해 동일한 라이브러리를 각 프로세스가 개별적으로 메모리에 적재해야 하므로, 물리적 메모리가 낭비된다.\n동일한 라이브러리 코드여도 각 프로세스의 주소 공간에 독자적으로 존재하는 코드이므로 별도의 적재가 필요하다. 그 결과, 메모리 낭비가 심하다. 동적 연결: 라이브러리를 호출하면 되므로 메모리에 한 번만 적재하여 낭비 X\n공용으로 쓰는 라이브러리를 shared library 라 한다. Summary\n특징 정적 연결 동적 연결 연결 시기 실행 파일 생성 전 실행 파일 생성 후, 호출 적재 횟수 각 프로세스 개별적으로 메모리에 한 번만 실행 파일에 라이브러리 포함 유무 O X 메모리 낭비 발생 O X 3. 물리적 메모리의 할당 방식 물리적 메모리 할당 방식과 사용자 영역 관리 방식은 다음과 같다. 3.1 연속할당(Contiguous allocation) 방식 프로세스를 메모리에 올릴 때, 주소 공간을 여러 개로 분할하지 않고, 메모리의 한 곳에 연속적으로 적재하는 방식\n고정분할 방식 과 가변분할 방식 으로 나눠진다. 연속적으로 할당하기 때문에 물리적 메모리 주소로 mapping 하는 게 쉽다. 연속 할당 기법에서는 프로세스의 주소 공간 전체를 담을 수 있는 가용공간을 찾아야 한다. 가용 공간(hole) : 사용되지 않은 메모리 공간으로, 메모리 내의 여러 곳에서 산발적으로 존재할 수 있다. 이 가용공간(hole)은 물리적 메모리 내부에 산발적으로 존재하기 때문에, 효율적으로 관리하기 위해서 운영체제는 사용 중인 공간과 가용 공간에 대한 정보를 각각 유지한다. 3.1.1 고정분할(Fixed partition) 방식 물리적 메모리를 영구적인 분할(partition)로 미리 나누어두고, 각 분할에 오직 하나의 프로세스만을 적재해 실행하는 방식\n이에 따라 다음과 같은 특징을 가진다.\n미리 나누는 분할의 크기는 다 동일할 수도 있고, 다르게 할 수도 있다. 동시에 메모리에 올릴 수 있는 프로그램의 수가 고정되었다. 수행 가능한 프로그램의 최대 크기 또한 제한된다. 외부 조각(external fragmentation)과 내부 조각(internal fragmentation)이 발생한다. 외부 조각과 내부 조각에 대해 알아보자.\n조각 종류 외부 조각 내부 조각 When 프로그램 크기 \u003e 분할 크기 프로그램 크기 \u003c 분할 크기 할당 유무 할당하지 않은 조각 할당된 조각 외부 조각: 프로그램의 크기가 분할 크기보다 커서 프로그램을 적재하지 못하여 발생하는 메모리 공간 하지만, 분할 크기보다 작은 프로그램이 도착하면 이 외부조각에 적재할 수 있다. 내부 조각: 하나의 분할에 프로그램을 적재한 후, 남아서 사용되지 않는 메모리 공간 남은 공간에 충분히 적재할 수 있는 프로그램이 있을지라도, 이미 할당된 조각이므로 다른 프로그램에 할당할 수 없다. 3.1.2 가변분할(Variable partition) 방식 미리 분할시키는 것이 아닌 프로그램이 실행될 때마다 메모리에 순서대로 차곡차곡 쌓는 방식 그래서, 분할의 크기, 개수가 동적으로 변한다. 현대의 컴퓨터가 사용하는 방식 분할의 크기를 프로그램 크기보다 일부러 크게 할당하지 않기 때문에, 내부조각이 발생하지 않는다.\nProblem 1:외부조각\n메모리에 존재하는 프로그램이 종료될 경우, 중간에 빈 공간이 발생하는데, 이 공간이 새로 시작하는 프로그램보다 작을 경우 외부조각이 발생할 가능성이 있다. Solution 1: Compaction\n외부조각 같은 hole을 해결하는 방법으로 컴팩션(compaction) 을 사용한다. Compaction이란??? 물리적 메모리 중에서 프로세스에 의해 사용 중인 메모리 영역을 한 쪽으로 몰고, 가용 공간들을 다른 한쪽으로 모아서 하나의 큰 가용공간을 만드는 방법 메모리 위치를 상당 부분 이동해야 해서 비용이 매우 많이 들기 때문에, 최소한의 메모리 이동으로 얻을려고 한다. 또한, 수행 중인 프로세스의 물리적 메모리 위치를 옮겨야 하므로, 실행 도중 프로세스 주소를 동적으로 바꿀 수 있는 run time binding 방식을 지원하는 환경에서만 수행할 수 있다. Problem 2: 동적 메모리 할당 문제(Dynamic storage-allocation problem)\nsize가 n인 프로세스를 메모리 내 가용 공간 중 어떤 위치에 올릴 지 결정하는 문제 Solution 2: 3가지\n아래 3가지 방법들 중 첫 번째와 두 번째가 속도와 공간 이용률 측면에서 효과적이다. 최초적합(first-fit) 방법 size가 n 이상인 것 중 가장 먼저 찾아지는 hole에 프로세스를 할당하는 방법으로, 시간적인 측면에서 효율적이다. 최적적합(best-fit) 방법 size가 n 이상인 가장 작은 hole을 찾아 새로운 프로그램을 할당하는 방법으로, 모든 hole의 리스트를 탐색하므로 시간적 오버헤드가 발생하지만, 공간적인 측면에서는 효율적이다. 최악적합(Worst-fit) 방법 가장 크기가 큰 hole을 찾아 새로운 프로그램을 할당하는 방법으로, 시간적 오버헤드가 발생하고, 가용 공간을 빨리 소진한다. 3.2 불연속할당(Noncontiguous allocation) 기법 물리적 메모리의 여러 위치에 분산되어 올라가는 메모리 할당 기법\n프로그램을 분할하는 기준에 따라 여러 방법으로 나눠진다.\n페이징(paging) 기법: 동일한 크기로 나누어 메모리에 올리는 기법 세그먼테이션(segmentation) 기법: 크기는 일정하지 않지만, 의미 단위로 나누어 메모리에 올리는 기법 페이지드 세그먼테이션(paged segmentation) 기법: segmentation을 기본으로 한 후, paging 기법으로 나누어 메모리에 올리는 기법 그러면 다음 챕터에서 위 3가지 기법들에 대해 알아보자.\nReference 운영체제와 정보기술의 원리 kocw 이화여자대학교 운영체제 - 반효경 교수 - ","wordCount":"1738","inLanguage":"en","datePublished":"2022-04-28T16:13:46+09:00","dateModified":"2022-04-28T16:13:46+09:00","mainEntityOfPage":{"@type":"WebPage","@id":"http://jeha00.github.io/post/os/os_chapter_07_%EB%A9%94%EB%AA%A8%EB%A6%AC%EA%B4%80%EB%A6%AC_1/"},"publisher":{"@type":"Organization","name":"Jeha DevLog","logo":{"@type":"ImageObject","url":"http://jeha00.github.io/favicon.ico"}}}</script></head><body class=dark id=top><script>localStorage.getItem("pref-theme")==="light"&&document.body.classList.remove("dark")</script><header class=header><nav class=nav><div class=logo><a href=http://jeha00.github.io/ accesskey=h title="@Jeha00 (Alt + H)">@Jeha00</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></span></div><ul id=menu><li><a href=http://jeha00.github.io/me/ title=About><span>About</span></a></li><li><a href=http://jeha00.github.io/archives/ title=Archive><span>Archive</span></a></li><li><a href=http://jeha00.github.io/categories/ title=Categories><span>Categories</span></a></li><li><a href=http://jeha00.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=http://jeha00.github.io/>Home</a>&nbsp;»&nbsp;<a href=http://jeha00.github.io/post/>Posts</a></div><h1 class=post-title>[TIL] OS Chapter 07: 메모리 관리 1</h1><div class=post-meta><span title='2022-04-28 16:13:46 +0900 KST'>April 28, 2022</span>&nbsp;|&nbsp;<a href=https://github.com/JeHa00/blog/content/post/OS/OS_Chapter_07_%eb%a9%94%eb%aa%a8%eb%a6%ac%ea%b4%80%eb%a6%ac_1.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#0-introduction aria-label="0. Introduction">0. Introduction</a></li><li><a href=#1-%ec%a3%bc%ec%86%8caddress-%eb%b0%94%ec%9d%b8%eb%94%a9 aria-label="1. 주소(address) 바인딩">1. 주소(address) 바인딩</a><ul><li><a href=#11-%ec%a3%bc%ec%86%8c%eb%9e%80 aria-label="1.1 주소란??">1.1 주소란??</a></li><li><a href=#12-%eb%85%bc%eb%a6%ac%ec%a0%81-%ec%a3%bc%ec%86%8c-%eb%ac%bc%eb%a6%ac%ec%a0%81-%ec%a3%bc%ec%86%8c aria-label="1.2 논리적 주소, 물리적 주소">1.2 논리적 주소, 물리적 주소</a></li><li><a href=#13-%ec%a3%bc%ec%86%8c-%eb%b0%94%ec%9d%b8%eb%94%a9address-binding aria-label="1.3 주소 바인딩(address binding)">1.3 주소 바인딩(address binding)</a></li><li><a href=#14-mmu-%ea%b8%b0%eb%b2%95mmu-scheme aria-label="1.4 MMU 기법(MMU scheme)">1.4 MMU 기법(MMU scheme)</a></li></ul></li><li><a href=#2-%eb%a9%94%eb%aa%a8%eb%a6%ac-%ea%b4%80%eb%a6%ac%ec%99%80-%ea%b4%80%eb%a0%a8%eb%90%9c-%ec%9a%a9%ec%96%b4 aria-label="2. 메모리 관리와 관련된 용어">2. 메모리 관리와 관련된 용어</a><ul><li><a href=#21-%eb%8f%99%ec%a0%81-%eb%a1%9c%eb%94%a9dynamic-loading aria-label="2.1 동적 로딩(Dynamic loading)">2.1 동적 로딩(Dynamic loading)</a></li><li><a href=#22-%ec%a4%91%ec%b2%a9overlays aria-label="2.2 중첩(overlays)">2.2 중첩(overlays)</a></li><li><a href=#23-%ec%8a%a4%ec%99%80%ed%95%91swapping aria-label="2.3 스와핑(Swapping)">2.3 스와핑(Swapping)</a></li><li><a href=#24-%eb%8f%99%ec%a0%81-%ec%97%b0%ea%b2%b0dynamic-linking aria-label="2.4 동적 연결(Dynamic linking)">2.4 동적 연결(Dynamic linking)</a></li></ul></li><li><a href=#3-%eb%ac%bc%eb%a6%ac%ec%a0%81-%eb%a9%94%eb%aa%a8%eb%a6%ac%ec%9d%98-%ed%95%a0%eb%8b%b9-%eb%b0%a9%ec%8b%9d aria-label="3. 물리적 메모리의 할당 방식">3. 물리적 메모리의 할당 방식</a><ul><li><a href=#31-%ec%97%b0%ec%86%8d%ed%95%a0%eb%8b%b9contiguous-allocation-%eb%b0%a9%ec%8b%9d aria-label="3.1 연속할당(Contiguous allocation) 방식">3.1 연속할당(Contiguous allocation) 방식</a><ul><li><a href=#311-%ea%b3%a0%ec%a0%95%eb%b6%84%ed%95%a0fixed-partition-%eb%b0%a9%ec%8b%9d aria-label="3.1.1 고정분할(Fixed partition) 방식">3.1.1 고정분할(Fixed partition) 방식</a></li><li><a href=#312-%ea%b0%80%eb%b3%80%eb%b6%84%ed%95%a0variable-partition-%eb%b0%a9%ec%8b%9d aria-label="3.1.2 가변분할(Variable partition) 방식">3.1.2 가변분할(Variable partition) 방식</a></li></ul></li><li><a href=#32-%eb%b6%88%ec%97%b0%ec%86%8d%ed%95%a0%eb%8b%b9noncontiguous-allocation-%ea%b8%b0%eb%b2%95 aria-label="3.2 불연속할당(Noncontiguous allocation) 기법">3.2 불연속할당(Noncontiguous allocation) 기법</a></li></ul></li><li><a href=#reference aria-label=Reference>Reference</a></li></ul></div></details></div><div class=post-content><h1 id=0-introduction>0. Introduction<a hidden class=anchor aria-hidden=true href=#0-introduction>#</a></h1><ul><li>해당 내용은 <a href="http://www.kyobobook.co.kr/product/detailViewKor.laf?ejkGb=KOR&mallGb=KOR&barcode=9791158903589&orderClick=LAG&Kc=">운영체제와 정보기술의 원리 -반효경 지음-</a> 와 <a href="http://www.kocw.net/home/cview.do?lid=3dd1117c48123b8e">kocw 이화여자대학교 운영체제 - 반효경 교수 -</a>를 보고 정리한 내용이다.</li><li>정확하지 않은 내용이 있다면 말씀해주시면 감사하겠습니다.</li></ul><p> </p><ul><li>이번 chapter 내용인 메모리 관리는 물리적인 메모리 관리로, 주요 내용은 address binding이다.</li><li>address binding에서의 OS의 역할은 없고, 다 HW가 해야한다.</li><li>address binding을 할 때마다 OS에게 CPU 제어권을 양도해도, 결국 물리적 메모리에 instruction을 실행하는 건 CPU다. 그래서 HW가 해야한다.</li></ul><p> </p><hr><h1 id=1-주소address-바인딩>1. 주소(address) 바인딩<a hidden class=anchor aria-hidden=true href=#1-주소address-바인딩>#</a></h1><p> </p><h2 id=11-주소란>1.1 주소란??<a hidden class=anchor aria-hidden=true href=#11-주소란>#</a></h2><blockquote><ul><li>서로 다른 위치를 구분하기 위해 사용하는 일련의 숫자</li><li>크게 논리적 주소와 물리적 주소로 나뉠 수 있다.</li></ul></blockquote><ul><li><strong>Memory는 주소를 통해 접근하는 저장장치다.</strong></li><li><strong>컴퓨터 시스템은 32bit 혹은 64bit의 주소체계를 사용하는데,</strong><ul><li>32bit는 2^(32) 가지, 64bit는 2^(64) 가지의 서로 다른 메모리 위치를 구분할 수 있다.</li></ul></li><li><strong>byte 단위로 메모리 주소를 부여한다.</strong></li></ul><p> </p><h2 id=12-논리적-주소-물리적-주소>1.2 논리적 주소, 물리적 주소<a hidden class=anchor aria-hidden=true href=#12-논리적-주소-물리적-주소>#</a></h2><ul><li><p><strong>논리적 주소(logical address, virtual address)란?</strong></p><ul><li>프로세스마다 독립적으로 가지는 주소 공간</li><li>각 프로세스마다 0번지부터 시작</li><li>CPU가 보는 주소는 logical address<ul><li>Why? 물리적 메모리에 올라오는 위치는 달라도 코드 상의 내용은 compile 시 내용.</li></ul></li></ul></li><li><p><strong>물리적 주소(physical address)란?</strong></p><ul><li>메모리에 실제로 올라가는 위치</li><li>물리적 주소의 낮은 주소 영역에는 kernel이 올라간다.</li><li>물리적 주소의 높은 주소 영역에는 user process들이 올라간다.</li></ul></li><li><p><strong>프로세스가 실행되기 위해서</strong></p><ul><li>해당 프로그램이 물리적 메모리에 올라가 있어야 한다.</li><li>해당 논리적 주소가 물리적 메모리의 어느 위치에 매핑되는지 확인해야 한다.</li></ul></li></ul><p> </p><h2 id=13-주소-바인딩address-binding>1.3 주소 바인딩(address binding)<a hidden class=anchor aria-hidden=true href=#13-주소-바인딩address-binding>#</a></h2><blockquote><p>logical address를 physical address로 연결시켜서, physical address를 결정하는 작업</p></blockquote><ul><li>Symbolic address &ndash;(compile)&ndash;> Logical address &ndash;(address binding)&ndash;> Physical address</li></ul><p><img loading=lazy src=https://user-images.githubusercontent.com/78094972/164484385-69a85293-56f5-455a-b08b-1611d24335d2.PNG alt=image></p><ul><li><p><strong>주소 바인딩 방식 3가지</strong>: 물리적 메모리 주소가 결정되는 시기에 따라 분류된다.</p><ul><li>컴파일 타임 바인딩(compile time binding)</li><li>로드 타임 바인딩(load time binding)</li><li>실행시간 바인딩(execution time binding or run time binding)<table><thead><tr><th>방식 이름</th><th>compile time binding</th><th>load time binding</th><th>run time binding</th></tr></thead><tbody><tr><td>시기</td><td>컴파일 시</td><td>프로그램 실행이 시작 시 (변경 가능 X)</td><td>프로그램 실행이 시작 시, (변경 가능 O)</td></tr><tr><td>swapping 효과</td><td>좋지 않음</td><td>좋지 않음</td><td>좋음</td></tr></tbody></table></li></ul></li><li><p><strong>Compile time binding</strong></p><ul><li>컴파일 시, 논리적인 주소와 물리적인 주소 다 생성된다.</li><li>compiler는 <em>절대 코드</em> 를 생성한다.<ul><li>그래서 program이 올라가 있는 물리적 메모리의 시작위치를 변경할려면 컴파일을 다시 해야 한다.</li></ul></li><li>물리적 주소의 0번지부터 시작한다.</li><li>현대의 시분할 컴퓨터 환경에서는 잘 사용하지 않는 기법</li></ul></li><li><p><strong>Load time binding</strong></p><ul><li>컴파일 시에는 논리적인 주소만 결정된다.</li><li>이를 실행하고 나서, 메모리가 비어있는 곳부터 올린다.</li><li>로더(loader)의 책임 하에 물리적 메모리 주소 부여<ul><li>Loader: user program을 memory에 적재시키는 프로그램</li></ul></li><li>compiler가 <em>재배치 가능 코드</em> 를 생성한 경우 가능</li></ul></li><li><p><strong>Run time binding</strong></p><ul><li>Load time binding 처럼 실행 시, physical address가 생성된다.</li><li>실행을 시작한 후에도 물리적 메모리상의 위치(물리적 주소)를 옮길 수 있는 방식</li><li>CPU가 주소 참조 시, address mapping table을 이용해 원하는 데이터가 물리적 메모리의 어느 위치에 존재하는지 확인한다.</li><li><code>MMU(Memory Management Unit)</code> 라는 하드웨어적 지원이 필요</li></ul></li></ul><p> </p><h2 id=14-mmu-기법mmu-scheme>1.4 MMU 기법(MMU scheme)<a hidden class=anchor aria-hidden=true href=#14-mmu-기법mmu-scheme>#</a></h2><blockquote><p>기준 레지스터를 사용하여 logical에서 physical address로 mapping해주는 HW device</p></blockquote><ul><li><p><strong>가정</strong></p><ul><li>프로그램의 주소 공간이 메모리의 한 장소에 연속적으로 적재되는 걸 가정한다.</li></ul></li><li><p><strong>MMU scheme</strong></p><ul><li>사용자 프로세스가 CPU에서 수행되여 생성해내는 모든 논리적 주소값에 대해 <strong><em>base register(= relocation register)</em></strong> 의 값을 더하여 물리적 주소값을 얻어낸다.</li><li><em>base register</em> = CPU가 사용하려는 프로세스의 물리적 메모리 시작 주소</li></ul></li></ul><p><img loading=lazy src=https://user-images.githubusercontent.com/78094972/165417203-6204b9ba-09a6-4433-838c-4fb697d183a3.PNG alt=image></p><ul><li><p><strong>user program</strong></p><ul><li><em>logical address</em> 만을 다룬다.</li><li>실제 <em>physical address</em> 를 볼 수 없으며, 알 필요가 없다.</li></ul></li><li><p><strong>예시</strong></p><ul><li>CPU가 논리적 주소: 123번지 정보를 요청</li><li>기준 레지스터(=재배치 레지스터): 23000</li><li>물리적 주소 = 123 + 23000 = 23123</li><li>물리적 주소 23123번지에서 CPU가 요청한 정보를 찾는다.</li><li>논리적 주소란 기준 레지스터로부터 얼마나 떨어져 있는지를 나타내는 것</li></ul></li><li><p><strong>동일한 논리적 주소</strong></p><ul><li>프로세스는 각 자신만의 고유한 주소 공간을 가진다.</li><li>그래서 동일한 논리적 주소라고 할 지라도, 서로 다른 내용을 담는다.</li><li><em>MMU 기법에서 프로세스가 바뀔 때마다 기준 레지스터의 값을 바뀌는 프로세스에 해당되는 값으로 재설정한다.</em></li></ul></li><li><p><strong>메모리 보안</strong></p><ul><li>Problem<ul><li>가상 메모리에 기준 레지스터를 더했을 때, 해당 프로세스의 주소 공간을 벗어나는 경우, 다른 프로세스 영역에 침범하거나, kernel 영역을 변경해 치명적인 결과를 초래할 수 있다.</li></ul></li><li>Solution<ul><li><strong><em>한계 레지스터(limit register)</em></strong> 를 사용하여, 프로세스 자신의 주소 공간을 넘어서는 메모리 참조를 하는지 확인한다.<ul><li><strong><em>한계 레지스터(limit register)</em></strong>: 논리적 주소의 범위</li></ul></li><li>벗어날 경우, trap을 발생시켜 해당 프로세스를 강제종료시킨다.</li></ul></li></ul></li></ul><p><img loading=lazy src=https://user-images.githubusercontent.com/78094972/165416345-7ee411ec-ad78-4bf0-b2ec-4849c3598f71.PNG alt=image></p><p> </p><hr><h1 id=2-메모리-관리와-관련된-용어>2. 메모리 관리와 관련된 용어<a hidden class=anchor aria-hidden=true href=#2-메모리-관리와-관련된-용어>#</a></h1><p> </p><h2 id=21-동적-로딩dynamic-loading>2.1 동적 로딩(Dynamic loading)<a hidden class=anchor aria-hidden=true href=#21-동적-로딩dynamic-loading>#</a></h2><blockquote><ul><li>다중 프로그래밍 환경에서 메모리를 효율적으로 사용하기 위한 기법</li><li>프로세스의 주소 공간 전체를 메모리에 다 올려놓는 게 아닌, 해당 부분이 불릴 때에마다 그 부분만 메모리에 적재하는 방식: 연속 할당에 해당되지 않는다.</li></ul></blockquote><ul><li><strong>loading: 물리적 메모리로 올리는 것</strong></li><li><strong>부분적으로만 올리는 이유</strong><ul><li>실제 프로그램의 코드 중 상당 부분 = 가끔씩 사용하는 방어용 코드 -> 주소 공간 전체 loading -> 메모리 낭비 초래</li></ul></li><li><strong>동적 로딩 -> 더 많은 프로그램 로딩 가능 -> 메모리 이용 효율성 향상</strong></li><li>운영체제 지원 없이 개발자가 코드로 구현 가능하고, OS는 라이브러리를 통해 지원 가능</li></ul><p> </p><h2 id=22-중첩overlays>2.2 중첩(overlays)<a hidden class=anchor aria-hidden=true href=#22-중첩overlays>#</a></h2><blockquote><p>메모리보다 큰 프로세스를 실행하기 위해서, 프로세스의 주소 공간을 분할해 실제 필요한 부분만을 메모리에 적재하는 기법</p></blockquote><ul><li><strong>중첩과 동적 로딩의 차이점: 목적</strong><ul><li>동적 로딩의 목적: 메모리에 multi-process를 실행하기 위한 용도</li><li>중첩의 목적: single-process를 실행하기 위한 환경에서 메모리 용량보다 큰 프로세스를 실행하기 위한 용도</li><li>운영체제의 지원 없이 프로그래머가 직접 구현해야 한다.</li></ul></li></ul><p> </p><h2 id=23-스와핑swapping>2.3 스와핑(Swapping)<a hidden class=anchor aria-hidden=true href=#23-스와핑swapping>#</a></h2><blockquote><p>프로세스의 주소 공간 전체를 메모리에서 backing store로 쫓아내는 것</p></blockquote><ul><li><p><strong>스왑 영역(Swap area)란??</strong></p><ul><li>다른 말로 <em>백킹 스토어(backing store)</em> 라고 한다.</li><li>디스크 내의 파일 시스템과는 별도로 존재하는 일정 영역으로,<ul><li><strong>파일 시스템</strong> 은 전원이 나가도 유지되어야 하는 비휘발성 저장공간이지만,</li><li><strong>스왑 영역</strong> 은 프로세스가 수행 중인 동안에만 디스크에 일시적으로 저장하는 휘발성 영역이다.</li><li>프로세스 실행이 종료되면 메모리에서 디스크로 내려놓는다. (swap out)</li></ul></li><li>그리고, 다음과 같은 특징을 가져야 한다.<ul><li>다수의 사용자 프로세스를 담을 수 있을 만큼 충분히 큰 저장 공간이다.</li><li>어느 정도의 접근 속도가 보장되야 한다.</li></ul></li></ul></li><li><p><strong>Swap in & out</strong></p><ul><li>Swap in: disk -> memory 올리는 작업</li><li>Swap out: memory -> disk 내리는 작업</li></ul></li><li><p><strong>스와핑이 일어나는 과정</strong></p><ul><li><p>첫 번째: <em>Swapper라 불리는 중기 스케쥴러</em> 에 의해 swap out할 process를 선정.</p><ul><li>선정 기준: priority<ul><li>priority가 낮은 프로세스를 swap out</li><li>priority가 높은 프로세스를 swap in</li></ul></li></ul></li><li><p>두 번째: 선정된 process를 메모리에 올라간 주소 공간 전체 내용을 disk swap area로 아웃시켜서 메모리의 프로세스 수를 조절한다.</p><ul><li><p>즉, Swapper로 멀티 프로그래밍 정도(degree of multi-programming)를 조절한다.</p></li><li><p>메모리에 많은 프로그램이 올라오면 할당되는 메모리 양이 지나치게 적어져, 시스템 전체 성능이 감소되기 때문이다.</p></li></ul></li><li><p><strong>Swap time</strong></p><ul><li>Swap time: swapping에 소요되는 시간</li><li>Transfer time: 데이터를 읽고 쓰는 전송 시간</li><li>Swap time은 디스크를 탐색하는 것보다 disk sector에서 transfer time이 대부분을 차지한다.</li><li>즉, transfer time 은 swap 되는 양에 비례</li></ul></li></ul></li><li><p><strong>address binding에 따른 swapping</strong></p><ul><li>compile time binding & load time binding: 다시 swap in 시, 원래 존재하던 메모리 위치로 다시 올라가야 해서 swapping의 효과가 좋지 않다.</li><li>runtime binding은 추후 빈 메모리 영역 아무 곳에나 프로세스를 올리기 때문에, swapping으로 인한 효과가 좋다.</li></ul></li></ul><p> </p><h2 id=24-동적-연결dynamic-linking>2.4 동적 연결(Dynamic linking)<a hidden class=anchor aria-hidden=true href=#24-동적-연결dynamic-linking>#</a></h2><ul><li><p><strong>연결(linking)이란??</strong></p><ul><li>목적 파일(object file)과 이미 컴파일된 라이브러리 파일을 묶어서 하나의 실행파일을 생성하는 과정<ul><li>Object file: 프로그래머가 작성한 source code를 컴파일하여 생성된 파일</li></ul></li></ul></li><li><p><strong>정적 연결(static linking)과 동적 연결(dynamic linking)의 차이: 첫 번째</strong></p><ul><li><p><strong>정적 연결</strong>: 프로그래머가 작성한 코드와 라이브러리가 <strong><em>모두 합쳐진 상태에서</em></strong> 실행파일이 생성되는 방식으로, 연결된 상태에서 실행파일을 생성하는 방식</p><ul><li>라이브러리가 프로그램의 실행 파일 코드에 포함되어, 실행파일의 크기가 상대적으로 크다.</li></ul></li><li><p><strong>동적 연결</strong> : <strong><em>라이브러리를 포함하지 않는</em></strong> 생성된 실행 파일이 <strong><em>라이브버리 호출 시</em></strong> , 연결이 이뤄지는 방식</p><ul><li>그래서 라이브러리의 위치를 찾기 위해 라이브러리 호출 부분에 <strong><em>stub</em></strong> 이라는 작은 코드를 둔다.</li><li>이 stub을 통해 해당 라이브러리 루틴이 메모리에 이미 존재하는지 먼저 살펴본다.<ul><li>메모리에 이미 존재 -> 그 메모리 위치에서 직접 참조</li><li>메모리에 없음 -> 디스크에서 읽어옴</li></ul></li></ul></li></ul></li><li><p><strong>정적 연결(static linking)과 동적 연결(dynamic linking)의 차이: 두 번째</strong></p><ul><li><p><strong>정적 연결</strong>: 첫 번째 차이점으로 인해 동일한 라이브러리를 각 프로세스가 <strong><em>개별적으로</em></strong> 메모리에 적재해야 하므로, 물리적 메모리가 낭비된다.</p><ul><li>동일한 라이브러리 코드여도 각 프로세스의 주소 공간에 독자적으로 존재하는 코드이므로 별도의 적재가 필요하다.</li><li>그 결과, 메모리 낭비가 심하다.</li></ul></li><li><p><strong>동적 연결</strong>: 라이브러리를 호출하면 되므로 <strong><em>메모리에 한 번만</em></strong> 적재하여 낭비 X</p><ul><li>공용으로 쓰는 라이브러리를 shared library 라 한다.</li></ul></li></ul></li><li><p><strong>Summary</strong></p><table><thead><tr><th>특징</th><th>정적 연결</th><th>동적 연결</th></tr></thead><tbody><tr><td>연결 시기</td><td>실행 파일 생성 전</td><td>실행 파일 생성 후, 호출</td></tr><tr><td>적재 횟수</td><td>각 프로세스 개별적으로</td><td>메모리에 한 번만</td></tr><tr><td>실행 파일에 라이브러리 포함 유무</td><td>O</td><td>X</td></tr><tr><td>메모리 낭비 발생</td><td>O</td><td>X</td></tr></tbody></table></li></ul><p> </p><hr><h1 id=3-물리적-메모리의-할당-방식>3. 물리적 메모리의 할당 방식<a hidden class=anchor aria-hidden=true href=#3-물리적-메모리의-할당-방식>#</a></h1><ul><li>물리적 메모리 할당 방식과 사용자 영역 관리 방식은 다음과 같다.</li></ul><p><img loading=lazy src=https://user-images.githubusercontent.com/78094972/165253477-335490e5-4c30-49e5-8d87-7aafbd875f5f.PNG alt=image></p><p> </p><h2 id=31-연속할당contiguous-allocation-방식>3.1 연속할당(Contiguous allocation) 방식<a hidden class=anchor aria-hidden=true href=#31-연속할당contiguous-allocation-방식>#</a></h2><blockquote><p>프로세스를 메모리에 올릴 때, 주소 공간을 여러 개로 분할하지 않고, 메모리의 한 곳에 연속적으로 적재하는 방식</p></blockquote><ul><li><strong>고정분할 방식</strong> 과 <strong>가변분할 방식</strong> 으로 나눠진다.</li><li>연속적으로 할당하기 때문에 물리적 메모리 주소로 mapping 하는 게 쉽다.</li><li>연속 할당 기법에서는 <strong><em>프로세스의 주소 공간 전체를</em></strong> 담을 수 있는 가용공간을 찾아야 한다.<ul><li><strong>가용 공간(hole)</strong> : 사용되지 않은 메모리 공간으로, 메모리 내의 여러 곳에서 산발적으로 존재할 수 있다.</li></ul></li><li>이 가용공간(hole)은 물리적 메모리 내부에 산발적으로 존재하기 때문에, 효율적으로 관리하기 위해서 운영체제는 사용 중인 공간과 가용 공간에 대한 정보를 각각 유지한다.</li></ul><p> </p><h3 id=311-고정분할fixed-partition-방식>3.1.1 고정분할(Fixed partition) 방식<a hidden class=anchor aria-hidden=true href=#311-고정분할fixed-partition-방식>#</a></h3><blockquote><p>물리적 메모리를 영구적인 분할(partition)로 미리 나누어두고, 각 분할에 오직 하나의 프로세스만을 적재해 실행하는 방식</p></blockquote><ul><li><p><strong>이에 따라 다음과 같은 특징을 가진다.</strong></p><ul><li>미리 나누는 분할의 크기는 다 동일할 수도 있고, 다르게 할 수도 있다.</li><li>동시에 메모리에 올릴 수 있는 프로그램의 수가 고정되었다.</li><li>수행 가능한 프로그램의 최대 크기 또한 제한된다.</li><li>외부 조각(external fragmentation)과 내부 조각(internal fragmentation)이 발생한다.</li></ul></li><li><p><strong>외부 조각과 내부 조각에 대해 알아보자.</strong></p><table><thead><tr><th>조각 종류</th><th>외부 조각</th><th>내부 조각</th></tr></thead><tbody><tr><td>When</td><td>프로그램 크기 > 분할 크기</td><td>프로그램 크기 &lt; 분할 크기</td></tr><tr><td>할당 유무</td><td>할당하지 않은 조각</td><td>할당된 조각</td></tr></tbody></table><ul><li>외부 조각:<ul><li>프로그램의 크기가 분할 크기보다 커서 프로그램을 적재하지 못하여 발생하는 메모리 공간</li><li>하지만, 분할 크기보다 작은 프로그램이 도착하면 이 외부조각에 적재할 수 있다.</li></ul></li><li>내부 조각:<ul><li>하나의 분할에 프로그램을 적재한 후, 남아서 사용되지 않는 메모리 공간</li><li>남은 공간에 충분히 적재할 수 있는 프로그램이 있을지라도, 이미 할당된 조각이므로 다른 프로그램에 할당할 수 없다.</li></ul></li></ul></li></ul><p><img loading=lazy src=https://user-images.githubusercontent.com/78094972/165446743-8ba76f95-5c65-48ed-a700-650bf3d40607.PNG alt=image></p><p> </p><h3 id=312-가변분할variable-partition-방식>3.1.2 가변분할(Variable partition) 방식<a hidden class=anchor aria-hidden=true href=#312-가변분할variable-partition-방식>#</a></h3><blockquote><ul><li>미리 분할시키는 것이 아닌 프로그램이 실행될 때마다 메모리에 순서대로 차곡차곡 쌓는 방식</li><li>그래서, 분할의 크기, 개수가 동적으로 변한다.</li><li>현대의 컴퓨터가 사용하는 방식</li></ul></blockquote><ul><li><p>분할의 크기를 프로그램 크기보다 일부러 크게 할당하지 않기 때문에, <strong>내부조각이 발생하지 않는다.</strong></p></li><li><p><strong>Problem 1:외부조각</strong></p><ul><li>메모리에 존재하는 프로그램이 종료될 경우, 중간에 빈 공간이 발생하는데,</li><li>이 공간이 새로 시작하는 프로그램보다 작을 경우 <strong>외부조각이 발생할 가능성</strong>이 있다.</li></ul></li><li><p><strong>Solution 1: Compaction</strong></p><ul><li>외부조각 같은 hole을 해결하는 방법으로 <strong><em>컴팩션(compaction)</em></strong> 을 사용한다.<ul><li>Compaction이란???<ul><li>물리적 메모리 중에서 프로세스에 의해 사용 중인 메모리 영역을 한 쪽으로 몰고, 가용 공간들을 다른 한쪽으로 모아서 하나의 큰 가용공간을 만드는 방법</li></ul></li></ul></li><li>메모리 위치를 상당 부분 이동해야 해서 <strong>비용이 매우 많이 들기 때문에</strong>, 최소한의 메모리 이동으로 얻을려고 한다.</li><li>또한, 수행 중인 프로세스의 물리적 메모리 위치를 옮겨야 하므로, 실행 도중 프로세스 주소를 동적으로 바꿀 수 있는 <strong><code>run time binding</code> 방식을 지원하는 환경에서만 수행</strong>할 수 있다.</li></ul></li><li><p><strong>Problem 2: 동적 메모리 할당 문제(Dynamic storage-allocation problem)</strong></p><ul><li>size가 n인 프로세스를 메모리 내 가용 공간 중 어떤 위치에 올릴 지 결정하는 문제</li></ul></li><li><p><strong>Solution 2: 3가지</strong></p><ul><li>아래 3가지 방법들 중 첫 번째와 두 번째가 속도와 공간 이용률 측면에서 효과적이다.</li><li>최초적합(first-fit) 방법<ul><li>size가 n 이상인 것 중 <strong>가장 먼저 찾아지는 hole</strong>에 프로세스를 할당하는 방법으로,</li><li>시간적인 측면에서 효율적이다.</li></ul></li><li>최적적합(best-fit) 방법<ul><li>size가 n 이상인 <strong>가장 작은 hole</strong>을 찾아 새로운 프로그램을 할당하는 방법으로,</li><li>모든 hole의 리스트를 탐색하므로 시간적 오버헤드가 발생하지만,</li><li>공간적인 측면에서는 효율적이다.</li></ul></li><li>최악적합(Worst-fit) 방법<ul><li><strong>가장 크기가 큰 hole</strong>을 찾아 새로운 프로그램을 할당하는 방법으로,</li><li>시간적 오버헤드가 발생하고, 가용 공간을 빨리 소진한다.</li></ul></li></ul></li></ul><p> </p><h2 id=32-불연속할당noncontiguous-allocation-기법>3.2 불연속할당(Noncontiguous allocation) 기법<a hidden class=anchor aria-hidden=true href=#32-불연속할당noncontiguous-allocation-기법>#</a></h2><blockquote><p>물리적 메모리의 여러 위치에 <strong>분산되어</strong> 올라가는 메모리 할당 기법</p></blockquote><ul><li><p><strong>프로그램을 분할하는 기준에 따라 여러 방법으로 나눠진다.</strong></p><ul><li>페이징(paging) 기법: 동일한 크기로 나누어 메모리에 올리는 기법</li><li>세그먼테이션(segmentation) 기법: 크기는 일정하지 않지만, 의미 단위로 나누어 메모리에 올리는 기법</li><li>페이지드 세그먼테이션(paged segmentation) 기법: segmentation을 기본으로 한 후, paging 기법으로 나누어 메모리에 올리는 기법</li></ul></li><li><p>그러면 다음 챕터에서 위 3가지 기법들에 대해 알아보자.</p></li></ul><p> </p><hr><h1 id=reference>Reference<a hidden class=anchor aria-hidden=true href=#reference>#</a></h1><ul><li><a href="http://www.kyobobook.co.kr/product/detailViewKor.laf?ejkGb=KOR&mallGb=KOR&barcode=9791158903589&orderClick=LAG&Kc=">운영체제와 정보기술의 원리</a></li><li><a href="http://www.kocw.net/home/cview.do?lid=3dd1117c48123b8e">kocw 이화여자대학교 운영체제 - 반효경 교수 -</a></li></ul></div><footer class=post-footer><ul class=post-tags><li><a href=http://jeha00.github.io/tags/til/>TIL</a></li><li><a href=http://jeha00.github.io/tags/os/>OS</a></li></ul><nav class=paginav><a class=prev href=http://jeha00.github.io/post/os/os_chapter_07_%EB%A9%94%EB%AA%A8%EB%A6%AC%EA%B4%80%EB%A6%AC_2/><span class=title>« Prev Page</span><br><span>[TIL] OS Chapter 07: 메모리 관리 2</span></a>
<a class=next href=http://jeha00.github.io/post/os/os_chapter_06_cpu_scheduling/><span class=title>Next Page »</span><br><span>[TIL] OS Chapter 06: CPU scheduling</span></a></nav><div class=share-buttons><a target=_blank rel="noopener noreferrer" aria-label="share [TIL] OS Chapter 07: 메모리 관리 1 on twitter" href="https://twitter.com/intent/tweet/?text=%5bTIL%5d%20OS%20Chapter%2007%3a%20%eb%a9%94%eb%aa%a8%eb%a6%ac%20%ea%b4%80%eb%a6%ac%201&url=http%3a%2f%2fjeha00.github.io%2fpost%2fos%2fos_chapter_07_%25EB%25A9%2594%25EB%25AA%25A8%25EB%25A6%25AC%25EA%25B4%2580%25EB%25A6%25AC_1%2f&hashtags=TIL%2cOS"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM195.519 424.544c135.939.0 210.268-112.643 210.268-210.268.0-3.218.0-6.437-.153-9.502 14.406-10.421 26.973-23.448 36.935-38.314-13.18 5.824-27.433 9.809-42.452 11.648 15.326-9.196 26.973-23.602 32.49-40.92-14.252 8.429-30.038 14.56-46.896 17.931-13.487-14.406-32.644-23.295-53.946-23.295-40.767.0-73.87 33.104-73.87 73.87.0 5.824.613 11.494 1.992 16.858-61.456-3.065-115.862-32.49-152.337-77.241-6.284 10.881-9.962 23.601-9.962 37.088.0 25.594 13.027 48.276 32.95 61.456-12.107-.307-23.448-3.678-33.41-9.196v.92c0 35.862 25.441 65.594 59.311 72.49-6.13 1.686-12.72 2.606-19.464 2.606-4.751.0-9.348-.46-13.946-1.38 9.349 29.426 36.628 50.728 68.965 51.341-25.287 19.771-57.164 31.571-91.8 31.571-5.977.0-11.801-.306-17.625-1.073 32.337 21.15 71.264 33.41 112.95 33.41z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share [TIL] OS Chapter 07: 메모리 관리 1 on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&url=http%3a%2f%2fjeha00.github.io%2fpost%2fos%2fos_chapter_07_%25EB%25A9%2594%25EB%25AA%25A8%25EB%25A6%25AC%25EA%25B4%2580%25EB%25A6%25AC_1%2f&title=%5bTIL%5d%20OS%20Chapter%2007%3a%20%eb%a9%94%eb%aa%a8%eb%a6%ac%20%ea%b4%80%eb%a6%ac%201&summary=%5bTIL%5d%20OS%20Chapter%2007%3a%20%eb%a9%94%eb%aa%a8%eb%a6%ac%20%ea%b4%80%eb%a6%ac%201&source=http%3a%2f%2fjeha00.github.io%2fpost%2fos%2fos_chapter_07_%25EB%25A9%2594%25EB%25AA%25A8%25EB%25A6%25AC%25EA%25B4%2580%25EB%25A6%25AC_1%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share [TIL] OS Chapter 07: 메모리 관리 1 on reddit" href="https://reddit.com/submit?url=http%3a%2f%2fjeha00.github.io%2fpost%2fos%2fos_chapter_07_%25EB%25A9%2594%25EB%25AA%25A8%25EB%25A6%25AC%25EA%25B4%2580%25EB%25A6%25AC_1%2f&title=%5bTIL%5d%20OS%20Chapter%2007%3a%20%eb%a9%94%eb%aa%a8%eb%a6%ac%20%ea%b4%80%eb%a6%ac%201"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share [TIL] OS Chapter 07: 메모리 관리 1 on facebook" href="https://facebook.com/sharer/sharer.php?u=http%3a%2f%2fjeha00.github.io%2fpost%2fos%2fos_chapter_07_%25EB%25A9%2594%25EB%25AA%25A8%25EB%25A6%25AC%25EA%25B4%2580%25EB%25A6%25AC_1%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share [TIL] OS Chapter 07: 메모리 관리 1 on whatsapp" href="https://api.whatsapp.com/send?text=%5bTIL%5d%20OS%20Chapter%2007%3a%20%eb%a9%94%eb%aa%a8%eb%a6%ac%20%ea%b4%80%eb%a6%ac%201%20-%20http%3a%2f%2fjeha00.github.io%2fpost%2fos%2fos_chapter_07_%25EB%25A9%2594%25EB%25AA%25A8%25EB%25A6%25AC%25EA%25B4%2580%25EB%25A6%25AC_1%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share [TIL] OS Chapter 07: 메모리 관리 1 on telegram" href="https://telegram.me/share/url?text=%5bTIL%5d%20OS%20Chapter%2007%3a%20%eb%a9%94%eb%aa%a8%eb%a6%ac%20%ea%b4%80%eb%a6%ac%201&url=http%3a%2f%2fjeha00.github.io%2fpost%2fos%2fos_chapter_07_%25EB%25A9%2594%25EB%25AA%25A8%25EB%25A6%25AC%25EA%25B4%2580%25EB%25A6%25AC_1%2f"><svg viewBox="2 2 28 28"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></div></footer></article></main><footer class=footer><span>&copy; 2023 <a href=http://jeha00.github.io/>Jeha DevLog</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerText="copy";function s(){t.innerText="copied!",setTimeout(()=>{t.innerText="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>