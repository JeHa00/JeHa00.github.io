<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>[TIL] OS Chapter 02: Introduction to Operating System | Jeha DevLog</title><meta name=keywords content="TIL,OS"><meta name=description content="운영체제란 무엇이고, 무슨 역할을 하는지, 어떻게 분류되는지, 그리고 CPU, 메모리, 입출력 장치의 대략적인 관리 mechanism에 대해 알아본다."><meta name=author content><link rel=canonical href=http://jeha00.github.io/post/os/os_chapter_02_%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C_%EA%B0%9C%EC%9A%94/><meta name=google-site-verification content="XYZabc"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.min.1e44d58192cbf6d7a4eb649bc43dbc3d4cc432677e5d8adc69b08c34cbe461ac.css integrity="sha256-HkTVgZLL9tek62SbxD28PUzEMmd+XYrcabCMNMvkYaw=" rel="preload stylesheet" as=style><link rel=icon href=http://jeha00.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=http://jeha00.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=http://jeha00.github.io/favicon-32x32.png><link rel=apple-touch-icon href=http://jeha00.github.io/apple-touch-icon.png><link rel=mask-icon href=http://jeha00.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><meta name=generator content="Hugo 0.101.0"><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><script type=application/javascript>var doNotTrack=!1;doNotTrack||(function(e,t,n,s,o,i,a){e.GoogleAnalyticsObject=o,e[o]=e[o]||function(){(e[o].q=e[o].q||[]).push(arguments)},e[o].l=1*new Date,i=t.createElement(n),a=t.getElementsByTagName(n)[0],i.async=1,i.src=s,a.parentNode.insertBefore(i,a)}(window,document,"script","https://www.google-analytics.com/analytics.js","ga"),ga("create","UA-123-45","auto"),ga("send","pageview"))</script><meta property="og:title" content="[TIL] OS Chapter 02: Introduction to Operating System"><meta property="og:description" content="운영체제란 무엇이고, 무슨 역할을 하는지, 어떻게 분류되는지, 그리고 CPU, 메모리, 입출력 장치의 대략적인 관리 mechanism에 대해 알아본다."><meta property="og:type" content="article"><meta property="og:url" content="http://jeha00.github.io/post/os/os_chapter_02_%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C_%EA%B0%9C%EC%9A%94/"><meta property="og:image" content="http://jeha00.github.io/47"><meta property="article:section" content="post"><meta property="article:published_time" content="2022-04-05T17:43:59+09:00"><meta property="article:modified_time" content="2022-04-05T17:43:59+09:00"><meta property="og:site_name" content="JeHa00 DevLog"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="http://jeha00.github.io/47"><meta name=twitter:title content="[TIL] OS Chapter 02: Introduction to Operating System"><meta name=twitter:description content="운영체제란 무엇이고, 무슨 역할을 하는지, 어떻게 분류되는지, 그리고 CPU, 메모리, 입출력 장치의 대략적인 관리 mechanism에 대해 알아본다."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"http://jeha00.github.io/post/"},{"@type":"ListItem","position":2,"name":"[TIL] OS Chapter 02: Introduction to Operating System","item":"http://jeha00.github.io/post/os/os_chapter_02_%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C_%EA%B0%9C%EC%9A%94/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"[TIL] OS Chapter 02: Introduction to Operating System","name":"[TIL] OS Chapter 02: Introduction to Operating System","description":"운영체제란 무엇이고, 무슨 역할을 하는지, 어떻게 분류되는지, 그리고 CPU, 메모리, 입출력 장치의 대략적인 관리 mechanism에 대해 알아본다.","keywords":["TIL","OS"],"articleBody":"0. Introduction 해당 내용은 운영체제와 정보기술의 원리을 보고 혼자 정리한 내용입니다. 정확하지 않은 내용이 있다면 말씀해주시면 감사하겠습니다. 1. 운영체제의 정의 운영체제란? 운영체제(operating system) 란??\n컴퓨터 하드웨어의 바로 윗단에 설치되는 소프트웨어로, 사용자 및 다른 소프트웨어와 하드웨어를 연결하는 소프트웨어 계층이다.\n왜 system이라 하는가??? system은 흔히들 하드웨어를 지칭할 때 주로 사용되는 단어인데, 이 system을 사용한 이유는 운영체제 없이 하드웨어만 있다면 컴퓨터 역할을 할 수 없고, OS와 하드웨어가 같이 있어야 진정한 컴퓨터이기 때문이다.\nkernel이란?? 소프트웨어가 실행되기 위해서는 메모리에 그 프로그램이 올라가야 한다. 운영체제도 하나의 SW이기 때문에, 컴퓨터 하드웨어의 전원이 켜지는 동시에, 메모리에 올라간다. 이 운영체제 SW는 규모가 큰 프로그램이기 때문에, 운영체제 전부를 메모리에 올린다면 메모리 공간 낭비가 심해진다.\n그래서 운영체제 중 항상 필요한 부분만 을 전원이 켜짐과 동시에 메모리에 올려놓고, 그렇지 않은 부분은 필요할 때 메모리로 올려서 사용한다. 메모리에 항상 상주하는 운영체제 부분 을 커널(kernel) 이라 한다. 이 커널을 좁은 의미의 운영체제 라고도 불리며, 넓은 의미의 운영체제 는 utility들(ex: copy)을 광범위하게 포함하는 개념이다.\n2. 운영체제의 기능 하드웨어 그리고 사용자를 위한 운영체제의 역할 운영체제는 사용자 및 다른 소프트웨어와 하드웨어를 연결하는 소프트웨어 계층이라는 관점에서 운영체제의 기능을 생각해보면, 하드웨어를 위한 역할 과 사용자를 위한 역할 로 나눠진다.\n전자 는 사용자를 대신하여 운영체제가 하드웨어인 컴퓨터 시스템 내의 resource를 효율적으로 관리하는 역할 을 말한다.\n후자 는 사용자가 컴퓨터 시스템을 편리하게 사용하도록, 사용자에게 편리한 인터페이스를 제공하는 역할 을 말한다. 하드웨어를 직접 다루는 부분은 운영체제가 대행하여, 사용자 및 프로그램이 이에 대한 내용은 알지 못해도 프로그램을 실행해주는 기능을 말한다.\n❗운영체제의 핵심 역할: 효율적, 균형있게, 안전하게 자원 관리하기 운영체제의 기능은 전자와 후자 중 중요한 핵심기능은 바로 전자 다.\n그래서 운영체제를 자원 관리자(resource manager) 라고도 부른다. 여기서 자원이란 하드웨어 자원(ex: CPU, memory, HDD) 과 소프트웨어 자원을 모두 총칭하는 말이다. 운영체제는 이 자원들을 효율적으로 관리 하여 가장 좋은 성능 을 내도록 만든다.\n하지만, 전체적인 성능을 향상시켜려다보면 일부 프로그램 또는 사용자가 불이익을 당할 수 있다. 그래서 운영체제는 사용자 및 프로그램들 간에 자원이 형평성 있게 분배 되도록 하는 균형자 역할도 함께 수행해야 한다.\n또한, 더 중요한게 사용자와 운영체제 자신을 보호하는 보안 역할을 담당한다. 악의성 프로그램으로 다른 사용자 프로그램에 접근하지 않도록 보안 및 보호 기능을 수행해야 한다.\n3. 운영체제의 분류 운영체제의 분류 중 하나는 multi-processing system 과 single-processing system 이다. CPU가 2개 이상 설치되면 전자, 1개만 설치되면 후자를 말한다. 여기서 분류는 후자를 가정으로 진행된다.\n운영체제의 분류에는 동시 작업을 지원하는지, 다중 사용자를 지원하는지, 실시간(real time)을 지원하는지에 따라 분류된다. 앞에서부터 차근 차근 알아보자.\n첫 번째 분류: 동시 작업의 지원 유무 동시 작업을 지원하는지의 여부에 따라 단일작업(single tasking)용 운영체제와 다중작업(multi tasking)용 운영체제로 나누어볼 수 있다. 각 설명은 다음 표와 같다.\n운영체제 분류 동시 작업 지원 유무 예시 single tasking X (한 번에 하나) 초창기 운영체제, DOS multi-tasking O (동시에 창 여러개) MS window, Unix Multi-tasking: 시분할, 다중 프로그래밍, 대화형 system 다중 작업 시에는 여러 프로그램이 CPU와 memory를 공유한다.\nCPU의 경우, 처리 속도가 워낙 빨라서 여러 프로그램이 CPU의 작업시간을 조금씩 나누어 번갈아 쓰지만, 사용자 입장에서는 동시 실행처럼 보인다. 이를 시분할 시스템(time sharing system) 이라 한다.\n또한, 메모리의 경우 메모리 공간을 분할해 여러 프로그램들을 동시에 메모리에 올려놓고 처리하는 시스템을 사용한다. 이를 다중 프로그래밍 시스템(multi-programming system) 이라 한다.\n다중 작업의 경우, 여러 프로그램을 같이 실행하지만, 사용자 개개인의 관점에서는 각 프로그램에 대한 입력 결과를 곧바로 화면에 보여준다. 이를 대화형 시스템(interactive system) 이라 한다. 여러 사용자가 동시 접속 하는 서버의 경우에도, 각 사용자 입장에서는 혼자 사용하는 것처럼 느끼게 해주므로 대화형 시스템에 해당된다.\n두 번째 분류: 다중 사용자 동시지원 유무 운영체제 분류 다중 사용자 지원 추가 설명 예시 단일 사용자용 X 한 번에 한 사용자만 DOS, MS window 다중 사용자용 O 여러 사용자 동시 접속 가능 server(서버) 세 번째 분류: 작업 처리 방식(일괄처리 와 시분할 방식) 작업 처리 방식 의미 추가 설명 예 일괄 처리 (batch processing) 일정량씩 모아 한꺼번에 처리하는 방식 응답 시간이 길다. 초창기 컴퓨터에 사용하는 punch card 시분할 방식 (time sharing system) 여러 작업을 수행 시, 일정 시간 단위로 분할해 CPU를 사용하는 방식 짧은 응답시간을 갖는다. 유닉스 운영체제 하의 서버 컴퓨터 다섯 번째 분류: 실시간(real time) 운영체제 real time system은 정해진 시간 안에 처리를 보장하는 시스템에서 사용된다.\n분류 설명 예 Hard realtime system 주어진 시간을 지키지 못할 경우, 매우 위험한 결과를 초래할 가능성 O 원자로, 공장 제어 시스템, 미사일 제어 시스템 Soft realtime system 데이터가 정해진 시간 단위로 되어야 올바른 기능을 수행할 수 있는 시스템. 위험한 결과 X 멀티 미디어 스트링 4. 운영체제의 예 MS Window와 Unix의 예를 통해 간단히 살펴보자.\nMS Window는 마이크로소프트에서 이전에 개발한 MS-DOS와 WINDOW 3.1을 발전시킨, 개인용 컴퓨터를 위한 운영체제다.\n마이크로소프트가 기존에 발표한 MS-DOS는 초보자가 사용하기 어려운 명령어 입력 방식을 지녔기 때문에, 좀 더 쉬운 사용을 위해 윈도우를 개발했다.\n그리고, WINDOW 3.1은 grapic interface와 mouse 기능을 지원하는 점에서 사용자에게 편리한 환경을 제공했지만, 독자적인 운영체제가 되지 못하고 MS-DOS 위에 수행된다는 점에서 여러 한계점을 가지고 있었다. 예를 들어 컴퓨터 시스템을 완전히 제어할 수 없는 것, 불안정하다는 것 그리고, WINDOW를 사용하면서도 DOS를 함께 사용해야 하는 부가적인 어려움이 있었다.\n그 이후 온전한 운영체제가 된 것이 윈도우 95다. 윈도우 XP부터는 인터페이스측면에서 그래픽 환경과 아이콘 방식을 기본적으로 채택하면서, 다양한 방식으로 지원해 자신에게 편한 방법으로 다룰 수 있게 했다.\nMS Window의 또 다른 큰 특징은 plug and play다. 시스템에 새로운 하드웨어를 장착하면 OS가 자동으로 감지하여, 새로운 하드웨어에 맞게 설정된다는 점이다.\n그러면 MS Window와 Unix를 비교해보겠다.\n이식성(protability) 이란?\n해당 소프트웨어를 다른 기종의 기계로 옮기는 것이 얼마나 용이한가를 나타내는 지표\nMS Window Unix 대상 누구든지 손쉽게 사용(개인용 컴퓨터) 프로그램 개발 환경을 위해 설계된 OS, 오랜 전통, 대형 컴퓨터,전문적인 목적 특징 1 편리한 인터페이스 이식성(protability)이 좋음 특징 2 안정성 낮음 안정성이 좋음 특징 3 kernel의 크기가 작음 특징 4 souce code 공개됨 → 실제 연구에 이바지 특징 5 스스로 꾸밀 수 있음 특징 6 후에 GUI 제공됨 5. 운영체제의 자원 관리 기능 자원이란 하드웨어 자원과 소프트웨어 자원을 포함한다고 했다. 이번 소단원에서는 하드웨어 자원을 어떻게 관리하는지 알아보자.\n하드웨어 자원에는 CPU, 메모리, 그리고 입출력 장치들로 구성된다.\n5.1 CPU 관리 기법: 3가지 CPU 란 Central Processing Unit의 약자로, 명령어를 실행하는 연산 장치를 말한다. 이 CPU 는 통상적으로 컴퓨터 한 대에 하나가 장착되기 때문에, 여러 프로세스들이 CPU를 효율적으로 나누어 사용할 수 있도록 관리되어야 한다. 이 CPU의 대표적인 관리 방법 에는 선입선출(First Come First Served: FCFS), 라운드 로빈(Round Robin), 우선순위(Priority) 기법이 있다.\n5.1.1 CPU 관리 기법 첫 번째: 선입선출(FCFS) CPU를 사용하기 위해 먼저 온 process를 먼저 처리하는 방식이 선입선출 이다. 일상생활에서 줄을 서서 기다리는 것과 동일하다. 이 방법의 단점은 CPU를 필요로 하는 process가 여러 개 있을 때, CPU를 먼저 얻은 process가 원하는 작업을 완료할 때까지 다른 프로세스들은 CPU를 사용하지 못한다는 점이다. CPU 자체의 효율적인 측면에서는 문제 없지만, 전체 시스템의 관점에서는 비효율적인 결과를 초래할 수 있다. 장시간 이용해야 하는 프로세스가 먼저 오고, 그 뒤에 단시간 이용해야하는 프로세스가 올 경우 단시간 이용하면 되지만, 먼저 온 프로세스로 인해 계속 대기해야하는 상황이 발생된다.\n5.1.2 CPU 관리 기법 두 번째: 라운드 로빈(Round Robin) 위 선입선출의 단점을 보완하여 나온 방법이 라운드 로빈(Round Robin) 이다. 이 방법은 CPU를 한 번 할당 받아 사용할 수 있는 시간을 일정하게 고정된 시간으로 제한 한다. 각 프로세스는 이 정해진 시간 동안에만 CPU를 할당받는다. 작업이 완료되지 않았어도, 시간이 끝나면 CPU를 내려놓고, CPU 대기열의 제일 뒤에 가서 줄을 서야 한다. 먼저 온 프로세스의 작업 완료 시간이 길어도, 계속해서 기다릴 문제가 발생되지 않는다. 각 process마다 이 정해진 시간만큼 보장받을 수 있다.\n5.1.3 CPU 관리 기법 세 번째: 우선순위(Priority) 대기 중인 프로세스들에게 우선순위를 부여하고, 우선순위가 높은 process들에게 먼저 CPU를 할당 한다. 먼저 와서 CPU를 기다릴지라도, 우선순위에 따라 융통성 있게 process들에게 CPU를 할당할 수 있다. 또한, 지나치게 오래 기다리는 프로세스가 발생하지 않도록, 기다리는 시간에 비례하여 우선순위를 점차 높여주는 방안도 활용된다.\n5.2 Memory란?? 다른 중요 관리 대상으로 Memory가 있다.\n메모리는 CPU가 직접 접근할 수 있는 컴퓨터 내부 기억장치다. 프로그램이 CPU에서 실행될라면 해당 부분이 메모리에 올라 있어야 한다.\n메모리 역시 CPU처럼 한정된 용량만 존재하기 때문에, 서로 다른 다수의 프로세스들이 나누어 쓸 수 있도록 해야 한다. 이 한정된 용량을 효율적인 관리하기 위해 운영체제는 메모리의 어느 부분이 어떤 프로그램에 의해 사용되고 있는지를 주소(address) 를 통해 관리한다.\n5.2.1 운영체제가 Memory 관리가 필요한 이유 프로세스와 메모리의 관계는 다음과 같다.\n추가적으로 할당하여 프로세스가 빨리 수행될 수 있지만, 메모리 자원을 낭비하는 경우도 발생한다. 운영체제는 프로그램에 메모리가 필요할 때 할당하고, 필요하지 않으면 메모리를 회수한다.\n따라서 운영체제는 전체 메모리 공간이 효율적으로 사용될 수 있도록 잘 판단해야 한다.\n또한, 각 프로세스가 자신의 메모리 영역에만 접근할 수 있도록 보안 관리를 잘 해야 한다.\n5.2.2 Memory 관리 방식 3가지 memory 관리 방식에는 고정 분할(fixed partition) 방식, 가변 분할(variable partition) 방식, 가상 메모리(virtual memory) 방식이 있다. 각 방식에 대해 알아보자.\nMemory 관리 방식 첫 번째: 고정 분할 방식 고정 분할 방식은 명칭 그대로 물리적 메모리를 미리 고정된 크기로 나누어 관리한다. 여기에는 몇 가지 단점이 있다.\n첫 번째, 프로그램 크기에 맞게 융통성 있게 할당할 수가 없다\n두 번째, 고정된 크기이기 때문에 최대 할당할 수 있는 프로그램의 수가 정해져 있다.\n세 번째, 나눠진 메모리 크기보다 큰 프로그램은 적재가 불가능 하다.\n네 번째, 나눠진 크기보다 작은 프로그램에 할당하면 분할 내에 남는 영역 이 발생한다. 이 영역을 내부 조각(internal fragmentation) 이라 한다. 이 영역은 올라온 프로그램에 의해서도 사용될 수 없고, 다른 프로그램에 할당할 수 없어서 비효율적으로 낭비되는 공간 이다.\nMemory 관리 방식 두 번째: 가변 분할 방식 가변 분할 방식은 매 시점 프로그램의 크기에 맞게 메모리를 분할해서 사용하는 방식이다.\n이 방식 또한 전체 물리적 메모리 크기보다 큰 프로그램에는 여전히 할당할 수 없다. 그리고, 고정 분할 방식의 내부 조각은 발생되지 않지만, 외부 조각(external fragmentation) 이 발생할 수 있다.\n외부조각이란 프로그램에 할당되지는 않았지만, 그 크기가 작아 프로그램을 올리지 못하는 메모리 영역을 말한다.\n그래서 비효율적으로 낭비되는 공간이다.\nMemory 관리 방식 세 번째: 가상 메모리(Virtual Memory) 기법 현대 컴퓨터 환경에서 가장 널리 사용되는 메모리 관리 기법이다. 이 기법에서 실행될 수 있는 프로그램의 크기는 물리적 메모리가 아닌 가상 메모리 크기에 의해 결정된다. 그래서 물리적 메모리보다 큰 프로그램도 지원할 수 있다.\n모든 프로그램은 물리적 메모리와 독립적으로 가상 메모리를 가지고 있다. 운영체제는 이 가상 메모리의 주소를 물리적 메모리의 주소로 mapping(전환, 연결)하는 기술을 사용하여 전환 후, 물리적 메모리에 올린다.\n예를 들어보자.\n가상 메모리 기법을 사용하여 현재 물리적 메모리보다 더 큰 메모리를 요구하는 프로그램을 실행한다고 하자. 각 프로그램은 전체가 동시에 사용되는 게 아니다. 그러므로 사용되고 있는 부분만 물리적 메모리에 올리고, 나머지는 보조기억장치(disk)에 저장해두었다가 필요할 때 적재하는 방식으로 큰 프로그램을 사용할 수 있다. 이 때, 사용되는 보조기억장치의 영역을 스왑 영역(swap area) 라고 부른다. 프로그램을 구성하는 가상 메모리 공간은 페이징(paging) 기법을 사용하여 저장된다.\n5.3 입출력 장치 관리 기법 이 CPU와 메모리는 휘발성으로 전원이 꺼지면 처리 중이던 정보가 모두 지워지기 때문에, 비휘발성인 보조기억장치 에 파일 형태로 저장한다.\n이 보조기억장치의 예로는 하드디스크가 있으며, 그 외에는 키보드, 마우스, 모니터 등이 입출력 장치 로 OS 관리 대상에 포함된다.\n입출력 장치 관리는 인터룹트(interrupt) 를 통해 이뤄진다.\nInterrupt mechanism CPU는 CPU scheduling에 따라 주어진 작업을 수행하다가, 주변 입출력 장치로의 controller가 CPU에게 인터룹트를 발생시키면 CPU는 자신이 하던 작업을 중단한다. 그리고 현재 자신이 하던 작업 상태를 저장한다. 왜냐하면 다시 중단된 작업을 나중에 이어서 해야하기 때문이다.\nController란 입출력 장치가 가지고 있는 sub CPU라 생각하자.\n이 인터룹트가 발생된 순간, CPU의 사용권은 프로그램에서 운영체제로 넘어온다. 그러면, 운영체제는 발생된 인터룹트의 종류에 맞는 인터룹트 처리루틴을 kernel에서 찾아서 처리루틴에 기록된 코드에 따라 일을 처리한다. 그 후, 다시 중단되 업무에 CPU는 복귀한다.\nReference 운영체제와 정보기술의 원리 ","wordCount":"1741","inLanguage":"en","datePublished":"2022-04-05T17:43:59+09:00","dateModified":"2022-04-05T17:43:59+09:00","mainEntityOfPage":{"@type":"WebPage","@id":"http://jeha00.github.io/post/os/os_chapter_02_%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C_%EA%B0%9C%EC%9A%94/"},"publisher":{"@type":"Organization","name":"Jeha DevLog","logo":{"@type":"ImageObject","url":"http://jeha00.github.io/favicon.ico"}}}</script></head><body class=dark id=top><script>localStorage.getItem("pref-theme")==="light"&&document.body.classList.remove("dark")</script><header class=header><nav class=nav><div class=logo><a href=http://jeha00.github.io/ accesskey=h title="@Jeha00 (Alt + H)">@Jeha00</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></span></div><ul id=menu><li><a href=http://jeha00.github.io/me/ title=About><span>About</span></a></li><li><a href=http://jeha00.github.io/archives/ title=Archive><span>Archive</span></a></li><li><a href=http://jeha00.github.io/categories/ title=Categories><span>Categories</span></a></li><li><a href=http://jeha00.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=http://jeha00.github.io/>Home</a>&nbsp;»&nbsp;<a href=http://jeha00.github.io/post/>Posts</a></div><h1 class=post-title>[TIL] OS Chapter 02: Introduction to Operating System</h1><div class=post-meta><span title='2022-04-05 17:43:59 +0900 KST'>April 5, 2022</span>&nbsp;|&nbsp;<a href=https://github.com/JeHa00/blog/content/post/OS/OS_Chapter_02_%ec%9a%b4%ec%98%81%ec%b2%b4%ec%a0%9c_%ea%b0%9c%ec%9a%94.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#0-introduction aria-label="0. Introduction">0. Introduction</a></li><li><a href=#1-%ec%9a%b4%ec%98%81%ec%b2%b4%ec%a0%9c%ec%9d%98-%ec%a0%95%ec%9d%98 aria-label="1. 운영체제의 정의">1. 운영체제의 정의</a><ul><ul><li><a href=#%ec%9a%b4%ec%98%81%ec%b2%b4%ec%a0%9c%eb%9e%80 aria-label=운영체제란?>운영체제란?</a></li><li><a href=#%ec%99%9c-system%ec%9d%b4%eb%9d%bc-%ed%95%98%eb%8a%94%ea%b0%80 aria-label="왜 system이라 하는가???">왜 system이라 하는가???</a></li><li><a href=#kernel%ec%9d%b4%eb%9e%80 aria-label=kernel이란??>kernel이란??</a></li></ul></ul></li><li><a href=#2-%ec%9a%b4%ec%98%81%ec%b2%b4%ec%a0%9c%ec%9d%98-%ea%b8%b0%eb%8a%a5 aria-label="2. 운영체제의 기능">2. 운영체제의 기능</a><ul><ul><li><a href=#%ed%95%98%eb%93%9c%ec%9b%a8%ec%96%b4-%ea%b7%b8%eb%a6%ac%ea%b3%a0-%ec%82%ac%ec%9a%a9%ec%9e%90%eb%a5%bc-%ec%9c%84%ed%95%9c-%ec%9a%b4%ec%98%81%ec%b2%b4%ec%a0%9c%ec%9d%98-%ec%97%ad%ed%95%a0 aria-label="하드웨어 그리고 사용자를 위한 운영체제의 역할">하드웨어 그리고 사용자를 위한 운영체제의 역할</a></li><li><a href=#%ec%9a%b4%ec%98%81%ec%b2%b4%ec%a0%9c%ec%9d%98-%ed%95%b5%ec%8b%ac-%ec%97%ad%ed%95%a0-%ed%9a%a8%ec%9c%a8%ec%a0%81-%ea%b7%a0%ed%98%95%ec%9e%88%ea%b2%8c-%ec%95%88%ec%a0%84%ed%95%98%ea%b2%8c-%ec%9e%90%ec%9b%90-%ea%b4%80%eb%a6%ac%ed%95%98%ea%b8%b0 aria-label="❗운영체제의 핵심 역할: 효율적, 균형있게, 안전하게 자원 관리하기">❗운영체제의 핵심 역할: 효율적, 균형있게, 안전하게 자원 관리하기</a></li></ul></ul></li><li><a href=#3-%ec%9a%b4%ec%98%81%ec%b2%b4%ec%a0%9c%ec%9d%98-%eb%b6%84%eb%a5%98 aria-label="3. 운영체제의 분류">3. 운영체제의 분류</a><ul><li><a href=#%ec%b2%ab-%eb%b2%88%ec%a7%b8-%eb%b6%84%eb%a5%98-%eb%8f%99%ec%8b%9c-%ec%9e%91%ec%97%85%ec%9d%98-%ec%a7%80%ec%9b%90-%ec%9c%a0%eb%ac%b4 aria-label="첫 번째 분류: 동시 작업의 지원 유무">첫 번째 분류: 동시 작업의 지원 유무</a><ul><li><a href=#multi-tasking-%ec%8b%9c%eb%b6%84%ed%95%a0-%eb%8b%a4%ec%a4%91-%ed%94%84%eb%a1%9c%ea%b7%b8%eb%9e%98%eb%b0%8d-%eb%8c%80%ed%99%94%ed%98%95-system aria-label="Multi-tasking: 시분할, 다중 프로그래밍, 대화형 system">Multi-tasking: 시분할, 다중 프로그래밍, 대화형 system</a></li></ul></li><li><a href=#%eb%91%90-%eb%b2%88%ec%a7%b8-%eb%b6%84%eb%a5%98-%eb%8b%a4%ec%a4%91-%ec%82%ac%ec%9a%a9%ec%9e%90-%eb%8f%99%ec%8b%9c%ec%a7%80%ec%9b%90-%ec%9c%a0%eb%ac%b4 aria-label="두 번째 분류: 다중 사용자 동시지원 유무">두 번째 분류: 다중 사용자 동시지원 유무</a></li><li><a href=#%ec%84%b8-%eb%b2%88%ec%a7%b8-%eb%b6%84%eb%a5%98-%ec%9e%91%ec%97%85-%ec%b2%98%eb%a6%ac-%eb%b0%a9%ec%8b%9d%ec%9d%bc%ea%b4%84%ec%b2%98%eb%a6%ac-%ec%99%80-%ec%8b%9c%eb%b6%84%ed%95%a0-%eb%b0%a9%ec%8b%9d aria-label="세 번째 분류: 작업 처리 방식(일괄처리 와 시분할 방식)">세 번째 분류: 작업 처리 방식(일괄처리 와 시분할 방식)</a></li><li><a href=#%eb%8b%a4%ec%84%af-%eb%b2%88%ec%a7%b8-%eb%b6%84%eb%a5%98-%ec%8b%a4%ec%8b%9c%ea%b0%84real-time-%ec%9a%b4%ec%98%81%ec%b2%b4%ec%a0%9c aria-label="다섯 번째 분류: 실시간(real time) 운영체제">다섯 번째 분류: 실시간(real time) 운영체제</a></li></ul></li><li><a href=#4-%ec%9a%b4%ec%98%81%ec%b2%b4%ec%a0%9c%ec%9d%98-%ec%98%88 aria-label="4. 운영체제의 예">4. 운영체제의 예</a></li><li><a href=#5-%ec%9a%b4%ec%98%81%ec%b2%b4%ec%a0%9c%ec%9d%98-%ec%9e%90%ec%9b%90-%ea%b4%80%eb%a6%ac-%ea%b8%b0%eb%8a%a5 aria-label="5. 운영체제의 자원 관리 기능">5. 운영체제의 자원 관리 기능</a><ul><li><a href=#51-cpu-%ea%b4%80%eb%a6%ac-%ea%b8%b0%eb%b2%95-3%ea%b0%80%ec%a7%80 aria-label="5.1 CPU 관리 기법: 3가지">5.1 CPU 관리 기법: 3가지</a><ul><li><a href=#511-cpu-%ea%b4%80%eb%a6%ac-%ea%b8%b0%eb%b2%95-%ec%b2%ab-%eb%b2%88%ec%a7%b8-%ec%84%a0%ec%9e%85%ec%84%a0%ec%b6%9cfcfs aria-label="5.1.1 CPU 관리 기법 첫 번째: 선입선출(FCFS)">5.1.1 CPU 관리 기법 첫 번째: 선입선출(FCFS)</a></li><li><a href=#512-cpu-%ea%b4%80%eb%a6%ac-%ea%b8%b0%eb%b2%95-%eb%91%90-%eb%b2%88%ec%a7%b8-%eb%9d%bc%ec%9a%b4%eb%93%9c-%eb%a1%9c%eb%b9%88round-robin aria-label="5.1.2 CPU 관리 기법 두 번째: 라운드 로빈(Round Robin)">5.1.2 CPU 관리 기법 두 번째: 라운드 로빈(Round Robin)</a></li><li><a href=#513-cpu-%ea%b4%80%eb%a6%ac-%ea%b8%b0%eb%b2%95-%ec%84%b8-%eb%b2%88%ec%a7%b8-%ec%9a%b0%ec%84%a0%ec%88%9c%ec%9c%84priority aria-label="5.1.3 CPU 관리 기법 세 번째: 우선순위(Priority)">5.1.3 CPU 관리 기법 세 번째: 우선순위(Priority)</a></li></ul></li><li><a href=#52-memory%eb%9e%80 aria-label="5.2 Memory란??">5.2 Memory란??</a><ul><li><a href=#521-%ec%9a%b4%ec%98%81%ec%b2%b4%ec%a0%9c%ea%b0%80-memory-%ea%b4%80%eb%a6%ac%ea%b0%80-%ed%95%84%ec%9a%94%ed%95%9c-%ec%9d%b4%ec%9c%a0 aria-label="5.2.1 운영체제가 Memory 관리가 필요한 이유">5.2.1 운영체제가 Memory 관리가 필요한 이유</a></li><li><a href=#522-memory-%ea%b4%80%eb%a6%ac-%eb%b0%a9%ec%8b%9d-3%ea%b0%80%ec%a7%80 aria-label="5.2.2 Memory 관리 방식 3가지">5.2.2 Memory 관리 방식 3가지</a></li><li><a href=#memory-%ea%b4%80%eb%a6%ac-%eb%b0%a9%ec%8b%9d-%ec%b2%ab-%eb%b2%88%ec%a7%b8-%ea%b3%a0%ec%a0%95-%eb%b6%84%ed%95%a0-%eb%b0%a9%ec%8b%9d aria-label="Memory 관리 방식 첫 번째: 고정 분할 방식">Memory 관리 방식 첫 번째: 고정 분할 방식</a></li><li><a href=#memory-%ea%b4%80%eb%a6%ac-%eb%b0%a9%ec%8b%9d-%eb%91%90-%eb%b2%88%ec%a7%b8-%ea%b0%80%eb%b3%80-%eb%b6%84%ed%95%a0-%eb%b0%a9%ec%8b%9d aria-label="Memory 관리 방식 두 번째: 가변 분할 방식">Memory 관리 방식 두 번째: 가변 분할 방식</a></li><li><a href=#memory-%ea%b4%80%eb%a6%ac-%eb%b0%a9%ec%8b%9d-%ec%84%b8-%eb%b2%88%ec%a7%b8-%ea%b0%80%ec%83%81-%eb%a9%94%eb%aa%a8%eb%a6%acvirtual-memory-%ea%b8%b0%eb%b2%95 aria-label="Memory 관리 방식 세 번째: 가상 메모리(Virtual Memory) 기법">Memory 관리 방식 세 번째: 가상 메모리(Virtual Memory) 기법</a></li></ul></li><li><a href=#53-%ec%9e%85%ec%b6%9c%eb%a0%a5-%ec%9e%a5%ec%b9%98-%ea%b4%80%eb%a6%ac-%ea%b8%b0%eb%b2%95 aria-label="5.3 입출력 장치 관리 기법">5.3 입출력 장치 관리 기법</a><ul><li><a href=#interrupt-mechanism aria-label="Interrupt mechanism">Interrupt mechanism</a></li></ul></li></ul></li><li><a href=#reference aria-label=Reference>Reference</a></li></ul></div></details></div><div class=post-content><h1 id=0-introduction>0. Introduction<a hidden class=anchor aria-hidden=true href=#0-introduction>#</a></h1><ul><li>해당 내용은 <a href="http://www.kyobobook.co.kr/product/detailViewKor.laf?ejkGb=KOR&mallGb=KOR&barcode=9791158903589&orderClick=LAG&Kc=">운영체제와 정보기술의 원리</a>을 보고 혼자 정리한 내용입니다.</li><li>정확하지 않은 내용이 있다면 말씀해주시면 감사하겠습니다.</li></ul><hr><h1 id=1-운영체제의-정의>1. 운영체제의 정의<a hidden class=anchor aria-hidden=true href=#1-운영체제의-정의>#</a></h1><h3 id=운영체제란>운영체제란?<a hidden class=anchor aria-hidden=true href=#운영체제란>#</a></h3><ul><li><p><strong><em>운영체제(operating system)</em></strong> 란??</p><p>컴퓨터 하드웨어의 바로 윗단에 설치되는 소프트웨어로, 사용자 및 다른 소프트웨어와 하드웨어를 연결하는 소프트웨어 계층이다.</p></li></ul><p> </p><h3 id=왜-system이라-하는가>왜 system이라 하는가???<a hidden class=anchor aria-hidden=true href=#왜-system이라-하는가>#</a></h3><p>system은 흔히들 하드웨어를 지칭할 때 주로 사용되는 단어인데, 이 system을 사용한 이유는 운영체제 없이 하드웨어만 있다면 컴퓨터 역할을 할 수 없고, OS와 하드웨어가 같이 있어야 진정한 컴퓨터이기 때문이다.</p><p> </p><h3 id=kernel이란>kernel이란??<a hidden class=anchor aria-hidden=true href=#kernel이란>#</a></h3><p>소프트웨어가 실행되기 위해서는 메모리에 그 프로그램이 올라가야 한다. 운영체제도 하나의 SW이기 때문에, 컴퓨터 하드웨어의 전원이 켜지는 동시에, 메모리에 올라간다. 이 운영체제 SW는 규모가 큰 프로그램이기 때문에, 운영체제 전부를 메모리에 올린다면 메모리 공간 낭비가 심해진다.<br>그래서 운영체제 중 <strong><em>항상 필요한 부분만</em></strong> 을 전원이 켜짐과 동시에 메모리에 올려놓고, 그렇지 않은 부분은 필요할 때 메모리로 올려서 사용한다. <strong><em>메모리에 항상 상주하는 운영체제 부분</em></strong> 을 <strong><em>커널(kernel)</em></strong> 이라 한다. 이 커널을 <strong><em>좁은 의미의 운영체제</em></strong> 라고도 불리며, <strong><em>넓은 의미의 운영체제</em></strong> 는 utility들(ex: copy)을 광범위하게 포함하는 개념이다.</p><p> </p><hr><h1 id=2-운영체제의-기능>2. 운영체제의 기능<a hidden class=anchor aria-hidden=true href=#2-운영체제의-기능>#</a></h1><p> </p><h3 id=하드웨어-그리고-사용자를-위한-운영체제의-역할>하드웨어 그리고 사용자를 위한 운영체제의 역할<a hidden class=anchor aria-hidden=true href=#하드웨어-그리고-사용자를-위한-운영체제의-역할>#</a></h3><p>운영체제는 사용자 및 다른 소프트웨어와 하드웨어를 연결하는 소프트웨어 계층이라는 관점에서 운영체제의 기능을 생각해보면, <strong><em>하드웨어를 위한 역할</em></strong> 과 <strong><em>사용자를 위한 역할</em></strong> 로 나눠진다.<br><strong>전자</strong> 는 사용자를 대신하여 <strong><em>운영체제가 하드웨어인 컴퓨터 시스템 내의 resource를 효율적으로 관리하는 역할</em></strong> 을 말한다.<br><strong>후자</strong> 는 <strong><em>사용자가 컴퓨터 시스템을 편리하게 사용하도록, 사용자에게 편리한 인터페이스를 제공하는 역할</em></strong> 을 말한다. 하드웨어를 직접 다루는 부분은 운영체제가 대행하여, 사용자 및 프로그램이 이에 대한 내용은 알지 못해도 프로그램을 실행해주는 기능을 말한다.</p><p> </p><h3 id=운영체제의-핵심-역할-효율적-균형있게-안전하게-자원-관리하기>❗운영체제의 핵심 역할: 효율적, 균형있게, 안전하게 자원 관리하기<a hidden class=anchor aria-hidden=true href=#운영체제의-핵심-역할-효율적-균형있게-안전하게-자원-관리하기>#</a></h3><p>운영체제의 기능은 전자와 후자 중 <strong><em>중요한 핵심기능은 바로 전자</em></strong> 다.<br>그래서 운영체제를 <strong><em>자원 관리자(resource manager)</em></strong> 라고도 부른다.
여기서 <strong><em>자원이란</em></strong> 하드웨어 자원(ex: CPU, memory, HDD) 과 소프트웨어 자원을 모두 총칭하는 말이다. 운영체제는 이 자원들을 <strong><em>효율적으로 관리</em></strong> 하여 <strong><em>가장 좋은 성능</em></strong> 을 내도록 만든다.</p><p>하지만, 전체적인 성능을 향상시켜려다보면 일부 프로그램 또는 사용자가 불이익을 당할 수 있다. 그래서 운영체제는 사용자 및 프로그램들 간에 자원이 <strong><em>형평성 있게 분배</em></strong> 되도록 하는 <strong><em>균형자</em></strong> 역할도 함께 수행해야 한다.</p><p>또한, 더 중요한게 사용자와 운영체제 자신을 보호하는 <strong><em>보안</em></strong> 역할을 담당한다. 악의성 프로그램으로 다른 사용자 프로그램에 접근하지 않도록 보안 및 보호 기능을 수행해야 한다.</p><p> </p><hr><h1 id=3-운영체제의-분류>3. 운영체제의 분류<a hidden class=anchor aria-hidden=true href=#3-운영체제의-분류>#</a></h1><p>운영체제의 분류 중 하나는 <strong><em>multi-processing system</em></strong> 과 <strong><em>single-processing system</em></strong> 이다. CPU가 2개 이상 설치되면 전자, 1개만 설치되면 후자를 말한다. 여기서 분류는 후자를 가정으로 진행된다.</p><p>운영체제의 분류에는 동시 작업을 지원하는지, 다중 사용자를 지원하는지, 실시간(real time)을 지원하는지에 따라 분류된다. 앞에서부터 차근 차근 알아보자.</p><p> </p><h2 id=첫-번째-분류-동시-작업의-지원-유무>첫 번째 분류: 동시 작업의 지원 유무<a hidden class=anchor aria-hidden=true href=#첫-번째-분류-동시-작업의-지원-유무>#</a></h2><p><strong>동시 작업을 지원</strong>하는지의 여부에 따라 <strong><em>단일작업(single tasking)용</em></strong> 운영체제와 <strong><em>다중작업(multi tasking)용</em></strong> 운영체제로 나누어볼 수 있다. 각 설명은 다음 표와 같다.</p><table><thead><tr><th>운영체제 분류</th><th>동시 작업 지원 유무</th><th>예시</th></tr></thead><tbody><tr><td>single tasking</td><td>X (한 번에 하나)</td><td>초창기 운영체제, DOS</td></tr><tr><td>multi-tasking</td><td>O (동시에 창 여러개)</td><td>MS window, Unix</td></tr></tbody></table><p> </p><h3 id=multi-tasking-시분할-다중-프로그래밍-대화형-system>Multi-tasking: 시분할, 다중 프로그래밍, 대화형 system<a hidden class=anchor aria-hidden=true href=#multi-tasking-시분할-다중-프로그래밍-대화형-system>#</a></h3><p><strong>다중 작업 시에는 여러 프로그램이 CPU와 memory를 공유</strong>한다.</p><p><strong><em>CPU의 경우</em></strong>, 처리 속도가 워낙 빨라서 여러 프로그램이 CPU의 작업시간을 조금씩 나누어 번갈아 쓰지만, 사용자 입장에서는 동시 실행처럼 보인다. 이를 <strong><em>시분할 시스템(time sharing system)</em></strong> 이라 한다.</p><p>또한, <strong><em>메모리의 경우</em></strong> 메모리 공간을 분할해 여러 프로그램들을 동시에 메모리에 올려놓고 처리하는 시스템을 사용한다. 이를 <strong><em>다중 프로그래밍 시스템(multi-programming system</em>)</strong> 이라 한다.</p><p>다중 작업의 경우, 여러 프로그램을 같이 실행하지만, 사용자 개개인의 관점에서는 각 프로그램에 대한 입력 결과를 곧바로 화면에 보여준다. 이를 <strong><em>대화형 시스템(interactive system)</em></strong> 이라 한다. 여러 사용자가 동시 접속 하는 서버의 경우에도, 각 사용자 입장에서는 혼자 사용하는 것처럼 느끼게 해주므로 대화형 시스템에 해당된다.</p><p> </p><h2 id=두-번째-분류-다중-사용자-동시지원-유무>두 번째 분류: 다중 사용자 동시지원 유무<a hidden class=anchor aria-hidden=true href=#두-번째-분류-다중-사용자-동시지원-유무>#</a></h2><table><thead><tr><th>운영체제 분류</th><th>다중 사용자 지원</th><th>추가 설명</th><th>예시</th></tr></thead><tbody><tr><td>단일 사용자용</td><td>X</td><td>한 번에 한 사용자만</td><td>DOS, MS window</td></tr><tr><td>다중 사용자용</td><td>O</td><td>여러 사용자 동시 접속 가능</td><td>server(서버)</td></tr></tbody></table><p> </p><h2 id=세-번째-분류-작업-처리-방식일괄처리-와-시분할-방식>세 번째 분류: 작업 처리 방식(일괄처리 와 시분할 방식)<a hidden class=anchor aria-hidden=true href=#세-번째-분류-작업-처리-방식일괄처리-와-시분할-방식>#</a></h2><table><thead><tr><th>작업 처리 방식</th><th>의미</th><th>추가 설명</th><th>예</th></tr></thead><tbody><tr><td>일괄 처리 (batch processing)</td><td>일정량씩 모아 한꺼번에 처리하는 방식</td><td>응답 시간이 길다.</td><td>초창기 컴퓨터에 사용하는 punch card</td></tr><tr><td>시분할 방식 (time sharing system)</td><td>여러 작업을 수행 시, 일정 시간 단위로 분할해 CPU를 사용하는 방식</td><td>짧은 응답시간을 갖는다.</td><td>유닉스 운영체제 하의 서버 컴퓨터</td></tr></tbody></table><p> </p><h2 id=다섯-번째-분류-실시간real-time-운영체제>다섯 번째 분류: 실시간(real time) 운영체제<a hidden class=anchor aria-hidden=true href=#다섯-번째-분류-실시간real-time-운영체제>#</a></h2><p>real time system은 정해진 시간 안에 처리를 보장하는 시스템에서 사용된다.</p><table><thead><tr><th>분류</th><th>설명</th><th>예</th></tr></thead><tbody><tr><td>Hard realtime system</td><td>주어진 시간을 지키지 못할 경우, 매우 위험한 결과를 초래할 가능성 O</td><td>원자로, 공장 제어 시스템, 미사일 제어 시스템</td></tr><tr><td>Soft realtime system</td><td>데이터가 정해진 시간 단위로 되어야 올바른 기능을 수행할 수 있는 시스템. 위험한 결과 X</td><td>멀티 미디어 스트링</td></tr></tbody></table><p> </p><hr><h1 id=4-운영체제의-예>4. 운영체제의 예<a hidden class=anchor aria-hidden=true href=#4-운영체제의-예>#</a></h1><p>MS Window와 Unix의 예를 통해 간단히 살펴보자.</p><p>MS Window는 마이크로소프트에서 이전에 개발한 MS-DOS와 WINDOW 3.1을 발전시킨, 개인용 컴퓨터를 위한 운영체제다.</p><p>마이크로소프트가 기존에 발표한 MS-DOS는 초보자가 사용하기 어려운 명령어 입력 방식을 지녔기 때문에, 좀 더 쉬운 사용을 위해 윈도우를 개발했다.</p><p>그리고, WINDOW 3.1은 grapic interface와 mouse 기능을 지원하는 점에서 사용자에게 편리한 환경을 제공했지만, 독자적인 운영체제가 되지 못하고 MS-DOS 위에 수행된다는 점에서 여러 한계점을 가지고 있었다. 예를 들어 컴퓨터 시스템을 완전히 제어할 수 없는 것, 불안정하다는 것 그리고, WINDOW를 사용하면서도 DOS를 함께 사용해야 하는 부가적인 어려움이 있었다.</p><p>그 이후 온전한 운영체제가 된 것이 윈도우 95다. 윈도우 XP부터는 인터페이스측면에서 그래픽 환경과 아이콘 방식을 기본적으로 채택하면서, 다양한 방식으로 지원해 자신에게 편한 방법으로 다룰 수 있게 했다.</p><p>MS Window의 또 다른 큰 특징은 <strong>plug and play</strong>다. 시스템에 새로운 하드웨어를 장착하면 OS가 자동으로 감지하여, 새로운 하드웨어에 맞게 설정된다는 점이다.</p><p>그러면 MS Window와 Unix를 비교해보겠다.</p><p><strong><em>이식성(protability)</em></strong> 이란?</p><p>해당 소프트웨어를 다른 기종의 기계로 옮기는 것이 얼마나 용이한가를 나타내는 지표</p><table><thead><tr><th></th><th>MS Window</th><th>Unix</th></tr></thead><tbody><tr><td>대상</td><td>누구든지 손쉽게 사용(개인용 컴퓨터)</td><td>프로그램 개발 환경을 위해 설계된 OS, 오랜 전통, 대형 컴퓨터,전문적인 목적</td></tr><tr><td>특징 1</td><td>편리한 인터페이스</td><td>이식성(protability)이 좋음</td></tr><tr><td>특징 2</td><td>안정성 낮음</td><td>안정성이 좋음</td></tr><tr><td>특징 3</td><td></td><td>kernel의 크기가 작음</td></tr><tr><td>특징 4</td><td></td><td>souce code 공개됨 → 실제 연구에 이바지</td></tr><tr><td>특징 5</td><td></td><td>스스로 꾸밀 수 있음</td></tr><tr><td>특징 6</td><td></td><td>후에 GUI 제공됨</td></tr></tbody></table><p> </p><hr><h1 id=5-운영체제의-자원-관리-기능>5. 운영체제의 자원 관리 기능<a hidden class=anchor aria-hidden=true href=#5-운영체제의-자원-관리-기능>#</a></h1><p>자원이란 하드웨어 자원과 소프트웨어 자원을 포함한다고 했다. 이번 소단원에서는 하드웨어 자원을 어떻게 관리하는지 알아보자.</p><p>하드웨어 자원에는 CPU, 메모리, 그리고 입출력 장치들로 구성된다.</p><p> </p><h2 id=51-cpu-관리-기법-3가지>5.1 CPU 관리 기법: 3가지<a hidden class=anchor aria-hidden=true href=#51-cpu-관리-기법-3가지>#</a></h2><p><strong><em>CPU</em></strong> 란 Central Processing Unit의 약자로, 명령어를 실행하는 연산 장치를 말한다. 이 <strong><em>CPU</em></strong> 는 통상적으로 <strong>컴퓨터 한 대에 하나</strong>가 장착되기 때문에, 여러 프로세스들이 CPU를 <strong>효율적으로</strong> 나누어 사용할 수 있도록 관리되어야 한다. 이 <strong>CPU의 대표적인 관리 방법</strong> 에는 <strong>선입선출(First Come First Served: FCFS), 라운드 로빈(Round Robin), 우선순위(Priority) 기법</strong>이 있다.</p><p> </p><h3 id=511-cpu-관리-기법-첫-번째-선입선출fcfs>5.1.1 CPU 관리 기법 첫 번째: 선입선출(FCFS)<a hidden class=anchor aria-hidden=true href=#511-cpu-관리-기법-첫-번째-선입선출fcfs>#</a></h3><p>CPU를 사용하기 위해 먼저 온 process를 먼저 처리하는 방식이 <strong><em>선입선출</em></strong> 이다. 일상생활에서 줄을 서서 기다리는 것과 동일하다. 이 방법의 단점은 CPU를 필요로 하는 process가 여러 개 있을 때, CPU를 먼저 얻은 process가 원하는 작업을 완료할 때까지 다른 프로세스들은 CPU를 사용하지 못한다는 점이다. <strong><em>CPU 자체의 효율적인 측면에서는 문제 없지만, 전체 시스템의 관점에서는 비효율적인 결과를 초래할 수 있다.</em></strong> 장시간 이용해야 하는 프로세스가 먼저 오고, 그 뒤에 단시간 이용해야하는 프로세스가 올 경우 단시간 이용하면 되지만, 먼저 온 프로세스로 인해 계속 대기해야하는 상황이 발생된다.</p><p> </p><h3 id=512-cpu-관리-기법-두-번째-라운드-로빈round-robin>5.1.2 CPU 관리 기법 두 번째: 라운드 로빈(Round Robin)<a hidden class=anchor aria-hidden=true href=#512-cpu-관리-기법-두-번째-라운드-로빈round-robin>#</a></h3><p>위 선입선출의 단점을 보완하여 나온 방법이 <strong><em>라운드 로빈(Round Robin)</em></strong> 이다. 이 방법은 <strong><em>CPU를 한 번 할당 받아 사용할 수 있는 시간을 일정하게 고정된 시간으로 제한</em></strong> 한다. 각 프로세스는 이 정해진 시간 동안에만 CPU를 할당받는다. 작업이 완료되지 않았어도, 시간이 끝나면 CPU를 내려놓고, CPU 대기열의 제일 뒤에 가서 줄을 서야 한다. 먼저 온 프로세스의 작업 완료 시간이 길어도, 계속해서 기다릴 문제가 발생되지 않는다. 각 process마다 이 정해진 시간만큼 보장받을 수 있다.</p><p> </p><h3 id=513-cpu-관리-기법-세-번째-우선순위priority>5.1.3 CPU 관리 기법 세 번째: 우선순위(Priority)<a hidden class=anchor aria-hidden=true href=#513-cpu-관리-기법-세-번째-우선순위priority>#</a></h3><p>대기 중인 프로세스들에게 우선순위를 부여하고, <strong><em>우선순위가 높은 process들에게 먼저 CPU를 할당</em></strong> 한다. 먼저 와서 CPU를 기다릴지라도, 우선순위에 따라 융통성 있게 process들에게 CPU를 할당할 수 있다. 또한, 지나치게 오래 기다리는 프로세스가 발생하지 않도록, 기다리는 시간에 비례하여 우선순위를 점차 높여주는 방안도 활용된다.</p><p> </p><h2 id=52-memory란>5.2 Memory란??<a hidden class=anchor aria-hidden=true href=#52-memory란>#</a></h2><p>다른 중요 관리 대상으로 Memory가 있다.</p><p><strong>메모리는 CPU가 직접 접근할 수 있는 컴퓨터 내부 기억장치</strong>다. 프로그램이 CPU에서 실행될라면 해당 부분이 메모리에 올라 있어야 한다.</p><p><strong><em>메모리</em></strong> 역시 CPU처럼 <strong>한정된 용량</strong>만 존재하기 때문에, 서로 다른 다수의 프로세스들이 <strong>나누어</strong> 쓸 수 있도록 해야 한다. 이 한정된 용량을 <strong>효율적인 관리</strong>하기 위해 운영체제는 메모리의 어느 부분이 어떤 프로그램에 의해 사용되고 있는지를 <strong>주소(address)</strong> 를 통해 관리한다.</p><p> </p><h3 id=521-운영체제가-memory-관리가-필요한-이유>5.2.1 운영체제가 Memory 관리가 필요한 이유<a hidden class=anchor aria-hidden=true href=#521-운영체제가-memory-관리가-필요한-이유>#</a></h3><p>프로세스와 메모리의 관계는 다음과 같다.</p><p>추가적으로 할당하여 프로세스가 <strong>빨리 수행</strong>될 수 있지만, 메모리 <strong>자원을 낭비</strong>하는 경우도 발생한다. <strong>운영체제는 프로그램에 메모리가 필요할 때 할당하고, 필요하지 않으면 메모리를 회수한다.</strong></p><p>따라서 운영체제는 전체 메모리 공간이 <strong>효율적으로 사용될 수 있도록 잘 판단</strong>해야 한다.</p><p>또한, 각 프로세스가 <strong>자신의 메모리 영역에만 접근</strong>할 수 있도록 보안 관리를 잘 해야 한다.</p><p> </p><h3 id=522-memory-관리-방식-3가지>5.2.2 Memory 관리 방식 3가지<a hidden class=anchor aria-hidden=true href=#522-memory-관리-방식-3가지>#</a></h3><p>memory 관리 방식에는 <strong>고정 분할(fixed partition) 방식, 가변 분할(variable partition) 방식, 가상 메모리(virtual memory) 방식</strong>이 있다. 각 방식에 대해 알아보자.</p><p> </p><h3 id=memory-관리-방식-첫-번째-고정-분할-방식>Memory 관리 방식 첫 번째: 고정 분할 방식<a hidden class=anchor aria-hidden=true href=#memory-관리-방식-첫-번째-고정-분할-방식>#</a></h3><p>고정 분할 방식은 명칭 그대로 물리적 메모리를 미리 고정된 크기로 나누어 관리한다. 여기에는 몇 가지 단점이 있다.</p><p>첫 번째, 프로그램 크기에 맞게 <strong><em>융통성 있게 할당할 수가 없다</em></strong></p><p>두 번째, 고정된 크기이기 때문에 <strong><em>최대 할당할 수 있는 프로그램의 수가 정해져 있다.</em></strong></p><p>세 번째, 나눠진 메모리 크기보다 큰 프로그램은 <strong><em>적재가 불가능</em></strong> 하다.</p><p>네 번째, 나눠진 크기보다 작은 프로그램에 할당하면 <strong>분할 내에 남는 영역</strong> 이 발생한다. 이 영역을 <strong>내부 조각(internal fragmentation)</strong> 이라 한다. 이 영역은 올라온 프로그램에 의해서도 사용될 수 없고, 다른 프로그램에 할당할 수 없어서 <strong>비효율적으로 낭비되는 공간</strong> 이다.</p><p> </p><h3 id=memory-관리-방식-두-번째-가변-분할-방식>Memory 관리 방식 두 번째: 가변 분할 방식<a hidden class=anchor aria-hidden=true href=#memory-관리-방식-두-번째-가변-분할-방식>#</a></h3><p>가변 분할 방식은 매 시점 프로그램의 크기에 맞게 메모리를 분할해서 사용하는 방식이다.</p><p>이 방식 또한 전체 물리적 메모리 크기보다 큰 프로그램에는 여전히 할당할 수 없다. 그리고, 고정 분할 방식의 내부 조각은 발생되지 않지만, <strong>외부 조각(external fragmentation)</strong> 이 발생할 수 있다.</p><p>외부조각이란 프로그램에 할당되지는 않았지만, 그 크기가 작아 프로그램을 올리지 못하는 메모리 영역을 말한다.</p><p>그래서 비효율적으로 낭비되는 공간이다.</p><p> </p><h3 id=memory-관리-방식-세-번째-가상-메모리virtual-memory-기법>Memory 관리 방식 세 번째: 가상 메모리(Virtual Memory) 기법<a hidden class=anchor aria-hidden=true href=#memory-관리-방식-세-번째-가상-메모리virtual-memory-기법>#</a></h3><p>현대 컴퓨터 환경에서 가장 널리 사용되는 메모리 관리 기법이다. 이 기법에서 실행될 수 있는 프로그램의 크기는 물리적 메모리가 아닌 <strong>가상 메모리 크기에 의해 결정</strong>된다. 그래서 <strong>물리적 메모리보다 큰 프로그램도 지원</strong>할 수 있다.</p><p>모든 프로그램은 물리적 메모리와 독립적으로 가상 메모리를 가지고 있다. 운영체제는 이 가상 메모리의 주소를 물리적 메모리의 주소로 <strong>mapping(전환, 연결)하는 기술</strong>을 사용하여 전환 후, 물리적 메모리에 올린다.</p><p>예를 들어보자.</p><p>가상 메모리 기법을 사용하여 현재 물리적 메모리보다 더 큰 메모리를 요구하는 프로그램을 실행한다고 하자. 각 프로그램은 전체가 동시에 사용되는 게 아니다. 그러므로 사용되고 있는 부분만 물리적 메모리에 올리고, 나머지는 보조기억장치(disk)에 저장해두었다가 필요할 때 적재하는 방식으로 큰 프로그램을 사용할 수 있다. 이 때, 사용되는 보조기억장치의 영역을 <strong>스왑 영역(swap area)</strong> 라고 부른다. 프로그램을 구성하는 가상 메모리 공간은 <strong>페이징(paging) 기법</strong>을 사용하여 저장된다.</p><p> </p><h2 id=53-입출력-장치-관리-기법>5.3 입출력 장치 관리 기법<a hidden class=anchor aria-hidden=true href=#53-입출력-장치-관리-기법>#</a></h2><p>이 CPU와 메모리는 휘발성으로 전원이 꺼지면 처리 중이던 정보가 모두 지워지기 때문에, 비휘발성인 <strong><em>보조기억장치</em></strong> 에 파일 형태로 저장한다.</p><p>이 보조기억장치의 예로는 하드디스크가 있으며, 그 외에는 키보드, 마우스, 모니터 등이 <strong><em>입출력 장치</em></strong> 로 OS 관리 대상에 포함된다.</p><p>입출력 장치 관리는 <strong><em>인터룹트(interrupt)</em></strong> 를 통해 이뤄진다.</p><p> </p><h3 id=interrupt-mechanism>Interrupt mechanism<a hidden class=anchor aria-hidden=true href=#interrupt-mechanism>#</a></h3><p>CPU는 CPU scheduling에 따라 주어진 작업을 수행하다가, 주변 입출력 장치로의 controller가 CPU에게 인터룹트를 발생시키면 CPU는 자신이 하던 작업을 중단한다. 그리고 현재 자신이 하던 작업 상태를 저장한다. 왜냐하면 다시 중단된 작업을 나중에 이어서 해야하기 때문이다.</p><p>Controller란 입출력 장치가 가지고 있는 sub CPU라 생각하자.</p><p>이 인터룹트가 발생된 순간, CPU의 사용권은 프로그램에서 운영체제로 넘어온다. 그러면, 운영체제는 발생된 인터룹트의 종류에 맞는 인터룹트 처리루틴을 kernel에서 찾아서 처리루틴에 기록된 코드에 따라 일을 처리한다. 그 후, 다시 중단되 업무에 CPU는 복귀한다.</p><p> </p><hr><h1 id=reference>Reference<a hidden class=anchor aria-hidden=true href=#reference>#</a></h1><ul><li><a href="http://www.kyobobook.co.kr/product/detailViewKor.laf?ejkGb=KOR&mallGb=KOR&barcode=9791158903589&orderClick=LAG&Kc=">운영체제와 정보기술의 원리</a></li></ul></div><footer class=post-footer><ul class=post-tags><li><a href=http://jeha00.github.io/tags/til/>TIL</a></li><li><a href=http://jeha00.github.io/tags/os/>OS</a></li></ul><nav class=paginav><a class=prev href=http://jeha00.github.io/post/python/python_basic_39_mapfilterreduce/><span class=title>« Prev Page</span><br><span>[TIL] Python basic 39: Map, Filter, Reduce</span></a>
<a class=next href=http://jeha00.github.io/post/python/python_basic_37_coroutine/><span class=title>Next Page »</span><br><span>[TIL] Python basic 37: Coroutine</span></a></nav><div class=share-buttons><a target=_blank rel="noopener noreferrer" aria-label="share [TIL] OS Chapter 02: Introduction to Operating System on twitter" href="https://twitter.com/intent/tweet/?text=%5bTIL%5d%20OS%20Chapter%2002%3a%20Introduction%20to%20Operating%20System&url=http%3a%2f%2fjeha00.github.io%2fpost%2fos%2fos_chapter_02_%25EC%259A%25B4%25EC%2598%2581%25EC%25B2%25B4%25EC%25A0%259C_%25EA%25B0%259C%25EC%259A%2594%2f&hashtags=TIL%2cOS"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM195.519 424.544c135.939.0 210.268-112.643 210.268-210.268.0-3.218.0-6.437-.153-9.502 14.406-10.421 26.973-23.448 36.935-38.314-13.18 5.824-27.433 9.809-42.452 11.648 15.326-9.196 26.973-23.602 32.49-40.92-14.252 8.429-30.038 14.56-46.896 17.931-13.487-14.406-32.644-23.295-53.946-23.295-40.767.0-73.87 33.104-73.87 73.87.0 5.824.613 11.494 1.992 16.858-61.456-3.065-115.862-32.49-152.337-77.241-6.284 10.881-9.962 23.601-9.962 37.088.0 25.594 13.027 48.276 32.95 61.456-12.107-.307-23.448-3.678-33.41-9.196v.92c0 35.862 25.441 65.594 59.311 72.49-6.13 1.686-12.72 2.606-19.464 2.606-4.751.0-9.348-.46-13.946-1.38 9.349 29.426 36.628 50.728 68.965 51.341-25.287 19.771-57.164 31.571-91.8 31.571-5.977.0-11.801-.306-17.625-1.073 32.337 21.15 71.264 33.41 112.95 33.41z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share [TIL] OS Chapter 02: Introduction to Operating System on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&url=http%3a%2f%2fjeha00.github.io%2fpost%2fos%2fos_chapter_02_%25EC%259A%25B4%25EC%2598%2581%25EC%25B2%25B4%25EC%25A0%259C_%25EA%25B0%259C%25EC%259A%2594%2f&title=%5bTIL%5d%20OS%20Chapter%2002%3a%20Introduction%20to%20Operating%20System&summary=%5bTIL%5d%20OS%20Chapter%2002%3a%20Introduction%20to%20Operating%20System&source=http%3a%2f%2fjeha00.github.io%2fpost%2fos%2fos_chapter_02_%25EC%259A%25B4%25EC%2598%2581%25EC%25B2%25B4%25EC%25A0%259C_%25EA%25B0%259C%25EC%259A%2594%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share [TIL] OS Chapter 02: Introduction to Operating System on reddit" href="https://reddit.com/submit?url=http%3a%2f%2fjeha00.github.io%2fpost%2fos%2fos_chapter_02_%25EC%259A%25B4%25EC%2598%2581%25EC%25B2%25B4%25EC%25A0%259C_%25EA%25B0%259C%25EC%259A%2594%2f&title=%5bTIL%5d%20OS%20Chapter%2002%3a%20Introduction%20to%20Operating%20System"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share [TIL] OS Chapter 02: Introduction to Operating System on facebook" href="https://facebook.com/sharer/sharer.php?u=http%3a%2f%2fjeha00.github.io%2fpost%2fos%2fos_chapter_02_%25EC%259A%25B4%25EC%2598%2581%25EC%25B2%25B4%25EC%25A0%259C_%25EA%25B0%259C%25EC%259A%2594%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share [TIL] OS Chapter 02: Introduction to Operating System on whatsapp" href="https://api.whatsapp.com/send?text=%5bTIL%5d%20OS%20Chapter%2002%3a%20Introduction%20to%20Operating%20System%20-%20http%3a%2f%2fjeha00.github.io%2fpost%2fos%2fos_chapter_02_%25EC%259A%25B4%25EC%2598%2581%25EC%25B2%25B4%25EC%25A0%259C_%25EA%25B0%259C%25EC%259A%2594%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share [TIL] OS Chapter 02: Introduction to Operating System on telegram" href="https://telegram.me/share/url?text=%5bTIL%5d%20OS%20Chapter%2002%3a%20Introduction%20to%20Operating%20System&url=http%3a%2f%2fjeha00.github.io%2fpost%2fos%2fos_chapter_02_%25EC%259A%25B4%25EC%2598%2581%25EC%25B2%25B4%25EC%25A0%259C_%25EA%25B0%259C%25EC%259A%2594%2f"><svg viewBox="2 2 28 28"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></div></footer></article></main><footer class=footer><span>&copy; 2023 <a href=http://jeha00.github.io/>Jeha DevLog</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerText="copy";function s(){t.innerText="copied!",setTimeout(()=>{t.innerText="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>