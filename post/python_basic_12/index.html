<!doctype html><html lang=en dir=auto>
<head><meta charset=utf-8>
<meta http-equiv=x-ua-compatible content="IE=edge">
<meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no">
<meta name=robots content="index, follow">
<title>[TIL] Python basic 12: Method | Jeha00 DevLog</title>
<meta name=keywords content="TIL,python">
<meta name=description content="함수의 중요성 및 선언, Packing & Unpacking, 중첩 함수(Nested function), 람바 함사(익명 함수), 함수 Type hint 에 대해 알아본다.">
<meta name=author content="Jeha00">
<link rel=canonical href=http://jeha00.github.io/post/python_basic_12/>
<meta name=google-site-verification content="XYZabc">
<meta name=yandex-verification content="XYZabc">
<meta name=msvalidate.01 content="XYZabc">
<link crossorigin=anonymous href=/assets/css/stylesheet.min.c88963fe2d79462000fd0fb1b3737783c32855d340583e4523343f8735c787f0.css integrity="sha256-yIlj/i15RiAA/Q+xs3N3g8MoVdNAWD5FIzQ/hzXHh/A=" rel="preload stylesheet" as=style>
<script defer crossorigin=anonymous src=/assets/js/highlight.min.7680afc38aa6b15ddf158a4f3780b7b1f7dde7e91d26f073e6229bb7a0793c92.js integrity="sha256-doCvw4qmsV3fFYpPN4C3sffd5+kdJvBz5iKbt6B5PJI=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=http://jeha00.github.io/favicon.ico>
<link rel=icon type=image/png sizes=16x16 href=http://jeha00.github.io/favicon-16x16.png>
<link rel=icon type=image/png sizes=32x32 href=http://jeha00.github.io/favicon-32x32.png>
<link rel=apple-touch-icon href=http://jeha00.github.io/apple-touch-icon.png>
<link rel=mask-icon href=http://jeha00.github.io/safari-pinned-tab.svg>
<meta name=theme-color content="#2e2e33">
<meta name=msapplication-TileColor content="#2e2e33">
<meta name=generator content="Hugo 0.92.1">
<noscript>
<style>#theme-toggle,.top-link{display:none}</style>
<style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style>
</noscript>
<script type=application/javascript>var doNotTrack=!1;doNotTrack||(function(a,e,f,g,b,c,d){a.GoogleAnalyticsObject=b,a[b]=a[b]||function(){(a[b].q=a[b].q||[]).push(arguments)},a[b].l=1*new Date,c=e.createElement(f),d=e.getElementsByTagName(f)[0],c.async=1,c.src=g,d.parentNode.insertBefore(c,d)}(window,document,'script','https://www.google-analytics.com/analytics.js','ga'),ga('create','UA-123-45','auto'),ga('send','pageview'))</script><meta property="og:title" content="[TIL] Python basic 12: Method">
<meta property="og:description" content="함수의 중요성 및 선언, Packing & Unpacking, 중첩 함수(Nested function), 람바 함사(익명 함수), 함수 Type hint 에 대해 알아본다.">
<meta property="og:type" content="article">
<meta property="og:url" content="http://jeha00.github.io/post/python_basic_12/"><meta property="og:image" content="http://jeha00.github.io/47"><meta property="article:section" content="post">
<meta property="article:published_time" content="2022-03-02T00:50:00+09:00">
<meta property="article:modified_time" content="2022-03-02T00:50:00+09:00"><meta property="og:site_name" content="JeHa00 DevLog">
<meta name=twitter:card content="summary_large_image">
<meta name=twitter:image content="http://jeha00.github.io/47">
<meta name=twitter:title content="[TIL] Python basic 12: Method">
<meta name=twitter:description content="함수의 중요성 및 선언, Packing & Unpacking, 중첩 함수(Nested function), 람바 함사(익명 함수), 함수 Type hint 에 대해 알아본다.">
<script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"http://jeha00.github.io/post/"},{"@type":"ListItem","position":2,"name":"[TIL] Python basic 12: Method","item":"http://jeha00.github.io/post/python_basic_12/"}]}</script>
<script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"[TIL] Python basic 12: Method","name":"[TIL] Python basic 12: Method","description":"함수의 중요성 및 선언, Packing \u0026amp; Unpacking, 중첩 함수(Nested function), 람바 함사(익명 함수), 함수 Type hint 에 대해 알아본다.","keywords":["TIL","python"],"articleBody":"1. 함수 중요성  첫 번째 , 코드의 흐름을 원활히 할 수 있다.  요즘은 코드의 복잡도가 커지면서 코드 양이 매우 많아졌다. 그래서 이 코드를 일괄작성하기가 힘들다. 이에 대한 대책으로 단계별로 생각하여 각 단계마다 함수를 사용하여 개발을 원활하게 풀어갈 수 있다.   두 번째, 함수로 사용하면 코드의 재사용성이 향상된다.  하나의 기능을 각 소스마다 중복하여 집어 넣으면, 그 기능을 수정해야할 경우, 다 수정해야하는 번거로움이 있다. 이런 것들이 비효율적이기 때문에, 함수로 만들면 한 번의 수정으로 다 수정할 수 있다.   세 번째, 코드의 안정성이 좋아진다.  그 이유는 개발자가 자신이 담당하는 함수에만 집중할 수 있기 때문에, 함수 이외의 부분과 나눠서 생각할 수 있다.     2. 함수 선언 및 사용   함수에서 return 사용하지 않으면\n print로 출력할 수 없다. unpacking을 사용할 수 없다.    여러 값을 return 으로 반환하는 것을 다중 반환이라 한다.\n  ## return 명령어가 없을 경우  def func_mul(x):  y1 = x * 10  x1 = func_mul(10)  print(x1, type(x1)) None  # 출력할 수 없다. ## return 명령어가 있을 경우  def func_mul(x):  y1 = x * 10  return y1  x1 = func_mul(10)  print(x1) 100 ## No return and unpacking  def func_mul1(x):  y1 = x * 10  y2 = x * 20  y3 = x * 30 # unpacking  x1, x2, x3 = func_mul1(10)  print(x1, x2, x3) TypeError: cannot unpack non-iterable NoneType object # 다중 반환 확인하기  def func_mul1(x):  y1 = x * 10  y2 = x * 20  y3 = x * 30  return y1, y2, y3 # unpacking  x1, x2, x3 = func_mul1(10)  print(x1, x2, x3) 100 200 300  원하는 data type으로 함수값을 출력하려면 어떻게 해야하는지 알아보자. return 할 data의 type이 출력할 data type이 된다.  ## tuple return  def func_mul1(x):  y1 = x * 10  y2 = x * 20  y3 = x * 30  return (y1, y2, y3)  # tuple 형식  t1 = func_mul1(10)  print(t1, type(t1)) (100, 200, 300)  ## list return  def func_mul2(x):  y1 = x * 10  y2 = x * 20  y3 = x * 30  return [y1, y2, y3]  # list 형식  t1 = func_mul2(10)  print(t1, type(t1)) [100, 200, 300]  ## dictionary return  def func_mul3(x):  y1 = x * 10  y2 = x * 20  y3 = x * 30  return {'v1' : y1, 'v2' : y2, 'v3' : y3} # keyword 형식  t1 = func_mul3(10)  print(t1, type(t1))  print(t1.values()) {'v1': 100, 'v2': 200, 'v3': 300}  dict_values([100, 200, 300])  d = func_mul3(30)  print(type(d), d, d.get('v2'), d.items(), d.keys()) {'v1': 300, 'v2': 600, 'v3': 900} 600 dict_items([('v1', 300), ('v2', 600), ('v3', 900)]) dict_keys(['v1', 'v2', 'v3'])  3. Packing, Unpacking 3.1 Positional argument, Keyword argument  함수 인자에는 Positional argument(위치인자)와 Keyword argument(키워드 인자)가 있다.  인자란 함수 기능에 필요한 값을 말한다. 기본값이 있다.  기본값이란 미리 기본으로 지정된 값을 말한다.   Positional argument는 인자값이 위치에 의해 결정되는 인자다.  순서가 중요하다.   Keyword argument는 key value가 key에 의해 결정되는 인자다.  순서 상관 없이 keyword가 중요하다.      # Positional argument(위치인자) # real number (실수)는 앞에, imaginary number(허수)는 뒤에 위치해야 된다. # 위치 즉, 순서가 중요하다.  complex(3, 5) (3 + 5j) # Keyword argument(키워드 인자) # key = value  complex (real = 3, imag = 5) (3 + 5j) 3.2 Packing  print 함수는 객체의 갯수에 제한 없이 출력한다.  # 1개  print('123 456 789') 123 456 789 # 3개  print('123, '456, '789') 123 456 789  print 함수처럼 함수가 받을 인자의 갯수를 유연하게 지정하기 위해 Python은 packing을 지원한다. packing 은  arguments를 하나의 객체로 합쳐서 받을 수 있도록 한다. positional argument packing 과 keyword argument packing이 있다.   positional argument packing은  * 한 개를 매개변수 앞에 붙여서 사용한다. 이 때는 tuple type 으로 하나의 객체가 된다.   keyword argument packing은  * 두 개 즉, **를 매개변수 앞에 붙여서 사용한다. keyword와 value로 구성된 dictionary type으로 하나의 객체가 된다.     positional argument packing을 사용하는 방법  parameter를 입력할 때, 입력되는 수만큼 (x, y, z, a, b)로 입력할 수 있다. 하지만, *args를 사용하여 하나의 객체로서 packing 하여 간단히 관리할 수 있다. args는 매개변수 명으로, 자유롭게 명명한다.     positional argument에 대해 앞서서 enumerate () 에 대해 알아보겠다.  # enumerate() # enumerate는 index 와 value 를 `tuple` 형식으로 하나의 성분으로서 맺어주고, return 해주는 함수다.  seasons = ['Spring', 'Summber', 'Fall', 'Winter'] # enumerate()를 하면 바로 id 값만 출력된다.  print(enumerate(seasons))   print(list(enumerate(seasons))) [(0, 'Spring'), (1, 'Summber'), (2, 'Fall'), (3, 'Winter')]  print(tuple(enumerate(seasons))) ((0, 'Spring'), (1, 'Summber'), (2, 'Fall'), (3, 'Winter'))  enumerate () 를 사용하여 positional arguments packing을 설명하겠다. enumerate ()를 for ~ in문에 사용하겠다.  # args == arguments  def args_func(*args):  for i, v in enumerate(args):  print('Result : {}'.format(i), v) # 인자의 수가 다양해도 다 받아지는 걸 알 수 있다.  args_func('Lee') Result : 0 Lee # 위치인자로 보낸 모든 객체들('Lee', 'Park')을 *args로 하나의 객체로서 관리해준다.  args_func('Lee', 'Park') Result : 0 Lee Result : 1 Park  args_func('Lee', 'Park', 'Kim') Result : 0 Lee Result : 1 Park Result : 2 Kim  keyword argument packing을 사용하는 방법   def kwargs_func(**kwargs):  for v in kwargs.keys():  print(\"{}\".format(v), kwargs[v]) # keyword arguments를 packing 하여 dictionary로 관리한다.  kwargs_func(name1='Apple') name1 Apple  kwargs_func(name1='Apple', name2='Window') name1 Apple name2 Window  kwargs_func(name1='Apple', name2='Window', name3='Choice') name1 Apple name2 Window name3 Choice  positional argument 와 keyword argument를 같이 사용해보자.   def example(args_1, args_2, *args, **kwargs):  print(args_1, args_2, args, kwargs)  example(10, 20, 'Lee', 'Kim', 'Park', 'Cho', age1=20, age2=30, age3=40) 10 20 ('Lee', 'Kim', 'Park', 'Cho') {'age1': 20, 'age2': 30, 'age3': 40} # args_1, args_2 로 총 2개이므로, print의 매개변수 앞에서 2개까지가 일반적인 positional argument이다. # 그 뒤에, *args 는 positional argument packing이므로 제한 없다. tuple 로 출력된 걸 확인할 수 있다. # 맨 마지막 인자는 ** 이므로, keyword argument packing이다. dictionary로 출력된 걸 확인할 수 있다. 3.3 Unpacking  Unpacking은 packing과는 반대로 여러개의 객체를 포함하고 있는 하나의 객체를 푼다. Unpacking 시 해체되는 인자의 수와 매칭되는 변수의 수가 동일해야 가능하다. packing 시에는 매개변수에 *을 붙였지만, unpacking 시에는 argument 앞에 *를 붙여서 사용한다.   def sum(a, b, c):  return a + b + c  number = (1, 2, 3)  print(sum(*number)) 6  또는 다음과 같은 방식으로 unpacking 할 수 있다.   def func_mul1(x):  y1 = x * 10  y2 = x * 20  y3 = x * 30  return y1, y2, y3 # unpacking  x1, x2, x3 = func_mul1(10)  4. 중첩 함수 (Nested function)  중첩 함수란 함수 내부에 정의된 또 다른 함수 중첩 함수는 함수형 프로그래밍에서 많이 사용된다. 호출하는 함수는 부모 함수 이다. 부모 함수의 하위 함수를 호출할 수 없고,부모 함수의 매개변수를 받아서 사용한다.  # 중첩 함수  def nested_func(num): # 부모 함수  def func_in_func(num): # 부모 함수의 매개변수를 받아서 사용 가능  print(num)  print(\"In func\")  func_in_func(num + 100)  nested_func(100) 200 # 부모 함수의 하위 함수를 호출하여 사용할 수 없다.  func_in_func(100) NameError: name 'func_in_func' is not defined  5. 람다(lambda) 함수 (익명함수)   람다식의 장점 from python 공식 사이트\n 메모리 절약 가독성 향상 코드 간결    람다식의 단점 (많은 실력자 분들이 람다식을 부정적으로 피력한다.)\n 과한 사용 시, 가독성 감소된다. 왜냐하면 익명 함수이기 때문이다. (빈번히 언급됨) (일반적인 함수는 함수명을 보고 그 기능을 추측할 수 있다.)    일반적인 함수와 람다식 함수의 차이\n  일반적인 함수는 함수명이 있기 때문에, 객체 생성 된다.\n  그 후, resource(memory)를 할당한다.\n  하지만, 람다식 함수는\n 즉시 실행 함수 라서, Heap 영역에 저장되고 (Heap 초기화), 메모리 초기화를 한다. 초기화로 메모리를 효율적으로 사용할 수 있다. 함수명이 존재하지 않아, 익명 함수라 한다. 그래서 별도의 변수에 할당해야 한다.     def mul_func(x, y):  return x * y  print(mul_func(10, 50)) 500 # 첫 번째: 이미 변수에 할당해 놓은 일반적인 함수를 넣는 방법  mul_func_var = mul_func  print(mul_func_var(10, 50)) 500 # 두 번째: 자주 쓰는 람다 함수이기 때문에, 정의를 해서 변수로 넘기는 방식 # 일시적으로 그 자리에서 함수가 필요할 때 사용한다. # def 와 return이 없어도 가능하다. # 람다식을 넣은 함수  lambda_mul_func = lambda x,y : x * y  print(lambda_mul_func(10, 50)) 500 # 함수 안에서 함수를 인자로 받는 함수  def func_final(x, y, func):  print(x * y * func(1,1)) # 첫 번째 방식  func_final(10, 50, mul_func_var) 500 # 두 번째 방식  func_final(10, 50, lambda_mul_func) 500 # 세 번째 방식: 바로 그 자리에서 람다식을 써서 넘기는 방법  func_final(10, 50, lambda x,y : x * y)  위 방식대로 총 함수를 정의하는데 3가지 방식이 있다. 각 방식에 대해서 언제 무엇을 써야할지 생각해보자.   6. 함수 Type Hint  함수의 매개변수와 함수의 결과값의 데이터 타입을 알려주기 위해 python 3.5 부터 나온 기능이다. def (parameter1: ) -   # 아래 예시처럼 각 매개변수의 데이터 타입이 무엇인지 알려준다. # 그리고, 함수의 결과값의 데이터 타입도 알려준다.  def tot_length1(word: str, num: int) - int:  return len(word) * num # 아래 함수는 위 함수와 동일하다.  def tot_length1(word, num):  return len(word) * num  print('hint exam1 : ', tot_length1(\"i love you\", 10))  print(type(tot_length1(\"i love you\", 10))) hint exam1 : 100 int'  def tot_length2(word: str, num: int) - None:  print('hint exam2 : ', len(word) * num)  print(tot_length2(\"niceman\", 10))  print(type(tot_length2(\"i love you\", 10))) hint exam2 : 70 Nonetype'  tot_length2의 data type이 Nonetype인 이유는 return 값이 없기 때문이다.   Reference  Positional argument, Keyword argument Packing, Unpacking enumerate lambda function  ","wordCount":"1515","inLanguage":"en","datePublished":"2022-03-02T00:50:00+09:00","dateModified":"2022-03-02T00:50:00+09:00","author":{"@type":"Person","name":"Jeha00"},"mainEntityOfPage":{"@type":"WebPage","@id":"http://jeha00.github.io/post/python_basic_12/"},"publisher":{"@type":"Organization","name":"Jeha00 DevLog","logo":{"@type":"ImageObject","url":"http://jeha00.github.io/favicon.ico"}}}</script>
</head>
<body id=top>
<script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add('dark'):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove('dark'):window.matchMedia('(prefers-color-scheme: dark)').matches&&document.body.classList.add('dark')</script>
<header class=header>
<nav class=nav>
<div class=logo>
<a href=http://jeha00.github.io/ accesskey=h title="Jeha00 (Alt + H)">Jeha00</a>
<span class=logo-switches>
<button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg>
</button>
</span>
</div>
<ul id=menu>
<li>
<a href=http://jeha00.github.io/archives/ title=Archive>
<span>Archive</span>
</a>
</li>
<li>
<a href=http://jeha00.github.io/categories/ title=Categories>
<span>Categories</span>
</a>
</li>
<li>
<a href=http://jeha00.github.io/tags/ title=Tags>
<span>Tags</span>
</a>
</li>
<li>
<a href=http://jeha00.github.io/search/ title="Search (Alt + /)" accesskey=/>
<span>Search</span>
</a>
</li>
</ul>
</nav>
</header>
<main class=main>
<article class=post-single>
<header class=post-header>
<div class=breadcrumbs><a href=http://jeha00.github.io/>Home</a>&nbsp;»&nbsp;<a href=http://jeha00.github.io/post/>Posts</a></div>
<h1 class=post-title>
[TIL] Python basic 12: Method
</h1>
<div class=post-meta><span title="2022-03-02 00:50:00 +0900 KST">March 2, 2022</span>&nbsp;·&nbsp;8 min&nbsp;·&nbsp;Jeha00&nbsp;|&nbsp;<a href=https://github.com/JeHa00/blog/content/post/Python_basic_12.md rel="noopener noreferrer" target=_blank>Suggest Changes</a>
</div>
</header> <div class=toc>
<details>
<summary accesskey=c title="(Alt + C)">
<span class=details>Table of Contents</span>
</summary>
<div class=inner><ul>
<li>
<a href=#1-%ed%95%a8%ec%88%98-%ec%a4%91%ec%9a%94%ec%84%b1 aria-label="1. 함수 중요성">1. 함수 중요성</a></li>
<li>
<a href=#2-%ed%95%a8%ec%88%98-%ec%84%a0%ec%96%b8-%eb%b0%8f-%ec%82%ac%ec%9a%a9 aria-label="2. 함수 선언 및 사용">2. 함수 선언 및 사용</a></li>
<li>
<a href=#3-packing-unpacking aria-label="3. Packing, Unpacking">3. Packing, Unpacking</a><ul>
<li>
<a href=#31-positional-argument-keyword-argument aria-label="3.1 Positional argument, Keyword argument">3.1 Positional argument, Keyword argument</a></li>
<li>
<a href=#32-packing aria-label="3.2 Packing">3.2 Packing</a></li>
<li>
<a href=#33-unpacking aria-label="3.3 Unpacking">3.3 Unpacking</a></li></ul>
</li>
<li>
<a href=#4-%ec%a4%91%ec%b2%a9-%ed%95%a8%ec%88%98-nested-function aria-label="4. 중첩 함수 (Nested function)">4. 중첩 함수 (Nested function)</a></li>
<li>
<a href=#5-%eb%9e%8c%eb%8b%a4lambda-%ed%95%a8%ec%88%98-%ec%9d%b5%eb%aa%85%ed%95%a8%ec%88%98 aria-label="5. 람다(lambda) 함수 (익명함수)">5. 람다(lambda) 함수 (익명함수)</a></li>
<li>
<a href=#6-%ed%95%a8%ec%88%98-type-hint aria-label="6. 함수 Type Hint">6. 함수 Type Hint</a></li>
<li>
<a href=#reference aria-label=Reference>Reference</a>
</li>
</ul>
</div>
</details>
</div>
<div class=post-content><h2 id=1-함수-중요성>1. 함수 중요성<a hidden class=anchor aria-hidden=true href=#1-함수-중요성>#</a></h2>
<ul>
<li>첫 번째 , <code>코드의 흐름</code>을 원활히 할 수 있다.
<ul>
<li>요즘은 코드의 복잡도가 커지면서 코드 양이 매우 많아졌다. 그래서 이 코드를 일괄작성하기가 힘들다. 이에 대한 대책으로 단계별로 생각하여 각 단계마다 함수를 사용하여 개발을 원활하게 풀어갈 수 있다.</li>
</ul>
</li>
<li>두 번째, 함수로 사용하면 <code>코드의 재사용성</code>이 향상된다.
<ul>
<li>하나의 기능을 각 소스마다 중복하여 집어 넣으면, 그 기능을 수정해야할 경우, 다 수정해야하는 번거로움이 있다. 이런 것들이 비효율적이기 때문에, 함수로 만들면 한 번의 수정으로 다 수정할 수 있다.</li>
</ul>
</li>
<li>세 번째, <code>코드의 안정성</code>이 좋아진다.
<ul>
<li>그 이유는 개발자가 자신이 담당하는 함수에만 집중할 수 있기 때문에, 함수 이외의 부분과 나눠서 생각할 수 있다.</li>
</ul>
</li>
</ul>
<hr>
<h2 id=2-함수-선언-및-사용>2. 함수 선언 및 사용<a hidden class=anchor aria-hidden=true href=#2-함수-선언-및-사용>#</a></h2>
<ul>
<li>
<p>함수에서 <code>return</code> 사용하지 않으면</p>
<ul>
<li><code>print</code>로 출력할 수 없다.</li>
<li><code>unpacking</code>을 사용할 수 없다.</li>
</ul>
</li>
<li>
<p>여러 값을 <code>return</code> 으로 반환하는 것을 <code>다중 반환</code>이라 한다.</p>
</li>
</ul>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yml data-lang=yml>
<span style=color:#75715e>## return 명령어가 없을 경우</span>
<span style=color:#f92672>&gt; def func_mul(x)</span>:
<span style=color:#ae81ff>&gt;    y1 = x * 10</span>

<span style=color:#ae81ff>&gt; x1 = func_mul(10)</span>
<span style=color:#ae81ff>&gt; print(x1, type(x1))</span>
<span style=color:#ae81ff>None &lt;class &#39;NoneType&#39;&gt;</span>
<span style=color:#75715e># 출력할 수 없다.</span>

<span style=color:#75715e>## return 명령어가 있을 경우</span>
<span style=color:#f92672>&gt; def func_mul(x)</span>:
<span style=color:#ae81ff>&gt;    y1 = x * 10</span>
<span style=color:#ae81ff>&gt;    return y1</span>

<span style=color:#ae81ff>&gt; x1 = func_mul(10)</span>
<span style=color:#ae81ff>&gt; print(x1)</span>
<span style=color:#ae81ff>100</span>


<span style=color:#75715e>## No return and unpacking</span>
<span style=color:#f92672>&gt; def func_mul1(x)</span>:
<span style=color:#ae81ff>&gt;    y1 = x * 10</span>
<span style=color:#ae81ff>&gt;    y2 = x * 20</span>
<span style=color:#ae81ff>&gt;    y3 = x * 30</span>

<span style=color:#75715e># unpacking</span>
<span style=color:#ae81ff>&gt; x1, x2, x3 = func_mul1(10)</span>

<span style=color:#ae81ff>&gt; print(x1, x2, x3)</span>
<span style=color:#f92672>TypeError</span>: <span style=color:#ae81ff>cannot unpack non-iterable NoneType object</span>

<span style=color:#75715e># 다중 반환 확인하기</span>
<span style=color:#f92672>&gt; def func_mul1(x)</span>:
<span style=color:#ae81ff>&gt;    y1 = x * 10</span>
<span style=color:#ae81ff>&gt;    y2 = x * 20</span>
<span style=color:#ae81ff>&gt;    y3 = x * 30</span>
<span style=color:#ae81ff>&gt;    return y1, y2, y3</span>
<span style=color:#75715e># unpacking</span>
<span style=color:#ae81ff>&gt; x1, x2, x3 = func_mul1(10)</span>
<span style=color:#ae81ff>&gt; print(x1, x2, x3)</span>
<span style=color:#ae81ff>100</span> <span style=color:#ae81ff>200</span> <span style=color:#ae81ff>300</span>

</code></pre></div><ul>
<li>원하는 <code>data type</code>으로 함수값을 출력하려면 어떻게 해야하는지 알아보자.</li>
<li>return 할 data의 type이 출력할 data type이 된다.</li>
</ul>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yml data-lang=yml>
<span style=color:#75715e>## tuple return</span>
<span style=color:#f92672>&gt; def func_mul1(x)</span>:
<span style=color:#ae81ff>&gt;    y1 = x * 10</span>
<span style=color:#ae81ff>&gt;    y2 = x * 20</span>
<span style=color:#ae81ff>&gt;    y3 = x * 30</span>
<span style=color:#ae81ff>&gt;    return (y1, y2, y3) </span> <span style=color:#75715e># tuple 형식</span>

<span style=color:#ae81ff>&gt; t1 = func_mul1(10)</span>
<span style=color:#ae81ff>&gt; print(t1, type(t1))</span>
<span style=color:#ae81ff>(100, 200, 300)  &lt;class &#39;tuple&#39;&gt;</span>

<span style=color:#75715e>## list return</span>
<span style=color:#f92672>&gt; def func_mul2(x)</span>:
<span style=color:#ae81ff>&gt;    y1 = x * 10</span>
<span style=color:#ae81ff>&gt;    y2 = x * 20</span>
<span style=color:#ae81ff>&gt;    y3 = x * 30</span>
<span style=color:#ae81ff>&gt;    return [y1, y2, y3] </span> <span style=color:#75715e># list 형식</span>

<span style=color:#ae81ff>&gt; t1 = func_mul2(10)</span>
<span style=color:#ae81ff>&gt; print(t1, type(t1))</span>
[<span style=color:#ae81ff>100</span>, <span style=color:#ae81ff>200</span>, <span style=color:#ae81ff>300</span>] <span style=color:#ae81ff>&lt;class &#39;list&#39;&gt;</span>

<span style=color:#75715e>## dictionary return</span>
<span style=color:#f92672>&gt; def func_mul3(x)</span>:
<span style=color:#ae81ff>&gt;    y1 = x * 10</span>
<span style=color:#ae81ff>&gt;    y2 = x * 20</span>
<span style=color:#ae81ff>&gt;    y3 = x * 30</span>
<span style=color:#ae81ff>&gt;    return {&#39;v1&#39; : y1, &#39;v2&#39; : y2, &#39;v3&#39; : y3}</span> <span style=color:#75715e># keyword 형식</span>

<span style=color:#ae81ff>&gt; t1 = func_mul3(10)</span>
<span style=color:#ae81ff>&gt; print(t1, type(t1))</span>
<span style=color:#ae81ff>&gt; print(t1.values())</span>
{<span style=color:#f92672>&#39;v1&#39;: 100, &#39;v2&#39;: 200, &#39;v3&#39;</span>: <span style=color:#ae81ff>300</span>} <span style=color:#ae81ff>&lt;class &#39;dict&#39;&gt;</span>
<span style=color:#ae81ff>dict_values([100, 200, 300])</span>

<span style=color:#ae81ff>&gt; d = func_mul3(30)</span>
<span style=color:#ae81ff>&gt; print(type(d), d, d.get(&#39;v2&#39;), d.items(), d.keys())</span>
<span style=color:#ae81ff>&lt;class &#39;dict&#39;&gt; {&#39;v1&#39;: 300, &#39;v2&#39;: 600, &#39;v3&#39;: 900} 600 dict_items([(&#39;v1&#39;, 300), (&#39;v2&#39;, 600), (&#39;v3&#39;, 900)]) dict_keys([&#39;v1&#39;, &#39;v2&#39;, &#39;v3&#39;])</span>
</code></pre></div><hr>
<h2 id=3-packing-unpacking>3. Packing, Unpacking<a hidden class=anchor aria-hidden=true href=#3-packing-unpacking>#</a></h2>
<h3 id=31-positional-argument-keyword-argument>3.1 Positional argument, Keyword argument<a hidden class=anchor aria-hidden=true href=#31-positional-argument-keyword-argument>#</a></h3>
<ul>
<li>함수 인자에는 <code>Positional argument(위치인자)</code>와 <code>Keyword argument(키워드 인자)</code>가 있다.
<ul>
<li>인자란 <code>함수 기능에 필요한 값</code>을 말한다.</li>
<li><code>기본값</code>이 있다.
<ul>
<li><code>기본값</code>이란 미리 기본으로 지정된 값을 말한다.</li>
</ul>
</li>
<li><code>Positional argument</code>는 인자값이 <code>위치</code>에 의해 결정되는 인자다.
<ul>
<li><code>순서</code>가 중요하다.</li>
</ul>
</li>
<li><code>Keyword argument</code>는 key value가 <code>key</code>에 의해 결정되는 인자다.
<ul>
<li><code>순서 상관 없이</code> <code>keyword</code>가 중요하다.</li>
</ul>
</li>
</ul>
</li>
</ul>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yml data-lang=yml><span style=color:#75715e># Positional argument(위치인자)</span>
<span style=color:#75715e># real number (실수)는 앞에, imaginary number(허수)는 뒤에 위치해야 된다.</span>
<span style=color:#75715e># 위치 즉, 순서가 중요하다.</span>
<span style=color:#ae81ff>&gt; complex(3, 5)</span>
<span style=color:#ae81ff>(3 + 5j)</span>

<span style=color:#75715e># Keyword argument(키워드 인자)</span>
<span style=color:#75715e># key = value</span>
<span style=color:#ae81ff>&gt; complex (real = 3, imag = 5)</span>
<span style=color:#ae81ff>(3 + 5j)</span>
</code></pre></div>
<h3 id=32-packing>3.2 Packing<a hidden class=anchor aria-hidden=true href=#32-packing>#</a></h3>
<ul>
<li><code>print</code> 함수는 객체의 갯수에 제한 없이 출력한다.</li>
</ul>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yml data-lang=yml><span style=color:#75715e># 1개</span>
<span style=color:#ae81ff>&gt; print(&#39;123 456 789&#39;)</span>
<span style=color:#ae81ff>123</span> <span style=color:#ae81ff>456</span> <span style=color:#ae81ff>789</span>

<span style=color:#75715e># 3개</span>
<span style=color:#ae81ff>&gt; print(&#39;123, &#39;456, &#39;789&#39;)</span>
<span style=color:#ae81ff>123</span> <span style=color:#ae81ff>456</span> <span style=color:#ae81ff>789</span>
</code></pre></div><ul>
<li><code>print</code> 함수처럼 함수가 받을 인자의 갯수를 유연하게 지정하기 위해 Python은 <code>packing</code>을 지원한다.</li>
<li><code>packing</code> 은
<ul>
<li><code>arguments</code>를 <code>하나의 객체</code>로 합쳐서 받을 수 있도록 한다.</li>
<li><code>positional argument</code> packing 과 <code>keyword argument</code> packing이 있다.</li>
</ul>
</li>
<li><code>positional argument</code> packing은
<ul>
<li><code>*</code> 한 개를 매개변수 앞에 붙여서 사용한다.</li>
<li>이 때는 <code>tuple</code> type 으로 <code>하나의 객체</code>가 된다.</li>
</ul>
</li>
<li><code>keyword argument</code> packing은
<ul>
<li><code>*</code> 두 개 즉, <code>**</code>를 매개변수 앞에 붙여서 사용한다.</li>
<li><code>keyword</code>와 <code>value</code>로 구성된 <code>dictionary</code> type으로 <code>하나의 객체</code>가 된다.</li>
</ul>
</li>
</ul>
<ul>
<li><code>positional argument</code> packing을 사용하는 방법
<ul>
<li>parameter를 입력할 때, 입력되는 수만큼 (x, y, z, a, b)로 입력할 수 있다.</li>
<li>하지만, <code>*args</code>를 사용하여 하나의 객체로서 packing 하여 간단히 관리할 수 있다.</li>
<li><code>args</code>는 매개변수 명으로, 자유롭게 명명한다.</li>
</ul>
</li>
</ul>
<ul>
<li><code>positional argument</code>에 대해 앞서서 <code>enumerate ()</code> 에 대해 알아보겠다.</li>
</ul>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yml data-lang=yml><span style=color:#75715e># enumerate()</span>
<span style=color:#75715e># enumerate는 index 와 value 를 `tuple` 형식으로 하나의 성분으로서 맺어주고, return 해주는 함수다.</span>
<span style=color:#ae81ff>&gt; seasons = [&#39;Spring&#39;, &#39;Summber&#39;, &#39;Fall&#39;, &#39;Winter&#39;]</span>

<span style=color:#75715e># enumerate()를 하면 바로 id 값만 출력된다.</span>
<span style=color:#ae81ff>&gt; print(enumerate(seasons))</span>
<span style=color:#ae81ff>&lt;enumerate object at 0x000002957E6DE640&gt;</span>

<span style=color:#ae81ff>&gt; print(list(enumerate(seasons)))</span>
[<span style=color:#ae81ff>(0, &#39;Spring&#39;), (1, &#39;Summber&#39;), (2, &#39;Fall&#39;), (3, &#39;Winter&#39;)]</span>

<span style=color:#ae81ff>&gt; print(tuple(enumerate(seasons)))</span>
<span style=color:#ae81ff>((0, &#39;Spring&#39;), (1, &#39;Summber&#39;), (2, &#39;Fall&#39;), (3, &#39;Winter&#39;))</span>

</code></pre></div><ul>
<li><code>enumerate ()</code> 를 사용하여 <code>positional arguments</code> packing을 설명하겠다.</li>
<li><code>enumerate ()</code>를 <code>for ~ in</code>문에 사용하겠다.</li>
</ul>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yml data-lang=yml><span style=color:#75715e># args == arguments</span>
<span style=color:#f92672>&gt; def args_func(*args)</span>:
<span style=color:#f92672>&gt;   for i, v in enumerate(args)</span>:
<span style=color:#f92672>&gt;     print(&#39;Result </span>: {}<span style=color:#e6db74>&#39;.format(i), v)
</span><span style=color:#e6db74>
</span><span style=color:#e6db74># 인자의 수가 다양해도 다 받아지는 걸 알 수 있다.
</span><span style=color:#e6db74>&gt; args_func(&#39;</span><span style=color:#ae81ff>Lee&#39;)</span>
<span style=color:#f92672>Result </span>: <span style=color:#ae81ff>0</span> <span style=color:#ae81ff>Lee</span>

<span style=color:#75715e># 위치인자로 보낸 모든 객체들(&#39;Lee&#39;, &#39;Park&#39;)을 *args로 하나의 객체로서 관리해준다.</span>
<span style=color:#ae81ff>&gt; args_func(&#39;Lee&#39;, &#39;Park&#39;)</span>
<span style=color:#f92672>Result </span>: <span style=color:#ae81ff>0</span> <span style=color:#ae81ff>Lee</span>
<span style=color:#f92672>Result </span>: <span style=color:#ae81ff>1</span> <span style=color:#ae81ff>Park</span>


<span style=color:#ae81ff>&gt; args_func(&#39;Lee&#39;, &#39;Park&#39;, &#39;Kim&#39;)</span>
<span style=color:#f92672>Result </span>: <span style=color:#ae81ff>0</span> <span style=color:#ae81ff>Lee</span>
<span style=color:#f92672>Result </span>: <span style=color:#ae81ff>1</span> <span style=color:#ae81ff>Park</span>
<span style=color:#f92672>Result </span>: <span style=color:#ae81ff>2</span> <span style=color:#ae81ff>Kim</span>
</code></pre></div><ul>
<li><code>keyword argument</code> packing을 사용하는 방법</li>
</ul>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yml data-lang=yml><span style=color:#f92672>&gt; def kwargs_func(**kwargs)</span>:
<span style=color:#f92672>&gt;     for v in kwargs.keys()</span>:
<span style=color:#ae81ff>&gt;       print(&#34;{}&#34;.format(v), kwargs[v])</span>

<span style=color:#75715e># keyword arguments를 packing 하여 dictionary로 관리한다.</span>
<span style=color:#ae81ff>&gt; kwargs_func(name1=&#39;Apple&#39;)</span>
<span style=color:#ae81ff>name1 Apple</span>

<span style=color:#ae81ff>&gt; kwargs_func(name1=&#39;Apple&#39;, name2=&#39;Window&#39;)</span>
<span style=color:#ae81ff>name1 Apple</span>
<span style=color:#ae81ff>name2 Window</span>

<span style=color:#ae81ff>&gt; kwargs_func(name1=&#39;Apple&#39;, name2=&#39;Window&#39;, name3=&#39;Choice&#39;)</span>
<span style=color:#ae81ff>name1 Apple</span>
<span style=color:#ae81ff>name2 Window</span>
<span style=color:#ae81ff>name3 Choice</span>
</code></pre></div><ul>
<li><code>positional argument</code> 와 <code>keyword argument</code>를 같이 사용해보자.</li>
</ul>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yml data-lang=yml><span style=color:#f92672>&gt; def example(args_1, args_2, *args, **kwargs)</span>:
<span style=color:#ae81ff>&gt;    print(args_1, args_2, args, kwargs)</span>
<span style=color:#ae81ff>&gt; example(10, 20, &#39;Lee&#39;, &#39;Kim&#39;, &#39;Park&#39;, &#39;Cho&#39;, age1=20, age2=30, age3=40)</span>
<span style=color:#ae81ff>10</span> <span style=color:#ae81ff>20</span> <span style=color:#ae81ff>(&#39;Lee&#39;, &#39;Kim&#39;, &#39;Park&#39;, &#39;Cho&#39;) {&#39;age1&#39;: 20, &#39;age2&#39;: 30, &#39;age3&#39;: 40}</span>

<span style=color:#75715e># args_1, args_2 로 총 2개이므로, print의 매개변수 앞에서 2개까지가 일반적인 positional argument이다.</span>

<span style=color:#75715e># 그 뒤에, *args 는 positional argument packing이므로 제한 없다. tuple 로 출력된 걸 확인할 수 있다.</span>

<span style=color:#75715e># 맨 마지막 인자는 ** 이므로, keyword argument packing이다. dictionary로 출력된 걸 확인할 수 있다.</span>

</code></pre></div><h3 id=33-unpacking>3.3 Unpacking<a hidden class=anchor aria-hidden=true href=#33-unpacking>#</a></h3>
<ul>
<li><code>Unpacking</code>은 <code>packing</code>과는 반대로 여러개의 객체를 포함하고 있는 하나의 객체를 푼다.</li>
<li><strong><code>Unpacking</code> 시 해체되는 <code>인자의 수</code>와 매칭되는 <code>변수의 수</code>가 동일해야 가능하다.</strong></li>
<li><code>packing</code> 시에는 <code>매개변수</code>에 <code>*</code>을 붙였지만, <code>unpacking</code> 시에는 <code>argument</code> 앞에 <code>*</code>를 붙여서 사용한다.</li>
</ul>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yml data-lang=yml><span style=color:#f92672>&gt; def sum(a, b, c)</span>:
<span style=color:#ae81ff>&gt;  return a + b + c</span>
<span style=color:#ae81ff>&gt; number = (1, 2, 3)</span>
<span style=color:#ae81ff>&gt; print(sum(*number))</span>
<span style=color:#ae81ff>6</span>
</code></pre></div><ul>
<li>또는 다음과 같은 방식으로 <code>unpacking</code> 할 수 있다.</li>
</ul>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yml data-lang=yml><span style=color:#f92672>&gt; def func_mul1(x)</span>:
<span style=color:#ae81ff>&gt;    y1 = x * 10</span>
<span style=color:#ae81ff>&gt;    y2 = x * 20</span>
<span style=color:#ae81ff>&gt;    y3 = x * 30</span>
<span style=color:#ae81ff>&gt;    return y1, y2, y3</span>
<span style=color:#75715e># unpacking</span>
<span style=color:#ae81ff>&gt; x1, x2, x3 = func_mul1(10)</span>
</code></pre></div><hr>
<h2 id=4-중첩-함수-nested-function>4. 중첩 함수 (Nested function)<a hidden class=anchor aria-hidden=true href=#4-중첩-함수-nested-function>#</a></h2>
<ul>
<li><code>중첩 함수</code>란 함수 내부에 정의된 또 다른 함수</li>
<li><code>중첩 함수</code>는 <code>함수형 프로그래밍</code>에서 많이 사용된다.</li>
<li>호출하는 함수는 <code>부모 함수</code> 이다.</li>
<li><code>부모 함수</code>의 하위 함수를 호출할 수 없고,<code>부모 함수</code>의 매개변수를 받아서 사용한다.</li>
</ul>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yml data-lang=yml><span style=color:#75715e># 중첩 함수</span>
<span style=color:#f92672>&gt; def nested_func(num)</span>:  <span style=color:#75715e># 부모 함수</span>
<span style=color:#f92672>&gt;    def func_in_func(num)</span>: <span style=color:#75715e># 부모 함수의 매개변수를 받아서 사용 가능</span>
<span style=color:#ae81ff>&gt;      print(num)</span>
<span style=color:#ae81ff>&gt;    print(&#34;In func&#34;)</span>
<span style=color:#ae81ff>&gt;    func_in_func(num + 100)</span>

<span style=color:#ae81ff>&gt; nested_func(100)</span>
<span style=color:#ae81ff>200</span>

<span style=color:#75715e># 부모 함수의 하위 함수를 호출하여 사용할 수 없다.</span>
<span style=color:#ae81ff>&gt; func_in_func(100)</span>
<span style=color:#f92672>NameError</span>: <span style=color:#ae81ff>name &#39;func_in_func&#39; is not defined</span>

</code></pre></div><hr>
<h2 id=5-람다lambda-함수-익명함수>5. 람다(lambda) 함수 (익명함수)<a hidden class=anchor aria-hidden=true href=#5-람다lambda-함수-익명함수>#</a></h2>
<ul>
<li>
<p>람다식의 장점 from python 공식 사이트</p>
<ul>
<li>메모리 절약</li>
<li>가독성 향상</li>
<li>코드 간결</li>
</ul>
</li>
<li>
<p>람다식의 단점 (많은 실력자 분들이 람다식을 부정적으로 피력한다.)</p>
<ul>
<li>과한 사용 시, 가독성 감소된다. 왜냐하면 <code>익명 함수</code>이기 때문이다.</li>
<li>(빈번히 언급됨)</li>
<li>(일반적인 함수는 함수명을 보고 그 기능을 추측할 수 있다.)</li>
</ul>
</li>
<li>
<p>일반적인 함수와 람다식 함수의 차이</p>
</li>
<li>
<p><code>일반적인 함수</code>는 <code>함수명</code>이 있기 때문에, <code>객체 생성</code> 된다.</p>
</li>
<li>
<p>그 후, <code>resource(memory)를 할당</code>한다.</p>
</li>
<li>
<p>하지만, <code>람다식 함수</code>는</p>
<ul>
<li><code>즉시 실행 함수</code> 라서,</li>
<li><code>Heap</code> 영역에 저장되고 (Heap 초기화),</li>
<li>메모리 초기화를 한다.</li>
<li>초기화로 메모리를 효율적으로 사용할 수 있다.</li>
<li>함수명이 존재하지 않아, <code>익명 함수</code>라 한다. 그래서 별도의 변수에 할당해야 한다.</li>
</ul>
</li>
</ul>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yml data-lang=yml><span style=color:#f92672>&gt; def mul_func(x, y)</span>:
<span style=color:#ae81ff>&gt;   return x * y</span>

<span style=color:#ae81ff>&gt; print(mul_func(10, 50))</span>
<span style=color:#ae81ff>500</span>

<span style=color:#75715e># 첫 번째: 이미 변수에 할당해 놓은 일반적인 함수를 넣는 방법</span>
<span style=color:#ae81ff>&gt; mul_func_var = mul_func</span>
<span style=color:#ae81ff>&gt; print(mul_func_var(10, 50))</span>
<span style=color:#ae81ff>500</span>

<span style=color:#75715e># 두 번째: 자주 쓰는 람다 함수이기 때문에, 정의를 해서 변수로 넘기는 방식</span>
<span style=color:#75715e># 일시적으로 그 자리에서 함수가 필요할 때 사용한다.</span>
<span style=color:#75715e># def 와 return이 없어도 가능하다.</span>
<span style=color:#75715e># 람다식을 넣은 함수</span>
<span style=color:#f92672>&gt; lambda_mul_func = lambda x,y </span>: <span style=color:#ae81ff>x * y</span>
<span style=color:#ae81ff>&gt; print(lambda_mul_func(10, 50))</span>
<span style=color:#ae81ff>500</span>

<span style=color:#75715e># 함수 안에서 함수를 인자로 받는 함수</span>
<span style=color:#f92672>&gt; def func_final(x, y, func)</span>:
<span style=color:#ae81ff>&gt;     print(x * y * func(1,1))</span>

<span style=color:#75715e># 첫 번째 방식</span>
<span style=color:#ae81ff>&gt; func_final(10, 50, mul_func_var)</span>
<span style=color:#ae81ff>500</span>

<span style=color:#75715e># 두 번째 방식</span>
<span style=color:#ae81ff>&gt; func_final(10, 50, lambda_mul_func)</span>
<span style=color:#ae81ff>500</span>

<span style=color:#75715e># 세 번째 방식: 바로 그 자리에서 람다식을 써서 넘기는 방법</span>
<span style=color:#f92672>&gt; func_final(10, 50, lambda x,y </span>: <span style=color:#ae81ff>x * y)</span>

</code></pre></div><ul>
<li>위 방식대로 총 함수를 정의하는데 <code>3가지 방식</code>이 있다.</li>
<li>각 방식에 대해서 언제 무엇을 써야할지 생각해보자.</li>
</ul>
<hr>
<h2 id=6-함수-type-hint>6. 함수 Type Hint<a hidden class=anchor aria-hidden=true href=#6-함수-type-hint>#</a></h2>
<ul>
<li>함수의 매개변수와 함수의 결과값의 데이터 타입을 알려주기 위해 <code>python 3.5</code> 부터 나온 기능이다.</li>
<li><code>def &lt;function-name>(parameter1: &lt;data type>) -> &lt;함수 결과값의 data type></code></li>
</ul>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yml data-lang=yml>
<span style=color:#75715e># 아래 예시처럼 각 매개변수의 데이터 타입이 무엇인지 알려준다.</span>
<span style=color:#75715e># 그리고, 함수의 결과값의 데이터 타입도 알려준다.</span>
<span style=color:#f92672>&gt; def tot_length1(word: str, num</span>: <span style=color:#f92672>int) -&gt; int</span>:
<span style=color:#ae81ff>&gt;    return len(word) * num</span>

<span style=color:#75715e># 아래 함수는 위 함수와 동일하다.</span>
<span style=color:#f92672>&gt; def tot_length1(word, num)</span>:
<span style=color:#ae81ff>&gt;    return len(word) * num</span>

<span style=color:#f92672>&gt; print(&#39;hint exam1 </span>: <span style=color:#e6db74>&#39;, tot_length1(&#34;i love you&#34;, 10))
</span><span style=color:#e6db74>&gt; print(type(tot_length1(&#34;i love you&#34;, 10)))
</span><span style=color:#e6db74>hint exam1 : 100
</span><span style=color:#e6db74>&lt;class &#39;</span><span style=color:#ae81ff>int&#39;&gt;</span>

<span style=color:#f92672>&gt; def tot_length2(word: str, num</span>: <span style=color:#f92672>int) -&gt; None</span>:
<span style=color:#f92672>&gt;    print(&#39;hint exam2 </span>: <span style=color:#e6db74>&#39;, len(word) * num)
</span><span style=color:#e6db74>
</span><span style=color:#e6db74>
</span><span style=color:#e6db74>&gt; print(tot_length2(&#34;niceman&#34;, 10))
</span><span style=color:#e6db74>&gt; print(type(tot_length2(&#34;i love you&#34;, 10)))
</span><span style=color:#e6db74>hint exam2 : 70
</span><span style=color:#e6db74>&lt;class &#39;</span><span style=color:#ae81ff>Nonetype&#39;&gt;</span>

</code></pre></div><ul>
<li><code>tot_length2</code>의 data type이 <code>Nonetype</code>인 이유는 <code>return 값</code>이 없기 때문이다.</li>
</ul>
<hr>
<h2 id=reference>Reference<a hidden class=anchor aria-hidden=true href=#reference>#</a></h2>
<ul>
<li><a href=https://wikidocs.net/22799>Positional argument, Keyword argument</a></li>
<li><a href=https://wikidocs.net/22801>Packing, Unpacking</a></li>
<li><a href="https://docs.python.org/ko/3.6/library/functions.html?highlight=enumerate#enumerate">enumerate</a></li>
<li><a href=https://wikidocs.net/22804>lambda function</a></li>
</ul>
</div>
<footer class=post-footer>
<ul class=post-tags>
<li><a href=http://jeha00.github.io/tags/til/>TIL</a></li>
<li><a href=http://jeha00.github.io/tags/python/>python</a></li>
</ul>
<nav class=paginav>
<a class=prev href=http://jeha00.github.io/post/python_basic_13/>
<span class=title>« Prev Page</span>
<br>
<span>[TIL] Python basic 13: input</span>
</a>
<a class=next href=http://jeha00.github.io/post/python_basic_11/>
<span class=title>Next Page »</span>
<br>
<span>[TIL] Python basic 11: 흐름 제어문 (while 반복문)</span>
</a>
</nav>
<div class=share-buttons>
<a target=_blank rel="noopener noreferrer" aria-label="share [TIL] Python basic 12: Method on twitter" href="https://twitter.com/intent/tweet/?text=%5bTIL%5d%20Python%20basic%2012%3a%20Method&url=http%3a%2f%2fjeha00.github.io%2fpost%2fpython_basic_12%2f&hashtags=TIL%2cpython"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM195.519 424.544c135.939.0 210.268-112.643 210.268-210.268.0-3.218.0-6.437-.153-9.502 14.406-10.421 26.973-23.448 36.935-38.314-13.18 5.824-27.433 9.809-42.452 11.648 15.326-9.196 26.973-23.602 32.49-40.92-14.252 8.429-30.038 14.56-46.896 17.931-13.487-14.406-32.644-23.295-53.946-23.295-40.767.0-73.87 33.104-73.87 73.87.0 5.824.613 11.494 1.992 16.858-61.456-3.065-115.862-32.49-152.337-77.241-6.284 10.881-9.962 23.601-9.962 37.088.0 25.594 13.027 48.276 32.95 61.456-12.107-.307-23.448-3.678-33.41-9.196v.92c0 35.862 25.441 65.594 59.311 72.49-6.13 1.686-12.72 2.606-19.464 2.606-4.751.0-9.348-.46-13.946-1.38 9.349 29.426 36.628 50.728 68.965 51.341-25.287 19.771-57.164 31.571-91.8 31.571-5.977.0-11.801-.306-17.625-1.073 32.337 21.15 71.264 33.41 112.95 33.41z"/></svg>
</a>
<a target=_blank rel="noopener noreferrer" aria-label="share [TIL] Python basic 12: Method on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&url=http%3a%2f%2fjeha00.github.io%2fpost%2fpython_basic_12%2f&title=%5bTIL%5d%20Python%20basic%2012%3a%20Method&summary=%5bTIL%5d%20Python%20basic%2012%3a%20Method&source=http%3a%2f%2fjeha00.github.io%2fpost%2fpython_basic_12%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg>
</a>
<a target=_blank rel="noopener noreferrer" aria-label="share [TIL] Python basic 12: Method on reddit" href="https://reddit.com/submit?url=http%3a%2f%2fjeha00.github.io%2fpost%2fpython_basic_12%2f&title=%5bTIL%5d%20Python%20basic%2012%3a%20Method"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg>
</a>
<a target=_blank rel="noopener noreferrer" aria-label="share [TIL] Python basic 12: Method on facebook" href="https://facebook.com/sharer/sharer.php?u=http%3a%2f%2fjeha00.github.io%2fpost%2fpython_basic_12%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg>
</a>
<a target=_blank rel="noopener noreferrer" aria-label="share [TIL] Python basic 12: Method on whatsapp" href="https://api.whatsapp.com/send?text=%5bTIL%5d%20Python%20basic%2012%3a%20Method%20-%20http%3a%2f%2fjeha00.github.io%2fpost%2fpython_basic_12%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg>
</a>
<a target=_blank rel="noopener noreferrer" aria-label="share [TIL] Python basic 12: Method on telegram" href="https://telegram.me/share/url?text=%5bTIL%5d%20Python%20basic%2012%3a%20Method&url=http%3a%2f%2fjeha00.github.io%2fpost%2fpython_basic_12%2f"><svg viewBox="2 2 28 28"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg>
</a>
</div>
</footer><script src=https://utteranc.es/client.js repo=JeHa00/blog-comments issue-term=pathname theme=github-dark crossorigin=anonymous async></script>
</article>
</main>
<footer class=footer>
<span>&copy; 2022 <a href=http://jeha00.github.io/>Jeha00 DevLog</a></span>
<span>
Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a>
</span>
</footer>
<a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a>
<script>let menu=document.getElementById('menu');menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(a=>{a.addEventListener("click",function(b){b.preventDefault();var a=this.getAttribute("href").substr(1);window.matchMedia('(prefers-reduced-motion: reduce)').matches?document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView({behavior:"smooth"}),a==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${a}`)})})</script>
<script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script>
<script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove('dark'),localStorage.setItem("pref-theme",'light')):(document.body.classList.add('dark'),localStorage.setItem("pref-theme",'dark'))})</script>
<script>document.querySelectorAll('pre > code').forEach(b=>{const c=b.parentNode.parentNode,a=document.createElement('button');a.classList.add('copy-code'),a.innerText='copy';function d(){a.innerText='copied!',setTimeout(()=>{a.innerText='copy'},2e3)}a.addEventListener('click',e=>{if('clipboard'in navigator){navigator.clipboard.writeText(b.textContent),d();return}const a=document.createRange();a.selectNodeContents(b);const c=window.getSelection();c.removeAllRanges(),c.addRange(a);try{document.execCommand('copy'),d()}catch(a){}c.removeRange(a)}),c.classList.contains("highlight")?c.appendChild(a):c.parentNode.firstChild==c||(b.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?b.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(a):b.parentNode.appendChild(a))})</script>
</body>
</html>