<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>[TIL] Network HTTP basic | Jeha DevLog</title><meta name=keywords content="TIL,Network,HTTP"><meta name=description content="HTTP란 무엇이고, HTTP의 특징인 클라이언트 서버 구조, stateless, connectionless, HTTP mesage에 대해 알아본다."><meta name=author content><link rel=canonical href=http://jeha00.github.io/post/network/http/http_3/><meta name=google-site-verification content="XYZabc"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.min.268b216eea772711d318d156ce02a8190962367a0bf469fa9a959114ea6b9ca3.css integrity="sha256-Joshbup3JxHTGNFWzgKoGQliNnoL9Gn6mpWRFOprnKM=" rel="preload stylesheet" as=style><link rel=icon href=http://jeha00.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=http://jeha00.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=http://jeha00.github.io/favicon-32x32.png><link rel=apple-touch-icon href=http://jeha00.github.io/apple-touch-icon.png><link rel=mask-icon href=http://jeha00.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><meta name=generator content="Hugo 0.101.0"><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><script type=application/javascript>var doNotTrack=!1;doNotTrack||(function(e,t,n,s,o,i,a){e.GoogleAnalyticsObject=o,e[o]=e[o]||function(){(e[o].q=e[o].q||[]).push(arguments)},e[o].l=1*new Date,i=t.createElement(n),a=t.getElementsByTagName(n)[0],i.async=1,i.src=s,a.parentNode.insertBefore(i,a)}(window,document,"script","https://www.google-analytics.com/analytics.js","ga"),ga("create","UA-123-45","auto"),ga("send","pageview"))</script><meta property="og:title" content="[TIL] Network HTTP basic"><meta property="og:description" content="HTTP란 무엇이고, HTTP의 특징인 클라이언트 서버 구조, stateless, connectionless, HTTP mesage에 대해 알아본다."><meta property="og:type" content="article"><meta property="og:url" content="http://jeha00.github.io/post/network/http/http_3/"><meta property="og:image" content="http://jeha00.github.io/47"><meta property="article:section" content="post"><meta property="article:published_time" content="2022-03-09T17:56:30+09:00"><meta property="article:modified_time" content="2022-03-09T17:56:30+09:00"><meta property="og:site_name" content="JeHa00 DevLog"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="http://jeha00.github.io/47"><meta name=twitter:title content="[TIL] Network HTTP basic"><meta name=twitter:description content="HTTP란 무엇이고, HTTP의 특징인 클라이언트 서버 구조, stateless, connectionless, HTTP mesage에 대해 알아본다."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"http://jeha00.github.io/post/"},{"@type":"ListItem","position":2,"name":"[TIL] Network HTTP basic","item":"http://jeha00.github.io/post/network/http/http_3/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"[TIL] Network HTTP basic","name":"[TIL] Network HTTP basic","description":"HTTP란 무엇이고, HTTP의 특징인 클라이언트 서버 구조, stateless, connectionless, HTTP mesage에 대해 알아본다.","keywords":["TIL","Network","HTTP"],"articleBody":"0. Introduction HTTP 학습내용의 기본 출처: 김영한님의 모든 개발자를 위한 HTTP 웹 기본지식 이다.\n강의를 듣고 정리한 내용과 모르는 부분에 대한 추가 내용을 합쳐 올린다.\n이 강의는 HTTP에 대한 웹 기본지식을 설명하는 강의이므로, 내용이 간략할 수 있다.\n학습 이유: 프레임워크를 사용하여 웹 개발을 배우기 전에, HTTP에 대해 기본적인 지식을 알고자 HTTP 공부를 시작한다. 이 강의에 대해 공부 후, 네트워크 전반에 대해 공부한다.\n1. 모든 것이 HTTP 1.1 HTTP란? (지금은 HTTP 시대!) : 링크를 통해 HTML 같은 문서를 연결할 수 있는 프로토콜을 의미한다. 하지만, 이제는 문서 뿐만 아니라 HTTP 메세지에 모든 것을 전송한다.\nHTML, TEXT IMAGE, 음성, 영상, 파일 JSON, XML (API) 거의 모든 형태의 데이터를 저장하여 전송 가능하다. 서버 간에 데이터를 주고 받을 때도 대부분 HTTP를 사용한다. 1.2 HTTP 역사 (HTTP/1.1을 기준으로 학습) HTTP/0.9 1991년: GET 메서드만 지원, HTTP 헤더X HTTP/1.0 1996년: 메서드, 헤더 추가 HTTP/1.1 1997년: 가장 많이 사용, 우리에게 가장 중요한 버전 HTTP 강의는 이 버전을 기준으로 설명한다. RFC2068 (1997) -\u003e RFC2616 (1999) -\u003e RFC7230~7235 (2014) 현재는 RFC7230 버전부터 본다. HTTP/2 2015년: 성능 개선 HTTP/3 진행중: TCP 대신에 UDP 사용, 성능 개선 1.3 기반 프로토콜 TCP 기반으로 작동하는 프로토콜은 HTTP/1.1, HTTP/2 다. UDP 기반으로 작동하는 프로토콜은 HTTP/3 다. 기본적으로 HTTP/1.1에서 개선된 것이므로 우리는 HTTP/1.1을 공부한다. 현재 HTTP/1.1 주로 사용한다. HTTP/2, HTTP/3도 점점 증가하고 있다. [HTTP/3가 UDP 기반인 이유]\n기본 TCP는 3 way handshake로 신뢰성이나 연결성이 보장되지만, 속도가 떨어진다. 그래서 UDP를 애플리케이션 레벨에서 재설계되어 나온게 HTTP/3다.\n사이트에서 기반 프로토콜을 확인하려면 검사(F12)에 들어가 Network tab을 클릭 한다. 하단에 Name tab을 오른쪽 마우스 클릭하여 Protocol을 체크한다. h3는 http/3 고, h2는 http/2 를 의미한다. 구글은 h3를 사용하고, 네이버는 h2를 사용한다. 1.4 HTTP 특징 클라이언트 서버 구조 무상태 프로토콜(stateless), 비연결성 HTTP 메시지 단순함, 확장 가능 HTTP는 단순하고, 스펙도 읽어볼만 하다. HTTP 메시지도 매우 단순하다. 크게 성공하는 표준 기술의 하나의 예로, 단순하지만 확장 가능한 기술이다. 각 특징들에 대해 알아보자.\n2. 클라이언트 서버 구조 HTTP는 클라이언트와 서버 구조로 되어있다.\n클라이언트는 HTTP 메세지를 만들어서 서버에 요청(request)을 보낸 후, 서버로부터 응답(response)이 올 때까지 기다린다.\n서버는 클라이언트로부터 온 요청(request)에 대한 결과를 만들어서 응답(response)한다.\n[클라이언트 서버 구조가 중요한 이유]\n독립적 구조 -\u003e 각자의 역할에 집중 옛날에는 클라이언트와 서버가 분리되어 있지 않고, 합쳐져 있었다. 그후 비지니스 로직과 데이터는 서버가 담당하여 집중하고, 클라이언트는 UI 사용성에 집중했다. 이로 인해서 클라이언트와 서버는 각각 독립적으로 진화할 수 있었다. 3. Stateful, Stateless 3.1 Stateful ‘Stateful’ 이란?? ‘한 서버’가 클라이언트의 이전 상태를 보존(기억)하기 때문에, 클라이언트의 요청에 응답하는 서버가 항상 같은 서버로 유지 되어야 하는 상태를 말한다.\n‘Stateful(상태 유지)‘의 문제점은 무엇일까?? 서버가 멈추거나 하는 여러 이유로 해당 서버를 쓸 수가 없는 상황이 발생했다. 다른 서버를 이용해야 한다. 이런 경우, 새로운 서버에서 이전 서버에 가지고 있던 상태값들을 가지고 있지 않아 에러가 발생된다.\n예시: 고객을 클라이언트, 점원을 서버라고 생각하자.\n서버가 문제 없이 유지되는 경우 1 2 3 4 5 6 7 8 9 고객: 이 `노트북` 얼마인가요? 점원: 100만원 입니다. (노트북 상태 유지) 고객: `2개` 구매하겠습니다. 점원: 200만원 입니다. 신용카드, 현금중에 어떤 걸로 구매 하시겠어요? (노트북, 2개 상태 유지) 고객: `신용카드`로 구매하겠습니다. 점원: 200만원 결제 완료되었습니다. (노트북, 2개, 신용카드 상태 유지) 서버가 바뀔 경우 1 2 3 4 5 6 7 8 고객: 이 `노트북` 얼마인가요? 점원 A: 100만원 입니다. 고객: `2개` 구매하겠습니다. 점원 B: ? 무엇을 2개 구매하시겠어요? (상태유지 X) 고객: `신용카드`로 구매하겠습니다. 점원C: ? 무슨 제품을 몇 개 신용카드로 구매하시겠어요? (상태 유지 X) 한 서버에서만 클라이언트의 상태를 기억하기 때문에, 서버가 변경되면 기존 서버에 저장된 클라이언트의 상태를 기억하지 못하여 에러가 발생했다. 그래서 항상 같은 서버로 유지 되어야 한다.\n3.2 Stateless Stateless 란?? 서버가 클라이언트의 이전 상태를 보존(기억)하지 않고, 클라이언트가 요청할 때마다 매번 모든 상태 값들을 전달 하기 때문에, 서버 변경이 용이 하다.\n예시 고객을 클라이언트, 점원을 서버라고 생각하자.\n서버가 문제 없이 유지되는 경우\n1 2 3 4 5 6 7 8 고객: 이 `노트북` 얼마인가요? 점원: 100만원 입니다. 고객: `노트북 2개` 구매하겠습니다. 점원: 노트북 2개는 200만원 입니다. 신용카드, 현금중에 어떤 걸로 구매 하시겠어요? 고객: `노트북 2개`를 `신용카드`로 구매하겠습니다. 점원: 200만원 결제 완료되었습니다. 서버가 바뀔 경우\n1 2 3 4 5 6 7 8 고객: 이 '노트북' 얼마인가요? 점원A: 100만원 입니다. 고객: '노트북 2개' 구매하겠습니다. 점원B: 노트북 2개는 200만원 입니다. 신용카드, 현금중에 어떤 걸로 구매 하시겠어요? 고객: '노트북 2개'를 '신용카드'로 구매하겠습니다. 점원C: 200만원 결제 완료되었습니다. 클라이언트가 모든 상태 값을 서버에 전달하기 때문에, 서버가 중간에 바뀌어도 문제가 되지 않는다. 항상 같은 서버로 유지될 필요없다. 그래서 서버 변경이 용이하기 때문에, stateless 는 무한한 서버 증설이 가능하다.\n무한한 서버 증설로 인한 이점 그러면 서버 증설이 무한히 가능하다면 어떤 이점이 있을까???\n같은 기능을 하는 서버들 안에서 서버의 수평 확장(scale out) 에 유리하다.\n🔆 stateless의 한계와 실무 방식 좋은 이점들이 많지만 실무 한계가 존재하여, 모든 것을 stateless(무상태) 로 할 수 없다 실무 한계가 존재한다.\n무상태 예시: 로그인이 필요 없는 단순한 서비스 소개 화면 상태 유지 예시: 로그인 로그인한 사용자의 경우, 로그인 했다는 상태를 서버에 유지해야 한다. 일반적으로 브라우저 쿠키와 서버 세션 등을 사용해서 상태를 유지한다. 그래서 상태유지는 최소한만 사용하고, 최대한 무상태로 서버를 설계한다.\n❗️ 수평 확장(scale out)과 수직 확장(scale up)의 차이: 스케일 아웃과 스케일 업\n3.3 🔆 정리 Stateful (상태유지): 중간에 서버가 변경되면 안된다.\n만약 서버가 변경되야 한다면 상태 정보를 전부 다른 서버에게 미리 알려줘야 한다. Stateless (무상태): 중간에 서버가 바뀌어도 된다.\n그래서 서버는 수평적 확장에 유리한다. (scale out) 하지만 모든 것을 무상태로 할 수 없기 때문에, 무상태로 서버를 최대한 설계하며, 상태 유지로 서버를 최소한 설계한다. 4. 비연결성 (connectionless) 4.1 연결을 유지하는 모델 TCP/IP 연결로 새로운 클라이언트와 연결하면서 이전 클라이언트와의 연결을 유지한다. 연결된 클라이언트가 놀고 있어도 서버가 유지해야 하는게 단점이다. 왜냐하면 서버의 자원이 연결을 유지하는데 계속 소모 되기 때문이다. 4.2 연결을 유지하지 않는 모델 (비연결성) TCP/IP 연결 후, 클라이언트와 서버의 단 하나의 요청 응답 흐름이 끝나면 연결을 바로 종료한다. 그리고 다른 클라이언트와 연결 시, 이전 클라이언트와의 연결은 유지하지 않는다. 즉, 서버는 연결 유지를 하지 않아 최소한의 자원만 사용 할 수 있다. HTTP의 비연결성 장점 HTTP는 기본이 연결을 유지하지 않는 모델이고, 일반적으로 초 단위 이하의 빠른 속도로 응답한다. 그래서 1시간 동안 수천명이 서비스를 사용해도 실제 서버에서 동시에 처리하는 요청은 수십개 이하로 매우 적다. 예) 웹 브라우저에서 계속 연속해서 검색 버튼을 누르지 않는다. 즉, 서버 자원을 매우 효율적으로 사용할 수 있다. 비연결성의 단점과 해결 방법 단점 TCP/IP 연결을 새로 맺어야 하기 때문에, 3 way handshake 시간이 추가된다. 웹 브라우저로 사이트를 요청하면 HTML 뿐만 아니라 JavaScript, css, 추가 이미지 등 수많은 자원이 함께 다운로드된다. 해결 방법 지금은 HTTP 지속 연결(Persistent Connections)로 문제 해결했다. HTTP/2 와 HTTP/3에서 더 많은 최적화를 한다. 4.3 HTTP 지속 연결: 비연결성의 한계 해결 방법 비연결성의 한계를 해결한 방법인 HTTP 지속 연결에 대해 알아보자.\nHTTP 초기에는 모든 자료에 대해서 비연결성으로 ‘연결 -\u003e 응답 -\u003e 종료’ 를 반복하여, 시간이 대략적으로 1초 가량 소모되었다고 한다.\n아래 이미지를 참조하자.\n그러면 HTTP 지속 연결로 어떻게 변했을까??\n클라이언트는 서버와 연결을 한 다음, 필요한 자원들을 모두 다운받을 때까지 요청/응답이 반복된 뒤 종료된다.\n또한, HTTP/2,3으로 오면서 더 빨라졌다. 특히, HTTP 3으로 오면서 UDP를 사용하여 연결 속도 자체도 줄어들었다.\n4.4 🔆 실무에서 HTTP 지속 연결하는 경우 실무 상황에서 특정 시간에 발생하는 대용량 트래픽의 경우, 수만명이 동시 요청하기 때문에 무상태와 HTTP 지속 연결로 서버를 설계해야 대응할 수 있는 부분이 매우 많아진다.\n예) 선착순 이벤트, 명절 KTX 예약, 학과 수업 등록, 선착순 할인 이벤트 5. HTTP 메시지 HTTP 메시지 구조를 알아보자. 공백 라인은 아래 순서로, 필수로 존재해야 한다. 5.1 시작 라인(start line) start line은 요청 메시지와 응답 메시지 로 나눠진다.\nstart line = request - line (요청 메시지) / status - line (응답 메시지)\nrequest-line = method SP(공백) request-target SP HTTP-version CRLF(엔터) status-line = HTTP-version SP status-code SP reason-phrase CRLF 5.1.1 요청 메시지 start line = request - line (요청 메시지) / status - line (응답 메시지)\nrequest-line = method SP(공백) request-target SP HTTP-version CRLF(엔터)\nHTTP method (GET /search?q=hello\u0026hl=ko HTTP/1.1)\n종류: GET, POST, PUT, DELETE … 서버가 수행해야 할 동작 지정 GET: 리소스 조회 / POST: 요청 내역 처리 request-target (GET /search?q=hello\u0026hl=ko HTTP/1.1)\nabsolute-path[?query] (절대경로[?쿼리]) 절대경로= “/” 로 시작하는 경로 참고: *, http://...?x=y 와 같이 다른 유형의 경로지정 방법도 있다. HTTP verison (GET /search?q=hello\u0026hl=ko HTTP/1.1)\n5.1.2 응답 메시지 start line = request - line (요청 메시지) / status - line (응답 메시지) status-line = HTTP-version SP status-code SP reason-phrase CRLF HTTP version HTTP 상태 코드: 요청 성공, 실패를 나타냄 200: 성공 400: 클라이언트 요청 오류 500: 서버 내부 오류 이유 문구: 사람이 이해할 수 있는 짧은 상태 코드 설명 글 5.2 HTTP header header - field = field - name “:” OWS field - value OWS\n(OWS: 띄어쓰기 허용)\nfield - name: 대소문자 구분 없음 field - value: 대소문자 구문 있음 용도 HTTP 전송에 필요한 모든 부가정보가 담겨져 있다. 예) 메시지 바디의 내용, 크기, 압축, 인증 예) 요청 클라이언트(브라우저) 정보, 서버 애플리케이션 정보, 캐시 관리 정보 표준 헤더가 너무 많다. (https://en.wikipedia.org/wiki/List_of_HTTP_header_fields) 필요한 경우, 임의의 헤더 추가 가능 5.3 HTTP message body 실제 전송할 데이터 HTML 문서, 이미지, 영상, JSON 등등 byte로 표현할 수 있는 모든 데이터 전송 가능 HTTP 정리 HTTP 메시지에 모든 것을 전송한다. HTTP 역사: HTTP/1.1을 기준으로 학습한다. 클라이언트 서버 구조이다. 무상태 프로토콜(stateless)다. HTTP 메시지 단순하며 확장 가능하다. 지금은 HTTP 시대다. Reference 모든 개발자를 위한 HTTP 웹 기본지식 HTTP 기본\u003e 스케일 아웃과 스케일 업 ","wordCount":"1442","inLanguage":"en","datePublished":"2022-03-09T17:56:30+09:00","dateModified":"2022-03-09T17:56:30+09:00","mainEntityOfPage":{"@type":"WebPage","@id":"http://jeha00.github.io/post/network/http/http_3/"},"publisher":{"@type":"Organization","name":"Jeha DevLog","logo":{"@type":"ImageObject","url":"http://jeha00.github.io/favicon.ico"}}}</script></head><body class=dark id=top><script>localStorage.getItem("pref-theme")==="light"&&document.body.classList.remove("dark")</script><header class=header><nav class=nav><div class=logo><a href=http://jeha00.github.io/ accesskey=h title="@Jeha00 (Alt + H)">@Jeha00</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></span></div><ul id=menu><li><a href=http://jeha00.github.io/me/ title=About><span>About</span></a></li><li><a href=http://jeha00.github.io/archives/ title=Archive><span>Archive</span></a></li><li><a href=http://jeha00.github.io/categories/ title=Categories><span>Categories</span></a></li><li><a href=http://jeha00.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=http://jeha00.github.io/>Home</a>&nbsp;»&nbsp;<a href=http://jeha00.github.io/post/>Posts</a></div><h1 class=post-title>[TIL] Network HTTP basic</h1><div class=post-meta><span title='2022-03-09 17:56:30 +0900 KST'>March 9, 2022</span>&nbsp;|&nbsp;<a href=https://github.com/JeHa00/blog/content/post/Network/HTTP/http_3.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#0-introduction aria-label="0. Introduction">0. Introduction</a></li><li><a href=#1-%eb%aa%a8%eb%93%a0-%ea%b2%83%ec%9d%b4-http aria-label="1. 모든 것이 HTTP">1. 모든 것이 HTTP</a><ul><li><a href=#11-http%eb%9e%80-%ec%a7%80%ea%b8%88%ec%9d%80-http-%ec%8b%9c%eb%8c%80 aria-label="1.1 HTTP란? (지금은 HTTP 시대!)">1.1 HTTP란? (<strong>지금은 HTTP 시대!</strong>)</a></li><li><a href=#12-http-%ec%97%ad%ec%82%ac-http11%ec%9d%84-%ea%b8%b0%ec%a4%80%ec%9c%bc%eb%a1%9c-%ed%95%99%ec%8a%b5 aria-label="1.2 HTTP 역사 (HTTP/1.1을 기준으로 학습)">1.2 HTTP 역사 (HTTP/1.1을 기준으로 학습)</a></li><li><a href=#13-%ea%b8%b0%eb%b0%98-%ed%94%84%eb%a1%9c%ed%86%a0%ec%bd%9c aria-label="1.3 기반 프로토콜">1.3 기반 프로토콜</a></li><li><a href=#14-http-%ed%8a%b9%ec%a7%95 aria-label="1.4 HTTP 특징">1.4 HTTP 특징</a></li></ul></li><li><a href=#2-%ed%81%b4%eb%9d%bc%ec%9d%b4%ec%96%b8%ed%8a%b8-%ec%84%9c%eb%b2%84-%ea%b5%ac%ec%a1%b0 aria-label="2. 클라이언트 서버 구조">2. 클라이언트 서버 구조</a></li><li><a href=#3-stateful-stateless aria-label="3. Stateful, Stateless">3. Stateful, Stateless</a><ul><li><a href=#31-stateful aria-label="3.1 Stateful">3.1 Stateful</a><ul><li><a href=#stateful-%ec%9d%b4%eb%9e%80 aria-label="&amp;lsquo;Stateful&amp;rsquo; 이란??">&lsquo;Stateful&rsquo; 이란??</a></li><li><a href=#stateful%ec%83%81%ed%83%9c-%ec%9c%a0%ec%a7%80%ec%9d%98-%eb%ac%b8%ec%a0%9c%ec%a0%90%ec%9d%80-%eb%ac%b4%ec%97%87%ec%9d%bc%ea%b9%8c aria-label="&amp;lsquo;Stateful(상태 유지)&amp;lsquo;의 문제점은 무엇일까??">&lsquo;Stateful(상태 유지)&lsquo;의 문제점은 무엇일까??</a></li></ul></li><li><a href=#32-stateless aria-label="3.2 Stateless">3.2 Stateless</a><ul><li><a href=#stateless-%eb%9e%80 aria-label="Stateless 란??">Stateless 란??</a></li><li><a href=#%ec%98%88%ec%8b%9c aria-label=예시>예시</a></li><li><a href=#%eb%ac%b4%ed%95%9c%ed%95%9c-%ec%84%9c%eb%b2%84-%ec%a6%9d%ec%84%a4%eb%a1%9c-%ec%9d%b8%ed%95%9c-%ec%9d%b4%ec%a0%90 aria-label="무한한 서버 증설로 인한 이점">무한한 서버 증설로 인한 이점</a></li><li><a href=#-stateless%ec%9d%98-%ed%95%9c%ea%b3%84%ec%99%80-%ec%8b%a4%eb%ac%b4-%eb%b0%a9%ec%8b%9d aria-label="🔆 stateless의 한계와 실무 방식">🔆 stateless의 한계와 실무 방식</a></li></ul></li><li><a href=#33--%ec%a0%95%eb%a6%ac aria-label="3.3 🔆 정리">3.3 🔆 정리</a></li></ul></li><li><a href=#4-%eb%b9%84%ec%97%b0%ea%b2%b0%ec%84%b1-connectionless aria-label="4. 비연결성 (connectionless)">4. 비연결성 (connectionless)</a><ul><li><a href=#41-%ec%97%b0%ea%b2%b0%ec%9d%84-%ec%9c%a0%ec%a7%80%ed%95%98%eb%8a%94-%eb%aa%a8%eb%8d%b8 aria-label="4.1 연결을 유지하는 모델">4.1 연결을 유지하는 모델</a></li><li><a href=#42-%ec%97%b0%ea%b2%b0%ec%9d%84-%ec%9c%a0%ec%a7%80%ed%95%98%ec%a7%80-%ec%95%8a%eb%8a%94-%eb%aa%a8%eb%8d%b8-%eb%b9%84%ec%97%b0%ea%b2%b0%ec%84%b1 aria-label="4.2 연결을 유지하지 않는 모델 (비연결성)">4.2 연결을 유지하지 않는 모델 (비연결성)</a><ul><li><a href=#http%ec%9d%98-%eb%b9%84%ec%97%b0%ea%b2%b0%ec%84%b1-%ec%9e%a5%ec%a0%90 aria-label="HTTP의 비연결성 장점">HTTP의 비연결성 장점</a></li><li><a href=#%eb%b9%84%ec%97%b0%ea%b2%b0%ec%84%b1%ec%9d%98-%eb%8b%a8%ec%a0%90%ea%b3%bc-%ed%95%b4%ea%b2%b0-%eb%b0%a9%eb%b2%95 aria-label="비연결성의 단점과 해결 방법">비연결성의 단점과 해결 방법</a></li></ul></li><li><a href=#43-http-%ec%a7%80%ec%86%8d-%ec%97%b0%ea%b2%b0-%eb%b9%84%ec%97%b0%ea%b2%b0%ec%84%b1%ec%9d%98-%ed%95%9c%ea%b3%84-%ed%95%b4%ea%b2%b0-%eb%b0%a9%eb%b2%95 aria-label="4.3 HTTP 지속 연결: 비연결성의 한계 해결 방법">4.3 HTTP 지속 연결: 비연결성의 한계 해결 방법</a><ul><li><a href=#44--%ec%8b%a4%eb%ac%b4%ec%97%90%ec%84%9c-http-%ec%a7%80%ec%86%8d-%ec%97%b0%ea%b2%b0%ed%95%98%eb%8a%94-%ea%b2%bd%ec%9a%b0 aria-label="4.4 🔆 실무에서 HTTP 지속 연결하는 경우">4.4 🔆 실무에서 HTTP 지속 연결하는 경우</a></li></ul></li></ul></li><li><a href=#5-http-%eb%a9%94%ec%8b%9c%ec%a7%80 aria-label="5. HTTP 메시지">5. HTTP 메시지</a><ul><li><a href=#51-%ec%8b%9c%ec%9e%91-%eb%9d%bc%ec%9d%b8start-line aria-label="5.1 시작 라인(start line)">5.1 시작 라인(start line)</a><ul><li><a href=#511-%ec%9a%94%ec%b2%ad-%eb%a9%94%ec%8b%9c%ec%a7%80 aria-label="5.1.1 요청 메시지">5.1.1 요청 메시지</a></li><li><a href=#512-%ec%9d%91%eb%8b%b5-%eb%a9%94%ec%8b%9c%ec%a7%80 aria-label="5.1.2 응답 메시지">5.1.2 응답 메시지</a></li></ul></li><li><a href=#52-http-header aria-label="5.2 HTTP header">5.2 HTTP header</a></li><li><a href=#53-http-message-body aria-label="5.3 HTTP message body">5.3 HTTP message body</a></li></ul></li><li><a href=#http-%ec%a0%95%eb%a6%ac aria-label="HTTP 정리">HTTP 정리</a></li><li><a href=#reference aria-label=Reference>Reference</a></li></ul></div></details></div><div class=post-content><h1 id=0-introduction>0. Introduction<a hidden class=anchor aria-hidden=true href=#0-introduction>#</a></h1><ul><li><p>HTTP 학습내용의 기본 출처: 김영한님의 <a href=https://www.inflearn.com/course/http-%EC%9B%B9-%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC>모든 개발자를 위한 HTTP 웹 기본지식</a> 이다.</p></li><li><p>강의를 듣고 정리한 내용과 모르는 부분에 대한 추가 내용을 합쳐 올린다.</p></li><li><p>이 강의는 HTTP에 대한 웹 기본지식을 설명하는 강의이므로, 내용이 간략할 수 있다.</p></li><li><p>학습 이유: 프레임워크를 사용하여 웹 개발을 배우기 전에, HTTP에 대해 기본적인 지식을 알고자 HTTP 공부를 시작한다. 이 강의에 대해 공부 후, 네트워크 전반에 대해 공부한다.</p></li></ul><p> </p><hr><h1 id=1-모든-것이-http>1. 모든 것이 HTTP<a hidden class=anchor aria-hidden=true href=#1-모든-것이-http>#</a></h1><h2 id=11-http란-지금은-http-시대>1.1 HTTP란? (<strong>지금은 HTTP 시대!</strong>)<a hidden class=anchor aria-hidden=true href=#11-http란-지금은-http-시대>#</a></h2><p>: 링크를 통해 HTML 같은 문서를 연결할 수 있는 프로토콜을 의미한다.
하지만, 이제는 문서 뿐만 아니라 <strong>HTTP 메세지에 모든 것을 전송</strong>한다.</p><ul><li>HTML, TEXT</li><li>IMAGE, 음성, 영상, 파일</li><li>JSON, XML (API)</li><li>거의 모든 형태의 데이터를 저장하여 전송 가능하다.</li><li>서버 간에 데이터를 주고 받을 때도 대부분 HTTP를 사용한다.</li></ul><p> </p><h2 id=12-http-역사-http11을-기준으로-학습>1.2 HTTP 역사 (HTTP/1.1을 기준으로 학습)<a hidden class=anchor aria-hidden=true href=#12-http-역사-http11을-기준으로-학습>#</a></h2><ul><li>HTTP/0.9 1991년: GET 메서드만 지원, HTTP 헤더X</li><li>HTTP/1.0 1996년: 메서드, 헤더 추가</li><li><strong>HTTP/1.1 1997년: 가장 많이 사용, 우리에게 가장 중요한 버전</strong><ul><li>HTTP 강의는 이 버전을 기준으로 설명한다.</li><li>RFC2068 (1997) -> RFC2616 (1999) -> RFC7230~7235 (2014)</li><li>현재는 RFC7230 버전부터 본다.</li></ul></li><li>HTTP/2 2015년: 성능 개선</li><li>HTTP/3 진행중: TCP 대신에 UDP 사용, 성능 개선</li></ul><p> </p><h2 id=13-기반-프로토콜>1.3 기반 프로토콜<a hidden class=anchor aria-hidden=true href=#13-기반-프로토콜>#</a></h2><ul><li><code>TCP</code> 기반으로 작동하는 프로토콜은 <code>HTTP/1.1</code>, <code>HTTP/2</code> 다.</li><li><code>UDP</code> 기반으로 작동하는 프로토콜은 <code>HTTP/3</code> 다.<ul><li>기본적으로 HTTP/1.1에서 개선된 것이므로 우리는 HTTP/1.1을 공부한다.</li></ul></li><li>현재 HTTP/1.1 주로 사용한다.<ul><li>HTTP/2, HTTP/3도 점점 증가하고 있다.</li></ul></li></ul><blockquote><p>[HTTP/3가 UDP 기반인 이유]<br>기본 TCP는 3 way handshake로 신뢰성이나 연결성이 보장되지만, 속도가 떨어진다. 그래서 UDP를 애플리케이션 레벨에서 재설계되어 나온게 <code>HTTP/3</code>다.</p></blockquote><p> </p><ul><li>사이트에서 기반 프로토콜을 확인하려면 검사(F12)에 들어가 <code>Network tab</code>을 클릭 한다.</li><li>하단에 Name tab을 오른쪽 마우스 클릭하여 Protocol을 체크한다.</li><li>h3는 http/3 고, h2는 http/2 를 의미한다.</li><li>구글은 h3를 사용하고, 네이버는 h2를 사용한다.</li></ul><p><img loading=lazy src=https://user-images.githubusercontent.com/78094972/157368318-ca06aad3-5926-4e3f-a4c9-7168daa68fc1.PNG alt=image></p><p><img loading=lazy src=https://user-images.githubusercontent.com/78094972/157368348-06f8e79f-3f69-40bc-a24c-2cac341bd340.PNG alt=image></p><p> </p><h2 id=14-http-특징>1.4 HTTP 특징<a hidden class=anchor aria-hidden=true href=#14-http-특징>#</a></h2><ul><li>클라이언트 서버 구조</li><li>무상태 프로토콜(stateless), 비연결성</li><li>HTTP 메시지</li><li>단순함, 확장 가능<ul><li>HTTP는 단순하고, 스펙도 읽어볼만 하다.</li><li>HTTP 메시지도 매우 단순하다.</li><li>크게 성공하는 표준 기술의 하나의 예로, 단순하지만 확장 가능한 기술이다.</li></ul></li></ul><p>각 특징들에 대해 알아보자.</p><p> </p><hr><h1 id=2-클라이언트-서버-구조>2. 클라이언트 서버 구조<a hidden class=anchor aria-hidden=true href=#2-클라이언트-서버-구조>#</a></h1><ul><li><p>HTTP는 클라이언트와 서버 구조로 되어있다.</p></li><li><p>클라이언트는 HTTP 메세지를 만들어서 서버에 요청(request)을 보낸 후, 서버로부터 응답(response)이 올 때까지 기다린다.</p></li><li><p>서버는 클라이언트로부터 온 요청(request)에 대한 결과를 만들어서 응답(response)한다.</p></li><li><p>[클라이언트 서버 구조가 중요한 이유]</p><ul><li>독립적 구조 -> 각자의 역할에 집중</li><li>옛날에는 클라이언트와 서버가 분리되어 있지 않고, 합쳐져 있었다. 그후 비지니스 로직과 데이터는 서버가 담당하여 집중하고, 클라이언트는 UI 사용성에 집중했다.</li><li>이로 인해서 클라이언트와 서버는 각각 <strong><em>독립적으로</em></strong> 진화할 수 있었다.</li></ul></li></ul><hr><h1 id=3-stateful-stateless>3. Stateful, Stateless<a hidden class=anchor aria-hidden=true href=#3-stateful-stateless>#</a></h1><h2 id=31-stateful>3.1 Stateful<a hidden class=anchor aria-hidden=true href=#31-stateful>#</a></h2><h3 id=stateful-이란>&lsquo;Stateful&rsquo; 이란??<a hidden class=anchor aria-hidden=true href=#stateful-이란>#</a></h3><p><strong>&lsquo;한 서버&rsquo;가 클라이언트의 이전 상태를 보존(기억)하기 때문에</strong>, 클라이언트의 요청에 응답하는 서버가 <strong><em>항상 같은 서버로 유지</em></strong> 되어야 하는 상태를 말한다.</p><h1 id=heading><a hidden class=anchor aria-hidden=true href=#heading>#</a></h1><h3 id=stateful상태-유지의-문제점은-무엇일까>&lsquo;Stateful(상태 유지)&lsquo;의 문제점은 무엇일까??<a hidden class=anchor aria-hidden=true href=#stateful상태-유지의-문제점은-무엇일까>#</a></h3><p>서버가 멈추거나 하는 여러 이유로 해당 서버를 쓸 수가 없는 상황이 발생했다. 다른 서버를 이용해야 한다. 이런 경우, 새로운 서버에서 이전 서버에 가지고 있던 상태값들을 가지고 있지 않아 에러가 발생된다.</p><ul><li><p>예시: 고객을 클라이언트, 점원을 서버라고 생각하자.</p><ul><li>서버가 문제 없이 유지되는 경우</li></ul><div class=highlight><div style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">3
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">4
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">5
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">6
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">7
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">8
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">9
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yml data-lang=yml><span style=display:flex><span>   <span style=color:#ff79c6>고객</span>: 이 `노트북` 얼마인가요?
</span></span><span style=display:flex><span>   <span style=color:#ff79c6>점원</span>: 100만원 입니다. (노트북 상태 유지)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>   <span style=color:#ff79c6>고객</span>: `2개` 구매하겠습니다.
</span></span><span style=display:flex><span>   <span style=color:#ff79c6>점원</span>: 200만원 입니다. 신용카드, 현금중에 어떤 걸로 구매 하시겠어요?
</span></span><span style=display:flex><span>          (노트북, 2개 상태 유지)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>   <span style=color:#ff79c6>고객</span>: `신용카드`로 구매하겠습니다.
</span></span><span style=display:flex><span>   <span style=color:#ff79c6>점원</span>: 200만원 결제 완료되었습니다. (노트북, 2개, 신용카드 상태 유지)
</span></span></code></pre></td></tr></table></div></div><ul><li>서버가 바뀔 경우</li></ul><div class=highlight><div style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">3
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">4
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">5
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">6
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">7
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">8
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yml data-lang=yml><span style=display:flex><span>  <span style=color:#ff79c6>고객</span>: 이 `노트북` 얼마인가요?
</span></span><span style=display:flex><span>  <span style=color:#ff79c6>점원 A</span>: 100만원 입니다.
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#ff79c6>고객</span>: `2개` 구매하겠습니다.
</span></span><span style=display:flex><span>  <span style=color:#ff79c6>점원 B</span>: ? 무엇을 2개 구매하시겠어요? (상태유지 X)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#ff79c6>고객</span>: `신용카드`로 구매하겠습니다.
</span></span><span style=display:flex><span>  <span style=color:#ff79c6>점원C</span>: ? 무슨 제품을 몇 개 신용카드로 구매하시겠어요? (상태 유지 X)
</span></span></code></pre></td></tr></table></div></div></li></ul><p>한 서버에서만 클라이언트의 상태를 기억하기 때문에, 서버가 변경되면 기존 서버에 저장된 클라이언트의 상태를 기억하지 못하여 에러가 발생했다. 그래서 <strong><em>항상 같은 서버로 유지</em></strong> 되어야 한다.</p><p> </p><hr><h2 id=32-stateless>3.2 Stateless<a hidden class=anchor aria-hidden=true href=#32-stateless>#</a></h2><h3 id=stateless-란>Stateless 란??<a hidden class=anchor aria-hidden=true href=#stateless-란>#</a></h3><p><strong>서버가 클라이언트의 이전 상태를 보존(기억)하지 않고</strong>, 클라이언트가 요청할 때마다 <strong><em>매번 모든 상태 값들을 전달</em></strong> 하기 때문에, <strong><em>서버 변경이 용이</em></strong> 하다.</p><h3 id=예시>예시<a hidden class=anchor aria-hidden=true href=#예시>#</a></h3><p>고객을 클라이언트, 점원을 서버라고 생각하자.</p><ul><li><p>서버가 문제 없이 유지되는 경우</p><div class=highlight><div style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">3
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">4
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">5
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">6
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">7
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">8
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yml data-lang=yml><span style=display:flex><span>  <span style=color:#ff79c6>고객</span>: 이 `노트북` 얼마인가요?
</span></span><span style=display:flex><span>  <span style=color:#ff79c6>점원</span>: 100만원 입니다.
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#ff79c6>고객</span>: `노트북 2개` 구매하겠습니다.
</span></span><span style=display:flex><span>  <span style=color:#ff79c6>점원</span>: 노트북 2개는 200만원 입니다. 신용카드, 현금중에 어떤 걸로 구매 하시겠어요?
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#ff79c6>고객</span>: `노트북 2개`를 `신용카드`로 구매하겠습니다.
</span></span><span style=display:flex><span>  <span style=color:#ff79c6>점원</span>: 200만원 결제 완료되었습니다.
</span></span></code></pre></td></tr></table></div></div></li><li><p>서버가 바뀔 경우</p><div class=highlight><div style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">3
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">4
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">5
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">6
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">7
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">8
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yml data-lang=yml><span style=display:flex><span>  <span style=color:#ff79c6>고객</span>: 이 &#39;노트북&#39; 얼마인가요?
</span></span><span style=display:flex><span>  <span style=color:#ff79c6>점원A</span>: 100만원 입니다.
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#ff79c6>고객</span>: <span style=color:#f1fa8c>&#39;노트북 2개&#39;</span> 구매하겠습니다.
</span></span><span style=display:flex><span>  <span style=color:#ff79c6>점원B</span>: 노트북 2개는 200만원 입니다. 신용카드, 현금중에 어떤 걸로 구매 하시겠어요?
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#ff79c6>고객</span>: <span style=color:#f1fa8c>&#39;노트북 2개&#39;</span>를 &#39;신용카드&#39;로 구매하겠습니다.
</span></span><span style=display:flex><span>  <span style=color:#ff79c6>점원C</span>: 200만원 결제 완료되었습니다.
</span></span></code></pre></td></tr></table></div></div></li></ul><p>클라이언트가 모든 상태 값을 서버에 전달하기 때문에, 서버가 중간에 바뀌어도 문제가 되지 않는다. 항상 같은 서버로 유지될 필요없다. 그래서 <strong>서버 변경이 용이</strong>하기 때문에, <strong><code>stateless</code></strong> 는 <strong>무한한 서버 증설이 가능</strong>하다.</p><h3 id=무한한-서버-증설로-인한-이점>무한한 서버 증설로 인한 이점<a hidden class=anchor aria-hidden=true href=#무한한-서버-증설로-인한-이점>#</a></h3><p>그러면 서버 증설이 무한히 가능하다면 어떤 이점이 있을까???</p><p>같은 기능을 하는 서버들 안에서 서버의 <strong><em>수평 확장(scale out)</em></strong> 에 유리하다.</p><p><img loading=lazy src="https://oopy.lazyrockets.com/api/v2/notion/image?src=https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2Fb6939ea2-0d68-4986-bc51-92a9eaf1b0a6%2FUntitled.png&blockId=8367b500-6305-4a9d-972d-babc19570513" alt=image></p><h3 id=-stateless의-한계와-실무-방식>🔆 stateless의 한계와 실무 방식<a hidden class=anchor aria-hidden=true href=#-stateless의-한계와-실무-방식>#</a></h3><p>좋은 이점들이 많지만 실무 한계가 존재하여, 모든 것을 <code>stateless(무상태)</code> 로 할 수 없다 실무 한계가 존재한다.</p><ul><li>무상태 예시: 로그인이 필요 없는 단순한 서비스 소개 화면</li><li>상태 유지 예시: 로그인<ul><li>로그인한 사용자의 경우, 로그인 했다는 상태를 서버에 유지해야 한다.</li><li>일반적으로 <strong><em>브라우저 쿠키와 서버 세션 등을 사용해서</em></strong> 상태를 유지한다.</li></ul></li></ul><p>그래서 상태유지는 최소한만 사용하고, 최대한 무상태로 서버를 설계한다.</p><p>❗️ 수평 확장(scale out)과 수직 확장(scale up)의 차이: <a href=https://m.blog.naver.com/islove8587/220548900044>스케일 아웃과 스케일 업</a></p><p> </p><h2 id=33--정리>3.3 🔆 정리<a hidden class=anchor aria-hidden=true href=#33--정리>#</a></h2><ul><li><p>Stateful (상태유지): 중간에 서버가 변경되면 안된다.</p><ul><li>만약 서버가 변경되야 한다면 상태 정보를 전부 다른 서버에게 미리 알려줘야 한다.</li></ul></li><li><p>Stateless (무상태): 중간에 서버가 바뀌어도 된다.</p><ul><li>그래서 서버는 수평적 확장에 유리한다. (scale out)</li><li><strong><em>하지만 모든 것을 무상태로 할 수 없기 때문에, 무상태로 서버를 최대한 설계하며, 상태 유지로 서버를 최소한 설계한다.</em></strong></li></ul></li></ul><p> </p><hr><h1 id=4-비연결성-connectionless>4. 비연결성 (connectionless)<a hidden class=anchor aria-hidden=true href=#4-비연결성-connectionless>#</a></h1><h2 id=41-연결을-유지하는-모델>4.1 연결을 유지하는 모델<a hidden class=anchor aria-hidden=true href=#41-연결을-유지하는-모델>#</a></h2><p><img loading=lazy src=https://user-images.githubusercontent.com/78094972/157386174-01e9379a-9c31-4423-8043-fb25905a794d.PNG alt=image></p><ul><li>TCP/IP 연결로 새로운 클라이언트와 연결하면서 이전 클라이언트와의 연결을 유지한다.</li><li>연결된 클라이언트가 놀고 있어도 서버가 유지해야 하는게 단점이다.</li><li>왜냐하면 서버의 자원이 연결을 유지하는데 <strong><em>계속 소모</em></strong> 되기 때문이다.</li></ul><p> </p><h2 id=42-연결을-유지하지-않는-모델-비연결성>4.2 연결을 유지하지 않는 모델 (비연결성)<a hidden class=anchor aria-hidden=true href=#42-연결을-유지하지-않는-모델-비연결성>#</a></h2><p><img loading=lazy src=https://user-images.githubusercontent.com/78094972/234801264-85af6185-60bf-466a-9027-1334306d70f9.png alt=image></p><ul><li>TCP/IP 연결 후, 클라이언트와 서버의 단 하나의 요청 응답 흐름이 끝나면 연결을 바로 종료한다.</li><li>그리고 다른 클라이언트와 연결 시, 이전 클라이언트와의 연결은 유지하지 않는다.</li><li>즉, 서버는 연결 유지를 하지 않아 <strong><em>최소한의 자원만 사용</em></strong> 할 수 있다.</li></ul><p> </p><h3 id=http의-비연결성-장점>HTTP의 비연결성 장점<a hidden class=anchor aria-hidden=true href=#http의-비연결성-장점>#</a></h3><ul><li>HTTP는 기본이 연결을 유지하지 않는 모델이고,</li><li>일반적으로 초 단위 이하의 빠른 속도로 응답한다.</li><li>그래서 1시간 동안 수천명이 서비스를 사용해도 실제 서버에서 동시에 처리하는 요청은 수십개 이하로 매우 적다.<ul><li>예) 웹 브라우저에서 계속 연속해서 검색 버튼을 누르지 않는다.</li></ul></li><li><strong><em>즉, 서버 자원을 매우 효율적으로 사용할 수 있다.</em></strong></li></ul><p> </p><h3 id=비연결성의-단점과-해결-방법>비연결성의 단점과 해결 방법<a hidden class=anchor aria-hidden=true href=#비연결성의-단점과-해결-방법>#</a></h3><ul><li>단점<ul><li>TCP/IP 연결을 새로 맺어야 하기 때문에, 3 way handshake 시간이 추가된다.</li><li>웹 브라우저로 사이트를 요청하면 HTML 뿐만 아니라 JavaScript, css, 추가 이미지 등 수많은 자원이 함께 다운로드된다.</li></ul></li><li>해결 방법<ul><li>지금은 <code>HTTP 지속 연결(Persistent Connections)</code>로 문제 해결했다.</li><li>HTTP/2 와 HTTP/3에서 더 많은 최적화를 한다.</li></ul></li></ul><p> </p><h2 id=43-http-지속-연결-비연결성의-한계-해결-방법>4.3 HTTP 지속 연결: 비연결성의 한계 해결 방법<a hidden class=anchor aria-hidden=true href=#43-http-지속-연결-비연결성의-한계-해결-방법>#</a></h2><p>비연결성의 한계를 해결한 방법인 <code>HTTP 지속 연결</code>에 대해 알아보자.</p><p>HTTP 초기에는 모든 자료에 대해서 비연결성으로 &lsquo;연결 -> 응답 -> 종료&rsquo; 를 반복하여, 시간이 대략적으로 1초 가량 소모되었다고 한다.</p><p>아래 이미지를 참조하자.</p><p><img loading=lazy src="https://oopy.lazyrockets.com/api/v2/notion/image?src=https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F37024fde-ab57-4953-9fd1-62dda7951b1f%2FUntitled.png&blockId=1fca311e-5841-45d2-8770-a9821f766e86" alt=image></p><p> </p><p>그러면 HTTP 지속 연결로 어떻게 변했을까??</p><p><img loading=lazy src="https://oopy.lazyrockets.com/api/v2/notion/image?src=https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F46a04f27-85b1-4573-931a-88e7df14c211%2FUntitled.png&blockId=318906c9-6dfc-4a2e-a813-0d08920d69ac" alt=image></p><p>클라이언트는 서버와 연결을 한 다음, 필요한 자원들을 모두 다운받을 때까지 요청/응답이 반복된 뒤 종료된다.</p><p>또한, HTTP/2,3으로 오면서 더 빨라졌다. 특히, HTTP 3으로 오면서 UDP를 사용하여 연결 속도 자체도 줄어들었다.</p><p> </p><h3 id=44--실무에서-http-지속-연결하는-경우>4.4 🔆 실무에서 HTTP 지속 연결하는 경우<a hidden class=anchor aria-hidden=true href=#44--실무에서-http-지속-연결하는-경우>#</a></h3><p><strong><em>실무 상황에서 특정 시간에 발생하는 대용량 트래픽의 경우, 수만명이 동시 요청하기 때문에 무상태와 HTTP 지속 연결로 서버를 설계해야 대응할 수 있는 부분이 매우 많아진다.</em></strong></p><ul><li>예) 선착순 이벤트, 명절 KTX 예약, 학과 수업 등록, 선착순 할인 이벤트</li></ul><p> </p><hr><h1 id=5-http-메시지>5. HTTP 메시지<a hidden class=anchor aria-hidden=true href=#5-http-메시지>#</a></h1><ul><li>HTTP 메시지 구조를 알아보자.<ul><li>공백 라인은 아래 순서로, 필수로 존재해야 한다.</li></ul></li></ul><p><img loading=lazy src="https://oopy.lazyrockets.com/api/v2/notion/image?src=https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F1c1ade79-e244-4886-953b-ba3c12b4f115%2FUntitled.png&blockId=1f0cf7a3-cd02-4903-92ed-e9782fe18f93" alt=image></p><p> </p><h2 id=51-시작-라인start-line>5.1 시작 라인(start line)<a hidden class=anchor aria-hidden=true href=#51-시작-라인start-line>#</a></h2><ul><li><p>start line은 요청 메시지와 응답 메시지 로 나눠진다.</p></li><li><p>start line = request - line (요청 메시지) / status - line (응답 메시지)</p><ul><li>request-line = method SP(공백) request-target SP HTTP-version CRLF(엔터)</li><li>status-line = HTTP-version SP status-code SP reason-phrase CRLF</li></ul></li></ul><h3 id=511-요청-메시지>5.1.1 요청 메시지<a hidden class=anchor aria-hidden=true href=#511-요청-메시지>#</a></h3><p><img loading=lazy src="https://oopy.lazyrockets.com/api/v2/notion/image?src=https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F9963de80-40e6-4cf3-a0cb-b048ab516fbc%2FUntitled.png&blockId=e21b890c-1a01-4393-8025-55d95e9d0705" alt=image></p><ul><li><p>start line = <strong>request - line (요청 메시지)</strong> / status - line (응답 메시지)</p><ul><li><p><strong>request-line</strong> = method SP(공백) request-target SP HTTP-version CRLF(엔터)</p></li><li><p>HTTP method (<strong>GET</strong> /search?q=hello&hl=ko HTTP/1.1)</p><ul><li>종류: GET, POST, PUT, DELETE &mldr;</li><li>서버가 수행해야 할 동작 지정<ul><li>GET: 리소스 조회 / POST: 요청 내역 처리</li></ul></li></ul></li><li><p>request-target (GET <strong>/search?q=hello&hl=ko</strong> HTTP/1.1)</p><ul><li>absolute-path[?query] (절대경로[?쿼리])</li><li>절대경로= &ldquo;/&rdquo; 로 시작하는 경로</li><li>참고: *, <a href="http://...?x=y">http://...?x=y</a> 와 같이 다른 유형의 경로지정 방법도 있다.</li></ul></li><li><p>HTTP verison (GET /search?q=hello&hl=ko <strong>HTTP/1.1</strong>)</p></li></ul></li></ul><p> </p><h3 id=512-응답-메시지>5.1.2 응답 메시지<a hidden class=anchor aria-hidden=true href=#512-응답-메시지>#</a></h3><p><img loading=lazy src="https://oopy.lazyrockets.com/api/v2/notion/image?src=https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F085e5d58-f33b-4406-999f-e07072372050%2FUntitled.png&blockId=cf01f06f-02d7-47a5-be2b-d21d8d042dcf" alt=image></p><ul><li>start line = request - line (요청 메시지) / status - line (응답 메시지)<ul><li>status-line = HTTP-version SP status-code SP reason-phrase CRLF</li><li>HTTP version</li><li>HTTP 상태 코드: 요청 성공, 실패를 나타냄<ul><li>200: 성공</li><li>400: 클라이언트 요청 오류</li><li>500: 서버 내부 오류</li></ul></li><li>이유 문구: 사람이 이해할 수 있는 짧은 상태 코드 설명 글</li></ul></li></ul><p> </p><h2 id=52-http-header>5.2 HTTP header<a hidden class=anchor aria-hidden=true href=#52-http-header>#</a></h2><blockquote><p><strong>header - field = field - name &ldquo;:&rdquo; OWS field - value OWS</strong><br>(OWS: 띄어쓰기 허용)</p></blockquote><ul><li><strong>field - name: 대소문자 구분 없음</strong></li><li>field - value: 대소문자 구문 있음</li><li>용도<ul><li><strong>HTTP 전송에 필요한 모든 부가정보가 담겨져 있다.</strong><ul><li>예) 메시지 바디의 내용, 크기, 압축, 인증</li><li>예) 요청 클라이언트(브라우저) 정보, 서버 애플리케이션 정보, 캐시 관리 정보</li></ul></li><li>표준 헤더가 너무 많다. (<a href=https://en.wikipedia.org/wiki/List_of_HTTP_header_fields>https://en.wikipedia.org/wiki/List_of_HTTP_header_fields</a>)</li><li>필요한 경우, 임의의 헤더 추가 가능</li></ul></li></ul><p> </p><h2 id=53-http-message-body>5.3 HTTP message body<a hidden class=anchor aria-hidden=true href=#53-http-message-body>#</a></h2><ul><li><strong>실제 전송할 데이터</strong></li><li>HTML 문서, 이미지, 영상, JSON 등등 byte로 표현할 수 있는 모든 데이터 전송 가능</li></ul><p> </p><hr><h1 id=http-정리>HTTP 정리<a hidden class=anchor aria-hidden=true href=#http-정리>#</a></h1><ul><li>HTTP 메시지에 모든 것을 전송한다.</li><li>HTTP 역사: HTTP/1.1을 기준으로 학습한다.</li><li>클라이언트 서버 구조이다.</li><li>무상태 프로토콜(stateless)다.</li><li>HTTP 메시지</li><li>단순하며 확장 가능하다.</li><li>지금은 HTTP 시대다.</li></ul><hr><h1 id=reference>Reference<a hidden class=anchor aria-hidden=true href=#reference>#</a></h1><ul><li><a href=https://www.inflearn.com/course/http-%EC%9B%B9-%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC>모든 개발자를 위한 HTTP 웹 기본지식</a></li><li><a href=h%3Chttps://catsbi.oopy.io/5c0b482c-b427-4052-9030-d2be0810eeb6>HTTP 기본</a>></li><li><a href=https://m.blog.naver.com/islove8587/220548900044>스케일 아웃과 스케일 업</a></li></ul></div><footer class=post-footer><ul class=post-tags><li><a href=http://jeha00.github.io/tags/til/>TIL</a></li><li><a href=http://jeha00.github.io/tags/network/>Network</a></li><li><a href=http://jeha00.github.io/tags/http/>HTTP</a></li></ul><nav class=paginav><a class=prev href=http://jeha00.github.io/post/network/http/http_4/><span class=title>« Prev Page</span><br><span>[TIL] Network HTTP method</span></a>
<a class=next href=http://jeha00.github.io/post/network/http/http_2/><span class=title>Next Page »</span><br><span>[TIL] Network HTTP intro. 2: URI 와 웹 브라우저 요청 흐름</span></a></nav><div class=share-buttons><a target=_blank rel="noopener noreferrer" aria-label="share [TIL] Network HTTP basic on twitter" href="https://twitter.com/intent/tweet/?text=%5bTIL%5d%20Network%20HTTP%20basic&url=http%3a%2f%2fjeha00.github.io%2fpost%2fnetwork%2fhttp%2fhttp_3%2f&hashtags=TIL%2cNetwork%2cHTTP"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM195.519 424.544c135.939.0 210.268-112.643 210.268-210.268.0-3.218.0-6.437-.153-9.502 14.406-10.421 26.973-23.448 36.935-38.314-13.18 5.824-27.433 9.809-42.452 11.648 15.326-9.196 26.973-23.602 32.49-40.92-14.252 8.429-30.038 14.56-46.896 17.931-13.487-14.406-32.644-23.295-53.946-23.295-40.767.0-73.87 33.104-73.87 73.87.0 5.824.613 11.494 1.992 16.858-61.456-3.065-115.862-32.49-152.337-77.241-6.284 10.881-9.962 23.601-9.962 37.088.0 25.594 13.027 48.276 32.95 61.456-12.107-.307-23.448-3.678-33.41-9.196v.92c0 35.862 25.441 65.594 59.311 72.49-6.13 1.686-12.72 2.606-19.464 2.606-4.751.0-9.348-.46-13.946-1.38 9.349 29.426 36.628 50.728 68.965 51.341-25.287 19.771-57.164 31.571-91.8 31.571-5.977.0-11.801-.306-17.625-1.073 32.337 21.15 71.264 33.41 112.95 33.41z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share [TIL] Network HTTP basic on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&url=http%3a%2f%2fjeha00.github.io%2fpost%2fnetwork%2fhttp%2fhttp_3%2f&title=%5bTIL%5d%20Network%20HTTP%20basic&summary=%5bTIL%5d%20Network%20HTTP%20basic&source=http%3a%2f%2fjeha00.github.io%2fpost%2fnetwork%2fhttp%2fhttp_3%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share [TIL] Network HTTP basic on reddit" href="https://reddit.com/submit?url=http%3a%2f%2fjeha00.github.io%2fpost%2fnetwork%2fhttp%2fhttp_3%2f&title=%5bTIL%5d%20Network%20HTTP%20basic"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share [TIL] Network HTTP basic on facebook" href="https://facebook.com/sharer/sharer.php?u=http%3a%2f%2fjeha00.github.io%2fpost%2fnetwork%2fhttp%2fhttp_3%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share [TIL] Network HTTP basic on whatsapp" href="https://api.whatsapp.com/send?text=%5bTIL%5d%20Network%20HTTP%20basic%20-%20http%3a%2f%2fjeha00.github.io%2fpost%2fnetwork%2fhttp%2fhttp_3%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share [TIL] Network HTTP basic on telegram" href="https://telegram.me/share/url?text=%5bTIL%5d%20Network%20HTTP%20basic&url=http%3a%2f%2fjeha00.github.io%2fpost%2fnetwork%2fhttp%2fhttp_3%2f"><svg viewBox="2 2 28 28"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></div></footer></article></main><footer class=footer><span>&copy; 2023 <a href=http://jeha00.github.io/>Jeha DevLog</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerText="copy";function s(){t.innerText="copied!",setTimeout(()=>{t.innerText="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>