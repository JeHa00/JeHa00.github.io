<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>[TIL] HTTP Header 2 | Jeha DevLog</title><meta name=keywords content="TIL,Network,HTTP"><meta name=description content="검증 헤더와 조건부 요청 헤더의 종류, 그중 캐시 관련 헤더에 대해서 알아본다. 그리고, 프록시 서버와 원(Origin) 서버의 차이와 캐시를 어떻게 무효화하는지 알아본다."><meta name=author content><link rel=canonical href=http://jeha00.github.io/post/network/http/http_8/><meta name=google-site-verification content="XYZabc"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.min.268b216eea772711d318d156ce02a8190962367a0bf469fa9a959114ea6b9ca3.css integrity="sha256-Joshbup3JxHTGNFWzgKoGQliNnoL9Gn6mpWRFOprnKM=" rel="preload stylesheet" as=style><link rel=icon href=http://jeha00.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=http://jeha00.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=http://jeha00.github.io/favicon-32x32.png><link rel=apple-touch-icon href=http://jeha00.github.io/apple-touch-icon.png><link rel=mask-icon href=http://jeha00.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><meta name=generator content="Hugo 0.101.0"><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><script type=application/javascript>var doNotTrack=!1;doNotTrack||(function(e,t,n,s,o,i,a){e.GoogleAnalyticsObject=o,e[o]=e[o]||function(){(e[o].q=e[o].q||[]).push(arguments)},e[o].l=1*new Date,i=t.createElement(n),a=t.getElementsByTagName(n)[0],i.async=1,i.src=s,a.parentNode.insertBefore(i,a)}(window,document,"script","https://www.google-analytics.com/analytics.js","ga"),ga("create","UA-123-45","auto"),ga("send","pageview"))</script><meta property="og:title" content="[TIL] HTTP Header 2"><meta property="og:description" content="검증 헤더와 조건부 요청 헤더의 종류, 그중 캐시 관련 헤더에 대해서 알아본다. 그리고, 프록시 서버와 원(Origin) 서버의 차이와 캐시를 어떻게 무효화하는지 알아본다."><meta property="og:type" content="article"><meta property="og:url" content="http://jeha00.github.io/post/network/http/http_8/"><meta property="og:image" content="http://jeha00.github.io/47"><meta property="article:section" content="post"><meta property="article:published_time" content="2022-03-18T21:51:01+09:00"><meta property="article:modified_time" content="2022-03-18T21:51:01+09:00"><meta property="og:site_name" content="JeHa00 DevLog"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="http://jeha00.github.io/47"><meta name=twitter:title content="[TIL] HTTP Header 2"><meta name=twitter:description content="검증 헤더와 조건부 요청 헤더의 종류, 그중 캐시 관련 헤더에 대해서 알아본다. 그리고, 프록시 서버와 원(Origin) 서버의 차이와 캐시를 어떻게 무효화하는지 알아본다."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"http://jeha00.github.io/post/"},{"@type":"ListItem","position":2,"name":"[TIL] HTTP Header 2","item":"http://jeha00.github.io/post/network/http/http_8/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"[TIL] HTTP Header 2","name":"[TIL] HTTP Header 2","description":"검증 헤더와 조건부 요청 헤더의 종류, 그중 캐시 관련 헤더에 대해서 알아본다. 그리고, 프록시 서버와 원(Origin) 서버의 차이와 캐시를 어떻게 무효화하는지 알아본다.","keywords":["TIL","Network","HTTP"],"articleBody":"Intro HTTP 학습내용의 기본 출처: 김영한님의 모든 개발자를 위한 HTTP 웹 기본지식 강의를 듣고 정리한 내용과 모르는 부분에 대한 추가 내용을 합쳐 올린다. 이 강의는 HTTP에 대한 웹 기본지식을 설명하는 강의이므로, 내용이 간략할 수 있다. 학습 이유: 프레임워크를 사용하여 웹 개발을 배우기 전에, HTTP에 대해 기본적인 지식을 알고자 HTTP 공부를 시작한다. 이 강의에 대해 공부 후, 네트워크 전반에 대해 공부한다. 이번 chapter에서는 지난 HTTP header [TIL] Network HTTP Header 1에 이어서 관련 header에 대해 집중적으로 알아본다.\nHTTP header의 용도는 [TIL] Network HTTP basic을 참고한다.\n1. 캐시 기본 동작 1.1 캐시가 없을 때 클라이언트가 GET 메소드를 사용하여 /star.jpg 를 조회요청을 서버에 보낸다. 서버는 이에 응답하여 HTTP 메세지를 생성하고, HTTP body에 data를 담는다. data의 크기는 다음 같이 가정한다. HTTP header의 data 크기: 0.1 Megabye HTTP body의 data 크기: 1.0 Megabyte 서버의 응답에 클라이언트는 star.jpg를 받는다. 그러면 캐시가 없는 상황에서 서버에 동일한 요청을 또 보내면 어떻게 될까?? 처음과 동일하게, 총 1.1M의 크기를 다운받는다. 캐시가 없기 때문에 데이터가 변경되지 않아도, 계속 네트워크를 통해서 데이터를 다운받아야 한다. 인터넷 네트워크는 비싸고 매우 느리다. 브라우저 로딩 속도가 느리다. 결국, 사용자는 느린 사용 경험을 겪는다. 1.2 캐시를 적용할 때 브라우저에 캐시 저장 공간을 사용한다. 클라이언트의 요청에 서버는 응답 메세지를 생성한다. 그리고, 클라이언트에게 응답 메세지를 보내면서 결과를 캐시에 저장한다. 클라이언트의 두 번째 요청 시, 클라이언트는 서버에 요청을 바로 보내지 않는다. 먼저, 브라우저 캐시에서 캐시 유효 시간을 먼저 검증한다. 유효 시간이 일치하면 캐시에서 조회하여 원하는 데이터를 사용한다. 캐시가 존재하기 때문에 캐시 가능 시간 동안 네트워크를 사용하지 않아도 된다. 비싼 네트워크 사용량을 줄일 수 있다. 브라우저 로딩 속도가 매우 빠르다. 사용자는 빠른 네트워크 경험을 할 수 있다. 1.3 캐시 시간 초과했을 때 캐시 유효 시간을 검증 요청한다. 서버에서 다시 전송한다. 응답 결과를 다시 캐시에 저장한다.\n캐시 유효 시간이 초과하면, 서버를 통해 데이터를 다시 조회하고, 캐시를 갱신한다.\n이때 다시 네트워크 다운로드가 발생한다.\n2. 검증 헤더와 조건부 요청 1 검증 헤더: 캐시 데이터와 서버 데이터가 같은지 검증하는 데이터. ex) Last-Modified header\n조건부 요청 헤더: 검증 헤더로 조건에 따른 분기. ex) if-modified-since: header\n캐시 유효 시간이 초과해서 서버에 다시 요청하면 다음 두 가지 상황이 나타난다.\n서버에서 기존 데이터를 변경하거나, 변경하지 않는 상황 캐시 만료 후에도 서버에서 데이터를 변경하지 않은 상황으로 가정하자.\n데이터를 전송하는 대신에 저장해 두었던 캐시를 재사용할 수 있다. 단, 클라이언트와 서버의 각 데이터가 같다는 사실을 확인할 수 있는 방법이 필요하다. 캐시 시간 초과로 서버에 재요청 시, if-modified-since: header를 메세지에 넣어 보낸다. 이 header가 조건부 요청 header다. 이 header는 캐시가 가지고 있는, 데이터 최종 수정일을 말한다. 서버에서 클라이언트가 보낸 요청과 서버의 해당 data의 데이터 최종 수정일을 비교. 동일할 경우, HTTP body를 전송하지 않고 HTTP header만 전송한다. 데이터가 수정되지 않았기 때문에, 304 Not Modified 상태이며, 검증헤더인 Last-Modified header를 추가한다. 그러면 응답 결과를 재사용하여, header data를 갱신한다.\n정리\n캐시 유효 시간이 초과해도, 서버의 데이터가 갱신되지 않으면 304 Not Modified + Header Meta data만 응답하면 된다. 여기서 Header Meta data란 검증헤더를 말한다. 이 때, HTTP Body는 없어도 된다. -\u003e 클라이언트는 서버가 보낸 응답 헤더정보로 캐시의 메타 정보를 갱신한다. -\u003e 클라이언트는 캐시에 저장되어 있는 데이터를 재활용한다. 결과적으로, 네트워크 다운로드가 발생하지만 용량이 적은 헤더 정보만 다운로드. 실제 웹 브라우저에서 다음 경로를 통해서 조건부 요청 헤더를 볼 수 있다.\n검사(F12) -\u003e Network tab 클릭 -\u003e Status 란에 글씨가 연한 게 Cache에서 불러온 것 다시 이미지 더블클릭 -\u003e 검사 -\u003e Network -\u003e 새로고침(F5) -\u003e 이미지 클릭 -\u003e headers tab -\u003e Request header -\u003e if-modified-since 보기 3. 검증 헤더와 조건부 요청 2 검증 헤더: Last-Modified, ETag\n조건부 요청 헤더: If-Modified-Since:, Last-Modified, If-None-Match:ETag\nLast-Modified header 의 단점을 해결하는 header에 대해 알아보자.\n검증 헤더 (Validator)\nLast-Modified, ETag 조건부 요청 헤더\nIf-Match, If-None-Match:ETag 값 사용 If-Modified-Since, If-Unmodified-Since: Last-Modified 값 사용 조건이 만족하면 200 OK 조건이 만족하지 않으면 304 Not Modified 예시\nIf-Modified-Since: 이후에 데이터가 수정되었다면??? 데이터 미변경 예시 캐시: 2020년 11월 10일 10:00:00 vs 서버:2020년 11월 10일 10:00:00 304 Not Modified, 헤더 데이터만 전송(BODY 미포함) 전송 용량 0.1M (헤더 0.1M, 바디 1.0M) 데이터 변경 예시 캐시: 2020년 11월 10일 10:00:00 vs 서버:2020년 11월 10일 11:00:00 200 OK, 모든 데이터 전송(BODY 포함) 전송 용량 1.1M (헤더 0.1M, 바디 1.0M) 3.1 If-Modified-Since:, Last-Modified 단점 1초 미만(0.x초) 단위로 캐시 조정이 불가능하다. 날짜 기반의 로직을 사용한다. 그래서 데이터를 수정해서 날짜가 다르면, 같은 데이터를 수정해서 데이터 결과가 똑같은 경우에도 다시 다운받아야 한다. 위 문제로 서버에서 별도의 캐시 로직을 관리하고 싶은 경우, 다음 Header들을 사용한다. ex) 스페이스나 주석처럼 크게 영향이 없는 변경에서 캐시를 유지하고 싶은 경우 3.2 해결책: ETag, IF-None-Match 날짜 기반의 date가 기준이 아닌 데이터의 버전 이름이 기준\nETag: Entity Tag 캐시용 데이터에 임의의 고유한 버전 이름을 달아둔다. ex) ETag: v1.0, ETag: a2jiodwjekij3 데이터가 변경되면 이 이름을 바꾸어서 변경한다. (Hash를 다시 생성한다.) ex) ETag: ‘aaaaa’, -\u003e ETag: ‘bbbbbb’ 진짜 단순하게 ETag만 보내서 같으면 유지, 다르면 다시 받는다. ETag: aaaaaaaaaa header 로 서버가 응답했다. 그리고 위 Tag 로 응답 결과를 캐시에 저장했다. 두 번째 요청을 했지만, 캐시 시간이 초과된 상황이다. 서버에 재요청을 보낼 때, 캐시가 가지고 있는 ETag의 내용을 If-None-Match: header로, 요청 message의 header에 함께 보낸다. 서버에서 응답하는 ETag의 내용과 If-None-Match:의 내용을 비교한다. 동일하다는 건, 아직 데이터는 수정되지 않았음을 의미한다. 데이터가 수정되지 않았기 때문에, HTTP 헤더만 보낸다. 응답 결과를 재사용하여, 캐쉬 데이터의 헤더 데이터를 갱신한다. 4. 캐시와 조건부 요청 헤더 캐쉬 제어 헤더의 종류에는 3가지가 있다. Cache-Control: 캐시 제어 Pragma: 캐시 제어(하위 호환) Expires: 캐시 유효 기간(하위 호환) 4.1 Cache-Control 캐시 지시어(directives)\nCache-Control: max-age\n초 단위로, 캐시 유효 시간을 알려준다. Cache-Control: no-cache\n데이터는 캐시해도 되지만, 항상 원(origin) 서버에 검증하고 사용해야 한다. Origin 서버라 하는 이유는 중간에 여러 proxy 서버가 있기 때문이다. Cache-Contrl: no-store\n데이터에 민감한 정보가 있으므로 저장하면 안된다. (메모리에서 사용하고 최대한 빨리 삭제) 4.2 Pragma 캐시 제어(하위 호환)\nPragma:no-cache HTTP 1.0 의 하위 호환 하위 호환이라 지금은 대부분 사용하지 않는다. 하지만, 구글에서는 여러 국가를 지원하기 때문에 사용하고 있다. 4.3 Expires 캐시 만료일 지정(하위 호환)\nexpires: Mon, 01 Jan 1990 00:00:00 GMT\n캐시 만료일을 정확한 날짜로 지정한다. HTTP 1.0부터 사용한다. 지금은 더 유연한 방법인 Cache-Control:max-age 를 권장한다. Cache-Control:max-age와 함께 사용하면 Expires는 무시된다. 4.4 검증 헤더와 조건부 요청 헤더 검증 헤더 (Validator)\nETag: “v1.0”, ETag: “asid93jkrh2l” Last-Modified: Thu, 04 Jun 2020 07:19:24 GMT 조건부 요청 헤더\nIf-Match, If-None-Match: ETag 값 사용 If-Modified-Since, If-Unmodified-Since: Last-Modified 값 사용 5. 프록시 캐시 Cache-Control\n캐시 지시어(directives) - 기타\nCache-Control: public\n응답이 public 캐시에 저장되어도 된다. Cache-Control: private\n응답이 해당 사용자만을 위한 것이다. private 캐시에 저장해야 한다. (기본값) Cache-Control: s-maxage\n프록시 캐시에만 적용되는 max-age\nAge: 60(HTTP 헤더)\nOrigin 서버에서 응답 후, proxy 캐시 내에 머문 시간(단위:초) 우리가 데이터를 받아야 알 수 있다. 원 서버와 클라이언트 사이에 중간 서버 없이, Origin (원) 서버에 직접 접근하는 경우 데이터를 가져오는데 비교적 긴 시간이 걸린다. 하지만 이렇게 proxy 캐시 서버를 도입하면 한국에서 보다 빨리 데이터를 받을 수 있다. 6. 캐시 무효화 확실한 캐시 무효화 응답\nCache-Control: no-cache, Cache-Control: no-store, Cache-Control: must-revalidate\nPragma: no-cache : HTTP 1.0 하위호환\n캐시 무효화가 필요한 이유:\n캐쉬를 적용하려고 하지 않아도, 웹 브라우저들이 임의로 적용한다. 그래서, 이 페이지는 캐쉬를 넣으면 안된다면, 위 헤더들을 반드시 넣어야 한다. Cache-Control directives(캐시 지시어) - 확실한 캐시 무효화\nCache-Control: no-cache\n데이터는 캐시해도 되지만, 항상 원 서버에 검증하고 사용해야 한다. Header 이름 혼동 주의! Cache-Control: no-store\n데이터에 민감한 정보가 있으므로 저장하면 안된다.\n(메모리에서 사용하고 최대한 빨리 삭제) Cache-Control: must-revalidate\n캐시 만료 후, 최초 조회시 원 서버에 검증해야 한다. 원 서버 접근 실패시 반드시 오류가 발생해야한다. 504(Gateway Timeout) =\u003e no-cache와의 차이점 must-revalidate는 캐시 유효 시간이라면 캐시를 사용함 Pragma: no-cache\nHTTP 1.0 하위 호환 no-cache vs must-revalidate no-cache의 기본 동작 (데이터가 수정되지 않은 상황) no-cache 상황에서, 프록시 캐시와 원 서버 간 네트워크 단절이 순간 발생한 경우 must=revalidate 상황에서, 프록시 캐시와 원 서버 간 네트워크 단절이 순간 발생한 경우 정리\n프록시 캐시와 원 서버 간 네트워크 단절이 순간 발생한 경우\nno-cache\n원 서버에 접근할 수 없는 경우, 서버 설정에 따라서 프록시 서버에서 응답할 수 있다. 응답한 data가 오류보다 오래된 데이터라도 보여준다. 단, 오류인지는 알려주지 않는다. must=revalidate\n원 서버에 접근할 수 없는 경우, 항상 오류가 발생해야 한다. 504 Gateway Timeout 으로 응답한다. 오류인지 알려준다 Reference 모든 개발자를 위한 HTTP 웹 기본지식 ","wordCount":"1265","inLanguage":"en","datePublished":"2022-03-18T21:51:01+09:00","dateModified":"2022-03-18T21:51:01+09:00","mainEntityOfPage":{"@type":"WebPage","@id":"http://jeha00.github.io/post/network/http/http_8/"},"publisher":{"@type":"Organization","name":"Jeha DevLog","logo":{"@type":"ImageObject","url":"http://jeha00.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=http://jeha00.github.io/ accesskey=h title="@Jeha00 (Alt + H)">@Jeha00</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></span></div><ul id=menu><li><a href=http://jeha00.github.io/me/ title=About><span>About</span></a></li><li><a href=http://jeha00.github.io/archives/ title=Archive><span>Archive</span></a></li><li><a href=http://jeha00.github.io/categories/ title=Categories><span>Categories</span></a></li><li><a href=http://jeha00.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=http://jeha00.github.io/>Home</a>&nbsp;»&nbsp;<a href=http://jeha00.github.io/post/>Posts</a></div><h1 class=post-title>[TIL] HTTP Header 2</h1><div class=post-meta>Network&nbsp;·&nbsp;<span title='2022-03-18 21:51:01 +0900 KST'>March 18, 2022</span></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#intro aria-label=Intro>Intro</a></li><li><a href=#1-%ec%ba%90%ec%8b%9c-%ea%b8%b0%eb%b3%b8-%eb%8f%99%ec%9e%91 aria-label="1. 캐시 기본 동작">1. 캐시 기본 동작</a><ul><li><a href=#11-%ec%ba%90%ec%8b%9c%ea%b0%80-%ec%97%86%ec%9d%84-%eb%95%8c aria-label="1.1 캐시가 없을 때">1.1 캐시가 없을 때</a></li><li><a href=#12-%ec%ba%90%ec%8b%9c%eb%a5%bc-%ec%a0%81%ec%9a%a9%ed%95%a0-%eb%95%8c aria-label="1.2 캐시를 적용할 때">1.2 캐시를 적용할 때</a></li><li><a href=#13-%ec%ba%90%ec%8b%9c-%ec%8b%9c%ea%b0%84-%ec%b4%88%ea%b3%bc%ed%96%88%ec%9d%84-%eb%95%8c aria-label="1.3 캐시 시간 초과했을 때">1.3 캐시 시간 초과했을 때</a></li></ul></li><li><a href=#2-%ea%b2%80%ec%a6%9d-%ed%97%a4%eb%8d%94%ec%99%80-%ec%a1%b0%ea%b1%b4%eb%b6%80-%ec%9a%94%ec%b2%ad-1 aria-label="2. 검증 헤더와 조건부 요청 1">2. 검증 헤더와 조건부 요청 1</a></li><li><a href=#3-%ea%b2%80%ec%a6%9d-%ed%97%a4%eb%8d%94%ec%99%80-%ec%a1%b0%ea%b1%b4%eb%b6%80-%ec%9a%94%ec%b2%ad-2 aria-label="3. 검증 헤더와 조건부 요청 2">3. 검증 헤더와 조건부 요청 2</a><ul><li><a href=#31-if-modified-since-last-modified-%eb%8b%a8%ec%a0%90 aria-label="3.1 If-Modified-Since:, Last-Modified 단점">3.1 <code>If-Modified-Since:</code>, <code>Last-Modified</code> 단점</a></li><li><a href=#32-%ed%95%b4%ea%b2%b0%ec%b1%85-etag-if-none-match aria-label="3.2 해결책: ETag, IF-None-Match">3.2 해결책: <code>ETag</code>, <code>IF-None-Match</code></a></li></ul></li><li><a href=#4-%ec%ba%90%ec%8b%9c%ec%99%80-%ec%a1%b0%ea%b1%b4%eb%b6%80-%ec%9a%94%ec%b2%ad-%ed%97%a4%eb%8d%94 aria-label="4. 캐시와 조건부 요청 헤더">4. 캐시와 조건부 요청 헤더</a><ul><li><a href=#41-cache-control aria-label="4.1 Cache-Control">4.1 Cache-Control</a></li><li><a href=#42-pragma aria-label="4.2 Pragma">4.2 Pragma</a></li><li><a href=#43-expires aria-label="4.3 Expires">4.3 Expires</a></li><li><a href=#44-%ea%b2%80%ec%a6%9d-%ed%97%a4%eb%8d%94%ec%99%80-%ec%a1%b0%ea%b1%b4%eb%b6%80-%ec%9a%94%ec%b2%ad-%ed%97%a4%eb%8d%94 aria-label="4.4 검증 헤더와 조건부 요청 헤더">4.4 검증 헤더와 조건부 요청 헤더</a></li></ul></li><li><a href=#5-%ed%94%84%eb%a1%9d%ec%8b%9c-%ec%ba%90%ec%8b%9c aria-label="5. 프록시 캐시">5. 프록시 캐시</a></li><li><a href=#6-%ec%ba%90%ec%8b%9c-%eb%ac%b4%ed%9a%a8%ed%99%94 aria-label="6. 캐시 무효화">6. 캐시 무효화</a><ul><li><a href=#no-cache-vs-must-revalidate aria-label="no-cache vs must-revalidate">no-cache vs must-revalidate</a></li></ul></li><li><a href=#reference aria-label=Reference>Reference</a></li></ul></div></details></div><div class=post-content><h1 id=intro>Intro<a hidden class=anchor aria-hidden=true href=#intro>#</a></h1><ul><li>HTTP 학습내용의 기본 출처: 김영한님의 <a href=https://www.inflearn.com/course/http-%EC%9B%B9-%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC>모든 개발자를 위한 HTTP 웹 기본지식</a></li><li>강의를 듣고 정리한 내용과 모르는 부분에 대한 추가 내용을 합쳐 올린다.</li><li>이 강의는 HTTP에 대한 웹 기본지식을 설명하는 강의이므로, 내용이 간략할 수 있다.</li></ul><p> </p><ul><li>학습 이유: 프레임워크를 사용하여 웹 개발을 배우기 전에, HTTP에 대해 기본적인 지식을 알고자 HTTP 공부를 시작한다. 이 강의에 대해 공부 후, 네트워크 전반에 대해 공부한다.</li></ul><p> </p><ul><li><p>이번 chapter에서는 지난 HTTP header <a href=https://jeha00.github.io/post/network/network_http_7/>[TIL] Network HTTP Header 1</a>에 이어서 관련 header에 대해 집중적으로 알아본다.</p></li><li><p>HTTP header의 용도는 <a href=https://jeha00.github.io/post/network/network_http_3/#52-http-header>[TIL] Network HTTP basic</a>을 참고한다.</p></li></ul><p> </p><hr><h1 id=1-캐시-기본-동작>1. 캐시 기본 동작<a hidden class=anchor aria-hidden=true href=#1-캐시-기본-동작>#</a></h1><p> </p><h2 id=11-캐시가-없을-때>1.1 캐시가 없을 때<a hidden class=anchor aria-hidden=true href=#11-캐시가-없을-때>#</a></h2><p><img loading=lazy src=https://user-images.githubusercontent.com/78094972/159005459-4793f519-f8e2-4af3-894f-875b45664987.PNG alt=image></p><p><img loading=lazy src=https://user-images.githubusercontent.com/78094972/159005470-e710e815-a0c0-4c41-9d41-69c3ba901a59.PNG alt=image></p><ul><li>클라이언트가 GET 메소드를 사용하여 /star.jpg 를 조회요청을 서버에 보낸다.</li><li>서버는 이에 응답하여 HTTP 메세지를 생성하고, HTTP body에 data를 담는다.</li><li>data의 크기는 다음 같이 가정한다.<ul><li>HTTP header의 data 크기: 0.1 Megabye</li><li>HTTP body의 data 크기: 1.0 Megabyte</li></ul></li><li>서버의 응답에 클라이언트는 star.jpg를 받는다.</li></ul><p> </p><ul><li>그러면 캐시가 없는 상황에서 서버에 동일한 요청을 또 보내면 어떻게 될까??</li></ul><p><img loading=lazy src=https://user-images.githubusercontent.com/78094972/159005472-c2031cd5-6a0e-4d53-b971-66c600902097.PNG alt=image></p><ul><li>처음과 동일하게, 총 1.1M의 크기를 다운받는다.</li></ul><p> </p><ul><li><strong><em>캐시가 없기 때문에</em></strong><ul><li>데이터가 변경되지 않아도, 계속 네트워크를 통해서 데이터를 다운받아야 한다.</li><li>인터넷 네트워크는 비싸고 매우 느리다.</li><li>브라우저 로딩 속도가 느리다.</li><li>결국, 사용자는 느린 사용 경험을 겪는다.</li></ul></li></ul><p> </p><h2 id=12-캐시를-적용할-때>1.2 캐시를 적용할 때<a hidden class=anchor aria-hidden=true href=#12-캐시를-적용할-때>#</a></h2><p><img loading=lazy src=https://user-images.githubusercontent.com/78094972/159005479-027ec26e-e0fb-426d-ad3b-df70e2e8a294.PNG alt=image></p><p><img loading=lazy src=https://user-images.githubusercontent.com/78094972/159005483-5bcff411-e444-4dfa-a8fd-7b9c298acf57.PNG alt=image></p><ul><li>브라우저에 캐시 저장 공간을 사용한다.</li><li>클라이언트의 요청에 서버는 응답 메세지를 생성한다.</li><li>그리고, 클라이언트에게 응답 메세지를 보내면서 결과를 캐시에 저장한다.</li></ul><p> </p><p><img loading=lazy src=https://user-images.githubusercontent.com/78094972/159005485-f165358b-54c4-4824-aa04-8bbf7b112923.PNG alt=image></p><p><img loading=lazy src=https://user-images.githubusercontent.com/78094972/159005488-55a8093f-0029-41a8-b1f8-2e6fc1e445d7.PNG alt=image></p><ul><li>클라이언트의 두 번째 요청 시, 클라이언트는 서버에 요청을 바로 보내지 않는다.</li><li>먼저, 브라우저 캐시에서 캐시 유효 시간을 먼저 검증한다.</li><li>유효 시간이 일치하면 캐시에서 조회하여 원하는 데이터를 사용한다.</li></ul><p> </p><ul><li><strong><em>캐시가 존재하기 때문에</em></strong><ul><li>캐시 가능 시간 동안 네트워크를 사용하지 않아도 된다.</li><li>비싼 네트워크 사용량을 줄일 수 있다.</li><li>브라우저 로딩 속도가 매우 빠르다.</li><li>사용자는 빠른 네트워크 경험을 할 수 있다.</li></ul></li></ul><p> </p><h2 id=13-캐시-시간-초과했을-때>1.3 캐시 시간 초과했을 때<a hidden class=anchor aria-hidden=true href=#13-캐시-시간-초과했을-때>#</a></h2><p><img loading=lazy src=https://user-images.githubusercontent.com/78094972/159005491-6f8f87a1-a6f2-4168-b86f-e053f88e84c7.PNG alt=image></p><ul><li>캐시 유효 시간을 검증 요청한다.</li></ul><p><img loading=lazy src=https://user-images.githubusercontent.com/78094972/159005492-f81a1019-cc7c-4026-a50a-2ea7bacd1c4f.PNG alt=image></p><ul><li>서버에서 다시 전송한다.</li></ul><p><img loading=lazy src=https://user-images.githubusercontent.com/78094972/159005493-bd112193-ab53-4712-b6d4-32f07328d608.PNG alt=image></p><ul><li><p>응답 결과를 다시 캐시에 저장한다.</p></li><li><p>캐시 유효 시간이 초과하면, 서버를 통해 데이터를 다시 조회하고, 캐시를 갱신한다.</p></li><li><p>이때 다시 네트워크 다운로드가 발생한다.</p></li></ul><hr><h1 id=2-검증-헤더와-조건부-요청-1>2. 검증 헤더와 조건부 요청 1<a hidden class=anchor aria-hidden=true href=#2-검증-헤더와-조건부-요청-1>#</a></h1><blockquote><p>검증 헤더: 캐시 데이터와 서버 데이터가 같은지 검증하는 데이터. ex) <code>Last-Modified</code> header<br>조건부 요청 헤더: 검증 헤더로 조건에 따른 분기. ex) <code>if-modified-since:</code> header</p></blockquote><ul><li><p>캐시 유효 시간이 초과해서 서버에 다시 요청하면 다음 두 가지 상황이 나타난다.</p><ul><li>서버에서 기존 데이터를 변경하거나, 변경하지 않는 상황</li></ul></li><li><p>캐시 만료 후에도 서버에서 데이터를 변경하지 않은 상황으로 가정하자.</p><ul><li>데이터를 전송하는 대신에 저장해 두었던 캐시를 재사용할 수 있다.</li><li>단, 클라이언트와 서버의 각 데이터가 같다는 사실을 확인할 수 있는 방법이 필요하다.</li></ul></li></ul><p> </p><p><img loading=lazy src=https://user-images.githubusercontent.com/78094972/159008398-034f1d5d-cffc-4d8a-8f11-4cdd0449491f.PNG alt=image></p><ul><li>캐시 시간 초과로 서버에 재요청 시, <code>if-modified-since:</code> header를 메세지에 넣어 보낸다.</li><li>이 header가 <code>조건부 요청</code> header다.</li><li>이 header는 <code>캐시가 가지고 있는, 데이터 최종 수정일</code>을 말한다.</li></ul><p><img loading=lazy src=https://user-images.githubusercontent.com/78094972/159008401-dee35854-fd61-48e9-9e6a-39885baa01ca.PNG alt=image></p><ul><li>서버에서 클라이언트가 보낸 요청과 서버의 해당 data의 데이터 최종 수정일을 비교.</li></ul><p><img loading=lazy src=https://user-images.githubusercontent.com/78094972/159008403-978b6dde-1bca-4aac-b0a1-b8d0781b844b.PNG alt=image></p><ul><li>동일할 경우, <code>HTTP body</code>를 전송하지 않고 <code>HTTP header</code>만 전송한다.</li><li>데이터가 수정되지 않았기 때문에, <code>304 Not Modified</code> 상태이며,</li><li>검증헤더인 <code>Last-Modified</code> header를 추가한다.</li></ul><p><img loading=lazy src=https://user-images.githubusercontent.com/78094972/159008405-8acd9936-8493-4cd9-95e4-95a5cac2534c.PNG alt=image></p><ul><li><p>그러면 응답 결과를 재사용하여, header data를 갱신한다.</p></li><li><p>정리</p><ul><li>캐시 유효 시간이 초과해도, 서버의 데이터가 갱신되지 않으면<ul><li><code>304 Not Modified</code> + <code>Header Meta data</code>만 응답하면 된다.</li><li>여기서 <code>Header Meta data</code>란 검증헤더를 말한다.</li><li>이 때, <code>HTTP Body</code>는 없어도 된다.</li><li>-> 클라이언트는 서버가 보낸 응답 헤더정보로 <code>캐시의 메타 정보</code>를 갱신한다.</li><li>-> 클라이언트는 캐시에 저장되어 있는 데이터를 재활용한다.</li><li>결과적으로, 네트워크 다운로드가 발생하지만 용량이 적은 헤더 정보만 다운로드.</li></ul></li></ul></li><li><p>실제 웹 브라우저에서 다음 경로를 통해서 조건부 요청 헤더를 볼 수 있다.</p><ul><li>검사(F12) -> Network tab 클릭 -> Status 란에 글씨가 연한 게 Cache에서 불러온 것</li><li>다시 이미지 더블클릭 -> 검사 -> Network -> 새로고침(F5) -> 이미지 클릭 -> headers tab -> Request header -> if-modified-since 보기</li></ul></li></ul><p><img loading=lazy src=https://user-images.githubusercontent.com/78094972/159013587-a2616b67-f5f5-4b97-baf1-f373d40eed2e.PNG alt=image></p><p> </p><hr><h1 id=3-검증-헤더와-조건부-요청-2>3. 검증 헤더와 조건부 요청 2<a hidden class=anchor aria-hidden=true href=#3-검증-헤더와-조건부-요청-2>#</a></h1><blockquote><p>검증 헤더: <code>Last-Modified</code>, <code>ETag</code><br>조건부 요청 헤더: <code>If-Modified-Since:</code>, <code>Last-Modified</code>, <code>If-None-Match:ETag</code></p></blockquote><ul><li><p><code>Last-Modified</code> header 의 단점을 해결하는 header에 대해 알아보자.</p></li><li><p><strong>검증 헤더 (Validator)</strong></p><ul><li><code>Last-Modified</code>, <code>ETag</code></li></ul></li><li><p><strong>조건부 요청 헤더</strong></p><ul><li><code>If-Match</code>, <code>If-None-Match:ETag 값</code> 사용</li><li><code>If-Modified-Since</code>, <code>If-Unmodified-Since: Last-Modified 값</code> 사용</li><li>조건이 만족하면 200 OK</li><li>조건이 만족하지 않으면 304 Not Modified</li></ul></li><li><p>예시</p><ul><li><code>If-Modified-Since:</code> 이후에 데이터가 수정되었다면???<ul><li><strong>데이터 미변경 예시</strong><ul><li>캐시: 2020년 11월 10일 10:00:00 vs 서버:2020년 11월 10일 10:00:00</li><li><strong>304 Not Modified</strong>, 헤더 데이터만 전송(BODY 미포함)</li><li>전송 용량 0.1M (헤더 0.1M, 바디 1.0M)</li></ul></li><li><strong>데이터 변경 예시</strong><ul><li>캐시: 2020년 11월 10일 10:00:00 vs 서버:2020년 11월 10일 <em>11:00:00</em></li><li><strong>200 OK</strong>, 모든 데이터 전송(BODY 포함)</li><li>전송 용량 1.1M (헤더 0.1M, 바디 1.0M)</li></ul></li></ul></li></ul></li></ul><p> </p><h2 id=31-if-modified-since-last-modified-단점>3.1 <code>If-Modified-Since:</code>, <code>Last-Modified</code> 단점<a hidden class=anchor aria-hidden=true href=#31-if-modified-since-last-modified-단점>#</a></h2><ul><li>1초 미만(0.x초) 단위로 캐시 조정이 불가능하다.</li><li>날짜 기반의 로직을 사용한다.</li><li>그래서 데이터를 수정해서 날짜가 다르면,</li><li>같은 데이터를 수정해서 데이터 결과가 똑같은 경우에도 다시 다운받아야 한다.</li><li>위 문제로 서버에서 별도의 캐시 로직을 관리하고 싶은 경우, 다음 Header들을 사용한다.<ul><li>ex) 스페이스나 주석처럼 크게 영향이 없는 변경에서 캐시를 유지하고 싶은 경우</li></ul></li></ul><p> </p><h2 id=32-해결책-etag-if-none-match>3.2 해결책: <code>ETag</code>, <code>IF-None-Match</code><a hidden class=anchor aria-hidden=true href=#32-해결책-etag-if-none-match>#</a></h2><blockquote><p>날짜 기반의 date가 기준이 아닌 데이터의 버전 이름이 기준</p></blockquote><ul><li><code>ETag</code>: Entity Tag</li><li>캐시용 데이터에 임의의 고유한 버전 이름을 달아둔다.<ul><li>ex) <code>ETag: v1.0</code>, <code>ETag: a2jiodwjekij3</code></li></ul></li><li>데이터가 변경되면 이 이름을 바꾸어서 변경한다. (Hash를 다시 생성한다.)<ul><li>ex) ETag: &lsquo;aaaaa&rsquo;, -> ETag: &lsquo;bbbbbb&rsquo;</li></ul></li><li><strong>진짜 단순하게 ETag만 보내서 같으면 유지, 다르면 다시 받는다.</strong></li></ul><p> </p><p><img loading=lazy src=https://user-images.githubusercontent.com/78094972/159034239-a629868d-4ac9-4874-88f1-81a18629e351.PNG alt=image></p><ul><li><code>ETag: aaaaaaaaaa</code> header 로 서버가 응답했다.</li></ul><p><img loading=lazy src=https://user-images.githubusercontent.com/78094972/159034243-6e9994d3-00f8-4535-95a8-f6f0a13c1e20.PNG alt=image></p><ul><li>그리고 위 Tag 로 응답 결과를 캐시에 저장했다.</li></ul><p><img loading=lazy src=https://user-images.githubusercontent.com/78094972/159034244-070ba99f-8ad9-442e-b0dc-91a960fb21e5.PNG alt=image></p><ul><li>두 번째 요청을 했지만, 캐시 시간이 초과된 상황이다.</li></ul><p><img loading=lazy src=https://user-images.githubusercontent.com/78094972/159034248-cfb46db5-781e-4b24-b498-d55234bae455.PNG alt=image></p><ul><li>서버에 재요청을 보낼 때, 캐시가 가지고 있는 <code>ETag</code>의 내용을 <code>If-None-Match:</code> header로, 요청 message의 header에 함께 보낸다.</li></ul><p><img loading=lazy src=https://user-images.githubusercontent.com/78094972/159034250-80cef4bf-4490-4b66-9a52-6212626d872c.PNG alt=image></p><ul><li>서버에서 응답하는 <code>ETag</code>의 내용과 <code>If-None-Match:</code>의 내용을 비교한다.</li><li>동일하다는 건, 아직 데이터는 수정되지 않았음을 의미한다.</li></ul><p><img loading=lazy src=https://user-images.githubusercontent.com/78094972/159034254-235f224d-524f-48f4-b18e-d06a8951f8fc.PNG alt=image></p><ul><li>데이터가 수정되지 않았기 때문에, <code>HTTP 헤더</code>만 보낸다.</li></ul><p><img loading=lazy src=https://user-images.githubusercontent.com/78094972/159034259-4649eb43-e181-4f33-9ac2-cf9bf8689444.PNG alt=image></p><ul><li>응답 결과를 재사용하여, 캐쉬 데이터의 헤더 데이터를 갱신한다.</li></ul><p> </p><hr><h1 id=4-캐시와-조건부-요청-헤더>4. 캐시와 조건부 요청 헤더<a hidden class=anchor aria-hidden=true href=#4-캐시와-조건부-요청-헤더>#</a></h1><ul><li>캐쉬 제어 헤더의 종류에는 3가지가 있다.<ul><li><code>Cache-Control</code>: 캐시 제어</li><li><code>Pragma</code>: 캐시 제어(하위 호환)</li><li><code>Expires</code>: 캐시 유효 기간(하위 호환)</li></ul></li></ul><p> </p><h2 id=41-cache-control>4.1 Cache-Control<a hidden class=anchor aria-hidden=true href=#41-cache-control>#</a></h2><blockquote><p>캐시 지시어(directives)</p></blockquote><ul><li><p><code>Cache-Control: max-age</code></p><ul><li>초 단위로, 캐시 유효 시간을 알려준다.</li></ul></li><li><p><code>Cache-Control: no-cache</code></p><ul><li>데이터는 캐시해도 되지만, 항상 원(origin) 서버에 검증하고 사용해야 한다.<ul><li>Origin 서버라 하는 이유는 중간에 여러 proxy 서버가 있기 때문이다.</li></ul></li></ul></li><li><p><code>Cache-Contrl: no-store</code></p><ul><li>데이터에 민감한 정보가 있으므로 저장하면 안된다.</li><li>(메모리에서 사용하고 최대한 빨리 삭제)</li></ul></li></ul><p> </p><h2 id=42-pragma>4.2 Pragma<a hidden class=anchor aria-hidden=true href=#42-pragma>#</a></h2><blockquote><p>캐시 제어(하위 호환)</p></blockquote><ul><li><code>Pragma:no-cache</code></li><li>HTTP 1.0 의 하위 호환<ul><li>하위 호환이라 지금은 대부분 사용하지 않는다.</li><li>하지만, 구글에서는 여러 국가를 지원하기 때문에 사용하고 있다.</li></ul></li></ul><p> </p><h2 id=43-expires>4.3 Expires<a hidden class=anchor aria-hidden=true href=#43-expires>#</a></h2><blockquote><p>캐시 만료일 지정(하위 호환)<br>expires: Mon, 01 Jan 1990 00:00:00 GMT</p></blockquote><ul><li>캐시 만료일을 정확한 날짜로 지정한다.</li><li>HTTP 1.0부터 사용한다.</li><li>지금은 더 유연한 방법인 <code>Cache-Control:max-age</code> 를 권장한다.</li><li><code>Cache-Control:max-age</code>와 함께 사용하면 <code>Expires</code>는 무시된다.</li></ul><p> </p><h2 id=44-검증-헤더와-조건부-요청-헤더>4.4 검증 헤더와 조건부 요청 헤더<a hidden class=anchor aria-hidden=true href=#44-검증-헤더와-조건부-요청-헤더>#</a></h2><ul><li><p><strong>검증 헤더 (Validator)</strong></p><ul><li>ETag: &ldquo;v1.0&rdquo;, ETag: &ldquo;asid93jkrh2l&rdquo;</li><li>Last-Modified: Thu, 04 Jun 2020 07:19:24 GMT</li></ul></li><li><p><strong>조건부 요청 헤더</strong></p><ul><li>If-Match, If-None-Match: ETag 값 사용</li><li>If-Modified-Since, If-Unmodified-Since: Last-Modified 값 사용</li></ul></li></ul><p> </p><hr><h1 id=5-프록시-캐시>5. 프록시 캐시<a hidden class=anchor aria-hidden=true href=#5-프록시-캐시>#</a></h1><blockquote><p>Cache-Control<br>캐시 지시어(directives) - 기타</p></blockquote><ul><li><p><code>Cache-Control: public</code></p><ul><li>응답이 public 캐시에 저장되어도 된다.</li></ul></li><li><p><code>Cache-Control: private</code></p><ul><li>응답이 해당 사용자만을 위한 것이다.</li><li>private 캐시에 저장해야 한다. (기본값)</li></ul></li><li><p><code>Cache-Control: s-maxage</code></p></li><li><p>프록시 캐시에만 적용되는 max-age</p></li><li><p><code>Age: 60</code>(HTTP 헤더)</p><ul><li>Origin 서버에서 응답 후, proxy 캐시 내에 머문 시간(단위:초)</li><li>우리가 데이터를 받아야 알 수 있다.</li></ul></li></ul><p> </p><p><img loading=lazy src=https://user-images.githubusercontent.com/78094972/159041113-bd3c9900-b4f9-49fe-a6cd-b54f38cd722b.PNG alt=image></p><ul><li>원 서버와 클라이언트 사이에 중간 서버 없이, Origin (원) 서버에 직접 접근하는 경우</li><li>데이터를 가져오는데 비교적 긴 시간이 걸린다.</li></ul><p><img loading=lazy src=https://user-images.githubusercontent.com/78094972/159041121-5909e892-5a06-4fcf-bb05-4fd820ac638f.PNG alt=image></p><ul><li>하지만 이렇게 proxy 캐시 서버를 도입하면 한국에서 보다 빨리 데이터를 받을 수 있다.</li></ul><p> </p><hr><h1 id=6-캐시-무효화>6. 캐시 무효화<a hidden class=anchor aria-hidden=true href=#6-캐시-무효화>#</a></h1><blockquote><p>확실한 캐시 무효화 응답<br><code>Cache-Control: no-cache</code>, <code>Cache-Control: no-store</code>, <code>Cache-Control: must-revalidate</code><br><code>Pragma: no-cache</code> : HTTP 1.0 하위호환</p></blockquote><ul><li><p>캐시 무효화가 필요한 이유:</p><ul><li>캐쉬를 적용하려고 하지 않아도, 웹 브라우저들이 임의로 적용한다.</li><li>그래서, 이 페이지는 캐쉬를 넣으면 안된다면, 위 헤더들을 반드시 넣어야 한다.</li></ul></li><li><p><strong>Cache-Control directives(캐시 지시어) - 확실한 캐시 무효화</strong></p><ul><li><p><code>Cache-Control: no-cache</code></p><ul><li>데이터는 캐시해도 되지만, 항상 원 서버에 검증하고 사용해야 한다.</li><li>Header 이름 혼동 주의!</li></ul></li><li><p><code>Cache-Control: no-store</code></p><ul><li>데이터에 민감한 정보가 있으므로 저장하면 안된다.<br>(메모리에서 사용하고 최대한 빨리 삭제)</li></ul></li><li><p><code>Cache-Control: must-revalidate</code></p><ul><li><em>캐시 만료 후, 최초 조회시</em> 원 서버에 검증해야 한다.</li><li>원 서버 접근 실패시 <em>반드시 오류가 발생해야한다.</em></li><li><em>504(Gateway Timeout)</em> => <code>no-cache</code>와의 차이점</li><li>must-revalidate는 캐시 유효 시간이라면 캐시를 사용함</li></ul></li><li><p><code>Pragma: no-cache</code></p><ul><li>HTTP 1.0 하위 호환</li></ul></li></ul></li></ul><p> </p><h2 id=no-cache-vs-must-revalidate>no-cache vs must-revalidate<a hidden class=anchor aria-hidden=true href=#no-cache-vs-must-revalidate>#</a></h2><ul><li><code>no-cache</code>의 기본 동작 (데이터가 수정되지 않은 상황)</li></ul><p><img loading=lazy src=https://user-images.githubusercontent.com/78094972/159101257-73033a97-cefe-4e54-b410-1e95235151ad.PNG alt=image></p><p><img loading=lazy src=https://user-images.githubusercontent.com/78094972/159101258-53f6d5be-2665-4d37-8a2d-dcf7a408f449.PNG alt=image></p><p> </p><ul><li><code>no-cache</code> 상황에서, 프록시 캐시와 원 서버 간 네트워크 단절이 순간 발생한 경우</li></ul><p><img loading=lazy src=https://user-images.githubusercontent.com/78094972/159101260-d3e0d59b-259a-4771-9da2-1f51aad9fe55.PNG alt=image></p><ul><li><code>must=revalidate</code> 상황에서, 프록시 캐시와 원 서버 간 네트워크 단절이 순간 발생한 경우</li></ul><p><img loading=lazy src=https://user-images.githubusercontent.com/78094972/159101256-67c91b6b-3d64-4047-b629-f7f80f334958.PNG alt=image></p><p> </p><ul><li><p>정리</p><ul><li><p>프록시 캐시와 원 서버 간 네트워크 단절이 순간 발생한 경우</p></li><li><p><code>no-cache</code></p><ul><li>원 서버에 접근할 수 없는 경우, 서버 설정에 따라서 프록시 서버에서 응답할 수 있다.</li><li>응답한 data가 오류보다 오래된 데이터라도 보여준다.</li><li><em>단, 오류인지는 알려주지 않는다.</em></li></ul></li><li><p><code>must=revalidate</code></p><ul><li>원 서버에 접근할 수 없는 경우, <strong>항상 오류</strong>가 발생해야 한다.</li><li><em>504 Gateway Timeout</em> 으로 응답한다.</li><li><em>오류인지 알려준다</em></li></ul></li></ul></li></ul><p> </p><hr><h1 id=reference>Reference<a hidden class=anchor aria-hidden=true href=#reference>#</a></h1><ul><li><a href=https://www.inflearn.com/course/http-%EC%9B%B9-%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC>모든 개발자를 위한 HTTP 웹 기본지식</a></li></ul></div><footer class=post-footer><ul class=post-tags><li><a href=http://jeha00.github.io/tags/til/>TIL</a></li><li><a href=http://jeha00.github.io/tags/network/>Network</a></li><li><a href=http://jeha00.github.io/tags/http/>HTTP</a></li></ul><nav class=paginav><a class=prev href=http://jeha00.github.io/post/python/python_basic_27_specialmethod/><span class=title>« Prev Page</span><br><span>[TIL] Python basic 27: Special Method</span></a>
<a class=next href=http://jeha00.github.io/post/network/http/http_7/><span class=title>Next Page »</span><br><span>[TIL] HTTP Header 1</span></a></nav><div class=share-buttons><a target=_blank rel="noopener noreferrer" aria-label="share [TIL] HTTP Header 2 on twitter" href="https://twitter.com/intent/tweet/?text=%5bTIL%5d%20HTTP%20Header%202&url=http%3a%2f%2fjeha00.github.io%2fpost%2fnetwork%2fhttp%2fhttp_8%2f&hashtags=TIL%2cNetwork%2cHTTP"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM195.519 424.544c135.939.0 210.268-112.643 210.268-210.268.0-3.218.0-6.437-.153-9.502 14.406-10.421 26.973-23.448 36.935-38.314-13.18 5.824-27.433 9.809-42.452 11.648 15.326-9.196 26.973-23.602 32.49-40.92-14.252 8.429-30.038 14.56-46.896 17.931-13.487-14.406-32.644-23.295-53.946-23.295-40.767.0-73.87 33.104-73.87 73.87.0 5.824.613 11.494 1.992 16.858-61.456-3.065-115.862-32.49-152.337-77.241-6.284 10.881-9.962 23.601-9.962 37.088.0 25.594 13.027 48.276 32.95 61.456-12.107-.307-23.448-3.678-33.41-9.196v.92c0 35.862 25.441 65.594 59.311 72.49-6.13 1.686-12.72 2.606-19.464 2.606-4.751.0-9.348-.46-13.946-1.38 9.349 29.426 36.628 50.728 68.965 51.341-25.287 19.771-57.164 31.571-91.8 31.571-5.977.0-11.801-.306-17.625-1.073 32.337 21.15 71.264 33.41 112.95 33.41z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share [TIL] HTTP Header 2 on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&url=http%3a%2f%2fjeha00.github.io%2fpost%2fnetwork%2fhttp%2fhttp_8%2f&title=%5bTIL%5d%20HTTP%20Header%202&summary=%5bTIL%5d%20HTTP%20Header%202&source=http%3a%2f%2fjeha00.github.io%2fpost%2fnetwork%2fhttp%2fhttp_8%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share [TIL] HTTP Header 2 on reddit" href="https://reddit.com/submit?url=http%3a%2f%2fjeha00.github.io%2fpost%2fnetwork%2fhttp%2fhttp_8%2f&title=%5bTIL%5d%20HTTP%20Header%202"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share [TIL] HTTP Header 2 on facebook" href="https://facebook.com/sharer/sharer.php?u=http%3a%2f%2fjeha00.github.io%2fpost%2fnetwork%2fhttp%2fhttp_8%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share [TIL] HTTP Header 2 on whatsapp" href="https://api.whatsapp.com/send?text=%5bTIL%5d%20HTTP%20Header%202%20-%20http%3a%2f%2fjeha00.github.io%2fpost%2fnetwork%2fhttp%2fhttp_8%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share [TIL] HTTP Header 2 on telegram" href="https://telegram.me/share/url?text=%5bTIL%5d%20HTTP%20Header%202&url=http%3a%2f%2fjeha00.github.io%2fpost%2fnetwork%2fhttp%2fhttp_8%2f"><svg viewBox="2 2 28 28"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></div></footer></article></main><footer class=footer><span>&copy; 2023 <a href=http://jeha00.github.io/>Jeha DevLog</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerText="copy";function s(){t.innerText="copied!",setTimeout(()=>{t.innerText="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>