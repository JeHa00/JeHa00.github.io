<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>[TIL]OSI 7 layer: 4계층 전송 계층 | Jeha DevLog</title><meta name=keywords content="TIL,Network"><meta name=description content="OSI 7 layer에서 신뢰성 있는 통신을 구현하는 4계층에 대해 더 알아보자."><meta name=author content><link rel=canonical href=http://jeha00.github.io/post/network/osi_7_layer/4_layer/><meta name=google-site-verification content="XYZabc"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.min.268b216eea772711d318d156ce02a8190962367a0bf469fa9a959114ea6b9ca3.css integrity="sha256-Joshbup3JxHTGNFWzgKoGQliNnoL9Gn6mpWRFOprnKM=" rel="preload stylesheet" as=style><link rel=icon href=http://jeha00.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=http://jeha00.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=http://jeha00.github.io/favicon-32x32.png><link rel=apple-touch-icon href=http://jeha00.github.io/apple-touch-icon.png><link rel=mask-icon href=http://jeha00.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><meta name=generator content="Hugo 0.101.0"><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><script type=application/javascript>var doNotTrack=!1;doNotTrack||(function(e,t,n,s,o,i,a){e.GoogleAnalyticsObject=o,e[o]=e[o]||function(){(e[o].q=e[o].q||[]).push(arguments)},e[o].l=1*new Date,i=t.createElement(n),a=t.getElementsByTagName(n)[0],i.async=1,i.src=s,a.parentNode.insertBefore(i,a)}(window,document,"script","https://www.google-analytics.com/analytics.js","ga"),ga("create","UA-123-45","auto"),ga("send","pageview"))</script><meta property="og:title" content="[TIL]OSI 7 layer: 4계층 전송 계층"><meta property="og:description" content="OSI 7 layer에서 신뢰성 있는 통신을 구현하는 4계층에 대해 더 알아보자."><meta property="og:type" content="article"><meta property="og:url" content="http://jeha00.github.io/post/network/osi_7_layer/4_layer/"><meta property="og:image" content="http://jeha00.github.io/47"><meta property="article:section" content="post"><meta property="article:published_time" content="2023-12-09T15:50:44+09:00"><meta property="article:modified_time" content="2023-12-09T15:50:44+09:00"><meta property="og:site_name" content="JeHa00 DevLog"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="http://jeha00.github.io/47"><meta name=twitter:title content="[TIL]OSI 7 layer: 4계층 전송 계층"><meta name=twitter:description content="OSI 7 layer에서 신뢰성 있는 통신을 구현하는 4계층에 대해 더 알아보자."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"http://jeha00.github.io/post/"},{"@type":"ListItem","position":2,"name":"[TIL]OSI 7 layer: 4계층 전송 계층","item":"http://jeha00.github.io/post/network/osi_7_layer/4_layer/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"[TIL]OSI 7 layer: 4계층 전송 계층","name":"[TIL]OSI 7 layer: 4계층 전송 계층","description":"OSI 7 layer에서 신뢰성 있는 통신을 구현하는 4계층에 대해 더 알아보자.","keywords":["TIL","Network"],"articleBody":"네트워크 학습 내용 순서 [TIL]Web Application Basic study: OSI 7 layer outline [TIL] Network OSI 7 layer: 1계층 [TIL] Network OSI 7 layer: 2계층 [TIL] Network OSI 7 layer: 3계층 이번 장에서는 전송(Transport) 계층인 4계층에 대해 알아보자.\n❗️ 패킷(packet)이란 용어에 대해서\n패킷이란 용어는 3계층의 데이터 단위임을 학습했다. 하지만 이 ‘패킷’이란 용어는 네트워크 전체적으로 데이터를 지칭하는 용어로도 사용되기도 한다. 그래서 이번 4계층 학습에서 언급되는 패킷들은 세그먼트가 맞지만, 3계층에서 IP 패킷으로 캡슐화되기 때문이거나 범용적으로 데이터를 나타내는 용어라고 생각하자.\n1. Transport 전송 계층 개요 3계층은 한 네트워크에서 다른 네트워크로 데이터를 전송하는 과정에 중점을 두고 맞춰져있다. 그러나, 네트워크 환경은 기본적으로 비신뢰성 환경이기 때문에 전송된 패킷이 정상적응로 전달되지 않을 수도 있고, 중간이 패킷이 유실되거나 손실될 수도 있다. 또한, 여러 패킷으로 나눠서 전달될 때 순서가 잘못될 수도 있다.\n이에 대한 해결책으로 4계층은 목적지에 신뢰할 수 있는 데이터를 전송할 수 있는가? 에 초점을 맞춘다. 이에 따라 역할, 전송방식이 정해진다.\n1) 4계층의 역할 목적지까지 신뢰할 수 있는 데이터를 전송하는 역할 오류 점검 및 데이터의 목적지가 어떤 애플리케이션인지 식별하는 역할 2) 4계층의 전송 방식 위 역할에 따랏 4계층의 전송 방식은 ‘연결형 통신’ 과 ‘비연결형 통신’ 2가지로 나눠진다.\n연결형 통신\n신뢰성과 정확성 연결 필요 사용되는 프로토콜: TCP (Transmission Control Protocol) 비연결형 통신\n효율성: 빠르게 일방적인 통신 (연결 불필요) 사용되는 프로토콜: UDP ex) 동영상 스트리핑 서비스 3) 4계층의 캡슐화, 역캡슐화 그리고 데이터 단위 4계층은 TCP 헤더 의 캡슐화, 역캡슐화가 일어나는 계층으로 이 때 데이터 단위는 segment(세그먼트) 다.\nTCP header + Application header + User data ❗️ 다시 한번 언급: 패킷(packet)이란 용어에 대해서\n패킷이란 용어는 3계층의 데이터 단위임을 학습했다. 하지만 이 ‘패킷’이란 용어는 네트워크 전체적으로 데이터를 지칭하는 용어로도 사용되기도 한다. 그래서 이번 4계층 학습에서 언급되는 패킷들은 ‘세그먼트’가 맞지만, 3계층에서 IP 패킷으로 캡슐화되기 때문이거나 범용적으로 데이터를 나타내는 용어라고 생각하자.\n2. TCP segment TCP segment는 응용 계층의 데이터에서 TCP 헤더를 캡슐화하거나, 네트워크 계층의 패킷에서 IP 헤더를 역캡슐화를 하면 되는 데이터 단위다.\n이 TCP 헤더에는 여러 정보들이 담겨있지만 주요 필드만을 언급하자면 다음과 같다.\n출발지 포트 번호, 목적지 포트 번호 일련 번호, 확인 응답 번호 TCP 플래그, 윈도우 크기 더 자세한 필드는 다음과 같다.\n출발지 포트 번호 (16 bit), 목적지 포트 번호 (16 bit) 일련 번호(sequence number) (32 bit) 송신자가 지정하는 순서 번호 고유한 번호 확인 응답 번호(acknowledgement number) (32 bit) 데이터를 정상적으로 수신했을 시 보내는 번호 일련 번호에 1을 더한 값이므로, 다음 데이터의 일련 번호라고도 볼 수 있다. 일련 번호 + 1 헤더 길이(header length) (4 bit) 옵션 필드가 가변적이라서 정확히 헤더의 길이를 파악하기 위해 사용 예약 영역 (6 bit) 나중에 사용하기 위해 남겨둔 영역 TCP 플래그 (코드 비트) (6 bit) 6개 비트로 구성: SYN, ACK, FIN, URG, PSH, RST 3 way handshake와 4 way handshake 와 관련 윈도우 크기(window size) (16 bit) 한 번에 전송할 수 있는 데이터의 양 TCP 흐름 제어와 관련 체크섬(checksum) (16 bit) 데이터를 보내는 중에 발생할 수 잇는 에러를 항상 검사하는데, 데이터에 대해 체크섬 방식으로 계산한 결과값을 이 필드에 저장 긴급 포인터(urgent pointer) (16 bit) TCP 플래그의 코드 비트 URG 비트 설정과 함께 사용 TCP 옵션 ❗️ IP 헤더는 포트 번호가 아닌 ‘출발지/목적지 IP 주소’ 였던 것을 기억하자.\n3. 3-way handshake \u0026 4-way handshake 3.1 TCP flag (code bit) 위 2개의 handshake 는 TCP 헤더의 TCP flag 코드 비트 와 관련있다.\nTCP의 연결 확립 과정과 연결 종료 과정에서 TCP flag 코드 비트가 중요한 역할을 한다.\n그러면 코드 비트에 대해 자세히 확인해보면 다음과 같이 6 bit가 존재한다.\nURG ACK PSH RST SYN FIN 0 0 0 0 0 0 각 1bit를 의미한다. 각 초기 비트 값은 0이며 각 과정에서 활성화되어 1로 바뀌어 전송된다.\n그리고 각 단어는 다음 의미를 가진다.\nURG: Urgent\nACK: Acknowledgement\nPSH: Push\nRST: Reset\nSYN: Synchronize\nFIN: Finish\n3.2 3-way handshake TCP는 연결을 확립하기 위해 3-way handshake 과정을 거친다. 이 때 SYN, ACK 두 비트를 사용한다.\n이 과정의 총 세 단계 순서는 다음과 같다.\n상황: 클라이언트와 서버가 존재하고, 클라이언트가 서버에 ‘세션 연결 확립’을 위해 요청을 보내려는 상황\n1) 연결 요청 - client –\u003e server with SYN: 1 클라이언트가 서버에게 연결 확립을 요청한다. 이 때 SYN이 1로 활성화된 세그먼트를 서버에 전송한다.\nURG ACK PSH RST SYN FIN 0 0 0 0 1 0 2) 확인 및 연결 요청 - client \u003c– server with SYN: 1, ACK: 1 클라이언트가 보낸 세그먼트를 서버가 확인하면서 서버에서도 연결을 요청하기 위해 SYN과 ACK bit가 1로 활성화된 세그먼트를 클라이언트에게 보낸다.\nURG ACK PSH RST SYN FIN 0 1 0 0 1 0 3) 확인 - client –\u003e server with ACK: 1 서버가 보낸 세그먼트를 클라이언트가 확인하고, 이에 응답하기 위해 ACK bit가 1로 활성화된 세그먼트를 서버에게 보낸다.\nURG ACK PSH RST SYN FIN 0 1 0 0 0 0 3.3 4-way handshake TCP는 연결을 종료하기 위해 4-way handshake 과정을 거친다. 이 때 FIN, ACK 두 비트를 사용한다.\n상황: 클라이언트와 서버 간 연결을 종료하기 위해 요청을 보내려는 상황\n1) 연결 종료 - client –\u003e server with FIN: 1 클라이언트가 서버에게 연결 종료를 요청한다. 이 때 FIN이 1로 활성화된 세그먼트를 전송한다.\nURG ACK PSH RST SYN FIN 0 0 0 0 0 1 2) 확인 - client \u003c– server with ACK: 1 서버는 클라이언트에게 연결 종료에 대한 응답을 하기 위해 ACK이 1로 활성화된 세그먼트를 전송한다.\nURG ACK PSH RST SYN FIN 0 1 0 0 0 0 3) 연결 종료 - client \u003c– server with FIN: 1 서버도 클라이언트에게 연결 종료를 요청한다. 이 때 FIN이 1로 활성화된 세그먼트를 전송한다.\nURG ACK PSH RST SYN FIN 0 0 0 0 0 1 4) 확인 - client –\u003e server with ACK: 1 클라이언트는 서버에게 연결 종료에 대한 응답을 하기 위해 ACK이 1로 활성화된 세그먼트를 전송한다.\nURG ACK PSH RST SYN FIN 0 1 0 0 0 0 3. TCP 에러 제어 에러 제어 개요 TCP는 전송된 세그먼트가 손실되거나 순서가 어긋났을 때 혹은 중복되었을 경우, 이에 대한 처리를 수행하는데 그 중 하나의 방법이 TCP 에러 제어 다. 이 제어를 통해 신뢰성 있는 데이터를 전송한다.\n에러 제어는 에러를 검출(detection)한 후, 에러를 정정(correction)하는 과정을 거친다. 에러 검출과 에러 정정 과정에는 다음과 같은 방법들이 존재한다.\n에러 제어 에러 검출(detection) CRC (Cyclic Redundancy Check) Checksum(체크섬): TCP 헤더의 체크섬 필드가 데이터에 대한 에러를 검사하는 기능이 있어, 세그먼트가 전송되는 도중 에러 발생 유무를 확인 에러 정정(correction): ARQ(Automatic Repeat reQuest) 방식을 사용하며, 이 방식의 종류는 다음과 같다. Stop and Wait ARQ Go-Back-N ARQ Selective Repeat ARQ 그러면 에러 정정 방법들에 대해 자세히 알아보자.\n에러 정정: Stop-and-Wait ARQ 매번 전송한 패킷에 대해 확인 응답을 받고 나서 그 다음 패킷을 전송하는 방식이다. 만약 일정 시간 동안 ACK을 받지 못하여 Timeout이 되었을 경우, 해당 패킷부터 재전송한다. 또한, 패킷 간 식별을 위해 0과 1의 패킷 혹은 ACK를 번걸아 가면서 전송한다.\n확인 응답을 받을 때까지 멈춰서 기다리는 방식이기 때문에 비효율적이다.\n위 그림을 기준으로 설명하자면 1, 2, 3번 패킷으로 구분되는 것이 아니라 0, 1, 0, 1번으로 구분된다.\n에러 정정: Go-Back-N ARQ 패킷이 도착하지 않아 타임아웃되었을 시, 이 패킷부터 다시 차례대로 재전송하는 방식이다.\n위 그림을 통해서 구체적인 예시를 들어보자.\nA 에서 패킷 0번, 1번, 2번 패킷을 전송한다. 이중 1번을 제외한 패킷들을 수신했다. 수신한 패킷에 대해 ACK을 보내는데 1번 패킷을 받지 못 했으므로, 그 이후에 2번, 3번 패킷을 B가 받아도 받은 패킷을 폐기한 후, 0번 ACK을 B가 재전송한다. 1번 패킷에 대한 확인 응답 ACK이 도착하지 않아 타임아웃되어 A가 패킷을 재전송할 때 다시 순서대로 1번 패킷, 2번 패킷, 3번 패킷을 보낸다.\n이처럼 뒤로 돌아가서 순서대로 다시 재전송하는 방식을 Go-Back-N 재전송 방식이다.\n에러 정정: Selective Repeat ARQ 패킷이 도착하지 않아 타임아웃되었을 시 수신하지 못한 패킷만을 선택적으로 재전송하는 방식이다.\n수신한 패킷에 대해 선택적으로 ACK 전송이 가능하며, 선택적 전송이 가능한 이유는 중간 패킷이 수신되지 못했을 경우 소실된 패킷 이후 패킷을 버퍼에 기록하기 때문이다. 소실된 패킷에 대한 확인 응답이 A에게 도착하지 않아 타임아웃되면 A에서 소실된 패킷이 재전송된다.\n소실된 패킷이 도착되면 소실된 패킷과 그 이후에 보내진 패킷들을 함께 상위계층으로 올린다.\n위 그림을 기준으로 설명해보자.\nA에서 초기에 0번, 1번, 2번 패킷이 전송된다. B에 정상적으로 도착한 건 1번 패킷을 제외한 나머지다. B에서는 수신한 패킷에 대해 선택적 ACK을 전송한다. 1번 패킷을 받지 못 했으므로, 1번 패킷 이후의 패킷은 버퍼에 저장된다. A에서는 이어서 3번, 4번 패킷이 전송된다. B에 정상적으로 도착했고, 이를 버퍼에 저장한다. 그리고, 이에 대해 선택적 ACK인 3번 ACK, 4번 ACK을 전송한다. 1번 패킷에 대한 확인응답이 A에게 도착하지 않아 타임아웃되면 A에서는 1번 패킷을 재전송한다. B에서는 이에 대한 1번 ACK을 전송하여 A는 확인응답을 받는다. B는 1번 패킷과 함께 버퍼에 저장된 2번, 3번, 4번 패킷을 상위 계층에 전송한다. 4. TCP 흐름 제어(TCP Flow Control) 송수신지의 데이터 처리 능력이 달라서 데이터가 유실될 수가 있는데 이를 방지하는 기법이다.\n흐름 제어 기법에는 두 가지 방법이 있지만, 주로 슬라이딩 윈도우 기법을 사용한다.\nStop-and-Wait 슬라이딩 윈도우(Sliding window): 윈도우 광고 기법 Stop-and-Wait Stop-and-Wait은 ‘TCP 에러 제어 챕터’ 에서 설명한 것처럼 모든 패킷에 대해 확인 응답을 받아야만 다음 패킷을 전송하는 방식이기 때문에 비효율적이라는 단점이 있다.\nSliding window 반면 슬라이딩 윈도우는 송수신지에 있는 슬라이딩 윈도우 를 활용하는 방식으로 Stop-and-wait 방식과 달리 송신측에서 응답을 받지 않아도 연속적으로 전송할 수 있다. 단지 연속적으로 전송하는 게 아니라 송수신측의 윈도우 크기를 서로 알려주기 때문에 데이터 유실을 방지할 수 있는 방식이다.\n즉 슬라이딩 윈도우 방식은 수신측과 송신측의 윈도우 크기를 서로 알리면서 윈도우 크기가 변한다. 먼저 윈도우 에 대해 알아보자면 송수신 각 측에서 만들어진 버퍼의 크기를 말한다.\n송신측 윈도우: Congestion window로, ‘cwnd’ 라고 표기 수신측 윈도우: Receiver window로 ‘rwnd’ 라고 표기 그러면 슬라이딩 윈도우 기법을 통한 TCP 흐름 제어를 살펴보자.\n위 이미지와 아래 설명을 함께 보자.\n송수신측의 윈도우 크기 모두 250이라 가정해보자.\n(0 - 250) 송신지(A)에서 100 바이트 데이터를 수신측(B)에 보낸다.\nB에서는 이 데이터를 받아 버퍼에 저장했기 때문에, 수신측 윈도우 크기는 250에서 ‘150’이 된다. 그리고 좌측 윈도우 경계선은 101로 이동된다. (101 - 250)\n그리고, B에서 확인 응답으로 ‘ACK 101’ 과 수신측의 현재 윈도우 크기 150을 보낸다.\nA에서 이 정보를 받아 동일하게 101부터 시작해서 윈도우 크기를 150에 맞추고, 시작 경계선을 101로 맞춘다.\n송신지 윈도우의 크기는 수신지 윈도우 크기에 맞춰서 수신측이 받을 수 있도록 크기를 맞춘다. 맞춘 후, A에서 다시 B에게 50 바이트를 전송한다.\nB에서 50 바이트 데이터를 버퍼에 저장한다. 윈도우 크기는 100으로 줄어들고, 좌측 윈도우 경계선이 151로 이동된다. (151 - 250)\n하지만 응용 프로세스가 B의 윈도우에 저장된 50 바이트 데이터를 처리하여 윈도우는 (151 - 300) 으로 이동되어 윈도우 크기는 150으로 늘어난다.\nB에서 A에게 확인 응답 ACK 151 과 window 크기는 150이라는 정보를 전달한다.\nB에서 보내진 정보를 A가 받아 B 윈도우 크기에 맞춰 A도 수정한다.\n위와 같은 작업 방식으로 진행된다.\n5. TCP 혼잡 제어 6. 포트 번호 7. UDP Reference 나노디그리 러닝스푼즈: Python \u0026 Django backend course 네트워크, 그림으로 이해해자 ","wordCount":"1647","inLanguage":"en","datePublished":"2023-12-09T15:50:44+09:00","dateModified":"2023-12-09T15:50:44+09:00","mainEntityOfPage":{"@type":"WebPage","@id":"http://jeha00.github.io/post/network/osi_7_layer/4_layer/"},"publisher":{"@type":"Organization","name":"Jeha DevLog","logo":{"@type":"ImageObject","url":"http://jeha00.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=http://jeha00.github.io/ accesskey=h title="@Jeha00 (Alt + H)">@Jeha00</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></span></div><ul id=menu><li><a href=http://jeha00.github.io/me/ title=About><span>About</span></a></li><li><a href=http://jeha00.github.io/archives/ title=Archive><span>Archive</span></a></li><li><a href=http://jeha00.github.io/categories/ title=Categories><span>Categories</span></a></li><li><a href=http://jeha00.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=http://jeha00.github.io/>Home</a>&nbsp;»&nbsp;<a href=http://jeha00.github.io/post/>Posts</a></div><h1 class=post-title>[TIL]OSI 7 layer: 4계층 전송 계층</h1><div class=post-meta>Network&nbsp;·&nbsp;<span title='2023-12-09 15:50:44 +0900 KST'>December 9, 2023</span></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#%eb%84%a4%ed%8a%b8%ec%9b%8c%ed%81%ac-%ed%95%99%ec%8a%b5-%eb%82%b4%ec%9a%a9-%ec%88%9c%ec%84%9c aria-label="네트워크 학습 내용 순서">네트워크 학습 내용 순서</a></li><li><a href=#1-transport-%ec%a0%84%ec%86%a1-%ea%b3%84%ec%b8%b5-%ea%b0%9c%ec%9a%94 aria-label="1. Transport 전송 계층 개요">1. Transport 전송 계층 개요</a><ul><ul><li><a href=#1-4%ea%b3%84%ec%b8%b5%ec%9d%98-%ec%97%ad%ed%95%a0 aria-label="1) 4계층의 역할">1) 4계층의 역할</a></li><li><a href=#2-4%ea%b3%84%ec%b8%b5%ec%9d%98-%ec%a0%84%ec%86%a1-%eb%b0%a9%ec%8b%9d aria-label="2) 4계층의 전송 방식">2) 4계층의 전송 방식</a></li><li><a href=#3-4%ea%b3%84%ec%b8%b5%ec%9d%98-%ec%ba%a1%ec%8a%90%ed%99%94-%ec%97%ad%ec%ba%a1%ec%8a%90%ed%99%94-%ea%b7%b8%eb%a6%ac%ea%b3%a0-%eb%8d%b0%ec%9d%b4%ed%84%b0-%eb%8b%a8%ec%9c%84 aria-label="3) 4계층의 캡슐화, 역캡슐화 그리고 데이터 단위">3) 4계층의 캡슐화, 역캡슐화 그리고 데이터 단위</a></li></ul></ul></li><li><a href=#2-tcp-segment aria-label="2. TCP segment">2. TCP segment</a></li><li><a href=#3-3-way-handshake--4-way-handshake aria-label="3. 3-way handshake &amp;amp; 4-way handshake">3. 3-way handshake & 4-way handshake</a><ul><li><a href=#31-tcp-flag-code-bit aria-label="3.1 TCP flag (code bit)">3.1 TCP flag (code bit)</a></li><li><a href=#32-3-way-handshake aria-label="3.2 3-way handshake">3.2 3-way handshake</a><ul><li><a href=#1-%ec%97%b0%ea%b2%b0-%ec%9a%94%ec%b2%ad---client----server-with-syn-1 aria-label="1) 연결 요청 - client &amp;ndash;&amp;gt; server with SYN: 1">1) 연결 요청 - client &ndash;> server with SYN: 1</a></li><li><a href=#2-%ed%99%95%ec%9d%b8-%eb%b0%8f-%ec%97%b0%ea%b2%b0-%ec%9a%94%ec%b2%ad---client----server-with-syn-1-ack-1 aria-label="2) 확인 및 연결 요청 - client &amp;lt;&amp;ndash; server with SYN: 1, ACK: 1">2) 확인 및 연결 요청 - client &lt;&ndash; server with SYN: 1, ACK: 1</a></li><li><a href=#3-%ed%99%95%ec%9d%b8---client----server-with-ack-1 aria-label="3) 확인 - client &amp;ndash;&amp;gt; server with ACK: 1">3) 확인 - client &ndash;> server with ACK: 1</a></li></ul></li><li><a href=#33-4-way-handshake aria-label="3.3 4-way handshake">3.3 4-way handshake</a><ul><li><a href=#1-%ec%97%b0%ea%b2%b0-%ec%a2%85%eb%a3%8c---client----server-with-fin-1 aria-label="1) 연결 종료 - client &amp;ndash;&amp;gt; server with FIN: 1">1) 연결 종료 - client &ndash;> server with FIN: 1</a></li><li><a href=#2-%ed%99%95%ec%9d%b8---client----server-with-ack-1 aria-label="2) 확인 - client &amp;lt;&amp;ndash; server with ACK: 1">2) 확인 - client &lt;&ndash; server with ACK: 1</a></li><li><a href=#3-%ec%97%b0%ea%b2%b0-%ec%a2%85%eb%a3%8c---client----server-with-fin-1 aria-label="3) 연결 종료 - client &amp;lt;&amp;ndash; server with FIN: 1">3) 연결 종료 - client &lt;&ndash; server with FIN: 1</a></li><li><a href=#4-%ed%99%95%ec%9d%b8---client----server-with-ack-1 aria-label="4) 확인 - client &amp;ndash;&amp;gt; server with ACK: 1">4) 확인 - client &ndash;> server with ACK: 1</a></li></ul></li></ul></li><li><a href=#3-tcp-%ec%97%90%eb%9f%ac-%ec%a0%9c%ec%96%b4 aria-label="3. TCP 에러 제어">3. TCP 에러 제어</a><ul><li><a href=#%ec%97%90%eb%9f%ac-%ec%a0%9c%ec%96%b4-%ea%b0%9c%ec%9a%94 aria-label="에러 제어 개요">에러 제어 개요</a></li><li><a href=#%ec%97%90%eb%9f%ac-%ec%a0%95%ec%a0%95-stop-and-wait-arq aria-label="에러 정정: Stop-and-Wait ARQ">에러 정정: Stop-and-Wait ARQ</a></li><li><a href=#%ec%97%90%eb%9f%ac-%ec%a0%95%ec%a0%95-go-back-n-arq aria-label="에러 정정: Go-Back-N ARQ">에러 정정: Go-Back-N ARQ</a></li><li><a href=#%ec%97%90%eb%9f%ac-%ec%a0%95%ec%a0%95-selective-repeat-arq aria-label="에러 정정: Selective Repeat ARQ">에러 정정: Selective Repeat ARQ</a></li></ul></li><li><a href=#4-tcp-%ed%9d%90%eb%a6%84-%ec%a0%9c%ec%96%b4tcp-flow-control aria-label="4. TCP 흐름 제어(TCP Flow Control)">4. TCP 흐름 제어(TCP Flow Control)</a><ul><ul><li><a href=#stop-and-wait aria-label=Stop-and-Wait>Stop-and-Wait</a></li><li><a href=#sliding-window aria-label="Sliding window">Sliding window</a></li></ul></ul></li><li><a href=#5-tcp-%ed%98%bc%ec%9e%a1-%ec%a0%9c%ec%96%b4 aria-label="5. TCP 혼잡 제어">5. TCP 혼잡 제어</a></li><li><a href=#6-%ed%8f%ac%ed%8a%b8-%eb%b2%88%ed%98%b8 aria-label="6. 포트 번호">6. 포트 번호</a></li><li><a href=#7-udp aria-label="7. UDP">7. UDP</a></li><li><a href=#reference aria-label=Reference>Reference</a></li></ul></div></details></div><div class=post-content><h1 id=네트워크-학습-내용-순서>네트워크 학습 내용 순서<a hidden class=anchor aria-hidden=true href=#네트워크-학습-내용-순서>#</a></h1><ol><li><a href=https://jeha00.github.io/post/network/osi_7_layer/0_outline/>[TIL]Web Application Basic study: OSI 7 layer outline</a></li><li><a href=https://jeha00.github.io/post/network/osi_7_layer/1_layer/>[TIL] Network OSI 7 layer: 1계층</a></li><li><a href=https://jeha00.github.io/post/network/osi_7_layer/2_layer/>[TIL] Network OSI 7 layer: 2계층</a></li><li><a href=https://jeha00.github.io/post/network/osi_7_layer/3_layer/>[TIL] Network OSI 7 layer: 3계층</a></li></ol><p>이번 장에서는 전송(Transport) 계층인 4계층에 대해 알아보자.</p><p>❗️ 패킷(packet)이란 용어에 대해서<br>패킷이란 용어는 3계층의 데이터 단위임을 학습했다. 하지만 이 &lsquo;패킷&rsquo;이란 용어는 네트워크 전체적으로 데이터를 지칭하는 용어로도 사용되기도 한다. 그래서 이번 4계층 학습에서 언급되는 패킷들은 세그먼트가 맞지만, 3계층에서 IP 패킷으로 캡슐화되기 때문이거나 범용적으로 데이터를 나타내는 용어라고 생각하자.</p><h1 id=1-transport-전송-계층-개요>1. Transport 전송 계층 개요<a hidden class=anchor aria-hidden=true href=#1-transport-전송-계층-개요>#</a></h1><hr><p>3계층은 한 네트워크에서 다른 네트워크로 데이터를 전송하는 과정에 중점을 두고 맞춰져있다. 그러나, 네트워크 환경은 기본적으로 비신뢰성 환경이기 때문에 전송된 패킷이 정상적응로 전달되지 않을 수도 있고, 중간이 패킷이 유실되거나 손실될 수도 있다. 또한, 여러 패킷으로 나눠서 전달될 때 순서가 잘못될 수도 있다.</p><p>이에 대한 해결책으로 4계층은 <strong><em>목적지에 신뢰할 수 있는 데이터를 전송할 수 있는가?</em></strong> 에 초점을 맞춘다. 이에 따라 역할, 전송방식이 정해진다.</p><h3 id=1-4계층의-역할>1) 4계층의 역할<a hidden class=anchor aria-hidden=true href=#1-4계층의-역할>#</a></h3><ul><li>목적지까지 신뢰할 수 있는 데이터를 전송하는 역할</li><li>오류 점검 및 데이터의 목적지가 어떤 애플리케이션인지 식별하는 역할</li></ul><h3 id=2-4계층의-전송-방식>2) 4계층의 전송 방식<a hidden class=anchor aria-hidden=true href=#2-4계층의-전송-방식>#</a></h3><p>위 역할에 따랏 4계층의 전송 방식은 <strong>&lsquo;연결형 통신&rsquo;</strong> 과 <strong>&lsquo;비연결형 통신&rsquo;</strong> 2가지로 나눠진다.</p><ul><li><p>연결형 통신</p><ul><li>신뢰성과 정확성</li><li>연결 필요</li><li>사용되는 프로토콜: TCP (Transmission Control Protocol)</li></ul></li><li><p>비연결형 통신</p><ul><li>효율성: 빠르게</li><li>일방적인 통신 (연결 불필요)</li><li>사용되는 프로토콜: UDP ex) 동영상 스트리핑 서비스</li></ul></li></ul><h3 id=3-4계층의-캡슐화-역캡슐화-그리고-데이터-단위>3) 4계층의 캡슐화, 역캡슐화 그리고 데이터 단위<a hidden class=anchor aria-hidden=true href=#3-4계층의-캡슐화-역캡슐화-그리고-데이터-단위>#</a></h3><p>4계층은 <strong>TCP 헤더</strong> 의 캡슐화, 역캡슐화가 일어나는 계층으로 이 때 데이터 단위는 <strong>segment(세그먼트)</strong> 다.</p><ul><li>TCP header + Application header + User data</li></ul><p>❗️ 다시 한번 언급: 패킷(packet)이란 용어에 대해서<br>패킷이란 용어는 3계층의 데이터 단위임을 학습했다. 하지만 이 &lsquo;패킷&rsquo;이란 용어는 네트워크 전체적으로 데이터를 지칭하는 용어로도 사용되기도 한다. 그래서 이번 4계층 학습에서 언급되는 패킷들은 &lsquo;세그먼트&rsquo;가 맞지만, 3계층에서 IP 패킷으로 캡슐화되기 때문이거나 범용적으로 데이터를 나타내는 용어라고 생각하자.</p><p> </p><h1 id=2-tcp-segment>2. TCP segment<a hidden class=anchor aria-hidden=true href=#2-tcp-segment>#</a></h1><hr><p>TCP segment는 응용 계층의 데이터에서 TCP 헤더를 캡슐화하거나, 네트워크 계층의 패킷에서 IP 헤더를 역캡슐화를 하면 되는 데이터 단위다.</p><p>이 TCP 헤더에는 여러 정보들이 담겨있지만 주요 필드만을 언급하자면 다음과 같다.</p><ul><li>출발지 포트 번호, 목적지 포트 번호</li><li>일련 번호, 확인 응답 번호</li><li>TCP 플래그, 윈도우 크기</li></ul><p>더 자세한 필드는 다음과 같다.</p><p><img loading=lazy src=https://github.com/JeHa00/image/assets/78094972/47c1b9e9-310e-4cc7-85ef-21ce4e11ebe8 alt=image></p><ul><li><strong>출발지 포트 번호 (16 bit), 목적지 포트 번호 (16 bit)</strong></li><li><strong>일련 번호(sequence number)</strong> (32 bit)<ul><li>송신자가 지정하는 순서 번호</li><li>고유한 번호</li></ul></li><li><strong>확인 응답 번호(acknowledgement number)</strong> (32 bit)<ul><li>데이터를 정상적으로 수신했을 시 보내는 번호</li><li>일련 번호에 1을 더한 값이므로, 다음 데이터의 일련 번호라고도 볼 수 있다.</li><li>일련 번호 + 1</li></ul></li><li>헤더 길이(header length) (4 bit)<ul><li>옵션 필드가 가변적이라서 정확히 헤더의 길이를 파악하기 위해 사용</li></ul></li><li>예약 영역 (6 bit)<ul><li>나중에 사용하기 위해 남겨둔 영역</li></ul></li><li><strong>TCP 플래그 (코드 비트)</strong> (6 bit)<ul><li>6개 비트로 구성: SYN, ACK, FIN, URG, PSH, RST</li><li>3 way handshake와 4 way handshake 와 관련</li></ul></li><li><strong>윈도우 크기(window size)</strong> (16 bit)<ul><li>한 번에 전송할 수 있는 데이터의 양</li><li>TCP 흐름 제어와 관련</li></ul></li><li>체크섬(checksum) (16 bit)<ul><li>데이터를 보내는 중에 발생할 수 잇는 에러를 항상 검사하는데, 데이터에 대해 체크섬 방식으로 계산한 결과값을 이 필드에 저장</li></ul></li><li>긴급 포인터(urgent pointer) (16 bit)<ul><li>TCP 플래그의 코드 비트 URG 비트 설정과 함께 사용</li></ul></li><li>TCP 옵션</li></ul><p>❗️ IP 헤더는 포트 번호가 아닌 &lsquo;출발지/목적지 IP 주소&rsquo; 였던 것을 기억하자.</p><p> </p><h1 id=3-3-way-handshake--4-way-handshake>3. 3-way handshake & 4-way handshake<a hidden class=anchor aria-hidden=true href=#3-3-way-handshake--4-way-handshake>#</a></h1><hr><h2 id=31-tcp-flag-code-bit>3.1 TCP flag (code bit)<a hidden class=anchor aria-hidden=true href=#31-tcp-flag-code-bit>#</a></h2><p>위 2개의 handshake 는 <strong><em>TCP 헤더의 TCP flag 코드 비트</em></strong> 와 관련있다.</p><p>TCP의 연결 확립 과정과 연결 종료 과정에서 TCP flag 코드 비트가 중요한 역할을 한다.</p><p>그러면 코드 비트에 대해 자세히 확인해보면 다음과 같이 6 bit가 존재한다.</p><table><thead><tr><th>URG</th><th>ACK</th><th>PSH</th><th>RST</th><th>SYN</th><th>FIN</th></tr></thead><tbody><tr><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td></tr></tbody></table><p>각 1bit를 의미한다. 각 초기 비트 값은 0이며 각 과정에서 활성화되어 1로 바뀌어 전송된다.</p><p>그리고 각 단어는 다음 의미를 가진다.</p><ul><li><p>URG: Urgent</p></li><li><p>ACK: Acknowledgement</p></li><li><p>PSH: Push</p></li><li><p>RST: Reset</p></li><li><p>SYN: Synchronize</p></li><li><p>FIN: Finish</p></li></ul><h2 id=32-3-way-handshake>3.2 3-way handshake<a hidden class=anchor aria-hidden=true href=#32-3-way-handshake>#</a></h2><p>TCP는 연결을 확립하기 위해 3-way handshake 과정을 거친다. 이 때 SYN, ACK 두 비트를 사용한다.</p><p>이 과정의 총 세 단계 순서는 다음과 같다.</p><p>상황: 클라이언트와 서버가 존재하고, 클라이언트가 서버에 &lsquo;세션 연결 확립&rsquo;을 위해 요청을 보내려는 상황</p><h3 id=1-연결-요청---client----server-with-syn-1>1) 연결 요청 - client &ndash;> server with SYN: 1<a hidden class=anchor aria-hidden=true href=#1-연결-요청---client----server-with-syn-1>#</a></h3><p>클라이언트가 서버에게 연결 확립을 요청한다. 이 때 SYN이 1로 활성화된 세그먼트를 서버에 전송한다.</p><table><thead><tr><th>URG</th><th>ACK</th><th>PSH</th><th>RST</th><th>SYN</th><th>FIN</th></tr></thead><tbody><tr><td>0</td><td>0</td><td>0</td><td>0</td><td><strong>1</strong></td><td>0</td></tr></tbody></table><h3 id=2-확인-및-연결-요청---client----server-with-syn-1-ack-1>2) 확인 및 연결 요청 - client &lt;&ndash; server with SYN: 1, ACK: 1<a hidden class=anchor aria-hidden=true href=#2-확인-및-연결-요청---client----server-with-syn-1-ack-1>#</a></h3><p>클라이언트가 보낸 세그먼트를 서버가 확인하면서 서버에서도 연결을 요청하기 위해 SYN과 ACK bit가 1로 활성화된 세그먼트를 클라이언트에게 보낸다.</p><table><thead><tr><th>URG</th><th>ACK</th><th>PSH</th><th>RST</th><th>SYN</th><th>FIN</th></tr></thead><tbody><tr><td>0</td><td><strong>1</strong></td><td>0</td><td>0</td><td><strong>1</strong></td><td>0</td></tr></tbody></table><h3 id=3-확인---client----server-with-ack-1>3) 확인 - client &ndash;> server with ACK: 1<a hidden class=anchor aria-hidden=true href=#3-확인---client----server-with-ack-1>#</a></h3><p>서버가 보낸 세그먼트를 클라이언트가 확인하고, 이에 응답하기 위해 ACK bit가 1로 활성화된 세그먼트를 서버에게 보낸다.</p><table><thead><tr><th>URG</th><th>ACK</th><th>PSH</th><th>RST</th><th>SYN</th><th>FIN</th></tr></thead><tbody><tr><td>0</td><td><strong>1</strong></td><td>0</td><td>0</td><td>0</td><td>0</td></tr></tbody></table><h2 id=33-4-way-handshake>3.3 4-way handshake<a hidden class=anchor aria-hidden=true href=#33-4-way-handshake>#</a></h2><p>TCP는 연결을 종료하기 위해 4-way handshake 과정을 거친다. 이 때 FIN, ACK 두 비트를 사용한다.</p><p>상황: 클라이언트와 서버 간 연결을 종료하기 위해 요청을 보내려는 상황</p><h3 id=1-연결-종료---client----server-with-fin-1>1) 연결 종료 - client &ndash;> server with FIN: 1<a hidden class=anchor aria-hidden=true href=#1-연결-종료---client----server-with-fin-1>#</a></h3><p>클라이언트가 서버에게 연결 종료를 요청한다. 이 때 FIN이 1로 활성화된 세그먼트를 전송한다.</p><table><thead><tr><th>URG</th><th>ACK</th><th>PSH</th><th>RST</th><th>SYN</th><th>FIN</th></tr></thead><tbody><tr><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td><strong>1</strong></td></tr></tbody></table><h3 id=2-확인---client----server-with-ack-1>2) 확인 - client &lt;&ndash; server with ACK: 1<a hidden class=anchor aria-hidden=true href=#2-확인---client----server-with-ack-1>#</a></h3><p>서버는 클라이언트에게 연결 종료에 대한 응답을 하기 위해 ACK이 1로 활성화된 세그먼트를 전송한다.</p><table><thead><tr><th>URG</th><th>ACK</th><th>PSH</th><th>RST</th><th>SYN</th><th>FIN</th></tr></thead><tbody><tr><td>0</td><td><strong>1</strong></td><td>0</td><td>0</td><td>0</td><td>0</td></tr></tbody></table><h3 id=3-연결-종료---client----server-with-fin-1>3) 연결 종료 - client &lt;&ndash; server with FIN: 1<a hidden class=anchor aria-hidden=true href=#3-연결-종료---client----server-with-fin-1>#</a></h3><p>서버도 클라이언트에게 연결 종료를 요청한다. 이 때 FIN이 1로 활성화된 세그먼트를 전송한다.</p><table><thead><tr><th>URG</th><th>ACK</th><th>PSH</th><th>RST</th><th>SYN</th><th>FIN</th></tr></thead><tbody><tr><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td><strong>1</strong></td></tr></tbody></table><h3 id=4-확인---client----server-with-ack-1>4) 확인 - client &ndash;> server with ACK: 1<a hidden class=anchor aria-hidden=true href=#4-확인---client----server-with-ack-1>#</a></h3><p>클라이언트는 서버에게 연결 종료에 대한 응답을 하기 위해 ACK이 1로 활성화된 세그먼트를 전송한다.</p><table><thead><tr><th>URG</th><th>ACK</th><th>PSH</th><th>RST</th><th>SYN</th><th>FIN</th></tr></thead><tbody><tr><td>0</td><td><strong>1</strong></td><td>0</td><td>0</td><td>0</td><td>0</td></tr></tbody></table><p> </p><h1 id=3-tcp-에러-제어>3. TCP 에러 제어<a hidden class=anchor aria-hidden=true href=#3-tcp-에러-제어>#</a></h1><hr><h2 id=에러-제어-개요>에러 제어 개요<a hidden class=anchor aria-hidden=true href=#에러-제어-개요>#</a></h2><p>TCP는 전송된 세그먼트가 손실되거나 순서가 어긋났을 때 혹은 중복되었을 경우, 이에 대한 처리를 수행하는데 그 중 하나의 방법이 <strong><em>TCP 에러 제어</em></strong> 다. 이 제어를 통해 신뢰성 있는 데이터를 전송한다.</p><p>에러 제어는 에러를 검출(detection)한 후, 에러를 정정(correction)하는 과정을 거친다. 에러 검출과 에러 정정 과정에는 다음과 같은 방법들이 존재한다.</p><ul><li>에러 제어<ul><li>에러 검출(detection)<ul><li>CRC (Cyclic Redundancy Check)</li><li>Checksum(체크섬): TCP 헤더의 체크섬 필드가 데이터에 대한 에러를 검사하는 기능이 있어, 세그먼트가 전송되는 도중 에러 발생 유무를 확인</li></ul></li><li>에러 정정(correction): ARQ(Automatic Repeat reQuest) 방식을 사용하며, 이 방식의 종류는 다음과 같다.<ul><li>Stop and Wait ARQ</li><li>Go-Back-N ARQ</li><li>Selective Repeat ARQ</li></ul></li></ul></li></ul><p>그러면 에러 정정 방법들에 대해 자세히 알아보자.</p><h2 id=에러-정정-stop-and-wait-arq>에러 정정: Stop-and-Wait ARQ<a hidden class=anchor aria-hidden=true href=#에러-정정-stop-and-wait-arq>#</a></h2><blockquote><p>매번 전송한 패킷에 대해 확인 응답을 받고 나서 그 다음 패킷을 전송하는 방식이다. 만약 일정 시간 동안 ACK을 받지 못하여 Timeout이 되었을 경우, 해당 패킷부터 재전송한다. 또한, 패킷 간 식별을 위해 0과 1의 패킷 혹은 ACK를 번걸아 가면서 전송한다.</p></blockquote><p>확인 응답을 받을 때까지 멈춰서 기다리는 방식이기 때문에 비효율적이다.</p><p><img loading=lazy src=https://github.com/JeHa00/image/assets/78094972/ad40e201-415e-4d27-a622-61e88c9aef0f alt=image></p><p>위 그림을 기준으로 설명하자면 1, 2, 3번 패킷으로 구분되는 것이 아니라 0, 1, 0, 1번으로 구분된다.</p><h1 id=heading><a hidden class=anchor aria-hidden=true href=#heading>#</a></h1><h2 id=에러-정정-go-back-n-arq>에러 정정: Go-Back-N ARQ<a hidden class=anchor aria-hidden=true href=#에러-정정-go-back-n-arq>#</a></h2><blockquote><p>패킷이 도착하지 않아 타임아웃되었을 시, 이 패킷부터 다시 차례대로 재전송하는 방식이다.</p></blockquote><p><img loading=lazy src=https://github.com/JeHa00/image/assets/78094972/a6481c62-e0b1-4afb-a026-c2a88d2ac89f alt=image></p><p>위 그림을 통해서 구체적인 예시를 들어보자.</p><p>A 에서 패킷 0번, 1번, 2번 패킷을 전송한다. 이중 1번을 제외한 패킷들을 수신했다. 수신한 패킷에 대해 ACK을 보내는데 1번 패킷을 받지 못 했으므로, 그 이후에 2번, 3번 패킷을 B가 받아도 받은 패킷을 폐기한 후, 0번 ACK을 B가 재전송한다. 1번 패킷에 대한 확인 응답 ACK이 도착하지 않아 타임아웃되어 A가 패킷을 재전송할 때 다시 순서대로 1번 패킷, 2번 패킷, 3번 패킷을 보낸다.</p><p>이처럼 뒤로 돌아가서 순서대로 다시 재전송하는 방식을 Go-Back-N 재전송 방식이다.</p><h1 id=heading-1><a hidden class=anchor aria-hidden=true href=#heading-1>#</a></h1><h2 id=에러-정정-selective-repeat-arq>에러 정정: Selective Repeat ARQ<a hidden class=anchor aria-hidden=true href=#에러-정정-selective-repeat-arq>#</a></h2><blockquote><p>패킷이 도착하지 않아 타임아웃되었을 시 수신하지 못한 패킷만을 선택적으로 재전송하는 방식이다.</p></blockquote><p>수신한 패킷에 대해 선택적으로 ACK 전송이 가능하며, 선택적 전송이 가능한 이유는 중간 패킷이 수신되지 못했을 경우 소실된 패킷 이후 패킷을 버퍼에 기록하기 때문이다. 소실된 패킷에 대한 확인 응답이 A에게 도착하지 않아 타임아웃되면 A에서 소실된 패킷이 재전송된다.</p><p>소실된 패킷이 도착되면 소실된 패킷과 그 이후에 보내진 패킷들을 함께 상위계층으로 올린다.</p><p><img loading=lazy src=https://github.com/JeHa00/image/assets/78094972/1c1b3978-0ae2-442e-a9e6-a8eb8107d4a5 alt=image></p><p>위 그림을 기준으로 설명해보자.</p><ul><li>A에서 초기에 0번, 1번, 2번 패킷이 전송된다. B에 정상적으로 도착한 건 1번 패킷을 제외한 나머지다.</li><li>B에서는 수신한 패킷에 대해 선택적 ACK을 전송한다.</li><li>1번 패킷을 받지 못 했으므로, 1번 패킷 이후의 패킷은 버퍼에 저장된다.</li><li>A에서는 이어서 3번, 4번 패킷이 전송된다. B에 정상적으로 도착했고, 이를 버퍼에 저장한다. 그리고, 이에 대해 선택적 ACK인 3번 ACK, 4번 ACK을 전송한다.</li><li>1번 패킷에 대한 확인응답이 A에게 도착하지 않아 타임아웃되면 A에서는 1번 패킷을 재전송한다.</li><li>B에서는 이에 대한 1번 ACK을 전송하여 A는 확인응답을 받는다.</li><li>B는 1번 패킷과 함께 버퍼에 저장된 2번, 3번, 4번 패킷을 상위 계층에 전송한다.</li></ul><p> </p><h1 id=4-tcp-흐름-제어tcp-flow-control>4. TCP 흐름 제어(TCP Flow Control)<a hidden class=anchor aria-hidden=true href=#4-tcp-흐름-제어tcp-flow-control>#</a></h1><hr><p>송수신지의 데이터 처리 능력이 달라서 데이터가 유실될 수가 있는데 이를 방지하는 기법이다.</p><p>흐름 제어 기법에는 두 가지 방법이 있지만, 주로 슬라이딩 윈도우 기법을 사용한다.</p><ul><li>Stop-and-Wait</li><li>슬라이딩 윈도우(Sliding window): 윈도우 광고 기법</li></ul><h3 id=stop-and-wait>Stop-and-Wait<a hidden class=anchor aria-hidden=true href=#stop-and-wait>#</a></h3><p>Stop-and-Wait은 &lsquo;TCP 에러 제어 챕터&rsquo; 에서 설명한 것처럼 모든 패킷에 대해 확인 응답을 받아야만 다음 패킷을 전송하는 방식이기 때문에 비효율적이라는 단점이 있다.</p><h3 id=sliding-window>Sliding window<a hidden class=anchor aria-hidden=true href=#sliding-window>#</a></h3><p>반면 슬라이딩 윈도우는 송수신지에 있는 <strong>슬라이딩 윈도우</strong> 를 활용하는 방식으로 Stop-and-wait 방식과 달리 송신측에서 응답을 받지 않아도 연속적으로 전송할 수 있다. 단지 연속적으로 전송하는 게 아니라 송수신측의 윈도우 크기를 서로 알려주기 때문에 데이터 유실을 방지할 수 있는 방식이다.</p><p>즉 슬라이딩 윈도우 방식은 수신측과 송신측의 윈도우 크기를 서로 알리면서 윈도우 크기가 변한다. 먼저 <strong>윈도우</strong> 에 대해 알아보자면 송수신 각 측에서 만들어진 버퍼의 크기를 말한다.</p><ul><li>송신측 윈도우: Congestion window로, <strong>&lsquo;cwnd&rsquo;</strong> 라고 표기</li><li>수신측 윈도우: Receiver window로 <strong>&lsquo;rwnd&rsquo;</strong> 라고 표기</li></ul><p>그러면 슬라이딩 윈도우 기법을 통한 TCP 흐름 제어를 살펴보자.</p><p><img loading=lazy src=https://github.com/JeHa00/image/assets/78094972/18badb77-355b-44d4-99a1-487cb595fd5a alt=image></p><p>위 이미지와 아래 설명을 함께 보자.</p><p>송수신측의 윈도우 크기 모두 250이라 가정해보자.</p><ul><li>(0 - 250)</li></ul><ol><li><p>송신지(A)에서 100 바이트 데이터를 수신측(B)에 보낸다.</p></li><li><p>B에서는 이 데이터를 받아 버퍼에 저장했기 때문에, 수신측 윈도우 크기는 250에서 &lsquo;150&rsquo;이 된다. 그리고 좌측 윈도우 경계선은 101로 이동된다. (101 - 250)</p></li><li><p>그리고, B에서 확인 응답으로 &lsquo;ACK 101&rsquo; 과 수신측의 현재 윈도우 크기 150을 보낸다.</p></li><li><p>A에서 이 정보를 받아 동일하게 101부터 시작해서 윈도우 크기를 150에 맞추고, 시작 경계선을 101로 맞춘다.</p></li></ol><ul><li>송신지 윈도우의 크기는 수신지 윈도우 크기에 맞춰서 수신측이 받을 수 있도록 크기를 맞춘다.</li></ul><ol start=5><li><p>맞춘 후, A에서 다시 B에게 50 바이트를 전송한다.</p></li><li><p>B에서 50 바이트 데이터를 버퍼에 저장한다. 윈도우 크기는 100으로 줄어들고, 좌측 윈도우 경계선이 151로 이동된다. (151 - 250)</p></li><li><p>하지만 응용 프로세스가 B의 윈도우에 저장된 50 바이트 데이터를 처리하여 윈도우는 (151 - 300) 으로 이동되어 윈도우 크기는 150으로 늘어난다.</p></li><li><p>B에서 A에게 확인 응답 ACK 151 과 window 크기는 150이라는 정보를 전달한다.</p></li><li><p>B에서 보내진 정보를 A가 받아 B 윈도우 크기에 맞춰 A도 수정한다.</p></li></ol><p>위와 같은 작업 방식으로 진행된다.</p><p> </p><h1 id=5-tcp-혼잡-제어>5. TCP 혼잡 제어<a hidden class=anchor aria-hidden=true href=#5-tcp-혼잡-제어>#</a></h1><hr><p> </p><h1 id=6-포트-번호>6. 포트 번호<a hidden class=anchor aria-hidden=true href=#6-포트-번호>#</a></h1><hr><p> </p><h1 id=7-udp>7. UDP<a hidden class=anchor aria-hidden=true href=#7-udp>#</a></h1><hr><p> </p><hr><h1 id=reference>Reference<a hidden class=anchor aria-hidden=true href=#reference>#</a></h1><ul><li><a href=https://learningspoons.com/course/detail/django-backend/>나노디그리 러닝스푼즈: Python & Django backend course</a></li><li><a href=https://www.inflearn.com/course/%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC-%EA%B7%B8%EB%A6%BC-%EC%9D%B4%ED%95%B4/dashboard>네트워크, 그림으로 이해해자</a></li></ul></div><footer class=post-footer><ul class=post-tags><li><a href=http://jeha00.github.io/tags/til/>TIL</a></li><li><a href=http://jeha00.github.io/tags/network/>Network</a></li></ul><nav class=paginav><a class=next href=http://jeha00.github.io/post/ci_cd/github_action/lecture_02/><span class=title>Next Page »</span><br><span>CI/CD를 위한 github action study: Activity type, filters, caching, environment variables and secrets</span></a></nav><div class=share-buttons><a target=_blank rel="noopener noreferrer" aria-label="share [TIL]OSI 7 layer: 4계층 전송 계층 on twitter" href="https://twitter.com/intent/tweet/?text=%5bTIL%5dOSI%207%20layer%3a%204%ea%b3%84%ec%b8%b5%20%ec%a0%84%ec%86%a1%20%ea%b3%84%ec%b8%b5&url=http%3a%2f%2fjeha00.github.io%2fpost%2fnetwork%2fosi_7_layer%2f4_layer%2f&hashtags=TIL%2cNetwork"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM195.519 424.544c135.939.0 210.268-112.643 210.268-210.268.0-3.218.0-6.437-.153-9.502 14.406-10.421 26.973-23.448 36.935-38.314-13.18 5.824-27.433 9.809-42.452 11.648 15.326-9.196 26.973-23.602 32.49-40.92-14.252 8.429-30.038 14.56-46.896 17.931-13.487-14.406-32.644-23.295-53.946-23.295-40.767.0-73.87 33.104-73.87 73.87.0 5.824.613 11.494 1.992 16.858-61.456-3.065-115.862-32.49-152.337-77.241-6.284 10.881-9.962 23.601-9.962 37.088.0 25.594 13.027 48.276 32.95 61.456-12.107-.307-23.448-3.678-33.41-9.196v.92c0 35.862 25.441 65.594 59.311 72.49-6.13 1.686-12.72 2.606-19.464 2.606-4.751.0-9.348-.46-13.946-1.38 9.349 29.426 36.628 50.728 68.965 51.341-25.287 19.771-57.164 31.571-91.8 31.571-5.977.0-11.801-.306-17.625-1.073 32.337 21.15 71.264 33.41 112.95 33.41z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share [TIL]OSI 7 layer: 4계층 전송 계층 on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&url=http%3a%2f%2fjeha00.github.io%2fpost%2fnetwork%2fosi_7_layer%2f4_layer%2f&title=%5bTIL%5dOSI%207%20layer%3a%204%ea%b3%84%ec%b8%b5%20%ec%a0%84%ec%86%a1%20%ea%b3%84%ec%b8%b5&summary=%5bTIL%5dOSI%207%20layer%3a%204%ea%b3%84%ec%b8%b5%20%ec%a0%84%ec%86%a1%20%ea%b3%84%ec%b8%b5&source=http%3a%2f%2fjeha00.github.io%2fpost%2fnetwork%2fosi_7_layer%2f4_layer%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share [TIL]OSI 7 layer: 4계층 전송 계층 on reddit" href="https://reddit.com/submit?url=http%3a%2f%2fjeha00.github.io%2fpost%2fnetwork%2fosi_7_layer%2f4_layer%2f&title=%5bTIL%5dOSI%207%20layer%3a%204%ea%b3%84%ec%b8%b5%20%ec%a0%84%ec%86%a1%20%ea%b3%84%ec%b8%b5"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share [TIL]OSI 7 layer: 4계층 전송 계층 on facebook" href="https://facebook.com/sharer/sharer.php?u=http%3a%2f%2fjeha00.github.io%2fpost%2fnetwork%2fosi_7_layer%2f4_layer%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share [TIL]OSI 7 layer: 4계층 전송 계층 on whatsapp" href="https://api.whatsapp.com/send?text=%5bTIL%5dOSI%207%20layer%3a%204%ea%b3%84%ec%b8%b5%20%ec%a0%84%ec%86%a1%20%ea%b3%84%ec%b8%b5%20-%20http%3a%2f%2fjeha00.github.io%2fpost%2fnetwork%2fosi_7_layer%2f4_layer%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share [TIL]OSI 7 layer: 4계층 전송 계층 on telegram" href="https://telegram.me/share/url?text=%5bTIL%5dOSI%207%20layer%3a%204%ea%b3%84%ec%b8%b5%20%ec%a0%84%ec%86%a1%20%ea%b3%84%ec%b8%b5&url=http%3a%2f%2fjeha00.github.io%2fpost%2fnetwork%2fosi_7_layer%2f4_layer%2f"><svg viewBox="2 2 28 28"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></div></footer></article></main><footer class=footer><span>&copy; 2023 <a href=http://jeha00.github.io/>Jeha DevLog</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerText="copy";function s(){t.innerText="copied!",setTimeout(()=>{t.innerText="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>