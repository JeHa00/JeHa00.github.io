<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>[DB]원티드 프리온보딩 백엔드 챌린지 MySQL: MySQL storage engine의 종류들, Transaction, Database Lock, Isolation Level | Jeha00 DevLog</title><meta name=keywords content="DB"><meta name=description content="MySQL storage engine들의 종류들과 default engine인 InnoDB /  Transaction이란 무엇인지 / Database Lock의 종류에는 어떤 것들이 있고, 왜 필요한지 / Isolation level에 대해 알아본다."><meta name=author content><link rel=canonical href=http://jeha00.github.io/post/db/wanted/lecture_02/><meta name=google-site-verification content="XYZabc"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.min.1e44d58192cbf6d7a4eb649bc43dbc3d4cc432677e5d8adc69b08c34cbe461ac.css integrity="sha256-HkTVgZLL9tek62SbxD28PUzEMmd+XYrcabCMNMvkYaw=" rel="preload stylesheet" as=style><link rel=icon href=http://jeha00.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=http://jeha00.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=http://jeha00.github.io/favicon-32x32.png><link rel=apple-touch-icon href=http://jeha00.github.io/apple-touch-icon.png><link rel=mask-icon href=http://jeha00.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><meta name=generator content="Hugo 0.101.0"><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><script type=application/javascript>var doNotTrack=!1;doNotTrack||(function(e,t,n,s,o,i,a){e.GoogleAnalyticsObject=o,e[o]=e[o]||function(){(e[o].q=e[o].q||[]).push(arguments)},e[o].l=1*new Date,i=t.createElement(n),a=t.getElementsByTagName(n)[0],i.async=1,i.src=s,a.parentNode.insertBefore(i,a)}(window,document,"script","https://www.google-analytics.com/analytics.js","ga"),ga("create","UA-123-45","auto"),ga("send","pageview"))</script><meta property="og:title" content="[DB]원티드 프리온보딩 백엔드 챌린지 MySQL: MySQL storage engine의 종류들, Transaction, Database Lock, Isolation Level"><meta property="og:description" content="MySQL storage engine들의 종류들과 default engine인 InnoDB /  Transaction이란 무엇인지 / Database Lock의 종류에는 어떤 것들이 있고, 왜 필요한지 / Isolation level에 대해 알아본다."><meta property="og:type" content="article"><meta property="og:url" content="http://jeha00.github.io/post/db/wanted/lecture_02/"><meta property="og:image" content="http://jeha00.github.io/47"><meta property="article:section" content="post"><meta property="article:published_time" content="2023-02-15T01:12:29+09:00"><meta property="article:modified_time" content="2023-02-15T01:12:29+09:00"><meta property="og:site_name" content="JeHa00 DevLog"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="http://jeha00.github.io/47"><meta name=twitter:title content="[DB]원티드 프리온보딩 백엔드 챌린지 MySQL: MySQL storage engine의 종류들, Transaction, Database Lock, Isolation Level"><meta name=twitter:description content="MySQL storage engine들의 종류들과 default engine인 InnoDB /  Transaction이란 무엇인지 / Database Lock의 종류에는 어떤 것들이 있고, 왜 필요한지 / Isolation level에 대해 알아본다."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"http://jeha00.github.io/post/"},{"@type":"ListItem","position":2,"name":"[DB]원티드 프리온보딩 백엔드 챌린지 MySQL: MySQL storage engine의 종류들, Transaction, Database Lock, Isolation Level","item":"http://jeha00.github.io/post/db/wanted/lecture_02/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"[DB]원티드 프리온보딩 백엔드 챌린지 MySQL: MySQL storage engine의 종류들, Transaction, Database Lock, Isolation Level","name":"[DB]원티드 프리온보딩 백엔드 챌린지 MySQL: MySQL storage engine의 종류들, Transaction, Database Lock, Isolation Level","description":"MySQL storage engine들의 종류들과 default engine인 InnoDB /  Transaction이란 무엇인지 / Database Lock의 종류에는 어떤 것들이 있고, 왜 필요한지 / Isolation level에 대해 알아본다.","keywords":["DB"],"articleBody":"0. Introduction 원티드 백엔드 챌린지 2월: MySQL ‘잘’ 사용하기 를 듣고 제 언어로 정리한 포스팅입니다.\n해당 챌린지의 목표는 주니어 개발자 및 개발 준비생을 대상으로 하기 때문에, MySQL의 특징을 이해하여 효율적으로 사용하고, MySQL 기본 개념들을 학습하여 기술 면접에 대비하는 게 목적입니다.\n그래서 운영체제의 cache 운용도가 높은 storage engine을 최적화할 때 어떻게 해야하는가 또는 쿼리 효율 개선 같은 내용은 다루지 않습니다.\n해당 포스팅의 주제와 키워드 이번 포스팅의 주제는 [Big Tech가 MySQL을 선택하는 이유] 입니다.\nKeyword: Transaction, Database Lock, Isolation Level\nMySQL installation Mac에서 MySQL 설치는 해당 문서 How to Install MySQL 8 on macOS Using Homebrew를 참고하자.\nMySQL 로그인 root 모드: mysql -u root -p 1. MySQL을 사용하는 BigTech와 이유 MySQL을 사용하는 BigTech Uber, Airbnb, Pinterest, Netflix, Twitter, Amazon, Udemy, Slack\nMySQL을 사용하는 이유 transaction을 요구할 때 에러없이 넣고 싶으면 RDBMS를 사용\n오픈 소스\n2. MySQL storage engine 데이터 읽기/쓰기를 담당하며, 어떤 스토리지 엔진을 사용하느냐에 따라서 MySQL에 데이터를 읽고 쓰는 방법이 다름\n2.1 Engine의 종류 MySQL 엔진은 크게 SQL 엔진과 Storage 엔진으로 나눠진다.\nSQL engine의 역할 query parsing\nORM 사용 시 이 기능을 통해서 SQL 문법으로 바꿔주는 역할 query optimizing\n쿼리를 실행하면 ‘실행계획’이라는 걸 가지고서 DB가 최적화를 스스로 고민 후 실행한다. 그러면 storage engine이 실행된 SQL을 바탕으로 데이터를 가져온다. query 실행\n더 상세한 Engine 종류는 MySQL 설치 및 실행 후 SHOW ENGINES을 입력하면 된다.\n2.2 중요한 Storage engines 위 이미지에 있는 ENGINE을 지금 단계에서는 다 알기보다는 아래 3가지만 알고 있자.\nMyISAM MEMORY InnoDB (제일 중요) 요즘은 innoDB가 default create table을 할 때 별도로 지정해주지 않는다면 default engine이 사용 ❗️ MEMORY ENGINE의 경우, memory에 저장되어 cache로 사용되는데 이 ENGINE을 사용하기보다는 redis를 사용해보자. (이런 게 있다 정도로만 알고 있자.)\nInnoDB의 장점 버퍼링\nread는 foreground thread를, write는 background thread를 사용한다. 그래서 thread pool에 한계가 있어서 모아서 진행해서 효율을 높이는 기능 Foreign key\ntransaction\nInnoDB만 transaction을 지원한다. InnoDB 때문에 MySQL에서도 postgreSQL처럼 transaction이 가능하다. 3. 🔆 Transaction 사용자의 작업셋을 ‘모두 완벽하게 처리’ 하거나 ‘처리하지 못하면 원상태로 복구’ 하여 작업의 완전성을 보장하는 하나의 논리적인 작업 단위\n그러면 MySQL InnoDB가 지원하는 transaction에 대해 눈으로 직접 확인해보자.\n🔆 서버 개발자들은 직접 db에 접근하지 않고 흔히들 ORM을 사용한다. 각 프레임워크에서는 각 ORM별로 트랜젝션을 지원하는 쿼리가 존재하기 때문에 사용해봐야 한다.\n3.1 트랜젝션을 지원하는 스토리지 엔진(InnoDB)와 트랜젝션을 지원하지 않는 스토리지 엔진(MyISAM) 비교 1) Engine이 다른 table 생성하기 엔진 설정이 각각 InnoDB고 MyISAM인 table을 생성해보자.\nSHOW databases 를 사용하여 databases 목록을 확인하고, 사용할 database를 use 을 사용하여 database를 바꾼다.\nENGINE이 MyISAM인 DB\nCREATE TABLE myisam (id INT NOT NULL, PRIMARY KEY(id)) ENGINE=MyISAM; ENGINE이 InnoDB인 DB\nCREATE TABLE innodb (id INT NOT NULL, PRIMARY KEY(id)); default이므로 따로 ENGINE을 입력하지 않아도 된다. 생성된 table 보기: SHOW CREATE TABLE \u003c생성된 table 이름\u003e\n2) 정수 5 data 추가하기 desc ;으로 구조를 출력할 수 있다.\nmyisam에 데이터를 추가한다.\nINSERT INTO myisam (id) VALUES (5); SELECT * FROM myisam 으로 table 데이터를 확인한다. innodb table에 데이터를 추가한다.\nINSERT INTO innodb (id) VALUES (5); SELECT * FROM innodb 으로 table 데이터를 확인한다. 3) 정수 1부터 5까지 data 추가해보기 myisam에 추가: INSERT INTO myisam (id) VALUES (1), (2), (3), (4), (5); 실행 결과: Duplicate entry '5' for key 'myisam.PRIMARY' innodb에 추가: INSERT INTO innodb (id) VALUES (1), (2), (3), (4), (5); 실행 결과: Duplicate entry '5' for key 'innodb.PRIMARY' 4) 실행 결과 확인해보기 myisam 확인해보기: SELECT * FROM myisam\nid 1 2 3 4 5 innodb 확인해보기: SELECT * FROM innodb\nid 5 🔆 innodb는 트랜젝션을 지원하기 때문에 한 가지 작업이라도 에러가 발생되어 처리되지 못하자 원상태 그대로를 유지한다. 이것이 바로 Transaction 이다.\n3.2 어떻게 가능한 걸까? ‘Buffer pool’ 과 ‘Undo log’ 를 사용한다.\nBuffer pool: 일괄적으로 모아서 처리하는 공간 Undo log: error가 발생되면 되돌리기 위해 데이터를 임시로 저장하는 공간 테이블의 데이터를 변경하는 작업을 하기 전에 다음 작업들이 일어난다.\n위에서 정수 1부터 5까지를 추가하는 명령어를 실행했었다.\ndisk에는 id가 5인 값이 저장되어 있는 상태였다. 명령어를 실행하면 Buffer pool에 먼저 id가 1부터 5인 값이 생성된다. Undo log에는 1)번 상태를 기억해두고 있다. 2)번에서 buffer pool에서 생성한 데이터를 하나씩 disk에 추가한다. 4)번 과정에서 error가 발생되면 3)번에서 기억해둔 데이터를 disk로 가져와 복귀시킨다. 3.3 Transaction - states transaction에도 상태(state)가 존재한다.\n3.2 어떻게 가능한 걸까? 에서의 각 과정은 다음과 같이 진행된다.\nActive state -\u003e Partially commited state -\u003e Failed state -\u003e Aborted state -\u003e Terminated state 만약 성공적으로 흘러가면 다음과 같이 진행된다.\nActive state -\u003e Partially committed state -\u003e Commited state -\u003e Terminated state 4. Database Lock 하나의 데이터를 동시에 여러 명이 조작할 수 없도록 데이터를 잠궈서 동시성을 보장하는 기능\n[Lock의 종류: MySQL engine lock vs InnoDB lock]\nSQL 엔진이 제공하는 lock: global lock, table lock, named lock, meta-data lock MySQL의 InnoDB가 제공하는 lock: record lock, Auto increment Lock 등등 위 Lock의 종류들은 다 MySQL이 알아서 Lock을 걸고 풀기 때문에 잘 사용되지 않는다.\nDEAD LOCK 한 곳에서만 자원에 접근이 가능하고, 다른 곳들로부터 자원에 접근하는 걸 막은 걸 ‘DEAD LOCK’이라 한다.\n만약 이 상황에 계속해서 지속되면 좋지 못한 상황이기 때문에 innoDB에서는 이 같은 Lock을 따로 관리리하는 table이 존재한다.\n4.1 글로벌 락(Global lock) 범위가 가장 넓은 lock으로서, 서버 전체에 영향을 미치기 때문에 A 서버에서 global lock을 걸면 B 서버에까지 적용된다.\n잘 사용되지 않는다.\nGlobal lock 걸기: FLUSH TABLES WITH READ LOCK;\nGlobal lock을 해제하기: Global lock을 걸은 서버에서 MySQL과의 연결이 끊겨야 해제\nSELECT를 제외한 모든 쿼리들이 대기상태로 남기 때문에, 쿼리를 입력해도 진행이 되지 않는다.\n서버 전체에 영향을 미치기 때문에 작업 대상이나 테이블이 다르더라도 동일하게 영향 받는다.\ntable이 myisam 상태에서 global lock을 걸면 innoDB에 있는 서버도 락이 걸린다. 4.2 Table Lock 특정 테이블에 대한 lock으로서 read lock과 write lock으로 나눠진다.\nread lock: READ 작업만 가능하도록 잠그는 기능\nLOCK TABLES innodb READ; write lock: WRITE 작업만 가능하도록 잠그는 기능\nLOCK TABLES innodb WRITE; lock을 걸지 않으면 DB를 read 또는 write하기 직전에 data가 바뀔 수 있기 때문이다.\n해당 명령어를 사용할 일은 거의 없다. 그 이유는 특별한 상황이 아니라면 다른 작업에 영향을 미치기 때문이다.\n테이블에 데이터를 변경하는 쿼리를 실행하면 자동으로 lock이 발생한다.\n데이터 추가, 변경 시 lock 설정 데이터 변경 commit 시 lock release InnoDB의 경우에는 DML 쿼리에서는 lock이 작동하지 않과 DDL의 경우에만 영향을 미침 스토리지 엔진의 구조 차이라는 정도만 알아두자. READ LOCK test 한 터미널에서 READ LOCK test 해보기\nREAD LOCK 걸기: LOCK TABLES innodb READ; UPDATE 작업 실행: INSERT INTO innodb (id) VALUES (34); 실행 결과: ERROR 1099 (HY000): Table 'innodb' was locked with a READ lock and can't be updated READ LOCK 풀기: UNLOCK TABLES; UPDATE 작업 실행 완료 두 터미널(A, B)에서 READ LOCK test 해보기\nA terminal에서 innodb에 대해 READ LOCK을 걸어보자. B termianl에서 UPDATE 작업 실행: INSERT INTO innodb (id) values (98); 결과: 쿼리문이 진행되지 않는다. A terminal에서 READ LOCK을 풀어보자: UNLOCK TABLES; 대기되고 있던 UPDATE SQL이 바로 진행된다. WRITE LOCK test 두 터미널(A, B)에서 READ LOCK test 해보기 Temianl A: LOCK TABLES innodb WRITE; 실행 Terminal B: SELECT * FROM innodb; 를 입력하면 실행되지 않고 LOCK에 걸린다. Terminal A: UNLOCK TABLES; 실행 Terminal B: 2)번에 명령어 바로 실행 4.3 Named Lock GET_LOCK()이라는 명령어로 임의의 문자열에 대해 잠금을 설정하는 Lock COMMIT 후 SELECT RELEASE_LOCK(문자열)을 입력하여 Lock이 해제된다. 자주 안사용한다. 여러 클라이언트가 상호 동기화를 처리해야할 때 사용할 수 있다. 많은 레코드에 대해 복잡한 요건으로 변경하는 트랜잭션에 유용하다. ❗️ MySQL에서는 autocommit이란 전역 변수가 참으로 되어 있어서 COMMIT 이 자동적으로 된다. 이를 확인하기 위해서는 SET GLOBAL VARIABLES LIKE 'autocommi';를 입력하면 확인할 수 있고, AUTO COMMIT을 끄고 싶으면 SET GLOBAL autocommit=0;을 입력한다.\nLock test A, B termianl에서 test 진행\nTerminal A: SELECT GET_LOCK('wanted', 30); 30분 동안 wanted 라는 문자열에 대해 사용하는 걸 잠금한다.\n결과: True\nGET_LOCK(‘wanted’, 30) 1 SELECT IS_FREE_LOCK('wanted');: 를 실행하여 LOCK이 자유로운지 확인하면 다음과 같은 결과가 뜬다. 0은 False를 의미하므로 Lock 걸려있다는 상태를 말한다.\nIS_FREE_LOCK(‘wanted’) 0 Terminal B: SELECT GET_LOCK('wanted', 20); 이미 A terminal에서 잠궜기 때문에 위 명령어는 잠겨져 대기하게 된다. Terminal A: SELECT RELEASE_LOCK('wanted');를 실행하면 Lock이 풀리면서 2)번 명령이 실행될 수 있다. 4.4 메타데이터 락 데이터베이스 객체(table, column)의 이름이나 구조를 변경하는 경우에 사용되는 락\n테이블 락처럼 별도의 명령어를 사용할 수는 없고, 테이블을 변경하는 등의 작업을 할 때 자동으로 가져왔다가 release한다.\n이는 다른 락과 달리 명령어가 없어서 직접 보여줄 수 없으니 이런 게 존재하는 것만 알고 있자.\n4.5 레코드 락 입력한 쿼리에 해당되는 record / row를 가져오는 동안 이 record / row에 lock을 거는 것 EXPLAIN SELECT * FROM innodb;: 해당 쿼리를 설명하는 테이블을 가져온다. id select_type table partitions type possible_keys key key_len ref rows filtered Extra 1 SIMPLE innodb NULL index NULL PRIMARY 4 NULL 2 100.00 Using index 여기서 rows column에서 2라고 나와있는데, 위 쿼리로 데이터를 가져오는 동안 2개의 row에 record lock을 거는 것\n만약 이게 8만개라면? 8만개의 row가 record lock에 걸린 것이므로 효율적이지 않다. 그래서 ‘인덱스’를 잘 설계해야 한다.\n4.6 Auto Increment Lock PRIMARY KEY 중복을 방지하고자 table 생성에 입력하는 auto increment에 lock을 거는 것\nrow 추가 시 id 값이 자동적으로 증가하는 설정인 AUTO_INCREMENT에 대해 lock을 거는 것이다.\n만약 row가 1개 밖에 없는 상황에서 여러 클라이언트가 데이터를 추가할 때, id = 2인 row가 여러 개가 생성될 수 있다. 그래서 innoDB가 동시에 데이터를 못 넣어 중복을 방지하고자 사용하는 게 auto increment lock이다.\n매우 빨라서 체감하기 어렵다.\n5. Isolation Level(격리수준) 여러 트랜잭션이 동시에 처리될 때 특정 트랜잭션이 다른 트랜잭션에서 변경하거나 조회하는 데이터를 볼 수 있게 허용할지 말지 결정한다.\n🔆 격리 수준의 종류에는 무엇이 있고, 각 격리 수준은 무엇이며 장단점은 뭔지, 그래서 무엇을 사용하면 좋은지에 대해서만 먼저 알고 있자.\n격리 수준의 종류: 각 격리 수준마다 단점이 존재하는데 이 모든 걸 다 해결하는 방법은 default engine인 innoDB를 사용하는 것 read uncommitted read committed repeatable read: 나머지는 이런 게 있다는 정도로만 알고, 이를 자세히 알자. serializable ❗️ 격리 기본 수준 값을 변경하려고 할 때, 트랜잭션이 진행 중이라 바꿀 수 없다는 Error가 발생했다면 COMMIT을 사용하라. ❗️ autocommit = 1 이어도 start transcation으로 트랜잭션을 명시적으로 시작해주면 commit 명령어를 입력해야 DB에 적용이 된다. ❗️ mysql에서 나갔다가 다시 들어오면 autocommit은 다시 1로 세팅된다.\n5.1 Read uncommitted (dirty read) COMMIT 되지 않은 데이터를 읽을 수 있는 격리 수준으로, 이런 데이터는 변경될 수 있기 때문에 ‘dirty read’라는 문제가 발생된다.\nRead uncommitted란? 거의 사용되지 않음\n트랜잭션의 변경 내용이 commit이나 rollback 여부에 상관 없이 보인다.\n문제점: 데이터 정합성 준수 x 다른 트랜젝션에서 ‘데이터를 업데이트한 시점’을 기준으로 한 트랜젝션에서 조회되는 데이터가 달라진다. 즉, 나의 transaction이 아닌데도 COMMIT 전 데이터를 읽을 수 있다.\n나의 transaction이 진행 중 rollback되어 데이터 업데이트가 취소되어도 취소된 데이터가 남아 있어서 에러가 발생될 수 있다.\n실습 autocommit을 off 시킨다: SET GLOBAL autocommit=0; 결과 확인: SHOW GLOBAL VARIABLES LIKE 'autocommit'; 실제 작업할 때는 건드리지 않는다. 기본 isolation level 값을 A, B terminal에서 모두 변경: SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED; A, B terminal에서 모두 트랜젝션 시작: START TRANSACTION; 변경된 isolation level을 mysql 8.0 부터는 확인할 수 없다. TABLE 새로 생성: CREATE TABLE auto (id INT NOT_NULL AUTO_INCREMENT, name VAR(4), PRIMARY_KEY(id)); A, B terminal에서 모두 트랜젝션 시작: START TRANSACTION A terminal에서 데이터 추가: INSERT INTO auto (name) VALUES ('jeha'); 현재 나의 transaction이므로 추가된 데이터가 보인다. B terminal에서 확인하기: SELECT * FROM auto; 다른 transaction인데 commit되지 않은 추가된 데이터가 보인다. ROLLBACK을 진행하여 TRANSACTION 취소: ROLLBACK; A terminal: SELECT * FROM auto; -\u003e commit을 실행하여 TRANSACTION을 마무리: COMMIT; 취소된 데이터를 확인할 수 없다. A terminal에 트랜젝션 과정 중에 데이터를 추가한 6번을 기준으로, B terminal에서 진행되는 트랜젝션 과정에서 조회되는 데이터가 달라진다.\n한 트랜젝션 과정에서 데이터의 정합성이 보장되지 못하는 문제점이 발생된다. 또한 이로 인해서 여러 문제점이 발생될 것이다.\n5.2 Read committed: Non repeatable read COMMIT된 것만 읽을 수 있는 격리 수준으로 트랜젝션이 완료된 데이터만 다른 트랜잭션에서 조회 가능하다.\nRead committed란? 커밋되기 전에는 undo log에 있는 곳의 데이터를 읽어오므로 추가한 값이 없고, 커밋 후에 불러오면 추가한 값이 존재한다.\nundo log: 뭔가 잘못되면 돌려야돼서 임시로 저장하는 공간 데이터 업데이트 sql을 입력하면 이 sql을 table에 적용하기 전에 undo log에 현 상태를 임시 저장한 후 sql을 적용한다. 그 후 커밋이 안되어있으면 데이터를 가져올 때 undo log에 있는 데이터를 조회한다. 문제점: 데이터 정합성 준수 x 다른 트랜젝션에서 COMMIT을 한 시점을 기준으로 한 트랜젝션에서 조회되는 데이터가 달라진다.\n동일 트랜젝션 과정에서 COMMIT 전후로 가져오는 데이터가 달라지기 때문에 정합성에서 어긋난다.\n만약 핀테크라면 금액이 달라지는 문제이기 때문에 심각하다.\n실습 autocommit을 off 시킨다: SET GLOBAL autocommit=0; 결과 확인: SHOW GLOBAL VARIABLES LIKE 'autocommit'; 실제 작업할 때는 건드리지 않는다. 기본 isolation level 값을 A, B terminal에서 모두 변경: SET TRANSACTION ISOLATION LEVEL READ COMMITTED; 변경된 isolation level을 mysql 8.0 부터는 확인할 수 없다. A, B terminal에서 모두 트랜젝션 시작: START TRANSACTION; 데이터 추가 전 데이터 조회 in A, B terminal: SELECT * FROM auto; A terminal에서 데이터 변경 후 확인: UPDATE auto SET name='kim' WHERE name='lee' -\u003e SELECT * FROM auto; 데이터 변경이 진행된 동일한 트랜젝션이므로 확인할 수 있다. B terminal에서 데이터 조회: SELECT * FROM auto; 변경 전 데이터로 조회된다. A terminal에서 commit 실행: COMMIT; B terminal에서 데이터 조회: SELECT * FROM auto; 변경 후 데이터로 조회된다. B terminal에서 commit 실행: COMMIT; READ UNCOMMITED와의 차이점을 확인했고, 문제점도 확인했다.\n7)번 단계를 기준으로 B terminal에서 transaction이 진행 중인데 조회되는 데이터가 달라졌다. 이 부분이 transaction 진행 중에 데이터의 정합성이 보장되어야하는데 그러지 못하는 문제점이다.\n5.3 🔆 Repeatable read Isolation level의 default 값으로서 InnoDB가 사용하는 것\n반복적으로 읽을 수 있다.\n언두 영역에 백업된 이전 데이터를 이용해서 동일 트랜잭션에서는 같은 내용을 보여줄 수 있도록 함\n문제점: phantom read undo record에는 lock을 걸 수 없어서 같은 트랜잭션에서 조회 가능 왔다갔다 해서 phantom read(유령)이라고 함 해결책 InnoDB에서는 undo log를 transaction-id을 기준으로 버전관리를 하여, 해당 transaction-id가 끝날 때까지 보관하기 때문에 phantom read가 문제가 되지 않는다.\n그래서 innoDB를 default engine으로 계속해서 사용한다.\n실습 autocommit을 off 시킨다: SET GLOBAL autocommit=0; 결과 확인: SHOW GLOBAL VARIABLES LIKE 'autocommit'; 실제 작업할 때는 건드리지 않는다. 기본 isolation level 값을 A, B terminal에서 모두 변경: SET TRANSACTION ISOLATION LEVEL REPEATABLE READ; 변경된 isolation level을 mysql 8.0 부터는 확인할 수 없다. A, B terminal에서 모두 트랜젝션 시작: START TRANSACTION; 데이터 추가 전 데이터 조회 in A, B terminal: SELECT * FROM auto; A terminal에서 데이터 변경: UPDATE auto SET name='lee' WHERE name='kim'; B terminal에서 데이터 조회: 4번과 동일한 데이터가 조회된다. read uncommited라면 5번을 기준으로 B terminal에서 조회되는 데이터가 달라지만, 그렇지 않았다. A terminal에서 commit: COMMIT; B terminal에서 데이터 조회: 4번과 동일한 데이터가 조회된다. read commited라면 7번을 기준으로 B terminal에서 조회되는 데이터가 달라지만, 그렇지 않았다. B terminal에서 트랜젝션 종료 후 데이터 조회: ROLLBACK; -\u003e SELECT * FROM auto; 5번에서 추가된 데이터를 확인할 수 있다. 한 TRANSACTION 동안 조회되는 데이터가 정합성을 준수하는 걸 확인했다.\n5.4 Serializable 위에 여러 read의 문제점을 해결하는 방법으로, 하나의 transaction에서 접근한 record에 lock을 걸어 다른 transaction이 동일한 데이터 접근할 경우 이를 막아 transaction 간의 완전한 격리를 이루는 기능\n문제점 read도 lock을 획득해야만 가능하다. 이 전 isolation level에서는 read에 lock을 걸면 write만 할 수 없고, write에 lock을 걸면 read만 할 수 없었다. 하지만, read에 lock을 걸면 write나 update, delete 등을 실행할 수 없다. 그래서 시간이 많이 걸려 효율적이지 않아 사용하지 않는다. 해결책: default인 innodb 사용하기 InnoDB에서 repeatable read를 사용하면 serializable은 불필요하다.\n6. 알아두면 좋은 명령어 SHOW CREATE TABLE 테이블이 어떻게 생성되었는지를 보여준다.\nORM으로 생성하면 실제 SQL에서 테이블을 어떻게 생성하는지 알기 어렵기 때문에 도움된다.\n특히 회사에 갔을 때 기존에 생성된 테이블들이 어떤식으로 만들어졌는지 궁금하다면?!? 매우 유용하다.\nORM으로 테이블을 생성했을 때 본인의 의도와 다르다면 추가 학습이 필요하다.\ncharset 어떤 character(문자열)의 데이터를 저장할지\ncollate 저장된 데이터를 어떤식으로 비교, 정렬 할지\n간단한 테이블에서는 문제가 되지 않는다 Reference 원티드 백엔드 챌린지 2월: MySQL ‘잘’ 사용하기 [백엔드 5차] 김유정 — 2023.03.03. 오후 5:51 첫 번째 수업때 NoSQL과 RDBMS의 차이에 대해 설명하시면서 RDBMS는 수평적 확장이 어려운 이유를 예를 들어서 설명해주셨던 것 같은데, 잘 기억이 안나네요…혹시 RDBMS가 수평적 확장이 어려운 이유에 대해서 설명해주실 수 있는 분 있을까요? 여러 글을 읽어봐도 잘 와닿지 않아서요.. 네네 — 2023.03.03. 오후 6:03 ㅇ RDBMS는 관계형이라서 그렇습니다. RDBMS는 스토리지의 효율적인 사용 등의 이유로 불필요한 데이터 중복을 줄이는데, 중복을 줄이는 방법으로 테이블간에 컬럼을통한(제약조건) 관계 형성에 있습니다. 그래서 RDBMS에서는 모델링이 중요하다고 하구요. 회사데이터로 예를들면 RDBMS에서는 사원 테이블, 부서테이블, 직무테이블 세개를 두고 사원번호 등을 통해서 세개 테이블을 조인해서 어떤 사원이 어떤 부서에 어떤 직무를 하는지 조회가 가능한 반면에 nosql에서는 사원-부서-직무 이렇게 한 객체 데이터를 통으로 저장을 합니다 따라서 nosql은 각 객체를 분류하는 기준(ex 남사원 여사원)으로 db를 수평적으로 2개로 확장해도 전혀 지장이 없지만 RDBMS 의 경우 위에 말씀드린 세개 테이블을 전부 기준에 맞게 분류하여 나누어서 확장을 해야하니 더 어렵습니다.\n","wordCount":"2562","inLanguage":"en","datePublished":"2023-02-15T01:12:29+09:00","dateModified":"2023-02-15T01:12:29+09:00","mainEntityOfPage":{"@type":"WebPage","@id":"http://jeha00.github.io/post/db/wanted/lecture_02/"},"publisher":{"@type":"Organization","name":"Jeha00 DevLog","logo":{"@type":"ImageObject","url":"http://jeha00.github.io/favicon.ico"}}}</script></head><body class=dark id=top><script>localStorage.getItem("pref-theme")==="light"&&document.body.classList.remove("dark")</script><header class=header><nav class=nav><div class=logo><a href=http://jeha00.github.io/ accesskey=h title="Jeha00 (Alt + H)">Jeha00</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></span></div><ul id=menu><li><a href=http://jeha00.github.io/me/ title=About><span>About</span></a></li><li><a href=http://jeha00.github.io/archives/ title=Archive><span>Archive</span></a></li><li><a href=http://jeha00.github.io/categories/ title=Categories><span>Categories</span></a></li><li><a href=http://jeha00.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=http://jeha00.github.io/>Home</a>&nbsp;»&nbsp;<a href=http://jeha00.github.io/post/>Posts</a></div><h1 class=post-title>[DB]원티드 프리온보딩 백엔드 챌린지 MySQL: MySQL storage engine의 종류들, Transaction, Database Lock, Isolation Level</h1><div class=post-meta><span title='2023-02-15 01:12:29 +0900 KST'>February 15, 2023</span>&nbsp;|&nbsp;<a href=https://github.com/JeHa00/blog/content/post/DB/WANTED/lecture_02.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#0-introduction aria-label="0. Introduction">0. Introduction</a><ul><ul><li><a href=#%ed%95%b4%eb%8b%b9-%ed%8f%ac%ec%8a%a4%ed%8c%85%ec%9d%98-%ec%a3%bc%ec%a0%9c%ec%99%80-%ed%82%a4%ec%9b%8c%eb%93%9c aria-label="해당 포스팅의 주제와 키워드">해당 포스팅의 주제와 키워드</a></li><li><a href=#mysql-installation aria-label="MySQL installation">MySQL installation</a></li><li><a href=#mysql-%eb%a1%9c%ea%b7%b8%ec%9d%b8 aria-label="MySQL 로그인">MySQL 로그인</a></li></ul></ul></li><li><a href=#1-mysql%ec%9d%84-%ec%82%ac%ec%9a%a9%ed%95%98%eb%8a%94-bigtech%ec%99%80-%ec%9d%b4%ec%9c%a0 aria-label="1. MySQL을 사용하는 BigTech와 이유">1. MySQL을 사용하는 BigTech와 이유</a><ul><ul><li><a href=#mysql%ec%9d%84-%ec%82%ac%ec%9a%a9%ed%95%98%eb%8a%94-bigtech aria-label="MySQL을 사용하는 BigTech">MySQL을 사용하는 BigTech</a></li><li><a href=#mysql%ec%9d%84-%ec%82%ac%ec%9a%a9%ed%95%98%eb%8a%94-%ec%9d%b4%ec%9c%a0 aria-label="MySQL을 사용하는 이유">MySQL을 사용하는 이유</a></li></ul></ul></li><li><a href=#2-mysql-storage-engine aria-label="2. MySQL storage engine">2. MySQL storage engine</a><ul><li><a href=#21-engine%ec%9d%98-%ec%a2%85%eb%a5%98 aria-label="2.1 Engine의 종류">2.1 Engine의 종류</a><ul><li><a href=#sql-engine%ec%9d%98-%ec%97%ad%ed%95%a0 aria-label="SQL engine의 역할">SQL engine의 역할</a></li></ul></li><li><a href=#22-%ec%a4%91%ec%9a%94%ed%95%9c-storage-engines aria-label="2.2 중요한 Storage engines">2.2 중요한 Storage engines</a><ul><li><a href=#innodb%ec%9d%98-%ec%9e%a5%ec%a0%90 aria-label="InnoDB의 장점">InnoDB의 장점</a></li></ul></li></ul></li><li><a href=#3--transaction aria-label="3. 🔆 Transaction">3. 🔆 Transaction</a><ul><li><a href=#31-%ed%8a%b8%eb%9e%9c%ec%a0%9d%ec%85%98%ec%9d%84-%ec%a7%80%ec%9b%90%ed%95%98%eb%8a%94-%ec%8a%a4%ed%86%a0%eb%a6%ac%ec%a7%80-%ec%97%94%ec%a7%84innodb%ec%99%80-%ed%8a%b8%eb%9e%9c%ec%a0%9d%ec%85%98%ec%9d%84-%ec%a7%80%ec%9b%90%ed%95%98%ec%a7%80-%ec%95%8a%eb%8a%94-%ec%8a%a4%ed%86%a0%eb%a6%ac%ec%a7%80-%ec%97%94%ec%a7%84myisam-%eb%b9%84%ea%b5%90 aria-label="3.1 트랜젝션을 지원하는 스토리지 엔진(InnoDB)와 트랜젝션을 지원하지 않는 스토리지 엔진(MyISAM) 비교">3.1 트랜젝션을 지원하는 스토리지 엔진(InnoDB)와 트랜젝션을 지원하지 않는 스토리지 엔진(MyISAM) 비교</a><ul><li><a href=#1-engine%ec%9d%b4-%eb%8b%a4%eb%a5%b8-table-%ec%83%9d%ec%84%b1%ed%95%98%ea%b8%b0 aria-label="1) Engine이 다른 table 생성하기">1) Engine이 다른 table 생성하기</a></li><li><a href=#2-%ec%a0%95%ec%88%98-5-data-%ec%b6%94%ea%b0%80%ed%95%98%ea%b8%b0 aria-label="2) 정수 5 data 추가하기">2) 정수 5 data 추가하기</a></li><li><a href=#3-%ec%a0%95%ec%88%98-1%eb%b6%80%ed%84%b0-5%ea%b9%8c%ec%a7%80-data-%ec%b6%94%ea%b0%80%ed%95%b4%eb%b3%b4%ea%b8%b0 aria-label="3) 정수 1부터 5까지 data 추가해보기">3) 정수 1부터 5까지 data 추가해보기</a></li><li><a href=#4-%ec%8b%a4%ed%96%89-%ea%b2%b0%ea%b3%bc-%ed%99%95%ec%9d%b8%ed%95%b4%eb%b3%b4%ea%b8%b0 aria-label="4) 실행 결과 확인해보기">4) 실행 결과 확인해보기</a></li></ul></li><li><a href=#32-%ec%96%b4%eb%96%bb%ea%b2%8c-%ea%b0%80%eb%8a%a5%ed%95%9c-%ea%b1%b8%ea%b9%8c aria-label="3.2 어떻게 가능한 걸까?">3.2 어떻게 가능한 걸까?</a></li><li><a href=#33-transaction---states aria-label="3.3 Transaction - states">3.3 Transaction - states</a></li></ul></li><li><a href=#4-database-lock aria-label="4. Database Lock">4. Database Lock</a><ul><ul><li><a href=#dead-lock aria-label="DEAD LOCK">DEAD LOCK</a></li></ul><li><a href=#41-%ea%b8%80%eb%a1%9c%eb%b2%8c-%eb%9d%bdglobal-lock aria-label="4.1 글로벌 락(Global lock)">4.1 글로벌 락(Global lock)</a></li><li><a href=#42-table-lock aria-label="4.2 Table Lock">4.2 Table Lock</a><ul><li><a href=#read-lock-test aria-label="READ LOCK test">READ LOCK test</a></li><li><a href=#write-lock-test aria-label="WRITE LOCK test">WRITE LOCK test</a></li></ul></li><li><a href=#43-named-lock aria-label="4.3 Named Lock">4.3 Named Lock</a><ul><li><a href=#lock-test aria-label="Lock test">Lock test</a></li></ul></li><li><a href=#44-%eb%a9%94%ed%83%80%eb%8d%b0%ec%9d%b4%ed%84%b0-%eb%9d%bd aria-label="4.4 메타데이터 락">4.4 메타데이터 락</a></li><li><a href=#45-%eb%a0%88%ec%bd%94%eb%93%9c-%eb%9d%bd aria-label="4.5 레코드 락">4.5 레코드 락</a></li><li><a href=#46-auto-increment-lock aria-label="4.6 Auto Increment Lock">4.6 Auto Increment Lock</a></li></ul></li><li><a href=#5-isolation-level%ea%b2%a9%eb%a6%ac%ec%88%98%ec%a4%80 aria-label="5. Isolation Level(격리수준)">5. Isolation Level(격리수준)</a><ul><li><a href=#51-read-uncommitted-dirty-read aria-label="5.1 Read uncommitted (dirty read)">5.1 Read uncommitted (dirty read)</a><ul><li><a href=#read-uncommitted%eb%9e%80 aria-label="Read uncommitted란?">Read uncommitted란?</a></li><li><a href=#%eb%ac%b8%ec%a0%9c%ec%a0%90-%eb%8d%b0%ec%9d%b4%ed%84%b0-%ec%a0%95%ed%95%a9%ec%84%b1-%ec%a4%80%ec%88%98-x aria-label="문제점: 데이터 정합성 준수 x">문제점: 데이터 정합성 준수 x</a></li><li><a href=#%ec%8b%a4%ec%8a%b5 aria-label=실습>실습</a></li></ul></li><li><a href=#52-read-committed-non-repeatable-read aria-label="5.2 Read committed: Non repeatable read">5.2 Read committed: Non repeatable read</a><ul><li><a href=#read-committed%eb%9e%80 aria-label="Read committed란?">Read committed란?</a></li><li><a href=#%eb%ac%b8%ec%a0%9c%ec%a0%90-%eb%8d%b0%ec%9d%b4%ed%84%b0-%ec%a0%95%ed%95%a9%ec%84%b1-%ec%a4%80%ec%88%98-x-1 aria-label="문제점: 데이터 정합성 준수 x">문제점: 데이터 정합성 준수 x</a></li><li><a href=#%ec%8b%a4%ec%8a%b5-1 aria-label=실습>실습</a></li></ul></li><li><a href=#53--repeatable-read aria-label="5.3 🔆 Repeatable read">5.3 🔆 Repeatable read</a><ul><li><a href=#%eb%ac%b8%ec%a0%9c%ec%a0%90-phantom-read aria-label="문제점: phantom read">문제점: phantom read</a></li><li><a href=#%ed%95%b4%ea%b2%b0%ec%b1%85 aria-label=해결책>해결책</a></li><li><a href=#%ec%8b%a4%ec%8a%b5-2 aria-label=실습>실습</a></li></ul></li><li><a href=#54-serializable aria-label="5.4 Serializable">5.4 Serializable</a><ul><li><a href=#%eb%ac%b8%ec%a0%9c%ec%a0%90 aria-label=문제점>문제점</a></li><li><a href=#%ed%95%b4%ea%b2%b0%ec%b1%85-default%ec%9d%b8-innodb-%ec%82%ac%ec%9a%a9%ed%95%98%ea%b8%b0 aria-label="해결책: default인 innodb 사용하기">해결책: default인 innodb 사용하기</a></li></ul></li></ul></li><li><a href=#6-%ec%95%8c%ec%95%84%eb%91%90%eb%a9%b4-%ec%a2%8b%ec%9d%80-%eb%aa%85%eb%a0%b9%ec%96%b4 aria-label="6. 알아두면 좋은 명령어">6. 알아두면 좋은 명령어</a><ul><ul><li><a href=#show-create-table aria-label="SHOW CREATE TABLE">SHOW CREATE TABLE</a></li><li><a href=#charset aria-label=charset>charset</a></li><li><a href=#collate aria-label=collate>collate</a></li></ul></ul></li><li><a href=#reference aria-label=Reference>Reference</a></li></ul></div></details></div><div class=post-content><h1 id=0-introduction>0. Introduction<a hidden class=anchor aria-hidden=true href=#0-introduction>#</a></h1><ul><li><p><a href=https://www.wanted.co.kr/events/pre_challenge_be_4>원티드 백엔드 챌린지 2월: MySQL &lsquo;잘&rsquo; 사용하기</a> 를 듣고 제 언어로 정리한 포스팅입니다.</p></li><li><p>해당 챌린지의 목표는 주니어 개발자 및 개발 준비생을 대상으로 하기 때문에, MySQL의 특징을 이해하여 효율적으로 사용하고, MySQL 기본 개념들을 학습하여 기술 면접에 대비하는 게 목적입니다.</p></li><li><p>그래서 운영체제의 cache 운용도가 높은 storage engine을 최적화할 때 어떻게 해야하는가 또는 쿼리 효율 개선 같은 내용은 다루지 않습니다.</p></li></ul><h3 id=해당-포스팅의-주제와-키워드>해당 포스팅의 주제와 키워드<a hidden class=anchor aria-hidden=true href=#해당-포스팅의-주제와-키워드>#</a></h3><ul><li><p>이번 포스팅의 주제는 <strong>[Big Tech가 MySQL을 선택하는 이유]</strong> 입니다.</p></li><li><p>Keyword: Transaction, Database Lock, Isolation Level</p></li></ul><h3 id=mysql-installation>MySQL installation<a hidden class=anchor aria-hidden=true href=#mysql-installation>#</a></h3><p>Mac에서 MySQL 설치는 해당 문서 <a href=https://hackernoon.com/how-to-install-mysql-8-on-macos-using-homebrew>How to Install MySQL 8 on macOS Using Homebrew</a>를 참고하자.</p><h3 id=mysql-로그인>MySQL 로그인<a hidden class=anchor aria-hidden=true href=#mysql-로그인>#</a></h3><ul><li>root 모드: <code>mysql -u root -p</code></li></ul><p> </p><hr><h1 id=1-mysql을-사용하는-bigtech와-이유>1. MySQL을 사용하는 BigTech와 이유<a hidden class=anchor aria-hidden=true href=#1-mysql을-사용하는-bigtech와-이유>#</a></h1><h3 id=mysql을-사용하는-bigtech>MySQL을 사용하는 BigTech<a hidden class=anchor aria-hidden=true href=#mysql을-사용하는-bigtech>#</a></h3><p>Uber, Airbnb, Pinterest, Netflix, Twitter, Amazon, Udemy, Slack</p><h3 id=mysql을-사용하는-이유>MySQL을 사용하는 이유<a hidden class=anchor aria-hidden=true href=#mysql을-사용하는-이유>#</a></h3><ul><li><p>transaction을 요구할 때 에러없이 넣고 싶으면 RDBMS를 사용</p></li><li><p>오픈 소스</p></li></ul><p> </p><hr><h1 id=2-mysql-storage-engine>2. MySQL storage engine<a hidden class=anchor aria-hidden=true href=#2-mysql-storage-engine>#</a></h1><blockquote><p><strong><em>데이터 읽기/쓰기를 담당하며, 어떤 스토리지 엔진을 사용하느냐에 따라서 MySQL에 데이터를 읽고 쓰는 방법이 다름</em></strong></p></blockquote><h2 id=21-engine의-종류>2.1 Engine의 종류<a hidden class=anchor aria-hidden=true href=#21-engine의-종류>#</a></h2><p>MySQL 엔진은 크게 SQL 엔진과 Storage 엔진으로 나눠진다.</p><h3 id=sql-engine의-역할>SQL engine의 역할<a hidden class=anchor aria-hidden=true href=#sql-engine의-역할>#</a></h3><ul><li><p>query parsing</p><ul><li>ORM 사용 시 이 기능을 통해서 SQL 문법으로 바꿔주는 역할</li></ul></li><li><p>query optimizing</p><ul><li>쿼리를 실행하면 &lsquo;실행계획&rsquo;이라는 걸 가지고서 DB가 최적화를 스스로 고민 후 실행한다. 그러면 storage engine이 실행된 SQL을 바탕으로 데이터를 가져온다.</li></ul></li><li><p>query 실행</p></li></ul><p>더 상세한 Engine 종류는 MySQL 설치 및 실행 후 <code>SHOW ENGINES</code>을 입력하면 된다.</p><p><img loading=lazy src=https://user-images.githubusercontent.com/78094972/218622985-74284cbc-43ac-430a-99fd-cbbd5ad03883.png alt=image></p><p> </p><h2 id=22-중요한-storage-engines>2.2 중요한 Storage engines<a hidden class=anchor aria-hidden=true href=#22-중요한-storage-engines>#</a></h2><p>위 이미지에 있는 ENGINE을 지금 단계에서는 다 알기보다는 아래 3가지만 알고 있자.</p><ul><li>MyISAM</li><li>MEMORY</li><li><strong>InnoDB (제일 중요)</strong><ul><li>요즘은 innoDB가 default</li><li>create table을 할 때 별도로 지정해주지 않는다면 default engine이 사용</li></ul></li></ul><p>❗️ MEMORY ENGINE의 경우, memory에 저장되어 cache로 사용되는데 이 ENGINE을 사용하기보다는 redis를 사용해보자. (이런 게 있다 정도로만 알고 있자.)</p><h3 id=innodb의-장점>InnoDB의 장점<a hidden class=anchor aria-hidden=true href=#innodb의-장점>#</a></h3><ul><li><p>버퍼링</p><ul><li>read는 foreground thread를, write는 background thread를 사용한다. 그래서 thread pool에 한계가 있어서 모아서 진행해서 효율을 높이는 기능</li></ul></li><li><p>Foreign key</p></li><li><p>transaction</p><ul><li>InnoDB만 transaction을 지원한다.</li><li>InnoDB 때문에 MySQL에서도 postgreSQL처럼 transaction이 가능하다.</li></ul></li></ul><p> </p><hr><h1 id=3--transaction>3. 🔆 Transaction<a hidden class=anchor aria-hidden=true href=#3--transaction>#</a></h1><blockquote><p><strong><em>사용자의 작업셋을 &lsquo;모두 완벽하게 처리&rsquo; 하거나 &lsquo;처리하지 못하면 원상태로 복구&rsquo; 하여 작업의 완전성을 보장하는 하나의 논리적인 작업 단위</em></strong></p></blockquote><p>그러면 MySQL InnoDB가 지원하는 transaction에 대해 눈으로 직접 확인해보자.</p><p>🔆 서버 개발자들은 직접 db에 접근하지 않고 흔히들 ORM을 사용한다. 각 프레임워크에서는 각 ORM별로 트랜젝션을 지원하는 쿼리가 존재하기 때문에 사용해봐야 한다.</p><h2 id=31-트랜젝션을-지원하는-스토리지-엔진innodb와-트랜젝션을-지원하지-않는-스토리지-엔진myisam-비교>3.1 트랜젝션을 지원하는 스토리지 엔진(InnoDB)와 트랜젝션을 지원하지 않는 스토리지 엔진(MyISAM) 비교<a hidden class=anchor aria-hidden=true href=#31-트랜젝션을-지원하는-스토리지-엔진innodb와-트랜젝션을-지원하지-않는-스토리지-엔진myisam-비교>#</a></h2><h3 id=1-engine이-다른-table-생성하기>1) Engine이 다른 table 생성하기<a hidden class=anchor aria-hidden=true href=#1-engine이-다른-table-생성하기>#</a></h3><p>엔진 설정이 각각 InnoDB고 MyISAM인 table을 생성해보자.</p><ul><li><p><code>SHOW databases</code> 를 사용하여 databases 목록을 확인하고, 사용할 database를 <code>use &lt;database name></code>을 사용하여 database를 바꾼다.</p></li><li><p>ENGINE이 MyISAM인 DB</p><ul><li><code>CREATE TABLE myisam (id INT NOT NULL, PRIMARY KEY(id)) ENGINE=MyISAM;</code></li></ul></li><li><p>ENGINE이 InnoDB인 DB</p><ul><li><code>CREATE TABLE innodb (id INT NOT NULL, PRIMARY KEY(id));</code></li><li>default이므로 따로 ENGINE을 입력하지 않아도 된다.</li></ul></li><li><p>생성된 table 보기: <code>SHOW CREATE TABLE &lt;생성된 table 이름></code></p></li></ul><h3 id=2-정수-5-data-추가하기>2) 정수 5 data 추가하기<a hidden class=anchor aria-hidden=true href=#2-정수-5-data-추가하기>#</a></h3><p><code>desc &lt;table name>;</code>으로 구조를 출력할 수 있다.</p><ul><li><p>myisam에 데이터를 추가한다.</p><ul><li><code>INSERT INTO myisam (id) VALUES (5);</code></li><li><code>SELECT * FROM myisam</code> 으로 table 데이터를 확인한다.</li></ul></li><li><p>innodb table에 데이터를 추가한다.</p><ul><li><code>INSERT INTO innodb (id) VALUES (5);</code></li><li><code>SELECT * FROM innodb</code> 으로 table 데이터를 확인한다.</li></ul></li></ul><h3 id=3-정수-1부터-5까지-data-추가해보기>3) 정수 1부터 5까지 data 추가해보기<a hidden class=anchor aria-hidden=true href=#3-정수-1부터-5까지-data-추가해보기>#</a></h3><ul><li>myisam에 추가: <code>INSERT INTO myisam (id) VALUES (1), (2), (3), (4), (5);</code><ul><li>실행 결과: <code>Duplicate entry '5' for key 'myisam.PRIMARY'</code></li></ul></li><li>innodb에 추가: <code>INSERT INTO innodb (id) VALUES (1), (2), (3), (4), (5);</code><ul><li>실행 결과: <code>Duplicate entry '5' for key 'innodb.PRIMARY'</code></li></ul></li></ul><h3 id=4-실행-결과-확인해보기>4) 실행 결과 확인해보기<a hidden class=anchor aria-hidden=true href=#4-실행-결과-확인해보기>#</a></h3><ul><li><p>myisam 확인해보기: <code>SELECT * FROM myisam</code></p><table><thead><tr><th>id</th></tr></thead><tbody><tr><td>1</td></tr><tr><td>2</td></tr><tr><td>3</td></tr><tr><td>4</td></tr><tr><td>5</td></tr></tbody></table></li><li><p>innodb 확인해보기: <code>SELECT * FROM innodb</code></p><table><thead><tr><th>id</th></tr></thead><tbody><tr><td>5</td></tr></tbody></table></li><li><p>🔆 innodb는 트랜젝션을 지원하기 때문에 한 가지 작업이라도 에러가 발생되어 처리되지 못하자 원상태 그대로를 유지한다. 이것이 바로 <strong>Transaction</strong> 이다.</p></li></ul><p> </p><h2 id=32-어떻게-가능한-걸까>3.2 어떻게 가능한 걸까?<a hidden class=anchor aria-hidden=true href=#32-어떻게-가능한-걸까>#</a></h2><blockquote><p><strong><em>&lsquo;Buffer pool&rsquo; 과 &lsquo;Undo log&rsquo; 를 사용한다.</em></strong></p></blockquote><ul><li>Buffer pool: 일괄적으로 모아서 처리하는 공간</li><li>Undo log: error가 발생되면 되돌리기 위해 데이터를 임시로 저장하는 공간</li></ul><p>테이블의 데이터를 변경하는 작업을 하기 전에 다음 작업들이 일어난다.</p><p>위에서 정수 1부터 5까지를 추가하는 명령어를 실행했었다.</p><ol><li>disk에는 id가 5인 값이 저장되어 있는 상태였다.</li><li>명령어를 실행하면 Buffer pool에 먼저 id가 1부터 5인 값이 생성된다.</li><li>Undo log에는 1)번 상태를 기억해두고 있다.</li><li>2)번에서 buffer pool에서 생성한 데이터를 하나씩 disk에 추가한다.</li><li>4)번 과정에서 error가 발생되면 3)번에서 기억해둔 데이터를 disk로 가져와 복귀시킨다.</li></ol><p> </p><h2 id=33-transaction---states>3.3 Transaction - states<a hidden class=anchor aria-hidden=true href=#33-transaction---states>#</a></h2><p><img loading=lazy src=https://user-images.githubusercontent.com/78094972/218648184-de64f4cd-4aa5-4376-90fb-db39359898e2.png alt=image></p><p>transaction에도 상태(state)가 존재한다.</p><p><a href=#32-%EC%96%B4%EB%96%BB%EA%B2%8C-%EA%B0%80%EB%8A%A5%ED%95%9C-%EA%B1%B8%EA%B9%8C>3.2 어떻게 가능한 걸까?</a> 에서의 각 과정은 다음과 같이 진행된다.</p><ul><li>Active state -> Partially commited state -> Failed state -> Aborted state -> Terminated state</li></ul><p>만약 성공적으로 흘러가면 다음과 같이 진행된다.</p><ul><li>Active state -> Partially committed state -> Commited state -> Terminated state</li></ul><p> </p><hr><h1 id=4-database-lock>4. Database Lock<a hidden class=anchor aria-hidden=true href=#4-database-lock>#</a></h1><blockquote><p><strong><em>하나의 데이터를 동시에 여러 명이 조작할 수 없도록 데이터를 잠궈서 동시성을 보장하는 기능</em></strong></p></blockquote><p><strong>[Lock의 종류: MySQL engine lock vs InnoDB lock]</strong></p><ul><li>SQL 엔진이 제공하는 lock: global lock, table lock, named lock, meta-data lock</li><li>MySQL의 InnoDB가 제공하는 lock: record lock, Auto increment Lock 등등</li></ul><p>위 Lock의 종류들은 다 MySQL이 알아서 Lock을 걸고 풀기 때문에 잘 사용되지 않는다.</p><h3 id=dead-lock>DEAD LOCK<a hidden class=anchor aria-hidden=true href=#dead-lock>#</a></h3><p>한 곳에서만 자원에 접근이 가능하고, 다른 곳들로부터 자원에 접근하는 걸 막은 걸 &lsquo;DEAD LOCK&rsquo;이라 한다.</p><p>만약 이 상황에 계속해서 지속되면 좋지 못한 상황이기 때문에 innoDB에서는 이 같은 Lock을 따로 관리리하는 table이 존재한다.</p><p> </p><h2 id=41-글로벌-락global-lock>4.1 글로벌 락(Global lock)<a hidden class=anchor aria-hidden=true href=#41-글로벌-락global-lock>#</a></h2><blockquote><p><strong><em>범위가 가장 넓은 lock으로서, 서버 전체에 영향을 미치기 때문에 A 서버에서 global lock을 걸면 B 서버에까지 적용된다.</em></strong></p></blockquote><ul><li><p>잘 사용되지 않는다.</p></li><li><p>Global lock 걸기: <code>FLUSH TABLES WITH READ LOCK;</code></p></li><li><p>Global lock을 해제하기: Global lock을 걸은 서버에서 MySQL과의 연결이 끊겨야 해제</p></li><li><p><code>SELECT</code>를 제외한 모든 쿼리들이 대기상태로 남기 때문에, 쿼리를 입력해도 진행이 되지 않는다.</p></li><li><p>서버 전체에 영향을 미치기 때문에 작업 대상이나 테이블이 다르더라도 동일하게 영향 받는다.</p><ul><li>table이 <code>myisam</code> 상태에서 global lock을 걸면 <code>innoDB</code>에 있는 서버도 락이 걸린다.</li></ul></li></ul><p> </p><h2 id=42-table-lock>4.2 Table Lock<a hidden class=anchor aria-hidden=true href=#42-table-lock>#</a></h2><blockquote><p><strong><em>특정 테이블에 대한 lock으로서 read lock과 write lock으로 나눠진다.</em></strong></p></blockquote><ul><li><p>read lock: READ 작업만 가능하도록 잠그는 기능</p><ul><li><code>LOCK TABLES innodb READ;</code></li></ul></li><li><p>write lock: WRITE 작업만 가능하도록 잠그는 기능</p><ul><li><code>LOCK TABLES innodb WRITE;</code></li></ul></li><li><p>lock을 걸지 않으면 DB를 read 또는 write하기 직전에 data가 바뀔 수 있기 때문이다.</p></li><li><p>해당 명령어를 사용할 일은 거의 없다. 그 이유는 특별한 상황이 아니라면 다른 작업에 영향을 미치기 때문이다.</p></li><li><p>테이블에 데이터를 변경하는 쿼리를 실행하면 자동으로 lock이 발생한다.</p><ul><li>데이터 추가, 변경 시 lock 설정</li><li>데이터 변경 commit 시 lock release</li><li>InnoDB의 경우에는 DML 쿼리에서는 lock이 작동하지 않과 DDL의 경우에만 영향을 미침<ul><li>스토리지 엔진의 구조 차이라는 정도만 알아두자.</li></ul></li></ul></li></ul><h3 id=read-lock-test>READ LOCK test<a hidden class=anchor aria-hidden=true href=#read-lock-test>#</a></h3><ul><li><p>한 터미널에서 READ LOCK test 해보기</p><ul><li><ol><li>READ LOCK 걸기: <code>LOCK TABLES innodb READ;</code></li></ol></li><li><ol start=2><li>UPDATE 작업 실행: <code>INSERT INTO innodb (id) VALUES (34);</code></li></ol></li><li><ol start=3><li>실행 결과: <code>ERROR 1099 (HY000): Table 'innodb' was locked with a READ lock and can't be updated</code></li></ol></li><li><ol start=4><li>READ LOCK 풀기: <code>UNLOCK TABLES;</code></li></ol></li><li><ol start=5><li>UPDATE 작업 실행 완료</li></ol></li></ul></li><li><p>두 터미널(A, B)에서 READ LOCK test 해보기</p><ul><li><ol><li>A terminal에서 innodb에 대해 READ LOCK을 걸어보자.</li></ol></li><li><ol start=2><li>B termianl에서 UPDATE 작업 실행: <code>INSERT INTO innodb (id) values (98);</code></li></ol></li><li><ol start=3><li>결과: 쿼리문이 진행되지 않는다.</li></ol></li></ul><p><img loading=lazy src=https://user-images.githubusercontent.com/78094972/218686955-2fd8cddd-0393-4115-aa94-c350a203bf33.png alt=image></p><ul><li><ol start=4><li>A terminal에서 READ LOCK을 풀어보자: <code>UNLOCK TABLES;</code></li></ol></li><li><ol start=5><li>대기되고 있던 UPDATE SQL이 바로 진행된다.</li></ol></li></ul><p><img loading=lazy src=https://user-images.githubusercontent.com/78094972/218687323-43530071-30ff-4c78-892f-03c86ba68cd5.png alt=image></p></li></ul><h3 id=write-lock-test>WRITE LOCK test<a hidden class=anchor aria-hidden=true href=#write-lock-test>#</a></h3><ul><li>두 터미널(A, B)에서 READ LOCK test 해보기<ul><li><ol><li>Temianl A: <code>LOCK TABLES innodb WRITE;</code> 실행</li></ol></li><li><ol start=2><li>Terminal B: <code>SELECT * FROM innodb;</code> 를 입력하면 실행되지 않고 LOCK에 걸린다.</li></ol></li><li><ol start=3><li>Terminal A: <code>UNLOCK TABLES;</code> 실행</li></ol></li><li><ol start=4><li>Terminal B: 2)번에 명령어 바로 실행</li></ol></li></ul></li></ul><p> </p><h2 id=43-named-lock>4.3 Named Lock<a hidden class=anchor aria-hidden=true href=#43-named-lock>#</a></h2><ul><li><code>GET_LOCK()</code>이라는 명령어로 임의의 문자열에 대해 잠금을 설정하는 Lock</li><li><code>COMMIT</code> 후 <code>SELECT RELEASE_LOCK(문자열)</code>을 입력하여 Lock이 해제된다.</li><li>자주 안사용한다.<ul><li>여러 클라이언트가 상호 동기화를 처리해야할 때 사용할 수 있다.</li><li>많은 레코드에 대해 복잡한 요건으로 변경하는 트랜잭션에 유용하다.</li></ul></li></ul><p>❗️ MySQL에서는 autocommit이란 전역 변수가 참으로 되어 있어서 COMMIT 이 자동적으로 된다. 이를 확인하기 위해서는 <code>SET GLOBAL VARIABLES LIKE 'autocommi';</code>를 입력하면 확인할 수 있고, AUTO COMMIT을 끄고 싶으면 <code>SET GLOBAL autocommit=0;</code>을 입력한다.</p><h3 id=lock-test>Lock test<a hidden class=anchor aria-hidden=true href=#lock-test>#</a></h3><ul><li><p>A, B termianl에서 test 진행</p><ul><li><ol><li>Terminal A: <code>SELECT GET_LOCK('wanted', 30);</code></li></ol><ul><li><p>30분 동안 wanted 라는 문자열에 대해 사용하는 걸 잠금한다.</p></li><li><p>결과: True</p><table><thead><tr><th>GET_LOCK(&lsquo;wanted&rsquo;, 30)</th></tr></thead><tbody><tr><td>1</td></tr></tbody></table></li><li><p><code>SELECT IS_FREE_LOCK('wanted');</code>: 를 실행하여 LOCK이 자유로운지 확인하면 다음과 같은 결과가 뜬다. 0은 False를 의미하므로 Lock 걸려있다는 상태를 말한다.</p><table><thead><tr><th>IS_FREE_LOCK(&lsquo;wanted&rsquo;)</th></tr></thead><tbody><tr><td>0</td></tr></tbody></table></li></ul></li><li><ol start=2><li>Terminal B: <code>SELECT GET_LOCK('wanted', 20);</code></li></ol><ul><li>이미 A terminal에서 잠궜기 때문에 위 명령어는 잠겨져 대기하게 된다.</li></ul></li><li><ol start=3><li>Terminal A: <code>SELECT RELEASE_LOCK('wanted');</code>를 실행하면 Lock이 풀리면서 2)번 명령이 실행될 수 있다.</li></ol></li></ul></li></ul><p> </p><h2 id=44-메타데이터-락>4.4 메타데이터 락<a hidden class=anchor aria-hidden=true href=#44-메타데이터-락>#</a></h2><blockquote><p><strong><em>데이터베이스 객체(table, column)의 이름이나 구조를 변경하는 경우에 사용되는 락</em></strong></p></blockquote><ul><li><p>테이블 락처럼 별도의 명령어를 사용할 수는 없고, 테이블을 변경하는 등의 작업을 할 때 자동으로 가져왔다가 release한다.</p></li><li><p>이는 다른 락과 달리 명령어가 없어서 직접 보여줄 수 없으니 이런 게 존재하는 것만 알고 있자.</p></li></ul><p> </p><h2 id=45-레코드-락>4.5 레코드 락<a hidden class=anchor aria-hidden=true href=#45-레코드-락>#</a></h2><ul><li>입력한 쿼리에 해당되는 record / row를 가져오는 동안 이 record / row에 lock을 거는 것</li><li><code>EXPLAIN SELECT * FROM innodb;</code>: 해당 쿼리를 설명하는 테이블을 가져온다.</li></ul><table><thead><tr><th>id</th><th>select_type</th><th>table</th><th>partitions</th><th>type</th><th>possible_keys</th><th>key</th><th>key_len</th><th>ref</th><th>rows</th><th>filtered</th><th>Extra</th></tr></thead><tbody><tr><td>1</td><td>SIMPLE</td><td>innodb</td><td>NULL</td><td>index</td><td>NULL</td><td>PRIMARY</td><td>4</td><td>NULL</td><td>2</td><td>100.00</td><td>Using index</td></tr></tbody></table><ul><li><p>여기서 rows column에서 2라고 나와있는데, 위 쿼리로 데이터를 가져오는 동안 2개의 row에 record lock을 거는 것</p></li><li><p>만약 이게 8만개라면? 8만개의 row가 record lock에 걸린 것이므로 효율적이지 않다. 그래서 &lsquo;인덱스&rsquo;를 잘 설계해야 한다.</p></li></ul><h2 id=46-auto-increment-lock>4.6 Auto Increment Lock<a hidden class=anchor aria-hidden=true href=#46-auto-increment-lock>#</a></h2><blockquote><p><strong><em>PRIMARY KEY 중복을 방지하고자 table 생성에 입력하는 auto increment에 lock을 거는 것</em></strong></p></blockquote><ul><li><p>row 추가 시 id 값이 자동적으로 증가하는 설정인 AUTO_INCREMENT에 대해 lock을 거는 것이다.</p></li><li><p>만약 row가 1개 밖에 없는 상황에서 여러 클라이언트가 데이터를 추가할 때, id = 2인 row가 여러 개가 생성될 수 있다. 그래서 innoDB가 동시에 데이터를 못 넣어 중복을 방지하고자 사용하는 게 auto increment lock이다.</p></li><li><p>매우 빨라서 체감하기 어렵다.</p></li></ul><p> </p><hr><h1 id=5-isolation-level격리수준>5. Isolation Level(격리수준)<a hidden class=anchor aria-hidden=true href=#5-isolation-level격리수준>#</a></h1><blockquote><p><strong><em>여러 트랜잭션이 동시에 처리될 때 특정 트랜잭션이 다른 트랜잭션에서 변경하거나 조회하는 데이터를 볼 수 있게 허용할지 말지 결정한다.</em></strong></p></blockquote><p>🔆 격리 수준의 종류에는 무엇이 있고, 각 격리 수준은 무엇이며 장단점은 뭔지, 그래서 무엇을 사용하면 좋은지에 대해서만 먼저 알고 있자.</p><ul><li>격리 수준의 종류: 각 격리 수준마다 단점이 존재하는데 이 모든 걸 다 해결하는 방법은 default engine인 innoDB를 사용하는 것<ul><li>read uncommitted</li><li>read committed</li><li>repeatable read: 나머지는 이런 게 있다는 정도로만 알고, 이를 자세히 알자.</li><li>serializable</li></ul></li></ul><p>❗️ 격리 기본 수준 값을 변경하려고 할 때, 트랜잭션이 진행 중이라 바꿀 수 없다는 Error가 발생했다면 <code>COMMIT</code>을 사용하라.<br>❗️ autocommit = 1 이어도 start transcation으로 트랜잭션을 명시적으로 시작해주면 commit 명령어를 입력해야 DB에 적용이 된다.<br>❗️ mysql에서 나갔다가 다시 들어오면 autocommit은 다시 1로 세팅된다.</p><h2 id=51-read-uncommitted-dirty-read>5.1 Read uncommitted (dirty read)<a hidden class=anchor aria-hidden=true href=#51-read-uncommitted-dirty-read>#</a></h2><blockquote><p><strong><em>COMMIT 되지 않은 데이터를 읽을 수 있는 격리 수준으로, 이런 데이터는 변경될 수 있기 때문에 &lsquo;dirty read&rsquo;라는 문제가 발생된다.</em></strong></p></blockquote><h3 id=read-uncommitted란>Read uncommitted란?<a hidden class=anchor aria-hidden=true href=#read-uncommitted란>#</a></h3><ul><li><p>거의 사용되지 않음</p></li><li><p>트랜잭션의 변경 내용이 commit이나 rollback 여부에 상관 없이 보인다.</p></li></ul><h3 id=문제점-데이터-정합성-준수-x>문제점: 데이터 정합성 준수 x<a hidden class=anchor aria-hidden=true href=#문제점-데이터-정합성-준수-x>#</a></h3><blockquote><p><strong><em>다른 트랜젝션에서 &lsquo;데이터를 업데이트한 시점&rsquo;을 기준으로 한 트랜젝션에서 조회되는 데이터가 달라진다. 즉, 나의 transaction이 아닌데도 COMMIT 전 데이터를 읽을 수 있다.</em></strong></p></blockquote><p>나의 transaction이 진행 중 rollback되어 데이터 업데이트가 취소되어도 취소된 데이터가 남아 있어서 에러가 발생될 수 있다.</p><h3 id=실습>실습<a hidden class=anchor aria-hidden=true href=#실습>#</a></h3><ol><li>autocommit을 off 시킨다: <code>SET GLOBAL autocommit=0;</code><ul><li>결과 확인: <code>SHOW GLOBAL VARIABLES LIKE 'autocommit';</code></li><li>실제 작업할 때는 건드리지 않는다.</li></ul></li><li>기본 isolation level 값을 A, B terminal에서 모두 변경: <code>SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;</code></li><li>A, B terminal에서 모두 트랜젝션 시작: <code>START TRANSACTION;</code><ul><li>변경된 isolation level을 mysql 8.0 부터는 확인할 수 없다.</li></ul></li><li>TABLE 새로 생성: <code>CREATE TABLE auto (id INT NOT_NULL AUTO_INCREMENT, name VAR(4), PRIMARY_KEY(id));</code></li><li>A, B terminal에서 모두 트랜젝션 시작: <code>START TRANSACTION</code></li><li>A terminal에서 데이터 추가: <code>INSERT INTO auto (name) VALUES ('jeha');</code><ul><li>현재 나의 transaction이므로 추가된 데이터가 보인다.</li></ul></li><li>B terminal에서 확인하기: <code>SELECT * FROM auto;</code><ul><li>다른 transaction인데 commit되지 않은 추가된 데이터가 보인다.</li></ul></li><li>ROLLBACK을 진행하여 TRANSACTION 취소: <code>ROLLBACK;</code></li><li>A terminal: <code>SELECT * FROM auto;</code> -> commit을 실행하여 TRANSACTION을 마무리: <code>COMMIT;</code><ul><li>취소된 데이터를 확인할 수 없다.</li></ul></li></ol><p>A terminal에 트랜젝션 과정 중에 데이터를 추가한 6번을 기준으로, B terminal에서 진행되는 트랜젝션 과정에서 조회되는 데이터가 달라진다.</p><p>한 트랜젝션 과정에서 데이터의 정합성이 보장되지 못하는 문제점이 발생된다. 또한 이로 인해서 여러 문제점이 발생될 것이다.</p><p> </p><h2 id=52-read-committed-non-repeatable-read>5.2 Read committed: Non repeatable read<a hidden class=anchor aria-hidden=true href=#52-read-committed-non-repeatable-read>#</a></h2><blockquote><p><strong><em>COMMIT된 것만 읽을 수 있는 격리 수준으로 트랜젝션이 완료된 데이터만 다른 트랜잭션에서 조회 가능하다.</em></strong></p></blockquote><h3 id=read-committed란>Read committed란?<a hidden class=anchor aria-hidden=true href=#read-committed란>#</a></h3><p>커밋되기 전에는 <a href=#32-%EC%96%B4%EB%96%BB%EA%B2%8C-%EA%B0%80%EB%8A%A5%ED%95%9C-%EA%B1%B8%EA%B9%8C>undo log</a>에 있는 곳의 데이터를 읽어오므로 추가한 값이 없고, 커밋 후에 불러오면 추가한 값이 존재한다.</p><ul><li>undo log: 뭔가 잘못되면 돌려야돼서 임시로 저장하는 공간</li><li>데이터 업데이트 sql을 입력하면 이 sql을 table에 적용하기 전에 undo log에 현 상태를 임시 저장한 후 sql을 적용한다.</li><li>그 후 커밋이 안되어있으면 데이터를 가져올 때 undo log에 있는 데이터를 조회한다.</li></ul><h3 id=문제점-데이터-정합성-준수-x-1>문제점: 데이터 정합성 준수 x<a hidden class=anchor aria-hidden=true href=#문제점-데이터-정합성-준수-x-1>#</a></h3><blockquote><p><strong><em>다른 트랜젝션에서 COMMIT을 한 시점을 기준으로 한 트랜젝션에서 조회되는 데이터가 달라진다.</em></strong></p></blockquote><p>동일 트랜젝션 과정에서 COMMIT 전후로 가져오는 데이터가 달라지기 때문에 정합성에서 어긋난다.</p><p>만약 핀테크라면 금액이 달라지는 문제이기 때문에 심각하다.</p><h3 id=실습-1>실습<a hidden class=anchor aria-hidden=true href=#실습-1>#</a></h3><ol><li>autocommit을 off 시킨다: <code>SET GLOBAL autocommit=0;</code><ul><li>결과 확인: <code>SHOW GLOBAL VARIABLES LIKE 'autocommit';</code></li><li>실제 작업할 때는 건드리지 않는다.</li></ul></li><li>기본 isolation level 값을 A, B terminal에서 모두 변경: <code>SET TRANSACTION ISOLATION LEVEL READ COMMITTED;</code><ul><li>변경된 isolation level을 mysql 8.0 부터는 확인할 수 없다.</li></ul></li><li>A, B terminal에서 모두 트랜젝션 시작: <code>START TRANSACTION;</code></li><li>데이터 추가 전 데이터 조회 in A, B terminal: <code>SELECT * FROM auto;</code></li><li>A terminal에서 데이터 변경 후 확인: <code>UPDATE auto SET name='kim' WHERE name='lee'</code> -> <code>SELECT * FROM auto;</code><ul><li>데이터 변경이 진행된 동일한 트랜젝션이므로 확인할 수 있다.</li></ul></li><li>B terminal에서 데이터 조회: <code>SELECT * FROM auto;</code><ul><li>변경 전 데이터로 조회된다.</li></ul></li><li>A terminal에서 commit 실행: <code>COMMIT;</code></li><li>B terminal에서 데이터 조회: <code>SELECT * FROM auto;</code><ul><li>변경 후 데이터로 조회된다.</li></ul></li><li>B terminal에서 commit 실행: <code>COMMIT;</code></li></ol><p>READ UNCOMMITED와의 차이점을 확인했고, 문제점도 확인했다.</p><p>7)번 단계를 기준으로 B terminal에서 transaction이 진행 중인데 조회되는 데이터가 달라졌다. 이 부분이 transaction 진행 중에 데이터의 정합성이 보장되어야하는데 그러지 못하는 문제점이다.</p><p> </p><h2 id=53--repeatable-read>5.3 🔆 Repeatable read<a hidden class=anchor aria-hidden=true href=#53--repeatable-read>#</a></h2><blockquote><p><strong><em>Isolation level의 default 값으로서 InnoDB가 사용하는 것</em></strong></p></blockquote><ul><li><p>반복적으로 읽을 수 있다.</p></li><li><p>언두 영역에 백업된 이전 데이터를 이용해서 동일 트랜잭션에서는 같은 내용을 보여줄 수 있도록 함</p></li></ul><h3 id=문제점-phantom-read>문제점: phantom read<a hidden class=anchor aria-hidden=true href=#문제점-phantom-read>#</a></h3><ul><li>undo record에는 lock을 걸 수 없어서 같은 트랜잭션에서 조회 가능</li><li>왔다갔다 해서 phantom read(유령)이라고 함</li></ul><h3 id=해결책>해결책<a hidden class=anchor aria-hidden=true href=#해결책>#</a></h3><p>InnoDB에서는 undo log를 transaction-id을 기준으로 버전관리를 하여, 해당 transaction-id가 끝날 때까지 보관하기 때문에 phantom read가 문제가 되지 않는다.</p><p>그래서 innoDB를 default engine으로 계속해서 사용한다.</p><h3 id=실습-2>실습<a hidden class=anchor aria-hidden=true href=#실습-2>#</a></h3><ol><li>autocommit을 off 시킨다: <code>SET GLOBAL autocommit=0;</code><ul><li>결과 확인: <code>SHOW GLOBAL VARIABLES LIKE 'autocommit';</code></li><li>실제 작업할 때는 건드리지 않는다.</li></ul></li><li>기본 isolation level 값을 A, B terminal에서 모두 변경: <code>SET TRANSACTION ISOLATION LEVEL REPEATABLE READ;</code><ul><li>변경된 isolation level을 mysql 8.0 부터는 확인할 수 없다.</li></ul></li><li>A, B terminal에서 모두 트랜젝션 시작: <code>START TRANSACTION;</code></li><li>데이터 추가 전 데이터 조회 in A, B terminal: <code>SELECT * FROM auto;</code></li><li>A terminal에서 데이터 변경: <code>UPDATE auto SET name='lee' WHERE name='kim';</code></li><li>B terminal에서 데이터 조회: 4번과 동일한 데이터가 조회된다.<ul><li>read uncommited라면 5번을 기준으로 B terminal에서 조회되는 데이터가 달라지만, 그렇지 않았다.</li></ul></li><li>A terminal에서 commit: <code>COMMIT;</code></li><li>B terminal에서 데이터 조회: 4번과 동일한 데이터가 조회된다.<ul><li>read commited라면 7번을 기준으로 B terminal에서 조회되는 데이터가 달라지만, 그렇지 않았다.</li></ul></li><li>B terminal에서 트랜젝션 종료 후 데이터 조회: <code>ROLLBACK;</code> -> <code>SELECT * FROM auto;</code><ul><li>5번에서 추가된 데이터를 확인할 수 있다.</li></ul></li></ol><p>한 TRANSACTION 동안 조회되는 데이터가 정합성을 준수하는 걸 확인했다.</p><p> </p><h2 id=54-serializable>5.4 Serializable<a hidden class=anchor aria-hidden=true href=#54-serializable>#</a></h2><blockquote><p><strong><em>위에 여러 read의 문제점을 해결하는 방법으로, 하나의 transaction에서 접근한 record에 lock을 걸어 다른 transaction이 동일한 데이터 접근할 경우 이를 막아 transaction 간의 완전한 격리를 이루는 기능</em></strong></p></blockquote><h3 id=문제점>문제점<a hidden class=anchor aria-hidden=true href=#문제점>#</a></h3><ul><li>read도 lock을 획득해야만 가능하다.<ul><li>이 전 isolation level에서는 read에 lock을 걸면 write만 할 수 없고, write에 lock을 걸면 read만 할 수 없었다.</li><li>하지만, read에 lock을 걸면 write나 update, delete 등을 실행할 수 없다.</li><li>그래서 시간이 많이 걸려 효율적이지 않아 사용하지 않는다.</li></ul></li></ul><h3 id=해결책-default인-innodb-사용하기>해결책: default인 innodb 사용하기<a hidden class=anchor aria-hidden=true href=#해결책-default인-innodb-사용하기>#</a></h3><p>InnoDB에서 repeatable read를 사용하면 serializable은 불필요하다.</p><p> </p><hr><h1 id=6-알아두면-좋은-명령어>6. 알아두면 좋은 명령어<a hidden class=anchor aria-hidden=true href=#6-알아두면-좋은-명령어>#</a></h1><h3 id=show-create-table>SHOW CREATE TABLE<a hidden class=anchor aria-hidden=true href=#show-create-table>#</a></h3><blockquote><p><strong><em>테이블이 어떻게 생성되었는지를 보여준다.</em></strong></p></blockquote><ul><li><p>ORM으로 생성하면 실제 SQL에서 테이블을 어떻게 생성하는지 알기 어렵기 때문에 도움된다.</p></li><li><p>특히 회사에 갔을 때 기존에 생성된 테이블들이 어떤식으로 만들어졌는지 궁금하다면?!? 매우 유용하다.</p></li><li><p>ORM으로 테이블을 생성했을 때 본인의 의도와 다르다면 추가 학습이 필요하다.</p></li></ul><h3 id=charset>charset<a hidden class=anchor aria-hidden=true href=#charset>#</a></h3><blockquote><p><strong><em>어떤 character(문자열)의 데이터를 저장할지</em></strong></p></blockquote><h3 id=collate>collate<a hidden class=anchor aria-hidden=true href=#collate>#</a></h3><blockquote><p><strong><em>저장된 데이터를 어떤식으로 비교, 정렬 할지</em></strong></p></blockquote><ul><li>간단한 테이블에서는 문제가 되지 않는다</li></ul><p> </p><hr><h1 id=reference>Reference<a hidden class=anchor aria-hidden=true href=#reference>#</a></h1><ul><li><a href=https://www.wanted.co.kr/events/pre_challenge_be_4>원티드 백엔드 챌린지 2월: MySQL &lsquo;잘&rsquo; 사용하기</a></li></ul><p>[백엔드 5차] 김유정 — 2023.03.03. 오후 5:51
첫 번째 수업때 NoSQL과 RDBMS의 차이에 대해 설명하시면서 RDBMS는 수평적 확장이 어려운 이유를 예를 들어서 설명해주셨던 것 같은데, 잘 기억이 안나네요&mldr;혹시 RDBMS가 수평적 확장이 어려운 이유에 대해서 설명해주실 수 있는 분 있을까요? 여러 글을 읽어봐도 잘 와닿지 않아서요..
네네 — 2023.03.03. 오후 6:03
ㅇ
RDBMS는 관계형이라서 그렇습니다. RDBMS는 스토리지의 효율적인 사용 등의 이유로 불필요한 데이터 중복을 줄이는데, 중복을 줄이는 방법으로 테이블간에 컬럼을통한(제약조건) 관계 형성에 있습니다. 그래서 RDBMS에서는 모델링이 중요하다고 하구요.
회사데이터로 예를들면 RDBMS에서는 사원 테이블, 부서테이블, 직무테이블 세개를 두고 사원번호 등을 통해서 세개 테이블을 조인해서 어떤 사원이 어떤 부서에 어떤 직무를 하는지 조회가 가능한 반면에 nosql에서는 사원-부서-직무 이렇게 한 객체 데이터를 통으로 저장을 합니다
따라서 nosql은 각 객체를 분류하는 기준(ex 남사원 여사원)으로 db를 수평적으로 2개로 확장해도 전혀 지장이 없지만 RDBMS 의 경우 위에 말씀드린 세개 테이블을 전부 기준에 맞게 분류하여 나누어서 확장을 해야하니 더 어렵습니다.</p></div><footer class=post-footer><ul class=post-tags><li><a href=http://jeha00.github.io/tags/db/>DB</a></li></ul><nav class=paginav><a class=prev href=http://jeha00.github.io/post/network/osi_7_layer/1_layer/><span class=title>« Prev Page</span><br><span>[TIL] Network OSI 7 layer: 1계층 물리 계층</span></a>
<a class=next href=http://jeha00.github.io/post/db/wanted/lecture_01/><span class=title>Next Page »</span><br><span>[DB]원티드 프리온보딩 백엔드 챌린지 MySQL: DB 원칙과 종류 비교(RDBMS vs NoSQL, Row vs Column oriented) 그리고 CAP Theorem</span></a></nav><div class=share-buttons><a target=_blank rel="noopener noreferrer" aria-label="share [DB]원티드 프리온보딩 백엔드 챌린지 MySQL: MySQL storage engine의 종류들, Transaction, Database Lock, Isolation Level on twitter" href="https://twitter.com/intent/tweet/?text=%5bDB%5d%ec%9b%90%ed%8b%b0%eb%93%9c%20%ed%94%84%eb%a6%ac%ec%98%a8%eb%b3%b4%eb%94%a9%20%eb%b0%b1%ec%97%94%eb%93%9c%20%ec%b1%8c%eb%a6%b0%ec%a7%80%20MySQL%3a%20MySQL%20storage%20engine%ec%9d%98%20%ec%a2%85%eb%a5%98%eb%93%a4%2c%20Transaction%2c%20Database%20Lock%2c%20Isolation%20Level&url=http%3a%2f%2fjeha00.github.io%2fpost%2fdb%2fwanted%2flecture_02%2f&hashtags=DB"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM195.519 424.544c135.939.0 210.268-112.643 210.268-210.268.0-3.218.0-6.437-.153-9.502 14.406-10.421 26.973-23.448 36.935-38.314-13.18 5.824-27.433 9.809-42.452 11.648 15.326-9.196 26.973-23.602 32.49-40.92-14.252 8.429-30.038 14.56-46.896 17.931-13.487-14.406-32.644-23.295-53.946-23.295-40.767.0-73.87 33.104-73.87 73.87.0 5.824.613 11.494 1.992 16.858-61.456-3.065-115.862-32.49-152.337-77.241-6.284 10.881-9.962 23.601-9.962 37.088.0 25.594 13.027 48.276 32.95 61.456-12.107-.307-23.448-3.678-33.41-9.196v.92c0 35.862 25.441 65.594 59.311 72.49-6.13 1.686-12.72 2.606-19.464 2.606-4.751.0-9.348-.46-13.946-1.38 9.349 29.426 36.628 50.728 68.965 51.341-25.287 19.771-57.164 31.571-91.8 31.571-5.977.0-11.801-.306-17.625-1.073 32.337 21.15 71.264 33.41 112.95 33.41z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share [DB]원티드 프리온보딩 백엔드 챌린지 MySQL: MySQL storage engine의 종류들, Transaction, Database Lock, Isolation Level on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&url=http%3a%2f%2fjeha00.github.io%2fpost%2fdb%2fwanted%2flecture_02%2f&title=%5bDB%5d%ec%9b%90%ed%8b%b0%eb%93%9c%20%ed%94%84%eb%a6%ac%ec%98%a8%eb%b3%b4%eb%94%a9%20%eb%b0%b1%ec%97%94%eb%93%9c%20%ec%b1%8c%eb%a6%b0%ec%a7%80%20MySQL%3a%20MySQL%20storage%20engine%ec%9d%98%20%ec%a2%85%eb%a5%98%eb%93%a4%2c%20Transaction%2c%20Database%20Lock%2c%20Isolation%20Level&summary=%5bDB%5d%ec%9b%90%ed%8b%b0%eb%93%9c%20%ed%94%84%eb%a6%ac%ec%98%a8%eb%b3%b4%eb%94%a9%20%eb%b0%b1%ec%97%94%eb%93%9c%20%ec%b1%8c%eb%a6%b0%ec%a7%80%20MySQL%3a%20MySQL%20storage%20engine%ec%9d%98%20%ec%a2%85%eb%a5%98%eb%93%a4%2c%20Transaction%2c%20Database%20Lock%2c%20Isolation%20Level&source=http%3a%2f%2fjeha00.github.io%2fpost%2fdb%2fwanted%2flecture_02%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share [DB]원티드 프리온보딩 백엔드 챌린지 MySQL: MySQL storage engine의 종류들, Transaction, Database Lock, Isolation Level on reddit" href="https://reddit.com/submit?url=http%3a%2f%2fjeha00.github.io%2fpost%2fdb%2fwanted%2flecture_02%2f&title=%5bDB%5d%ec%9b%90%ed%8b%b0%eb%93%9c%20%ed%94%84%eb%a6%ac%ec%98%a8%eb%b3%b4%eb%94%a9%20%eb%b0%b1%ec%97%94%eb%93%9c%20%ec%b1%8c%eb%a6%b0%ec%a7%80%20MySQL%3a%20MySQL%20storage%20engine%ec%9d%98%20%ec%a2%85%eb%a5%98%eb%93%a4%2c%20Transaction%2c%20Database%20Lock%2c%20Isolation%20Level"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share [DB]원티드 프리온보딩 백엔드 챌린지 MySQL: MySQL storage engine의 종류들, Transaction, Database Lock, Isolation Level on facebook" href="https://facebook.com/sharer/sharer.php?u=http%3a%2f%2fjeha00.github.io%2fpost%2fdb%2fwanted%2flecture_02%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share [DB]원티드 프리온보딩 백엔드 챌린지 MySQL: MySQL storage engine의 종류들, Transaction, Database Lock, Isolation Level on whatsapp" href="https://api.whatsapp.com/send?text=%5bDB%5d%ec%9b%90%ed%8b%b0%eb%93%9c%20%ed%94%84%eb%a6%ac%ec%98%a8%eb%b3%b4%eb%94%a9%20%eb%b0%b1%ec%97%94%eb%93%9c%20%ec%b1%8c%eb%a6%b0%ec%a7%80%20MySQL%3a%20MySQL%20storage%20engine%ec%9d%98%20%ec%a2%85%eb%a5%98%eb%93%a4%2c%20Transaction%2c%20Database%20Lock%2c%20Isolation%20Level%20-%20http%3a%2f%2fjeha00.github.io%2fpost%2fdb%2fwanted%2flecture_02%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share [DB]원티드 프리온보딩 백엔드 챌린지 MySQL: MySQL storage engine의 종류들, Transaction, Database Lock, Isolation Level on telegram" href="https://telegram.me/share/url?text=%5bDB%5d%ec%9b%90%ed%8b%b0%eb%93%9c%20%ed%94%84%eb%a6%ac%ec%98%a8%eb%b3%b4%eb%94%a9%20%eb%b0%b1%ec%97%94%eb%93%9c%20%ec%b1%8c%eb%a6%b0%ec%a7%80%20MySQL%3a%20MySQL%20storage%20engine%ec%9d%98%20%ec%a2%85%eb%a5%98%eb%93%a4%2c%20Transaction%2c%20Database%20Lock%2c%20Isolation%20Level&url=http%3a%2f%2fjeha00.github.io%2fpost%2fdb%2fwanted%2flecture_02%2f"><svg viewBox="2 2 28 28"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></div></footer></article></main><footer class=footer><span>&copy; 2023 <a href=http://jeha00.github.io/>Jeha00 DevLog</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerText="copy";function s(){t.innerText="copied!",setTimeout(()=>{t.innerText="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>