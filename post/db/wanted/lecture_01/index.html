<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>DB 원칙과 종류 비교(RDBMS vs NoSQL, Row vs Column oriented) 그리고 CAP Theorem | Jeha DevLog</title><meta name=keywords content="DB"><meta name=description content="데이터베이스의 3가지 원칙 / 데이터베이스의 종류 RDBMS와 NoSQL의 비교 / 또 다른 분류 기준인 row oriented db와 column oriented db의 차이 / DB 선정 시 고려할 CAP Theorem 에 대해 알아본다."><meta name=author content><link rel=canonical href=http://jeha00.github.io/post/db/wanted/lecture_01/><meta name=google-site-verification content="XYZabc"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.min.98b03e72aec907a0ac061df0117773231da749cf102384a4522e91bc58f66b1e.css integrity="sha256-mLA+cq7JB6CsBh3wEXdzIx2nSc8QI4SkUi6RvFj2ax4=" rel="preload stylesheet" as=style><link rel=icon href=http://jeha00.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=http://jeha00.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=http://jeha00.github.io/favicon-32x32.png><link rel=apple-touch-icon href=http://jeha00.github.io/apple-touch-icon.png><link rel=mask-icon href=http://jeha00.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><meta name=generator content="Hugo 0.101.0"><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><script type=application/javascript>var doNotTrack=!1;doNotTrack||(function(e,t,n,s,o,i,a){e.GoogleAnalyticsObject=o,e[o]=e[o]||function(){(e[o].q=e[o].q||[]).push(arguments)},e[o].l=1*new Date,i=t.createElement(n),a=t.getElementsByTagName(n)[0],i.async=1,i.src=s,a.parentNode.insertBefore(i,a)}(window,document,"script","https://www.google-analytics.com/analytics.js","ga"),ga("create","UA-123-45","auto"),ga("send","pageview"))</script><meta property="og:title" content="DB 원칙과 종류 비교(RDBMS vs NoSQL, Row vs Column oriented) 그리고 CAP Theorem"><meta property="og:description" content="데이터베이스의 3가지 원칙 / 데이터베이스의 종류 RDBMS와 NoSQL의 비교 / 또 다른 분류 기준인 row oriented db와 column oriented db의 차이 / DB 선정 시 고려할 CAP Theorem 에 대해 알아본다."><meta property="og:type" content="article"><meta property="og:url" content="http://jeha00.github.io/post/db/wanted/lecture_01/"><meta property="og:image" content="http://jeha00.github.io/47"><meta property="article:section" content="post"><meta property="article:published_time" content="2023-02-13T21:54:56+09:00"><meta property="article:modified_time" content="2023-02-13T21:54:56+09:00"><meta property="og:site_name" content="JeHa00 DevLog"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="http://jeha00.github.io/47"><meta name=twitter:title content="DB 원칙과 종류 비교(RDBMS vs NoSQL, Row vs Column oriented) 그리고 CAP Theorem"><meta name=twitter:description content="데이터베이스의 3가지 원칙 / 데이터베이스의 종류 RDBMS와 NoSQL의 비교 / 또 다른 분류 기준인 row oriented db와 column oriented db의 차이 / DB 선정 시 고려할 CAP Theorem 에 대해 알아본다."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"http://jeha00.github.io/post/"},{"@type":"ListItem","position":2,"name":"DB 원칙과 종류 비교(RDBMS vs NoSQL, Row vs Column oriented) 그리고 CAP Theorem","item":"http://jeha00.github.io/post/db/wanted/lecture_01/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"DB 원칙과 종류 비교(RDBMS vs NoSQL, Row vs Column oriented) 그리고 CAP Theorem","name":"DB 원칙과 종류 비교(RDBMS vs NoSQL, Row vs Column oriented) 그리고 CAP Theorem","description":"데이터베이스의 3가지 원칙 / 데이터베이스의 종류 RDBMS와 NoSQL의 비교 / 또 다른 분류 기준인 row oriented db와 column oriented db의 차이 / DB 선정 시 고려할 CAP Theorem 에 대해 알아본다.","keywords":["DB"],"articleBody":"0. Introduction 원티드 백엔드 챌린지 2월: MySQL ‘잘’ 사용하기 를 듣고 제 언어로 정리한 포스팅입니다.\n해당 챌린지의 목표는 주니어 개발자 및 개발 준비생을 대상으로 하기 때문에, MySQL의 특징을 이해하여 효율적으로 사용하고, MySQL 기본 개념들을 학습하여 기술 면접에 대비하는 게 목적입니다.\n그래서 운영체제의 cache 운용도가 높은 storage engine을 최적화할 때 어떻게 해야하는가 또는 쿼리 효율 개선 같은 내용은 다루지 않습니다.\n해당 포스팅의 주제와 키워드 이번 포스팅의 주제는 [다양한 데이터베이스의 특징과 장단점] 입니다.\nKeyword: 데이터 베이스의 원칙, CAP Theorem, RDBMS, NoSQL\n기본 용어: Read / write / query / record \u0026 row\nrecord는 DB에 저장된 data를 의미 1. 데이터베이스의 원칙 무결성, 안전성, 확장성\n아래 3가지를 고려하여 DB를 정해야 한다.\n1.1 무결성(data integrity) 데이터가 전송, 저장, 처리되는 과정에서 변경되거나 손상되지 않아야한다는 원칙 -\u003e 정확성, 일관성, 유효성을 유지\nintegrity 단어의 의미 integrity 단어는 말, 행동, 생각이 일치하여 일관되고, 이 생각을 기반으로 행동과 말이 온전한 상태라는 의미를 가진다.\n그렇다면 DB에서의 integrity란? 데이터는 일관되어야 하고, 완전해야 하고, 손상되지 않고 정확해야 한다는 의미다.\n그래서 데이터의 정확성, 일관성, 유효성 을 유지한다.\n어떤 개발자가 동일한 데이터를 요청하면 동일한 값을 가진 데이터가 보내져야 한다.\n1.2 안전성(data reliability) 데이터를 보호해야한다는 원칙\ndb를 복제하든지, stand-by db를 대기해둔다든지, 인증/인가되지 않은 사용자로부터 데이터를 보호 하는 걸 말한다.\n1.3 확장성(scalability) 데이터 양이나 사용자가 늘어날 때 대비하기 위해 확장되는 성질\nMySQL, Redis는 확장성이 좋지 않다.\n2. 다양한 데이터베이스 종류: RDBMS vs NoSQL - DB의 종류: RDBMS(MySQL, PostgreSQL..), NoSQL(redis, MongoDB)\n- 서비스에 적합한 DB 선택법: CAP Theorem\n2.1 RDBMS Ex: MySQL, Oracle, PostgreSQL…\n데이터를 row와 column으로 이뤄진 table의 형태 로 저장되기 때문에 데이터 무결성이 보장 된다. 그래서 만약 schema가 자주 변경되거나 column이 자주 변경되는 데이터는 RDBMS가 적합하지 않다.\n그리고, 이 저장된 table로부터 SQL(Structured Query Language) 를 사용해서 데이터를 쉽게 읽어오거나 조작한다.\nscale out이 아닌 scale up이 가능한 이유:\n여러 db를 서버에 나눠서 저장해도 table name이 중복될 수 없기 때문에 scale up을 해야 한다. 하지만 이 특성으로 인해 분산 저장을 하지 않기 때문에 데이터 일관성이 잘 유지된다. 2.2 NoSQL Ex: key-value, graph, document\n데이터가 저장되는 형태인 key-value, graph, document 에 따라 NoSQL 여러 종류로 나눠진다.\n데이터가 저장되는 형태는 더 많지만 위 3가지가 대부분이므로 더 알아보지 않는다.\n2.2.1 key-value key-value 쌍으로 데이터가 저장된다. 여기서 Key는 unique identifier로 사용되기 때문에 key는 중복되지 않는다. 그래서 추가하면 기존에 있던 key는 날라간다. ex) redis, DynamoDB [Redis]\ncache로 사용: 자주 사용되는 쿼리 명령어를 캐쉬에 저장하여 바로 사용 docker나 쿠버네티스 상에 올릴 때 많이 사용 celery와도 많이 사용하여 message broker로서 pub/subscribe 에 보내진다. ❗️한계: 위 3가지 DB 원칙 중 확장성의 관점에서는 redis는 in-memory 기반으로 최대 RAM 크기까지만 확장이 가능하기 때문이다.( not scalable ) [DynamoDB in AWS] 최근에 많이 사용되고 있다. redis와 달리 key가 partiton key(primary) 와 sort key(secondary, optional)로 나눠진다. partition key는 scale out으로 DB가 나눠졌을 때 값이 존재하는 위치를 나타낸다. 장점: scalable → HA(High Availability), serverless 2.2.2 graph 데이터가 graph 형태로 저장되기 때문에, SNS 등 관계가 복잡한 상황에서 자주 사용된다.\nex) instagram, linkedin\n각 user를 node로 생각하고, node 간의 관계는 edge를 사용해서 나타낸다. 종류: Neo4j, OrientDB 등 2.2.3 document 데이터가 document 형태로 저장되서 구조가 자유롭다. ex) JSON 또는 XML 형태\nMongoDB를 통해서 설명해보겠다.\nMySQL과 비교하자면 Collections이 table이고, Documents가 table의 row라고 생각하면 된다.\n스키마를 만들 수 있지만, 형태가 스키마에서 떨어져도 자유롭게 저장할 수 있다. 그래서 이 DB는 블로그 같은 곳에 사용될 수 있다. DB 별로 데이터를 조작할 수 있는 언어가 따로 있다. 종류: MongoDB, CassandraDB, Couchbase 등이 해당 3. DB를 나누는 또 다른 기준: row oriented db vs column oriented db DB를 나누는 또 다른 기준이 row-oriented 와 column-oriented가 있다.\nrow 와 column oriendtd에 따른 DB 종류 row-oriented DB: MySQL, PostgreSQL, hbase column-oriented DB: CassandraDB, hbase, Bigquery big query: 구글에서 만든 DB 엔진 row와 column oriented에 따른 read, insert 성능 차이 row oriented db column oriented db read 느림 빠름 insert 빠름 느림 가정 데이터가 아래 table처럼 저장되어 있다고 가정하자.\nName City Age James Seoul 29 Kang London 33 Mac London 27 3.1 Row oriented DB column으로 스키마가 정해져서 row가 원하는 데이터인 DB\n그러면 Row oriented DB에 대해 알아보자.\n3.1.1 disk에 저장되는 형태 row oriented DB의 저장 형태는 대략적으로 다음과 같다.\ntable의 각 row들이 disk에 저장될 때 한 줄로 저장된다.\n| James | Seoul | 29 | Kang | London | 33 | Mac | London | 27 |\ndisk의 block에는 다음과 같이 각 row 들로 저장된다.\n🔆 sector, block의 차이\nblock 1\nName City Age James Seoul 29 block 2\nName City Age Kang London 33 block 3\nName City Age Mac London 27 3.1.2 추가 row oriented db에서의 데이터 추가는 문제가 되지 않는다.\n만약 row가 한 줄 추가된다면 table은 다음과 같이 한 줄 추가된다.\nName City Age James Seoul 29 Kang London 33 Mac London 27 Paul Chicago 22 disk에는 다음과 같이 동일한 row의 맨 끝에 추가된다. 추가된 데이터는 bold 표시를 했다.\n| James | Seoul | 29 | Kang | London | 33 | Mac | London | 27 | Paul | Chicago | 22 |\n그래서 row oriented db에서의 데이터 추가는 간단하여 문제가 되지 않는다.\n3.1.3 조회 조회하려는 속성 값에 대해 연속적으로 저장되지 않기 때문에 문제가 된다.\n나이 관련된 데이터를 조회하고 싶을 때 row로 저장되기 때문에 나이 관련 데이터가 연속적이지 않아 조회하는 데 시간이 걸린다.\n| James | Seoul | 29 | Kang | London | 33 | Mac | London | 27 |Paul | Chicago | 22 |\n그래서 id가 auto increment여도 순서가 보장되지 않기 때문에 이를 위해서 row 기반 DB에서는 별도의 index 테이블을 사용한다.\n🔆 즉, row oriented db에서의 최적화란 read를 어떻게 빠르게 할 것인가를 의미한다.\n3.1.4 삭제 후 추가 데이터 삭제하여 생긴 빈 자리에 그대로 추가되기 때문에 데이터 순서가 보장되지 않는다. 그래서 DB에서는 ‘인덱스’라는 걸 생성하여 관리한다.\n현재 table이 다음과 같다고 가정하자.\nName City Age James Seoul 29 Kang London 33 Mac London 27 Paul Chicago 22 disk에는 다음과 같이 같이 한 줄로 이어서 저장되어 있다.\n| James | Seoul | 29 | Kang | London | 33 | Mac | London | 27 | Paul | Chicago | 22 | 이런 상황에서 | Mac | London | 27 | 데이터가 삭제된다면 디스크에서는 어떻게 될까?\n| James | Seoul | 29 | Kang | London | 33 | | | ___ | Paul | Chicago | 22 | 위와 같이 빈 자리가 생긴다.\n그 다음 다른 데이터 | Mike | Shanghai | 43 | 이 추가되면 디스크에는 어떻게 저장되는 것일까?\n뒤에 있는 | Paul | Chicago | 22 | 이 댕겨지면서 뒤에 저장될까? 아니면 빈 자리에 데이터가 그대로 추가될까?\n바로 후자다.\n그래서 row oriented db 는 db에 저장되는 순서를 보장하지 않는다. 이 특성으로 인해서 ORDER BY 로 정렬할 때, id의 경우 DB에서 별도로 인덱스라는 걸 생성하여 관리한다고 한다.\n❗️추가할 때, 빈 자리로 데이터를 shift하면 순서가 맞혀지지 않을까? 이럴 경우, shift하는데 시간이 많이 걸리기 때문에 빈 자리에 바로 추가하는 게 낫다.\n3.2 Column oriented DB row으로 스키마가 정해져서 column이 원하는 데이터인 DB\n3.2.1 disk에 저장되는 형태 그리고, disk에는 다음과 같이 저장된다.\nblock 1\nName James Kang Mac block 2\nCity Seoul London London block 3\nAge 29 33 27 3.2.2 추가 row 기반 db처럼 끝에 추가되는 게 아닌 ‘데이터 사이에 추가 ’ 되는 거라 오래 걸린다.\n추가 되기 전 디스크에 저장된 형태는 다음과 같다.\n| James | Kang| Mac | Seoul | London | London | 29 | 33 | 27 | 데이터가 추가되면 아래와 같은 순서로 데이터가 저장된다. 추가된 데이터는 bold 처리했다.\n| James | Kang| Mac | Paul | Seoul | London | London | Chicago | 29 | 33 | 27 | 22 | 저장된 데이터의 순서를 보면 row oriented db와 달리 어떻게 저장되는지 이해할 수 있다.\n3.2.3 조회 만약 내가 Age를 기준으로 데이터를 찾는다고 하면 row oriented db와 달리 조회하는 게 쉽다. 왜냐하면 아래와 같이 한 가지 column에 대해 한 디스크 위치에 저장되어 있기 때문이다.\nbold 처리된 게 나이 관련 데이터다.\n| James | Kang| Mac |Paul | Seoul | London | London |Chicago | 29 | 33| 27 | 22 | 그래서 bigquery가 데이터 조회에서 MySQL보다 빠른 이유가 바로 이 때문이다.\n4. 서비스에 적합한 데이터베이스 선택법 4.1 CAP Theorem consistency(일관성) 데이터베이스가 서버가 여러 개인 분산 데이터베이스 상에서 모든 node들이 데이터베이스 안에 같은 값을 가지고 있어야 하는 성질 (같은 정보를 공유하고 있어야하는 성질) 어떤 노드에게 요청을 보내도 상관없이 같은 데이터를 보여준다. 하지만 request를 보내면 동기화를 위해서 해당 request가 delay 될 수 있다. 그래서 일관성의 목표는 데이터의 동기화가 충분히 빨라서 사용 상 문제가 없도록 하는 것이다. 금융 쪽에서는 이 일관성이 중요하다. 송금 데이터가 데이터베이스 노드당 동기화되지 않으면 송금 안된 줄 알고 계속 보낸다. 실생활에서 예시: 통신사 상담원에게 전화하여 집 주소를 변경하고 전화를 끊은 뒤 집 주소 중 일부가 잘못 전달된 걸 알고, 다시 전화하여 다른 상담원이 받을 지라도 변경된 내용을 정확히 알고 있는 상황 availability(가용성) 데이터베이스에 보내는 모든 request는 response를 반드시 받아야 하는 성질로, 시스템이 중단되는 일 없이 언제든지 사용 가능한 상태여야 한다. 작업이 실패하더라도 사용자는 응답을 받을 수 있어야 한다. consistency는 동기화 때문에 response가 바로 안온다. 하지만 해당 response가 가장 최근 데이터라는 것을 보장받을 수 없다. 데이터가 일관되지 않아도 언제든지 접근할 수 있다. 접근하는 node에 따라 값이 다르다 E-commerce에서 중요 실생활에서 예시: 24시간 가능한 통신사 고객센터 partition-tolerance(분할 허용성) DB node 간 소통이 불가능 하더라도 서비스는 정상적으로 작동하는 성질 데이터량이 매우 많을 때 중요 인스타그램 같은 SNS에서 중요 실생활에서 예시: 통신사 고객센터에 전화하여 문의를 하니 고객센터에서는 현재 본사와 통신할 수 없다고 한다. 하지만 고객센터는 정상적으로 운영된다. 4.2 위 3가지를 다 가질 수 없는 이유 서버가 s1과 s2로 나눠져 있는 상황이라고 하자.\npartition-tolerance가 없으면?? consistency, availability 함께 지원된다.\n이 s1과 s2 사이에서 소통할 수가 없어서 데이터를 분산 저장할 수 없다. 그러면 한 서버로만 흘러가서 write / read를 수행하기 때문에 request를 보내면 바로 response를 받을 수 있고, 항상 동일한 데이터를 얻을 수 있다. partition-tolerance가 있으면? consistency와 availability는 함께 지원되지 않는다.\n서버가 끊겨도 계속해서 소통할 수 있다면?\ndb가 consistency하다면 db에 요청을 보냈을 때, s1과 s2의 각 서버가 동기화 작업을 하느라 response가 느려지고, 사용자는 계속 기다려야 한다.\n쿠팡에서 탄산수를 주문했는데 바로 response가 오지 않는다. 왜냐하면 다른 서버에도 저장을 해야하기 때문이다. 하지만 db가 consistency하지 않고, 데이터가 availability 하다면 write/read request를 했을 때 바로 response가 온다. 대신에 write한 데이터가 모든 서버에 동기화되지 않기 때문에, 어느 서버로 흘러가냐에 따라서 내가 요청한 write data가 안올 수 있다.\n4.3 예시 RDBMS RDBMS: Netflix (ex: MySQL)\n영상에 대한 정보를 저장하는 방식 데이터 분산은 잘 안되서 내가 write한 걸 잘 읽어올 수 있다. NoSQL NoSQL: 인스타그램\n인스타그램은 availability를 굉장히 중요하게 생각한다.\n즉, 데이터가 write된 게 매우 중요하게 여겨서, 해당 사용자가 속한 노드에서 이 데이터가 저장되었는지가 중요하다. 왜냐하면 글이나 메세지는 작성된 게 남겨져야하기 때문이다. 그리고 consistency를 중요하게 여기지 않는다.\n즉, 저장된 데이터가 다른 노드들에 복제되었는지는 그리 중요하지 않아서, 동기화를 바로 하지 않고 나중에 할 시간이 별도로 있다. Cassandra DB 블로그↗️\n그래서 각 도메인과 데이터 종류에 따라서 DB 선택을 잘 해야 한다.\n5. RDBMS와 NoSQL 비교 RDBMS NoSQL Data modeling 특징 1 스키마에 맞춰서 관리하기 때문에 데이터 정합성 보장 자유롭게 데이터를 관리할 수 있다. 어느 data가 해당 관계를 맺고 있는 데이터가 자주 변경되는 경우 해당 데이터 구조를 정확히 알 수 없고, 데이터가 변경/확장 되는 경우 해당 Scalability Scale up Scale out Query Language SQL(Structured Query Language) 문법이 조금 다름 Consistency Strong eventual consistency flexibility Not really very flexible 위 데이터 종류에 맞춰서 분리 적용한다.\n사용자 정보의 경우 스키마가 변하지 않기 때문에 RDBMS를 사용한다. RDBMS는 scale out이 어려운 이유 RDBMS는 위에서 언급한 대로 스키마에 맞춰서 데이터가 저장되기 때문에 중복이 어렵다. 이는 다르게 말하자면 테이블 간에 column을 통한 관계 형성이라는 제약 조건을 통해서 이뤄지고 있다. (그래서 데이터 모델링이 RDBMS에서는 중요하다.)\n그래서 이런 제약조건을 모두 만족하면서 분류하여 나눠서 확장을 해야하므로 Nosql보다 더 어렵다. nosql은 각 객체를 분류하는 기준이 강하지 않기 때문이다. 즉 중복을 줄이기 위한 “관계” 로 인해서 확장하기가 어렵다.\n🔆 Scale up VS. Scale out scale out의 단점: 데이터가 중복될 수 있다. Reference 원티드 백엔드 챌린지 2월: MySQL ‘잘’ 사용하기 Understanding NoSQL Databases by the CAP Theorem What is MongoDB – Working and Features How row oriented and column oriented db works? A Beginner’s Guide to CAP Theorem for Data Engineering CAP 이론 소개 - 데이터베이스 초보자용 ","wordCount":"1916","inLanguage":"en","datePublished":"2023-02-13T21:54:56+09:00","dateModified":"2023-02-13T21:54:56+09:00","mainEntityOfPage":{"@type":"WebPage","@id":"http://jeha00.github.io/post/db/wanted/lecture_01/"},"publisher":{"@type":"Organization","name":"Jeha DevLog","logo":{"@type":"ImageObject","url":"http://jeha00.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=http://jeha00.github.io/ accesskey=h title="@Jeha00 (Alt + H)">@Jeha00</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></span></div><ul id=menu><li><a href=http://jeha00.github.io/me/ title=About><span>About</span></a></li><li><a href=http://jeha00.github.io/archives/ title=Archive><span>Archive</span></a></li><li><a href=http://jeha00.github.io/categories/ title=Categories><span>Categories</span></a></li><li><a href=http://jeha00.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=http://jeha00.github.io/>Home</a>&nbsp;»&nbsp;<a href=http://jeha00.github.io/post/>Posts</a></div><h1 class=post-title>DB 원칙과 종류 비교(RDBMS vs NoSQL, Row vs Column oriented) 그리고 CAP Theorem</h1><div class=post-meta>DB&nbsp;·&nbsp;<span title='2023-02-13 21:54:56 +0900 KST'>February 13, 2023</span></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#0-introduction aria-label="0. Introduction">0. Introduction</a><ul><ul><li><a href=#%ed%95%b4%eb%8b%b9-%ed%8f%ac%ec%8a%a4%ed%8c%85%ec%9d%98-%ec%a3%bc%ec%a0%9c%ec%99%80-%ed%82%a4%ec%9b%8c%eb%93%9c aria-label="해당 포스팅의 주제와 키워드">해당 포스팅의 주제와 키워드</a></li></ul></ul></li><li><a href=#1-%eb%8d%b0%ec%9d%b4%ed%84%b0%eb%b2%a0%ec%9d%b4%ec%8a%a4%ec%9d%98-%ec%9b%90%ec%b9%99 aria-label="1. 데이터베이스의 원칙">1. 데이터베이스의 원칙</a><ul><li><a href=#11-%eb%ac%b4%ea%b2%b0%ec%84%b1data-integrity aria-label="1.1 무결성(data integrity)">1.1 무결성(data integrity)</a><ul><li><a href=#integrity-%eb%8b%a8%ec%96%b4%ec%9d%98-%ec%9d%98%eb%af%b8 aria-label="integrity 단어의 의미">integrity 단어의 의미</a></li><li><a href=#%ea%b7%b8%eb%a0%87%eb%8b%a4%eb%a9%b4-db%ec%97%90%ec%84%9c%ec%9d%98-integrity%eb%9e%80 aria-label="그렇다면 DB에서의 integrity란?">그렇다면 DB에서의 integrity란?</a></li></ul></li><li><a href=#12-%ec%95%88%ec%a0%84%ec%84%b1data-reliability aria-label="1.2 안전성(data reliability)">1.2 안전성(data reliability)</a></li><li><a href=#13-%ed%99%95%ec%9e%a5%ec%84%b1scalability aria-label="1.3 확장성(scalability)">1.3 확장성(scalability)</a></li></ul></li><li><a href=#2-%eb%8b%a4%ec%96%91%ed%95%9c-%eb%8d%b0%ec%9d%b4%ed%84%b0%eb%b2%a0%ec%9d%b4%ec%8a%a4-%ec%a2%85%eb%a5%98-rdbms-vs-nosql aria-label="2. 다양한 데이터베이스 종류: RDBMS vs NoSQL">2. 다양한 데이터베이스 종류: RDBMS vs NoSQL</a><ul><li><a href=#21-rdbms aria-label="2.1 RDBMS">2.1 RDBMS</a></li><li><a href=#22-nosql aria-label="2.2 NoSQL">2.2 NoSQL</a><ul><li><a href=#221-key-value aria-label="2.2.1 key-value">2.2.1 key-value</a></li><li><a href=#222-graph aria-label="2.2.2 graph">2.2.2 graph</a></li><li><a href=#223-document aria-label="2.2.3 document">2.2.3 document</a></li></ul></li></ul></li><li><a href=#3-db%eb%a5%bc-%eb%82%98%eb%88%84%eb%8a%94-%eb%98%90-%eb%8b%a4%eb%a5%b8-%ea%b8%b0%ec%a4%80-row-oriented-db-vs-column-oriented-db aria-label="3. DB를 나누는 또 다른 기준: row oriented db vs column oriented db">3. DB를 나누는 또 다른 기준: row oriented db vs column oriented db</a><ul><ul><li><a href=#row-%ec%99%80-column-oriendtd%ec%97%90-%eb%94%b0%eb%a5%b8-db-%ec%a2%85%eb%a5%98 aria-label="row 와 column oriendtd에 따른 DB 종류">row 와 column oriendtd에 따른 DB 종류</a></li><li><a href=#row%ec%99%80-column-oriented%ec%97%90-%eb%94%b0%eb%a5%b8-read-insert-%ec%84%b1%eb%8a%a5-%ec%b0%a8%ec%9d%b4 aria-label="row와 column oriented에 따른 read, insert 성능 차이">row와 column oriented에 따른 read, insert 성능 차이</a></li><li><a href=#%ea%b0%80%ec%a0%95 aria-label=가정>가정</a></li></ul><li><a href=#31-row-oriented-db aria-label="3.1 Row oriented DB">3.1 Row oriented DB</a><ul><li><a href=#311-disk%ec%97%90-%ec%a0%80%ec%9e%a5%eb%90%98%eb%8a%94-%ed%98%95%ed%83%9c aria-label="3.1.1 disk에 저장되는 형태">3.1.1 disk에 저장되는 형태</a></li><li><a href=#312-%ec%b6%94%ea%b0%80 aria-label="3.1.2 추가">3.1.2 추가</a></li><li><a href=#313-%ec%a1%b0%ed%9a%8c aria-label="3.1.3 조회">3.1.3 조회</a></li><li><a href=#314-%ec%82%ad%ec%a0%9c-%ed%9b%84-%ec%b6%94%ea%b0%80 aria-label="3.1.4 삭제 후 추가">3.1.4 삭제 후 추가</a></li><li><a href=#%ec%b6%94%ea%b0%80%ed%95%a0-%eb%95%8c-%eb%b9%88-%ec%9e%90%eb%a6%ac%eb%a1%9c-%eb%8d%b0%ec%9d%b4%ed%84%b0%eb%a5%bc-shift%ed%95%98%eb%a9%b4-%ec%88%9c%ec%84%9c%ea%b0%80-%eb%a7%9e%ed%98%80%ec%a7%80%ec%a7%80-%ec%95%8a%ec%9d%84%ea%b9%8c aria-label="❗️추가할 때, 빈 자리로 데이터를 shift하면 순서가 맞혀지지 않을까?">❗️추가할 때, 빈 자리로 데이터를 shift하면 순서가 맞혀지지 않을까?</a></li></ul></li><li><a href=#32-column-oriented-db aria-label="3.2 Column oriented DB">3.2 Column oriented DB</a><ul><li><a href=#321-disk%ec%97%90-%ec%a0%80%ec%9e%a5%eb%90%98%eb%8a%94-%ed%98%95%ed%83%9c aria-label="3.2.1 disk에 저장되는 형태">3.2.1 disk에 저장되는 형태</a></li><li><a href=#322-%ec%b6%94%ea%b0%80 aria-label="3.2.2 추가">3.2.2 추가</a></li><li><a href=#323-%ec%a1%b0%ed%9a%8c aria-label="3.2.3 조회">3.2.3 조회</a></li></ul></li></ul></li><li><a href=#4-%ec%84%9c%eb%b9%84%ec%8a%a4%ec%97%90-%ec%a0%81%ed%95%a9%ed%95%9c-%eb%8d%b0%ec%9d%b4%ed%84%b0%eb%b2%a0%ec%9d%b4%ec%8a%a4-%ec%84%a0%ed%83%9d%eb%b2%95 aria-label="4. 서비스에 적합한 데이터베이스 선택법">4. 서비스에 적합한 데이터베이스 선택법</a><ul><li><a href=#41-cap-theorem aria-label="4.1 CAP Theorem">4.1 CAP Theorem</a></li><li><a href=#consistency%ec%9d%bc%ea%b4%80%ec%84%b1 aria-label=consistency(일관성)>consistency(일관성)</a></li><li><a href=#availability%ea%b0%80%ec%9a%a9%ec%84%b1 aria-label=availability(가용성)>availability(가용성)</a></li><li><a href=#partition-tolerance%eb%b6%84%ed%95%a0-%ed%97%88%ec%9a%a9%ec%84%b1 aria-label="partition-tolerance(분할 허용성)">partition-tolerance(분할 허용성)</a></li><li><a href=#42-%ec%9c%84-3%ea%b0%80%ec%a7%80%eb%a5%bc-%eb%8b%a4-%ea%b0%80%ec%a7%88-%ec%88%98-%ec%97%86%eb%8a%94-%ec%9d%b4%ec%9c%a0 aria-label="4.2 위 3가지를 다 가질 수 없는 이유">4.2 위 3가지를 다 가질 수 없는 이유</a><ul><li><a href=#partition-tolerance%ea%b0%80-%ec%97%86%ec%9c%bc%eb%a9%b4 aria-label="partition-tolerance가 없으면??">partition-tolerance가 없으면??</a></li><li><a href=#partition-tolerance%ea%b0%80-%ec%9e%88%ec%9c%bc%eb%a9%b4 aria-label="partition-tolerance가 있으면?">partition-tolerance가 있으면?</a></li></ul></li><li><a href=#43-%ec%98%88%ec%8b%9c aria-label="4.3 예시">4.3 예시</a><ul><li><a href=#rdbms aria-label=RDBMS>RDBMS</a></li><li><a href=#nosql aria-label=NoSQL>NoSQL</a></li></ul></li></ul></li><li><a href=#5-rdbms%ec%99%80-nosql-%eb%b9%84%ea%b5%90 aria-label="5. RDBMS와 NoSQL 비교">5. RDBMS와 NoSQL 비교</a><ul><ul><li><a href=#rdbms%eb%8a%94-scale-out%ec%9d%b4-%ec%96%b4%eb%a0%a4%ec%9a%b4-%ec%9d%b4%ec%9c%a0 aria-label="RDBMS는 scale out이 어려운 이유">RDBMS는 scale out이 어려운 이유</a></li><li><a href=#-scale-up-vs-scale-out aria-label="🔆 Scale up VS. Scale out">🔆 Scale up VS. Scale out</a></li></ul></ul></li><li><a href=#reference aria-label=Reference>Reference</a></li></ul></div></details></div><div class=post-content><h1 id=0-introduction>0. Introduction<a hidden class=anchor aria-hidden=true href=#0-introduction>#</a></h1><ul><li><p><a href=https://www.wanted.co.kr/events/pre_challenge_be_4>원티드 백엔드 챌린지 2월: MySQL &lsquo;잘&rsquo; 사용하기</a> 를 듣고 제 언어로 정리한 포스팅입니다.</p></li><li><p>해당 챌린지의 목표는 주니어 개발자 및 개발 준비생을 대상으로 하기 때문에, MySQL의 특징을 이해하여 효율적으로 사용하고, MySQL 기본 개념들을 학습하여 기술 면접에 대비하는 게 목적입니다.</p></li><li><p>그래서 운영체제의 cache 운용도가 높은 storage engine을 최적화할 때 어떻게 해야하는가 또는 쿼리 효율 개선 같은 내용은 다루지 않습니다.</p></li></ul><h3 id=해당-포스팅의-주제와-키워드>해당 포스팅의 주제와 키워드<a hidden class=anchor aria-hidden=true href=#해당-포스팅의-주제와-키워드>#</a></h3><ul><li><p>이번 포스팅의 주제는 <strong>[다양한 데이터베이스의 특징과 장단점]</strong> 입니다.</p></li><li><p>Keyword: 데이터 베이스의 원칙, CAP Theorem, RDBMS, NoSQL</p></li><li><p>기본 용어: Read / write / query / record & row</p><ul><li>record는 DB에 저장된 data를 의미</li></ul></li></ul><p> </p><hr><h1 id=1-데이터베이스의-원칙>1. 데이터베이스의 원칙<a hidden class=anchor aria-hidden=true href=#1-데이터베이스의-원칙>#</a></h1><blockquote><p><strong><em>무결성, 안전성, 확장성</em></strong></p></blockquote><p>아래 3가지를 고려하여 DB를 정해야 한다.</p><h2 id=11-무결성data-integrity>1.1 무결성(data integrity)<a hidden class=anchor aria-hidden=true href=#11-무결성data-integrity>#</a></h2><blockquote><p><strong><em>데이터가 전송, 저장, 처리되는 과정에서 변경되거나 손상되지 않아야한다는 원칙 -> 정확성, 일관성, 유효성을 유지</em></strong></p></blockquote><h3 id=integrity-단어의-의미>integrity 단어의 의미<a hidden class=anchor aria-hidden=true href=#integrity-단어의-의미>#</a></h3><p>integrity 단어는 말, 행동, 생각이 일치하여 일관되고, 이 생각을 기반으로 행동과 말이 온전한 상태라는 의미를 가진다.</p><h3 id=그렇다면-db에서의-integrity란>그렇다면 DB에서의 integrity란?<a hidden class=anchor aria-hidden=true href=#그렇다면-db에서의-integrity란>#</a></h3><p>데이터는 일관되어야 하고, 완전해야 하고, 손상되지 않고 정확해야 한다는 의미다.</p><p>그래서 데이터의 <strong>정확성, 일관성, 유효성</strong> 을 유지한다.</p><p>어떤 개발자가 동일한 데이터를 요청하면 동일한 값을 가진 데이터가 보내져야 한다.</p><p> </p><h2 id=12-안전성data-reliability>1.2 안전성(data reliability)<a hidden class=anchor aria-hidden=true href=#12-안전성data-reliability>#</a></h2><blockquote><p><strong><em>데이터를 보호해야한다는 원칙</em></strong></p></blockquote><p>db를 복제하든지, stand-by db를 대기해둔다든지, 인증/인가되지 않은 사용자로부터 <strong>데이터를 보호</strong> 하는 걸 말한다.</p><p> </p><h2 id=13-확장성scalability>1.3 확장성(scalability)<a hidden class=anchor aria-hidden=true href=#13-확장성scalability>#</a></h2><blockquote><p><strong><em>데이터 양이나 사용자가 늘어날 때 대비하기 위해 확장되는 성질</em></strong></p></blockquote><p>MySQL, Redis는 확장성이 좋지 않다.</p><p> </p><hr><h1 id=2-다양한-데이터베이스-종류-rdbms-vs-nosql>2. 다양한 데이터베이스 종류: RDBMS vs NoSQL<a hidden class=anchor aria-hidden=true href=#2-다양한-데이터베이스-종류-rdbms-vs-nosql>#</a></h1><blockquote><p><strong>- <em>DB의 종류: RDBMS(MySQL, PostgreSQL..), NoSQL(redis, MongoDB)</em></strong><br><strong>- <em>서비스에 적합한 DB 선택법: CAP Theorem</em></strong></p></blockquote><h2 id=21-rdbms>2.1 RDBMS<a hidden class=anchor aria-hidden=true href=#21-rdbms>#</a></h2><blockquote><p><strong><em>Ex: MySQL, Oracle, PostgreSQL&mldr;</em></strong></p></blockquote><ul><li><p>데이터를 row와 column으로 이뤄진 <strong>table의 형태</strong> 로 저장되기 때문에 <strong>데이터 무결성이 보장</strong> 된다. 그래서 만약 schema가 자주 변경되거나 column이 자주 변경되는 데이터는 RDBMS가 적합하지 않다.</p></li><li><p>그리고, 이 저장된 table로부터 <strong>SQL(Structured Query Language)</strong> 를 사용해서 데이터를 쉽게 읽어오거나 조작한다.</p></li><li><p>scale out이 아닌 scale up이 가능한 이유:</p><ul><li>여러 db를 서버에 나눠서 저장해도 <strong>table name이 중복될 수 없기 때문에</strong> scale up을 해야 한다. 하지만 이 특성으로 인해 분산 저장을 하지 않기 때문에 데이터 일관성이 잘 유지된다.</li></ul></li></ul><p> </p><h2 id=22-nosql>2.2 NoSQL<a hidden class=anchor aria-hidden=true href=#22-nosql>#</a></h2><blockquote><p><strong><em>Ex: key-value, graph, document</em></strong></p></blockquote><p>데이터가 저장되는 형태인 key-value, graph, document 에 따라 NoSQL 여러 종류로 나눠진다.</p><p>데이터가 저장되는 형태는 더 많지만 위 3가지가 대부분이므로 더 알아보지 않는다.</p><h3 id=221-key-value>2.2.1 key-value<a hidden class=anchor aria-hidden=true href=#221-key-value>#</a></h3><ul><li>key-value 쌍으로 데이터가 저장된다.</li><li>여기서 Key는 unique identifier로 사용되기 때문에 key는 중복되지 않는다. 그래서 추가하면 기존에 있던 key는 날라간다.</li><li>ex) redis, DynamoDB</li></ul><p><strong>[Redis]</strong></p><ul><li>cache로 사용: 자주 사용되는 쿼리 명령어를 캐쉬에 저장하여 바로 사용</li><li>docker나 쿠버네티스 상에 올릴 때 많이 사용</li><li>celery와도 많이 사용하여 message broker로서 pub/subscribe 에 보내진다.</li><li>❗️한계: 위 3가지 DB 원칙 중 확장성의 관점에서는 redis는 in-memory 기반으로 최대 RAM 크기까지만 확장이 가능하기 때문이다.( <strong>not scalable</strong> )</li></ul><p><strong>[DynamoDB in AWS]</strong>
<img loading=lazy src=https://d2908q01vomqb2.cloudfront.net/887309d048beef83ad3eabf2a79a64a389ab1c9f/2018/09/10/dynamodb-partition-key-1.gif alt=image></p><ul><li>최근에 많이 사용되고 있다.</li><li>redis와 달리 key가 partiton key(primary) 와 sort key(secondary, optional)로 나눠진다.<ul><li>partition key는 scale out으로 DB가 나눠졌을 때 값이 존재하는 위치를 나타낸다.</li></ul></li><li>장점: scalable → HA(High Availability), serverless</li></ul><p> </p><h3 id=222-graph>2.2.2 graph<a hidden class=anchor aria-hidden=true href=#222-graph>#</a></h3><blockquote><p><strong><em>데이터가 graph 형태로 저장되기 때문에, SNS 등 관계가 복잡한 상황에서 자주 사용된다.</em></strong></p><p><strong><em>ex) instagram, linkedin</em></strong></p></blockquote><ul><li>각 user를 node로 생각하고, node 간의 관계는 edge를 사용해서 나타낸다.</li><li>종류: Neo4j, OrientDB 등</li></ul><p> </p><h3 id=223-document>2.2.3 document<a hidden class=anchor aria-hidden=true href=#223-document>#</a></h3><blockquote><p><strong><em>데이터가 document 형태로 저장되서 구조가 자유롭다. ex) JSON 또는 XML 형태</em></strong></p></blockquote><p>MongoDB를 통해서 설명해보겠다.</p><p><img loading=lazy src=https://media.geeksforgeeks.org/wp-content/uploads/20200127193216/mongodb-nosql-working.jpg alt=image></p><p>MySQL과 비교하자면 Collections이 table이고, Documents가 table의 row라고 생각하면 된다.</p><ul><li>스키마를 만들 수 있지만, 형태가 스키마에서 떨어져도 자유롭게 저장할 수 있다.</li><li>그래서 이 DB는 블로그 같은 곳에 사용될 수 있다.</li><li>DB 별로 데이터를 조작할 수 있는 언어가 따로 있다.</li><li>종류: MongoDB, CassandraDB, Couchbase 등이 해당</li></ul><p> </p><hr><h1 id=3-db를-나누는-또-다른-기준-row-oriented-db-vs-column-oriented-db>3. DB를 나누는 또 다른 기준: row oriented db vs column oriented db<a hidden class=anchor aria-hidden=true href=#3-db를-나누는-또-다른-기준-row-oriented-db-vs-column-oriented-db>#</a></h1><p>DB를 나누는 또 다른 기준이 row-oriented 와 column-oriented가 있다.</p><h3 id=row-와-column-oriendtd에-따른-db-종류>row 와 column oriendtd에 따른 DB 종류<a hidden class=anchor aria-hidden=true href=#row-와-column-oriendtd에-따른-db-종류>#</a></h3><ul><li>row-oriented DB: MySQL, PostgreSQL, hbase</li><li>column-oriented DB: CassandraDB, hbase, Bigquery<ul><li>big query: 구글에서 만든 DB 엔진</li></ul></li></ul><h3 id=row와-column-oriented에-따른-read-insert-성능-차이>row와 column oriented에 따른 read, insert 성능 차이<a hidden class=anchor aria-hidden=true href=#row와-column-oriented에-따른-read-insert-성능-차이>#</a></h3><table><thead><tr><th></th><th>row oriented db</th><th>column oriented db</th></tr></thead><tbody><tr><td>read</td><td>느림</td><td>빠름</td></tr><tr><td>insert</td><td>빠름</td><td>느림</td></tr></tbody></table><h3 id=가정>가정<a hidden class=anchor aria-hidden=true href=#가정>#</a></h3><p>데이터가 아래 table처럼 저장되어 있다고 가정하자.</p><table><thead><tr><th>Name</th><th>City</th><th>Age</th></tr></thead><tbody><tr><td>James</td><td>Seoul</td><td>29</td></tr><tr><td>Kang</td><td>London</td><td>33</td></tr><tr><td>Mac</td><td>London</td><td>27</td></tr></tbody></table><p> </p><h2 id=31-row-oriented-db>3.1 Row oriented DB<a hidden class=anchor aria-hidden=true href=#31-row-oriented-db>#</a></h2><blockquote><p><strong><em>column으로 스키마가 정해져서 row가 원하는 데이터인 DB</em></strong></p></blockquote><p>그러면 Row oriented DB에 대해 알아보자.</p><h3 id=311-disk에-저장되는-형태>3.1.1 disk에 저장되는 형태<a hidden class=anchor aria-hidden=true href=#311-disk에-저장되는-형태>#</a></h3><p>row oriented DB의 저장 형태는 대략적으로 다음과 같다.</p><p>table의 각 row들이 disk에 저장될 때 한 줄로 저장된다.</p><p>| James | Seoul | 29 | Kang | London | 33 | Mac | London | 27 |</p><p>disk의 block에는 다음과 같이 각 row 들로 저장된다.</p><p>🔆 <a href="http://www.ktword.co.kr/test/view/view.php?m_temp1=4849">sector, block의 차이</a></p><ul><li><p>block 1</p><table><thead><tr><th>Name</th><th>City</th><th>Age</th></tr></thead><tbody><tr><td>James</td><td>Seoul</td><td>29</td></tr></tbody></table></li><li><p>block 2</p><table><thead><tr><th>Name</th><th>City</th><th>Age</th></tr></thead><tbody><tr><td>Kang</td><td>London</td><td>33</td></tr></tbody></table></li><li><p>block 3</p><table><thead><tr><th>Name</th><th>City</th><th>Age</th></tr></thead><tbody><tr><td>Mac</td><td>London</td><td>27</td></tr></tbody></table></li></ul><h3 id=312-추가>3.1.2 추가<a hidden class=anchor aria-hidden=true href=#312-추가>#</a></h3><blockquote><p><strong><em>row oriented db에서의 데이터 추가는 문제가 되지 않는다.</em></strong></p></blockquote><p>만약 row가 한 줄 추가된다면 table은 다음과 같이 한 줄 추가된다.</p><table><thead><tr><th>Name</th><th>City</th><th>Age</th></tr></thead><tbody><tr><td>James</td><td>Seoul</td><td>29</td></tr><tr><td>Kang</td><td>London</td><td>33</td></tr><tr><td>Mac</td><td>London</td><td>27</td></tr><tr><td>Paul</td><td>Chicago</td><td>22</td></tr></tbody></table><p>disk에는 다음과 같이 동일한 row의 맨 끝에 추가된다. 추가된 데이터는 bold 표시를 했다.</p><p>| James | Seoul | 29 | Kang | London | 33 | Mac | London | 27 | <strong>Paul</strong> | <strong>Chicago</strong> | <strong>22</strong> |</p><p>그래서 row oriented db에서의 데이터 추가는 간단하여 문제가 되지 않는다.</p><h3 id=313-조회>3.1.3 조회<a hidden class=anchor aria-hidden=true href=#313-조회>#</a></h3><blockquote><p><strong><em>조회하려는 속성 값에 대해 연속적으로 저장되지 않기 때문에 문제가 된다.</em></strong></p></blockquote><p>나이 관련된 데이터를 조회하고 싶을 때 row로 저장되기 때문에 나이 관련 데이터가 연속적이지 않아 조회하는 데 시간이 걸린다.</p><p>| James | Seoul | <strong>29</strong> | Kang | London | <strong>33</strong> | Mac | London | <strong>27</strong> |Paul | Chicago | <strong>22</strong> |</p><p>그래서 id가 auto increment여도 순서가 보장되지 않기 때문에 이를 위해서 row 기반 DB에서는 별도의 index 테이블을 사용한다.</p><p>🔆 즉, row oriented db에서의 최적화란 read를 어떻게 빠르게 할 것인가를 의미한다.</p><h3 id=314-삭제-후-추가>3.1.4 삭제 후 추가<a hidden class=anchor aria-hidden=true href=#314-삭제-후-추가>#</a></h3><blockquote><p><strong><em>데이터 삭제하여 생긴 빈 자리에 그대로 추가되기 때문에 데이터 순서가 보장되지 않는다. 그래서 DB에서는 &lsquo;인덱스&rsquo;라는 걸 생성하여 관리한다.</em></strong></p></blockquote><p>현재 table이 다음과 같다고 가정하자.</p><table><thead><tr><th>Name</th><th>City</th><th>Age</th></tr></thead><tbody><tr><td>James</td><td>Seoul</td><td>29</td></tr><tr><td>Kang</td><td>London</td><td>33</td></tr><tr><td>Mac</td><td>London</td><td>27</td></tr><tr><td>Paul</td><td>Chicago</td><td>22</td></tr></tbody></table><p>disk에는 다음과 같이 같이 한 줄로 이어서 저장되어 있다.</p><ul><li>| James | Seoul | 29 | Kang | London | 33 | Mac | London | 27 | Paul | Chicago | 22 |</li></ul><p>이런 상황에서 <strong>| Mac | London | 27 |</strong> 데이터가 삭제된다면 디스크에서는 어떻게 될까?</p><ul><li>| James | Seoul | 29 | Kang | London | 33 | <em><strong>|</strong></em> | ___ | Paul | Chicago | 22 |</li></ul><p>위와 같이 빈 자리가 생긴다.</p><p>그 다음 다른 데이터 <strong>| Mike | Shanghai | 43 |</strong> 이 추가되면 디스크에는 어떻게 저장되는 것일까?</p><p>뒤에 있는 | Paul | Chicago | 22 | 이 댕겨지면서 뒤에 저장될까? 아니면 빈 자리에 데이터가 그대로 추가될까?</p><p>바로 후자다.</p><p>그래서 <strong>row oriented db 는 db에 저장되는 순서를 보장하지 않는다.</strong> 이 특성으로 인해서 ORDER BY 로 정렬할 때, id의 경우 DB에서 별도로 인덱스라는 걸 생성하여 관리한다고 한다.</p><h3 id=추가할-때-빈-자리로-데이터를-shift하면-순서가-맞혀지지-않을까>❗️추가할 때, 빈 자리로 데이터를 shift하면 순서가 맞혀지지 않을까?<a hidden class=anchor aria-hidden=true href=#추가할-때-빈-자리로-데이터를-shift하면-순서가-맞혀지지-않을까>#</a></h3><p>이럴 경우, shift하는데 시간이 많이 걸리기 때문에 빈 자리에 바로 추가하는 게 낫다.</p><p> </p><h2 id=32-column-oriented-db>3.2 Column oriented DB<a hidden class=anchor aria-hidden=true href=#32-column-oriented-db>#</a></h2><blockquote><p><strong><em>row으로 스키마가 정해져서 column이 원하는 데이터인 DB</em></strong></p></blockquote><h3 id=321-disk에-저장되는-형태>3.2.1 disk에 저장되는 형태<a hidden class=anchor aria-hidden=true href=#321-disk에-저장되는-형태>#</a></h3><p>그리고, disk에는 다음과 같이 저장된다.</p><ul><li><p>block 1</p><table><thead><tr><th>Name</th><th></th><th></th></tr></thead><tbody><tr><td>James</td><td>Kang</td><td>Mac</td></tr></tbody></table></li><li><p>block 2</p><table><thead><tr><th>City</th><th></th><th></th></tr></thead><tbody><tr><td>Seoul</td><td>London</td><td>London</td></tr></tbody></table></li><li><p>block 3</p><table><thead><tr><th>Age</th><th></th><th></th></tr></thead><tbody><tr><td>29</td><td>33</td><td>27</td></tr></tbody></table></li></ul><h1 id=heading><a hidden class=anchor aria-hidden=true href=#heading>#</a></h1><h3 id=322-추가>3.2.2 추가<a hidden class=anchor aria-hidden=true href=#322-추가>#</a></h3><blockquote><p><strong><em>row 기반 db처럼 끝에 추가되는 게 아닌 &lsquo;데이터 사이에 추가 &rsquo; 되는 거라 오래 걸린다.</em></strong></p></blockquote><p>추가 되기 전 디스크에 저장된 형태는 다음과 같다.</p><ul><li>| James | Kang| Mac | Seoul | London | London | 29 | 33 | 27 |</li></ul><p>데이터가 추가되면 아래와 같은 순서로 데이터가 저장된다. 추가된 데이터는 bold 처리했다.</p><ul><li>| James | Kang| Mac | <strong>Paul</strong> | Seoul | London | London | <strong>Chicago</strong> | 29 | 33 | 27 | <strong>22</strong> |</li></ul><p>저장된 데이터의 순서를 보면 row oriented db와 달리 어떻게 저장되는지 이해할 수 있다.</p><h1 id=heading-1><a hidden class=anchor aria-hidden=true href=#heading-1>#</a></h1><h3 id=323-조회>3.2.3 조회<a hidden class=anchor aria-hidden=true href=#323-조회>#</a></h3><p>만약 내가 Age를 기준으로 데이터를 찾는다고 하면 row oriented db와 달리 조회하는 게 쉽다. 왜냐하면 아래와 같이 한 가지 column에 대해 한 디스크 위치에 저장되어 있기 때문이다.</p><p>bold 처리된 게 나이 관련 데이터다.</p><ul><li>| James | Kang| Mac |Paul | Seoul | London | London |Chicago | <strong>29</strong> | <strong>33</strong>| <strong>27</strong> | <strong>22</strong> |</li></ul><p>그래서 bigquery가 데이터 조회에서 MySQL보다 빠른 이유가 바로 이 때문이다.</p><p> </p><hr><h1 id=4-서비스에-적합한-데이터베이스-선택법>4. 서비스에 적합한 데이터베이스 선택법<a hidden class=anchor aria-hidden=true href=#4-서비스에-적합한-데이터베이스-선택법>#</a></h1><h2 id=41-cap-theorem>4.1 CAP Theorem<a hidden class=anchor aria-hidden=true href=#41-cap-theorem>#</a></h2><p><img loading=lazy src=https://user-images.githubusercontent.com/78094972/217833930-899a11e5-dcf0-463a-aeaf-8fc12f6fecb6.png alt=image></p><h2 id=consistency일관성>consistency(일관성)<a hidden class=anchor aria-hidden=true href=#consistency일관성>#</a></h2><ul><li>데이터베이스가 서버가 여러 개인 분산 데이터베이스 상에서 모든 node들이 데이터베이스 안에 <strong>같은 값을 가지고 있어야 하는 성질 (같은 정보를 공유하고 있어야하는 성질)</strong><ul><li>어떤 노드에게 요청을 보내도 상관없이 같은 데이터를 보여준다.</li></ul></li><li>하지만 request를 보내면 동기화를 위해서 해당 request가 delay 될 수 있다.</li><li>그래서 일관성의 목표는 데이터의 동기화가 충분히 빨라서 사용 상 문제가 없도록 하는 것이다.</li><li>금융 쪽에서는 이 일관성이 중요하다.<ul><li>송금 데이터가 데이터베이스 노드당 동기화되지 않으면 송금 안된 줄 알고 계속 보낸다.</li></ul></li><li>실생활에서 예시: 통신사 상담원에게 전화하여 집 주소를 변경하고 전화를 끊은 뒤 집 주소 중 일부가 잘못 전달된 걸 알고, 다시 전화하여 다른 상담원이 받을 지라도 변경된 내용을 정확히 알고 있는 상황</li></ul><h2 id=availability가용성>availability(가용성)<a hidden class=anchor aria-hidden=true href=#availability가용성>#</a></h2><ul><li>데이터베이스에 보내는 모든 request는 response를 반드시 받아야 하는 성질로, 시스템이 중단되는 일 없이 언제든지 사용 가능한 상태여야 한다.<ul><li>작업이 실패하더라도 사용자는 응답을 받을 수 있어야 한다.</li><li>consistency는 동기화 때문에 response가 바로 안온다.</li></ul></li><li>하지만 해당 response가 가장 최근 데이터라는 것을 보장받을 수 없다. 데이터가 일관되지 않아도 언제든지 접근할 수 있다.</li><li>접근하는 node에 따라 값이 다르다</li><li>E-commerce에서 중요</li><li>실생활에서 예시: 24시간 가능한 통신사 고객센터</li></ul><h2 id=partition-tolerance분할-허용성>partition-tolerance(분할 허용성)<a hidden class=anchor aria-hidden=true href=#partition-tolerance분할-허용성>#</a></h2><ul><li>DB node 간 소통이 불가능 하더라도 서비스는 정상적으로 작동하는 성질</li><li>데이터량이 매우 많을 때 중요</li><li>인스타그램 같은 SNS에서 중요</li><li>실생활에서 예시: 통신사 고객센터에 전화하여 문의를 하니 고객센터에서는 현재 본사와 통신할 수 없다고 한다. 하지만 고객센터는 정상적으로 운영된다.</li></ul><p> </p><h2 id=42-위-3가지를-다-가질-수-없는-이유>4.2 위 3가지를 다 가질 수 없는 이유<a hidden class=anchor aria-hidden=true href=#42-위-3가지를-다-가질-수-없는-이유>#</a></h2><p>서버가 s1과 s2로 나눠져 있는 상황이라고 하자.</p><h3 id=partition-tolerance가-없으면>partition-tolerance가 없으면??<a hidden class=anchor aria-hidden=true href=#partition-tolerance가-없으면>#</a></h3><blockquote><p><strong><em>consistency, availability 함께 지원된다.</em></strong></p></blockquote><ul><li>이 s1과 s2 사이에서 소통할 수가 없어서 데이터를 분산 저장할 수 없다.</li><li>그러면 한 서버로만 흘러가서 write / read를 수행하기 때문에 request를 보내면 바로 response를 받을 수 있고, 항상 동일한 데이터를 얻을 수 있다.</li></ul><h3 id=partition-tolerance가-있으면>partition-tolerance가 있으면?<a hidden class=anchor aria-hidden=true href=#partition-tolerance가-있으면>#</a></h3><blockquote><p><strong><em>consistency와 availability는 함께 지원되지 않는다.</em></strong></p></blockquote><p>서버가 끊겨도 계속해서 소통할 수 있다면?</p><ul><li><p>db가 consistency하다면 db에 요청을 보냈을 때, s1과 s2의 각 서버가 동기화 작업을 하느라 response가 느려지고, 사용자는 계속 기다려야 한다.</p><ul><li>쿠팡에서 탄산수를 주문했는데 바로 response가 오지 않는다. 왜냐하면 다른 서버에도 저장을 해야하기 때문이다.</li></ul></li><li><p>하지만 db가 consistency하지 않고, 데이터가 availability 하다면 write/read request를 했을 때 바로 response가 온다. 대신에 write한 데이터가 모든 서버에 동기화되지 않기 때문에, 어느 서버로 흘러가냐에 따라서 내가 요청한 write data가 안올 수 있다.</p></li></ul><p> </p><h2 id=43-예시>4.3 예시<a hidden class=anchor aria-hidden=true href=#43-예시>#</a></h2><h3 id=rdbms>RDBMS<a hidden class=anchor aria-hidden=true href=#rdbms>#</a></h3><p>RDBMS: Netflix (ex: MySQL)</p><ul><li>영상에 대한 정보를 저장하는 방식</li><li>데이터 분산은 잘 안되서 내가 write한 걸 잘 읽어올 수 있다.</li></ul><h3 id=nosql>NoSQL<a hidden class=anchor aria-hidden=true href=#nosql>#</a></h3><p>NoSQL: 인스타그램</p><ul><li><p>인스타그램은 availability를 굉장히 중요하게 생각한다.</p><ul><li>즉, 데이터가 write된 게 매우 중요하게 여겨서, 해당 사용자가 속한 노드에서 이 데이터가 저장되었는지가 중요하다. 왜냐하면 글이나 메세지는 작성된 게 남겨져야하기 때문이다.</li></ul></li><li><p>그리고 consistency를 중요하게 여기지 않는다.</p><ul><li>즉, 저장된 데이터가 다른 노드들에 복제되었는지는 그리 중요하지 않아서, 동기화를 바로 하지 않고 나중에 할 시간이 별도로 있다.</li></ul></li><li><p><a href=https://jasonkang14.github.io/database/cassandra-db>Cassandra DB 블로그</a>↗️</p></li></ul><p>그래서 각 도메인과 데이터 종류에 따라서 DB 선택을 잘 해야 한다.</p><p> </p><hr><h1 id=5-rdbms와-nosql-비교>5. RDBMS와 NoSQL 비교<a hidden class=anchor aria-hidden=true href=#5-rdbms와-nosql-비교>#</a></h1><table><thead><tr><th></th><th>RDBMS</th><th>NoSQL</th></tr></thead><tbody><tr><td>Data modeling 특징 1</td><td>스키마에 맞춰서 관리하기 때문에 데이터 정합성 보장</td><td>자유롭게 데이터를 관리할 수 있다.</td></tr><tr><td>어느 data가 해당</td><td>관계를 맺고 있는 데이터가 자주 변경되는 경우 해당</td><td>데이터 구조를 정확히 알 수 없고, 데이터가 변경/확장 되는 경우 해당</td></tr><tr><td>Scalability</td><td>Scale up</td><td>Scale out</td></tr><tr><td>Query Language</td><td>SQL(Structured Query Language)</td><td>문법이 조금 다름</td></tr><tr><td>Consistency</td><td>Strong</td><td>eventual consistency</td></tr><tr><td>flexibility</td><td>Not really</td><td>very flexible</td></tr></tbody></table><p>위 데이터 종류에 맞춰서 분리 적용한다.</p><ul><li>사용자 정보의 경우 스키마가 변하지 않기 때문에 RDBMS를 사용한다.</li></ul><h1 id=heading-2><a hidden class=anchor aria-hidden=true href=#heading-2>#</a></h1><h3 id=rdbms는-scale-out이-어려운-이유>RDBMS는 scale out이 어려운 이유<a hidden class=anchor aria-hidden=true href=#rdbms는-scale-out이-어려운-이유>#</a></h3><p>RDBMS는 위에서 언급한 대로 스키마에 맞춰서 데이터가 저장되기 때문에 중복이 어렵다. 이는 다르게 말하자면 테이블 간에 column을 통한 관계 형성이라는 제약 조건을 통해서 이뤄지고 있다. (그래서 데이터 모델링이 RDBMS에서는 중요하다.)</p><p>그래서 이런 제약조건을 모두 만족하면서 분류하여 나눠서 확장을 해야하므로 Nosql보다 더 어렵다. nosql은 각 객체를 분류하는 기준이 강하지 않기 때문이다. 즉 중복을 줄이기 위한 &ldquo;관계&rdquo; 로 인해서 확장하기가 어렵다.</p><h1 id=heading-3><a hidden class=anchor aria-hidden=true href=#heading-3>#</a></h1><h3 id=-scale-up-vs-scale-out>🔆 Scale up VS. Scale out<a hidden class=anchor aria-hidden=true href=#-scale-up-vs-scale-out>#</a></h3><p><img loading=lazy src=https://user-images.githubusercontent.com/78094972/217833521-8484166b-990a-4e8b-b3f9-7db94d40baec.png alt=image></p><ul><li>scale out의 단점: 데이터가 중복될 수 있다.</li></ul><hr><h1 id=reference>Reference<a hidden class=anchor aria-hidden=true href=#reference>#</a></h1><ul><li><a href=https://www.wanted.co.kr/events/pre_challenge_be_4>원티드 백엔드 챌린지 2월: MySQL &lsquo;잘&rsquo; 사용하기</a></li><li><a href=https://data-science-blog.com/blog/2021/10/14/cap-theorem/>Understanding NoSQL Databases by the CAP Theorem</a></li><li><a href=https://www.geeksforgeeks.org/what-is-mongodb-working-and-features/>What is MongoDB – Working and Features</a></li><li><a href="https://www.youtube.com/watch?v=uMkVi4SDLbM">How row oriented and column oriented db works?</a></li><li><a href=https://www.analyticsvidhya.com/blog/2020/08/a-beginners-guide-to-cap-theorem-for-data-engineering/>A Beginner’s Guide to CAP Theorem for Data Engineering</a></li><li><a href=https://onduway.tistory.com/106>CAP 이론 소개 - 데이터베이스 초보자용</a></li></ul></div><footer class=post-footer><ul class=post-tags><li><a href=http://jeha00.github.io/tags/db/>DB</a></li></ul><nav class=paginav><a class=prev href=http://jeha00.github.io/post/db/wanted/lecture_02/><span class=title>« Prev Page</span><br><span>MySQL storage engine의 종류들, Transaction, Database Lock, Isolation Level</span></a>
<a class=next href=http://jeha00.github.io/post/bookstudy/pythoncleancode/chapter08_commonpythongotchas/><span class=title>Next Page »</span><br><span>클린 코드, 이제는 파이썬이다: 파이썬에서 빠지기 쉬운 함정들(Common Python Gotchas)</span></a></nav><div class=share-buttons><a target=_blank rel="noopener noreferrer" aria-label="share DB 원칙과 종류 비교(RDBMS vs NoSQL, Row vs Column oriented) 그리고 CAP Theorem on twitter" href="https://twitter.com/intent/tweet/?text=DB%20%ec%9b%90%ec%b9%99%ea%b3%bc%20%ec%a2%85%eb%a5%98%20%eb%b9%84%ea%b5%90%28RDBMS%20vs%20NoSQL%2c%20Row%20vs%20Column%20oriented%29%20%ea%b7%b8%eb%a6%ac%ea%b3%a0%20CAP%20Theorem&url=http%3a%2f%2fjeha00.github.io%2fpost%2fdb%2fwanted%2flecture_01%2f&hashtags=DB"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM195.519 424.544c135.939.0 210.268-112.643 210.268-210.268.0-3.218.0-6.437-.153-9.502 14.406-10.421 26.973-23.448 36.935-38.314-13.18 5.824-27.433 9.809-42.452 11.648 15.326-9.196 26.973-23.602 32.49-40.92-14.252 8.429-30.038 14.56-46.896 17.931-13.487-14.406-32.644-23.295-53.946-23.295-40.767.0-73.87 33.104-73.87 73.87.0 5.824.613 11.494 1.992 16.858-61.456-3.065-115.862-32.49-152.337-77.241-6.284 10.881-9.962 23.601-9.962 37.088.0 25.594 13.027 48.276 32.95 61.456-12.107-.307-23.448-3.678-33.41-9.196v.92c0 35.862 25.441 65.594 59.311 72.49-6.13 1.686-12.72 2.606-19.464 2.606-4.751.0-9.348-.46-13.946-1.38 9.349 29.426 36.628 50.728 68.965 51.341-25.287 19.771-57.164 31.571-91.8 31.571-5.977.0-11.801-.306-17.625-1.073 32.337 21.15 71.264 33.41 112.95 33.41z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share DB 원칙과 종류 비교(RDBMS vs NoSQL, Row vs Column oriented) 그리고 CAP Theorem on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&url=http%3a%2f%2fjeha00.github.io%2fpost%2fdb%2fwanted%2flecture_01%2f&title=DB%20%ec%9b%90%ec%b9%99%ea%b3%bc%20%ec%a2%85%eb%a5%98%20%eb%b9%84%ea%b5%90%28RDBMS%20vs%20NoSQL%2c%20Row%20vs%20Column%20oriented%29%20%ea%b7%b8%eb%a6%ac%ea%b3%a0%20CAP%20Theorem&summary=DB%20%ec%9b%90%ec%b9%99%ea%b3%bc%20%ec%a2%85%eb%a5%98%20%eb%b9%84%ea%b5%90%28RDBMS%20vs%20NoSQL%2c%20Row%20vs%20Column%20oriented%29%20%ea%b7%b8%eb%a6%ac%ea%b3%a0%20CAP%20Theorem&source=http%3a%2f%2fjeha00.github.io%2fpost%2fdb%2fwanted%2flecture_01%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share DB 원칙과 종류 비교(RDBMS vs NoSQL, Row vs Column oriented) 그리고 CAP Theorem on reddit" href="https://reddit.com/submit?url=http%3a%2f%2fjeha00.github.io%2fpost%2fdb%2fwanted%2flecture_01%2f&title=DB%20%ec%9b%90%ec%b9%99%ea%b3%bc%20%ec%a2%85%eb%a5%98%20%eb%b9%84%ea%b5%90%28RDBMS%20vs%20NoSQL%2c%20Row%20vs%20Column%20oriented%29%20%ea%b7%b8%eb%a6%ac%ea%b3%a0%20CAP%20Theorem"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share DB 원칙과 종류 비교(RDBMS vs NoSQL, Row vs Column oriented) 그리고 CAP Theorem on facebook" href="https://facebook.com/sharer/sharer.php?u=http%3a%2f%2fjeha00.github.io%2fpost%2fdb%2fwanted%2flecture_01%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share DB 원칙과 종류 비교(RDBMS vs NoSQL, Row vs Column oriented) 그리고 CAP Theorem on whatsapp" href="https://api.whatsapp.com/send?text=DB%20%ec%9b%90%ec%b9%99%ea%b3%bc%20%ec%a2%85%eb%a5%98%20%eb%b9%84%ea%b5%90%28RDBMS%20vs%20NoSQL%2c%20Row%20vs%20Column%20oriented%29%20%ea%b7%b8%eb%a6%ac%ea%b3%a0%20CAP%20Theorem%20-%20http%3a%2f%2fjeha00.github.io%2fpost%2fdb%2fwanted%2flecture_01%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share DB 원칙과 종류 비교(RDBMS vs NoSQL, Row vs Column oriented) 그리고 CAP Theorem on telegram" href="https://telegram.me/share/url?text=DB%20%ec%9b%90%ec%b9%99%ea%b3%bc%20%ec%a2%85%eb%a5%98%20%eb%b9%84%ea%b5%90%28RDBMS%20vs%20NoSQL%2c%20Row%20vs%20Column%20oriented%29%20%ea%b7%b8%eb%a6%ac%ea%b3%a0%20CAP%20Theorem&url=http%3a%2f%2fjeha00.github.io%2fpost%2fdb%2fwanted%2flecture_01%2f"><svg viewBox="2 2 28 28"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></div></footer></article></main><footer class=footer><span>&copy; 2024 <a href=http://jeha00.github.io/>Jeha DevLog</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerText="copy";function s(){t.innerText="copied!",setTimeout(()=>{t.innerText="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>