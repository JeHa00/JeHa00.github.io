<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Docker study: Docker 학습을 위한 OS background knowledge | Jeha00 DevLog</title><meta name=keywords content="docker"><meta name=description content="Docker 학습을 시작하기에 앞서 Docker가 왜 필요한지, 컴퓨터 시스템의 핵심은 무엇이고, 운영체제는 무슨 역할을 하는지, process와 thread란 무엇인지, 메모리 구조는 어떻게 구성되어 있는지, 마지막으로 컨테이너에 대해 체험해본다."><meta name=author content><link rel=canonical href=http://jeha00.github.io/post/docker/01_os-for-docker/><meta name=google-site-verification content="XYZabc"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.min.1e44d58192cbf6d7a4eb649bc43dbc3d4cc432677e5d8adc69b08c34cbe461ac.css integrity="sha256-HkTVgZLL9tek62SbxD28PUzEMmd+XYrcabCMNMvkYaw=" rel="preload stylesheet" as=style><link rel=icon href=http://jeha00.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=http://jeha00.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=http://jeha00.github.io/favicon-32x32.png><link rel=apple-touch-icon href=http://jeha00.github.io/apple-touch-icon.png><link rel=mask-icon href=http://jeha00.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><meta name=generator content="Hugo 0.101.0"><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><script type=application/javascript>var doNotTrack=!1;doNotTrack||(function(e,t,n,s,o,i,a){e.GoogleAnalyticsObject=o,e[o]=e[o]||function(){(e[o].q=e[o].q||[]).push(arguments)},e[o].l=1*new Date,i=t.createElement(n),a=t.getElementsByTagName(n)[0],i.async=1,i.src=s,a.parentNode.insertBefore(i,a)}(window,document,"script","https://www.google-analytics.com/analytics.js","ga"),ga("create","UA-123-45","auto"),ga("send","pageview"))</script><meta property="og:title" content="Docker study: Docker 학습을 위한 OS background knowledge"><meta property="og:description" content="Docker 학습을 시작하기에 앞서 Docker가 왜 필요한지, 컴퓨터 시스템의 핵심은 무엇이고, 운영체제는 무슨 역할을 하는지, process와 thread란 무엇인지, 메모리 구조는 어떻게 구성되어 있는지, 마지막으로 컨테이너에 대해 체험해본다."><meta property="og:type" content="article"><meta property="og:url" content="http://jeha00.github.io/post/docker/01_os-for-docker/"><meta property="og:image" content="http://jeha00.github.io/47"><meta property="article:section" content="post"><meta property="article:published_time" content="2022-10-31T01:00:56+09:00"><meta property="article:modified_time" content="2022-10-31T01:00:56+09:00"><meta property="og:site_name" content="JeHa00 DevLog"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="http://jeha00.github.io/47"><meta name=twitter:title content="Docker study: Docker 학습을 위한 OS background knowledge"><meta name=twitter:description content="Docker 학습을 시작하기에 앞서 Docker가 왜 필요한지, 컴퓨터 시스템의 핵심은 무엇이고, 운영체제는 무슨 역할을 하는지, process와 thread란 무엇인지, 메모리 구조는 어떻게 구성되어 있는지, 마지막으로 컨테이너에 대해 체험해본다."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"http://jeha00.github.io/post/"},{"@type":"ListItem","position":2,"name":"Docker study: Docker 학습을 위한 OS background knowledge","item":"http://jeha00.github.io/post/docker/01_os-for-docker/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Docker study: Docker 학습을 위한 OS background knowledge","name":"Docker study: Docker 학습을 위한 OS background knowledge","description":"Docker 학습을 시작하기에 앞서 Docker가 왜 필요한지, 컴퓨터 시스템의 핵심은 무엇이고, 운영체제는 무슨 역할을 하는지, process와 thread란 무엇인지, 메모리 구조는 어떻게 구성되어 있는지, 마지막으로 컨테이너에 대해 체험해본다.","keywords":["docker"],"articleBody":"0. Introduction 해당 강의는 러닝스푼즈 - 나노디그리 Python \u0026 Django backed course의 장철원 강사님의 docker 강의를 학습한 내용입니다.\ndocker는 운영체제와 많이 연관되어 있어서, docker를 잘 사용하고 한다면 운영체제에 대해 자세히 알아야 한다. 하지만, 많은 개발자들이 운영체제를 깊이 이해하지 못하여 docker를 잘 사용하지 못하는 상황이라고 한다.\n1. 컴퓨터 시스템 서버의 용량이 가득찼을 때 할 수 있는 해결책 2가지: scale up \u0026 out\n해결책 1: Scale up 장점: 더 고사양의 서버를 사용하여 1대로 운영가능 단점: 한번 먹통이 되면 서비스가 중단 가능성 있음 해결책 2: Scale out 수많은 서버에 프로그램을 배포하는 방식 서버를 1대에서 3대로 늘렸다고 생각을 했을 때, 3대에 배포를 다 해야한다. 문제점: 그러면 우리가 올리는 프로젝트가 다 제대로 올라갈 수 있을까? 그렇지 않다… 왜냐하면 사람의 컴퓨터 환경에 따라 다르기 때문이다. 10대 ~ 20대로 늘어나면 더 많은 어려움이 존재한다. 그래서 어떻게 보면 운이 기대야하는 문제점이다. 해결책 2 문제점의 해결책: docker docker를 사용하고 나서 위 문제점이 해결되었다. 2. 좁은 의미의 컴퓨터 컴퓨터란? compute라는 어원이 시작된 것으로 computer 계산하는 기계를 의미한다. 여기서 ‘계산’이란 우리가 생각하는 산수가 아닌 좀더 포괄적인 의미다. 좁은 의미의 컴퓨터: CPU + RAM 컴퓨터를 열었을 때 main board에 있는 CPU와 RAM이 제일 중요하다.\nCPU\n계산을 담당하는게 CPU CPU가 좋아질수록 처리속도가 그만큼 빠르다 RAM\n노트에 수학문제에 대한 풀이를 적어놓는데, 이 풀이는 머리에서 처리한 결과를 잠깐 적어놓은 것이다. 그러면 왜 적어놓을까? 이를 기억하면서 풀 수 없기 때문이다. 내 두뇌를 이용해서 문제를 풀고 있지만 노트라는 보조장치를 이용해서 더 손쉬운 풀이를 가능하게 만들어준다. RAM을 바로 이 용도로 생각하자. 보조장치\n좁은 의미의 컴퓨터는 CPU와 RAM을 합친거라고 보면 되고 나머지는 보조 장치라 할 수 있다. 입출력 장치\n키보드, 마우스, 모니터 보조 기억 장치 (HDD, SSD)\nRAM도 사실상 용량이 그렇게 크지 않기 때문에 보조 기억 장치를 사용 3. 운영체제 개념 컴퓨터는 하드웨어와 소프트웨어로 구성되어 있다. 그리고 이 소프트웨어는 User application과 OS로 구성되어 있다.\n하드웨어 : 마우스, 키보드 실제로 존재하는 컴퓨터를 구성하는 장치 소프트웨어 : 눈으로는 볼 수 있지만 손으로는 만질 수 없는 것들 이 OS를 또 쪼개면 kernel, OS 라이브러리, OS 외 라이브러리로 구성된다.\n전원이 켜지면? 전원이 켜지면 이 kernel이 보조기억장치에서 RAM으로 올라간다. 이 커널도 하나의 코드이고, 하드디스크에 존재한다.\n컴퓨터 전원을 종료할 때까지 메모리에 올라가 있다.\n만약 이상한 에러가 있을 때 컴퓨터를 껏다키면 에러가 해결이 될 때가 있는데 커널이 메모리에 올라가있는 순간 발생한 문제들이 초기화됨\nshell이란? 커널과 사용자 간 다리 역할을 하는 프로그램으로, 이 shell을 사용하여 사용자는 운영체제와 상호작용이 가능하다.\n종류: bash, zsh 운영체제의 기능 프로세서, 기억장치, 파일 정보 등 자원 관리 자원을 효율적으로 관리하기 위해 스케쥴링 기능 제공 여러 명령어 중 무엇을 먼저 처리할 지 일정을 짜주는것 사용자와 시스템 간 편리한 인터페이스 제공 하드웨어와 네트워크 관리 프로그램이 실행될 수 있는 환경 제공 운영체제가 제공하는 서비스 프로그램 실행\n프로그램을 메모리에 올리고 실행 하는게 가능 I/O 운영(operations)\n프로그램을 실행할 때는 파일이나 I/O 디바이스와 같은 I / O이 요구 될 수 있다. 예를 들어 네트워크 인터페이스로부터 무언가를 읽는다거나 파일 시스템에 무언가를 쓸때 특정 디바이스의 특정 기능이 요구될 수 있다. 효율성을 위해 이는 유저가 직접 I/O 디바이스를 컨트롤 할 수는 없고, 이는 운영 체제가 담당한다. 파일 시스템\n프로그램은 파일이나 디렉토리를 읽거나 써야할 때가 있음 파일이나 디렉토리의 이름을 짓거나 특정 파일을 검색할 때도 잇음 커뮤니케이션\n프로세스들끼리 정보를 교환해야하는 경우가 있는데 이처럼 프로세스들 간의 커뮤니케이션이나 네트워크를 이용해서 서로 다른 컴퓨터가 커뮤니케이션 해야할 경우가 있다. 이 경우 커뮤니케이션은 shared memory를 이용하는데 이때 shared memory에 데이터를 읽고 쓰는 일을 운영체제가 담당한다. resource allocation(할당)\n다수의 프로세스가 동시에 실행될 때 운영체제는 각 프로세스에 자원을 할당하는 역할을 한다. 이때 자원이라는 것은 CPU, memory, storage같은 것을 의미한다. 4. Process와 Thread 프로그램(program) 프로그램이란? 실행 가능한 명령어의 집합\n프로그램은 하드디스크와 같은 저장 장치에 저장되어 있지만 메모리에는 올라가지 않은 정적인 상태\n프로그램은 메모리가 아닌 디스크에 존재한다.\n결론적으로 실행을 하지 않은 코드를 즉 프로그램이라고 한다. 컴파일된 바이너리 이미지 형태 or 파이썬 스크립트 같이 인터프리터 형태\n디스크에 저장된 실행 가능한 명령어의 집합이기만 하면 프로그램 컴파일러와 인터프리터 컴파일러(compiler)\n원시 코드 → 컴파일 언어 → 목적코드 원시 코드를 목적 코드로 변환해주는 것 실행속도는 빠르지만, 배우기는 어렵다 ex) C, JAVA 인터프리터(interpreter)\n한꺼번에 컴파일 단계를 거치는 컴파일 언어와 다르게 한줄 한줄 실행 실행속도가 느리지만, 배우기는 빠르다 Process 실행 중인 프로그램\n하드디스크에 있는 프로그램을 메모리(RAM) 상에 올린 것\n실상 프로그램을 여러개 사용했다라고 하는 건 프로그램이 아닌 프로세스를 여러개 돌리는 것이다. 그래서 프로세스를 너무 많이 사용하게 되면 더 이상의 프로그램(프로세스)를 띄울 수가 없다. 왜냐하면 RAM을 다 사용했기 때문이다.\nThread 프로세스가 할당 받은 자원을 이용하는 실행단위이자 프로세스 내에 실행되는 여러 흐름의 단위\n프로세스는 최소 한 개 이상의 쓰레드를 가짐, 이를 메인 쓰레드(main thread)라고 한다.\n쓰레드는 독자적인 스택 메모리를 가진다.\n프로세스는 쓰레드의 컨테이너이다. 프로세스는 쓰레드의 정보를 담고 있는 것에 불과하다.\n쓰레드 예시(웹 브라우저의 경우)\n하나의 쓰레드는 이미지와 텍스트를 보여주는 일을 수행 다른 쓰레드는 네트워크 상의 데이터를 가져오는 일을 수행 🔆 파이썬에서 멀티쓰레드가 존재하니까 여유가 생기면 공부해보자!\n5. 메모리 구조 Kernel space 우리가 컴퓨터를 실행하는 순간 커널 스페이스에 커널이 올라간다. 어떤걸 하더라고 커널 스페이스에는 프로세스를 못올린다. Process의 메모리 상에서 4가지 구조 메모리에 올라간 프로세스는 Stack - Heap - Data - Code 구조를 가진다. Stack 방향으로 갈수록 높은 메모리 주소를 가지며, code 방향으로 갈수록 낮은 메모리 주소를 가진다. 🔆 Stack 지역변수, 매개변수, 함수 리턴값 - 위에서 아래로 쌓인다. (높은 메모리 주소 -\u003e 낮은 메모리 주소 방향으로 할당)\n지역 변수(local variable) 저장 매개 변수(parameter) 저장 함수 호출과 함께 할당 함수 호출이 종료되면 소멸 재귀 함수처럼 무한정 반복되는 함수 호출시 stack overflow 문제 발생 해킹 시에는 일부러 stack overflow를 만들어서 들어간다. 🔆 Heap 동적 할당 데이터 stack과 반대방향으로 쌓인다. (낮은 메모리 주소 -\u003e 높은 메모리 주소 방향으로 할당)\n사용자가 직접 관리하는 영역\nC언어에서는 사용자가 직접 입력하고, 지정하여 지정한 것만 사용한다. 그래서 지우는 것도 사용자가 직접 한다. 하지만 java에서는 java가 heap 할당을 해주기 때문에, garbage collector가 필요하다. 사용자에 의해 메모리 할당 및 해제\nC언어에서 malloc 명령어를 수행했을 때 메모리가 할당되는 곳\n자바에서 가비지 컬렉션을 할 때, 정리되는 영역\nData 전역변수, 정적변수\n전역변수 (global), 정적 변수(static)를 저장 프로세스 시작과 함께 할당 프로세스 종료와 함께 소멸 Code 코드, 함수, 제어문\n실행할 프로그램의 소스 코드가 저장되는 곳 그래서 텍스트(text) 영역이라고도 한다. CPU는 코드 영역에 저장된 명령어를 하나씩 가져가서 처리한다. 6. Namespace 프로세스를 실행할 때 시스템 리소스를 분리해서 실행할 수 있도록 도와주는 기능\n네임스페이스는 컨테이너 개념과 이어진다. namespace의 종료와 역할 네임스페이스 의미 역할 pid PID: Process ID 리눅스 커널의 프로세스 ID 분리 net NET: Networking 네트워크 인터페이스(NET) 관리 ipc IPC: Inter Process Communication 프로세스 간 통신(IPC) 접근 관리 mnt MNT: Mount 파일 시스템의 마운트 관리 uts UTX: Unix Timesharing System 커널과 버전 식별자 분리 실습 EC2 로그인 후, work directory를 생성한다. 그 안에 test directory 생성 ls -al 또는 ll 입력하여 확인하기 프로그램 생성하기 vim 으로 아무 파일 생성하기 ex) vi while_loop.py 프로그램 실행하기 python while_loop.py \u0026\n\u0026의 의미는 백그라운드 실행한다는 의미다. 그러면 다음과 같은 값이 뜬다. [1] 25514 이는 PID 를 의미한다. 다음으로 ps -ef | grep while_loop을 입력하면 다음과 같이 뜬다.\n1 2 3 #UID PID PPID C STIME TTY CMD ubuntu 25514 25390 99 10:14 pts/0 00:01:03 python3 while_loop.py ubuntu 25522 25390 0 10:15 pts/0 00:00:00 grep --color=auto while_loop 프로그램을 담고 있는 컨테이너 확인하기 프로세스는 쓰레드를 담고 있는 컨테이너라고 했는데, 위 PID를 담고 있는 컨테이너를 확인해보자. ls /proc를 실행하면 여러 목록들이 나오는데 거기서 25514를 확인할 수 있다. ls /proc/25514 를 입력하면 여러 파일 목록들이 나온다. /proc/25514는 프로그램이 실행하는 동안 이 프로그램을 닫고 있는 컨테이너를 말한다. 프로그램 종료 시키기 만약 실행한 프로그램을 종료시키면 위에 생성된 /proc/25514는 사라진다. 명령어: kill -9 25514 PID를 입력할 때는 복붙해서 한다. 1 2 ubuntu 25543 25390 0 10:25 pts/0 00:00:00 grep --color=auto while_loop [1]+ Killed python3 while_loop.py ❗️ root 계정이 아닌 사용자 추가하여 사용하기\nReference 러닝스푼즈 - 나노디그리 Python \u0026 Django backed course의 ","wordCount":"1199","inLanguage":"en","datePublished":"2022-10-31T01:00:56+09:00","dateModified":"2022-10-31T01:00:56+09:00","mainEntityOfPage":{"@type":"WebPage","@id":"http://jeha00.github.io/post/docker/01_os-for-docker/"},"publisher":{"@type":"Organization","name":"Jeha00 DevLog","logo":{"@type":"ImageObject","url":"http://jeha00.github.io/favicon.ico"}}}</script></head><body class=dark id=top><script>localStorage.getItem("pref-theme")==="light"&&document.body.classList.remove("dark")</script><header class=header><nav class=nav><div class=logo><a href=http://jeha00.github.io/ accesskey=h title="Jeha00 (Alt + H)">Jeha00</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></span></div><ul id=menu><li><a href=http://jeha00.github.io/about/ title=About><span>About</span></a></li><li><a href=http://jeha00.github.io/projects/ title=Project><span>Project</span></a></li><li><a href=http://jeha00.github.io/archives/ title=Archive><span>Archive</span></a></li><li><a href=http://jeha00.github.io/categories/ title=Categories><span>Categories</span></a></li><li><a href=http://jeha00.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=http://jeha00.github.io/>Home</a>&nbsp;»&nbsp;<a href=http://jeha00.github.io/post/>Posts</a></div><h1 class=post-title>Docker study: Docker 학습을 위한 OS background knowledge</h1><div class=post-meta><span title='2022-10-31 01:00:56 +0900 KST'>October 31, 2022</span>&nbsp;|&nbsp;<a href=https://github.com/JeHa00/blog/content/post/Docker/01_os-for-docker.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#0-introduction aria-label="0. Introduction">0. Introduction</a></li><li><a href=#1-%ec%bb%b4%ed%93%a8%ed%84%b0-%ec%8b%9c%ec%8a%a4%ed%85%9c aria-label="1. 컴퓨터 시스템">1. 컴퓨터 시스템</a><ul><ul><li><a href=#%ed%95%b4%ea%b2%b0%ec%b1%85-1-scale-up aria-label="해결책 1: Scale up">해결책 1: Scale up</a></li><li><a href=#%ed%95%b4%ea%b2%b0%ec%b1%85-2-scale-out aria-label="해결책 2: Scale out">해결책 2: Scale out</a></li><li><a href=#%ed%95%b4%ea%b2%b0%ec%b1%85-2-%eb%ac%b8%ec%a0%9c%ec%a0%90%ec%9d%98-%ed%95%b4%ea%b2%b0%ec%b1%85-docker aria-label="해결책 2 문제점의 해결책: docker">해결책 2 문제점의 해결책: docker</a></li></ul></ul></li><li><a href=#2-%ec%a2%81%ec%9d%80-%ec%9d%98%eb%af%b8%ec%9d%98-%ec%bb%b4%ed%93%a8%ed%84%b0 aria-label="2. 좁은 의미의 컴퓨터">2. 좁은 의미의 컴퓨터</a><ul><ul><li><a href=#%ec%bb%b4%ed%93%a8%ed%84%b0%eb%9e%80 aria-label=컴퓨터란?>컴퓨터란?</a></li><li><a href=#%ec%a2%81%ec%9d%80-%ec%9d%98%eb%af%b8%ec%9d%98-%ec%bb%b4%ed%93%a8%ed%84%b0-cpu--ram aria-label="좁은 의미의 컴퓨터: CPU + RAM">좁은 의미의 컴퓨터: CPU + RAM</a></li></ul></ul></li><li><a href=#3-%ec%9a%b4%ec%98%81%ec%b2%b4%ec%a0%9c-%ea%b0%9c%eb%85%90 aria-label="3. 운영체제 개념">3. 운영체제 개념</a><ul><ul><li><a href=#%ec%a0%84%ec%9b%90%ec%9d%b4-%ec%bc%9c%ec%a7%80%eb%a9%b4 aria-label="전원이 켜지면?">전원이 켜지면?</a></li><li><a href=#shell%ec%9d%b4%eb%9e%80 aria-label=shell이란?>shell이란?</a></li><li><a href=#%ec%9a%b4%ec%98%81%ec%b2%b4%ec%a0%9c%ec%9d%98-%ea%b8%b0%eb%8a%a5 aria-label="운영체제의 기능">운영체제의 기능</a></li><li><a href=#%ec%9a%b4%ec%98%81%ec%b2%b4%ec%a0%9c%ea%b0%80-%ec%a0%9c%ea%b3%b5%ed%95%98%eb%8a%94-%ec%84%9c%eb%b9%84%ec%8a%a4 aria-label="운영체제가 제공하는 서비스">운영체제가 제공하는 서비스</a></li></ul></ul></li><li><a href=#4-process%ec%99%80-thread aria-label="4. Process와 Thread">4. Process와 Thread</a><ul><ul><li><a href=#%ed%94%84%eb%a1%9c%ea%b7%b8%eb%9e%a8program aria-label=프로그램(program)>프로그램(program)</a></li><li><a href=#%ec%bb%b4%ed%8c%8c%ec%9d%bc%eb%9f%ac%ec%99%80-%ec%9d%b8%ed%84%b0%ed%94%84%eb%a6%ac%ed%84%b0 aria-label="컴파일러와 인터프리터">컴파일러와 인터프리터</a></li><li><a href=#process aria-label=Process>Process</a></li><li><a href=#thread aria-label=Thread>Thread</a></li></ul></ul></li><li><a href=#5-%eb%a9%94%eb%aa%a8%eb%a6%ac-%ea%b5%ac%ec%a1%b0 aria-label="5. 메모리 구조">5. 메모리 구조</a><ul><li><a href=#kernel-space aria-label="Kernel space">Kernel space</a></li><li><a href=#process%ec%9d%98-%eb%a9%94%eb%aa%a8%eb%a6%ac-%ec%83%81%ec%97%90%ec%84%9c-4%ea%b0%80%ec%a7%80-%ea%b5%ac%ec%a1%b0 aria-label="Process의 메모리 상에서 4가지 구조">Process의 메모리 상에서 4가지 구조</a></li><li><a href=#-stack aria-label="🔆 Stack">🔆 Stack</a></li><li><a href=#-heap aria-label="🔆 Heap">🔆 Heap</a></li><li><a href=#data aria-label=Data>Data</a></li><li><a href=#code aria-label=Code>Code</a></li></ul></li><li><a href=#6-namespace aria-label="6. Namespace">6. Namespace</a><ul><ul><li><a href=#namespace%ec%9d%98-%ec%a2%85%eb%a3%8c%ec%99%80-%ec%97%ad%ed%95%a0 aria-label="namespace의 종료와 역할">namespace의 종료와 역할</a></li></ul><li><a href=#%ec%8b%a4%ec%8a%b5 aria-label=실습>실습</a><ul><li><a href=#%ed%94%84%eb%a1%9c%ea%b7%b8%eb%9e%a8-%ec%83%9d%ec%84%b1%ed%95%98%ea%b8%b0 aria-label="프로그램 생성하기">프로그램 생성하기</a></li><li><a href=#%ed%94%84%eb%a1%9c%ea%b7%b8%eb%9e%a8-%ec%8b%a4%ed%96%89%ed%95%98%ea%b8%b0 aria-label="프로그램 실행하기">프로그램 실행하기</a></li><li><a href=#%ed%94%84%eb%a1%9c%ea%b7%b8%eb%9e%a8%ec%9d%84-%eb%8b%b4%ea%b3%a0-%ec%9e%88%eb%8a%94-%ec%bb%a8%ed%85%8c%ec%9d%b4%eb%84%88-%ed%99%95%ec%9d%b8%ed%95%98%ea%b8%b0 aria-label="프로그램을 담고 있는 컨테이너 확인하기">프로그램을 담고 있는 컨테이너 확인하기</a></li><li><a href=#%ed%94%84%eb%a1%9c%ea%b7%b8%eb%9e%a8-%ec%a2%85%eb%a3%8c-%ec%8b%9c%ed%82%a4%ea%b8%b0 aria-label="프로그램 종료 시키기">프로그램 종료 시키기</a></li></ul></li></ul></li><li><a href=#reference aria-label=Reference>Reference</a></li></ul></div></details></div><div class=post-content><h1 id=0-introduction>0. Introduction<a hidden class=anchor aria-hidden=true href=#0-introduction>#</a></h1><ul><li><p>해당 강의는 <a href=https://learningspoons.com/course/detail/django-backend/>러닝스푼즈 - 나노디그리 Python & Django backed course</a>의 장철원 강사님의 docker 강의를 학습한 내용입니다.</p></li><li><p>docker는 운영체제와 많이 연관되어 있어서, docker를 잘 사용하고 한다면 운영체제에 대해 자세히 알아야 한다. 하지만, 많은 개발자들이 운영체제를 깊이 이해하지 못하여 docker를 잘 사용하지 못하는 상황이라고 한다.</p></li></ul><hr><h1 id=1-컴퓨터-시스템>1. 컴퓨터 시스템<a hidden class=anchor aria-hidden=true href=#1-컴퓨터-시스템>#</a></h1><p>서버의 용량이 가득찼을 때 할 수 있는 해결책 2가지: scale up & out</p><h3 id=해결책-1-scale-up>해결책 1: Scale up<a hidden class=anchor aria-hidden=true href=#해결책-1-scale-up>#</a></h3><ul><li>장점: 더 고사양의 서버를 사용하여 1대로 운영가능</li><li>단점: 한번 먹통이 되면 서비스가 중단 가능성 있음</li></ul><h3 id=해결책-2-scale-out>해결책 2: Scale out<a hidden class=anchor aria-hidden=true href=#해결책-2-scale-out>#</a></h3><ul><li>수많은 서버에 프로그램을 배포하는 방식<ul><li>서버를 1대에서 3대로 늘렸다고 생각을 했을 때, 3대에 배포를 다 해야한다.</li></ul></li><li>문제점: 그러면 우리가 올리는 프로젝트가 다 제대로 올라갈 수 있을까? 그렇지 않다… 왜냐하면 사람의 컴퓨터 환경에 따라 다르기 때문이다.<ul><li>10대 ~ 20대로 늘어나면 더 많은 어려움이 존재한다.</li><li>그래서 어떻게 보면 운이 기대야하는 문제점이다.</li></ul></li></ul><h3 id=해결책-2-문제점의-해결책-docker>해결책 2 문제점의 해결책: docker<a hidden class=anchor aria-hidden=true href=#해결책-2-문제점의-해결책-docker>#</a></h3><ul><li>docker를 사용하고 나서 위 문제점이 해결되었다.</li></ul><hr><h1 id=2-좁은-의미의-컴퓨터>2. 좁은 의미의 컴퓨터<a hidden class=anchor aria-hidden=true href=#2-좁은-의미의-컴퓨터>#</a></h1><h3 id=컴퓨터란>컴퓨터란?<a hidden class=anchor aria-hidden=true href=#컴퓨터란>#</a></h3><ul><li>compute라는 어원이 시작된 것으로 computer 계산하는 기계를 의미한다.</li><li>여기서 ‘계산’이란 우리가 생각하는 산수가 아닌 좀더 포괄적인 의미다.</li></ul><h3 id=좁은-의미의-컴퓨터-cpu--ram>좁은 의미의 컴퓨터: CPU + RAM<a hidden class=anchor aria-hidden=true href=#좁은-의미의-컴퓨터-cpu--ram>#</a></h3><p>컴퓨터를 열었을 때 main board에 있는 CPU와 RAM이 제일 중요하다.</p><ul><li><p>CPU</p><ul><li>계산을 담당하는게 CPU</li><li>CPU가 좋아질수록 처리속도가 그만큼 빠르다</li></ul></li><li><p>RAM</p><ul><li>노트에 수학문제에 대한 풀이를 적어놓는데, 이 풀이는 머리에서 처리한 결과를 잠깐 적어놓은 것이다.</li><li>그러면 왜 적어놓을까? 이를 기억하면서 풀 수 없기 때문이다.</li><li>내 두뇌를 이용해서 문제를 풀고 있지만 노트라는 보조장치를 이용해서 더 손쉬운 풀이를 가능하게 만들어준다.</li><li>RAM을 바로 이 용도로 생각하자.</li></ul></li><li><p>보조장치</p><ul><li>좁은 의미의 컴퓨터는 CPU와 RAM을 합친거라고 보면 되고 나머지는 보조 장치라 할 수 있다.</li></ul></li><li><p>입출력 장치</p><ul><li>키보드, 마우스, 모니터</li></ul></li><li><p>보조 기억 장치 (HDD, SSD)</p><ul><li>RAM도 사실상 용량이 그렇게 크지 않기 때문에 보조 기억 장치를 사용</li></ul></li></ul><hr><h1 id=3-운영체제-개념>3. 운영체제 개념<a hidden class=anchor aria-hidden=true href=#3-운영체제-개념>#</a></h1><p>컴퓨터는 하드웨어와 소프트웨어로 구성되어 있다. 그리고 이 소프트웨어는 User application과 OS로 구성되어 있다.</p><ul><li>하드웨어 : 마우스, 키보드 실제로 존재하는 컴퓨터를 구성하는 장치</li><li>소프트웨어 : 눈으로는 볼 수 있지만 손으로는 만질 수 없는 것들</li></ul><p>이 OS를 또 쪼개면 kernel, OS 라이브러리, OS 외 라이브러리로 구성된다.</p><h3 id=전원이-켜지면>전원이 켜지면?<a hidden class=anchor aria-hidden=true href=#전원이-켜지면>#</a></h3><p>전원이 켜지면 이 kernel이 보조기억장치에서 RAM으로 올라간다. 이 커널도 하나의 코드이고, 하드디스크에 존재한다.</p><p>컴퓨터 전원을 종료할 때까지 메모리에 올라가 있다.</p><p>만약 이상한 에러가 있을 때 컴퓨터를 껏다키면 에러가 해결이 될 때가 있는데 커널이 메모리에 올라가있는 순간 발생한 문제들이 초기화됨</p><h3 id=shell이란>shell이란?<a hidden class=anchor aria-hidden=true href=#shell이란>#</a></h3><blockquote><p>커널과 사용자 간 다리 역할을 하는 프로그램으로, 이 shell을 사용하여 사용자는 운영체제와 상호작용이 가능하다.</p></blockquote><ul><li>종류: bash, zsh</li></ul><h3 id=운영체제의-기능>운영체제의 기능<a hidden class=anchor aria-hidden=true href=#운영체제의-기능>#</a></h3><ul><li>프로세서, 기억장치, 파일 정보 등 자원 관리</li><li>자원을 효율적으로 관리하기 위해 스케쥴링 기능 제공<ul><li>여러 명령어 중 무엇을 먼저 처리할 지 일정을 짜주는것</li></ul></li><li>사용자와 시스템 간 편리한 인터페이스 제공</li><li>하드웨어와 네트워크 관리</li><li>프로그램이 실행될 수 있는 환경 제공</li></ul><h3 id=운영체제가-제공하는-서비스>운영체제가 제공하는 서비스<a hidden class=anchor aria-hidden=true href=#운영체제가-제공하는-서비스>#</a></h3><ul><li><p>프로그램 실행</p><ul><li>프로그램을 메모리에 올리고 실행 하는게 가능</li></ul></li><li><p>I/O 운영(operations)</p><ul><li>프로그램을 실행할 때는 파일이나 I/O 디바이스와 같은 I / O이 요구 될 수 있다.</li><li>예를 들어 네트워크 인터페이스로부터 무언가를 읽는다거나 파일 시스템에 무언가를 쓸때 특정 디바이스의 특정 기능이 요구될 수 있다. 효율성을 위해 이는 유저가 직접 I/O 디바이스를 컨트롤 할 수는 없고, 이는 운영 체제가 담당한다.</li></ul></li><li><p>파일 시스템</p><ul><li>프로그램은 파일이나 디렉토리를 읽거나 써야할 때가 있음</li><li>파일이나 디렉토리의 이름을 짓거나 특정 파일을 검색할 때도 잇음</li></ul></li><li><p>커뮤니케이션</p><ul><li>프로세스들끼리 정보를 교환해야하는 경우가 있는데 이처럼 프로세스들 간의 커뮤니케이션이나 네트워크를 이용해서 서로 다른 컴퓨터가 커뮤니케이션 해야할 경우가 있다. 이 경우 커뮤니케이션은 shared memory를 이용하는데 이때 shared memory에 데이터를 읽고 쓰는 일을 운영체제가 담당한다.</li></ul></li><li><p>resource allocation(할당)</p><ul><li>다수의 프로세스가 동시에 실행될 때 운영체제는 각 프로세스에 자원을 할당하는 역할을 한다.</li><li>이때 자원이라는 것은 CPU, memory, storage같은 것을 의미한다.</li></ul></li></ul><hr><h1 id=4-process와-thread>4. Process와 Thread<a hidden class=anchor aria-hidden=true href=#4-process와-thread>#</a></h1><h3 id=프로그램program>프로그램(program)<a hidden class=anchor aria-hidden=true href=#프로그램program>#</a></h3><blockquote><p>프로그램이란? 실행 가능한 명령어의 집합</p></blockquote><ul><li><p>프로그램은 하드디스크와 같은 저장 장치에 저장되어 있지만 메모리에는 올라가지 않은 정적인 상태</p></li><li><p>프로그램은 메모리가 아닌 디스크에 존재한다.</p><ul><li>결론적으로 실행을 하지 않은 코드를 즉 프로그램이라고 한다.</li></ul></li><li><p>컴파일된 바이너리 이미지 형태 or 파이썬 스크립트 같이 인터프리터 형태</p><ul><li>디스크에 저장된 실행 가능한 명령어의 집합이기만 하면 프로그램</li></ul></li></ul><h3 id=컴파일러와-인터프리터>컴파일러와 인터프리터<a hidden class=anchor aria-hidden=true href=#컴파일러와-인터프리터>#</a></h3><ul><li><p>컴파일러(compiler)</p><ul><li>원시 코드 → 컴파일 언어 → 목적코드</li><li>원시 코드를 목적 코드로 변환해주는 것</li><li>실행속도는 빠르지만, 배우기는 어렵다</li><li>ex) C, JAVA</li></ul></li><li><p>인터프리터(interpreter)</p><ul><li>한꺼번에 컴파일 단계를 거치는 컴파일 언어와 다르게 한줄 한줄 실행</li><li>실행속도가 느리지만, 배우기는 빠르다</li></ul></li></ul><h3 id=process>Process<a hidden class=anchor aria-hidden=true href=#process>#</a></h3><blockquote><p><strong><em>실행 중인 프로그램</em></strong><br><strong><em>하드디스크에 있는 프로그램을 메모리(RAM) 상에 올린 것</em></strong></p></blockquote><ul><li>실상 프로그램을 여러개 사용했다라고 하는 건 프로그램이 아닌 프로세스를 여러개 돌리는 것이다.</li></ul><p>그래서 프로세스를 너무 많이 사용하게 되면 더 이상의 프로그램(프로세스)를 띄울 수가 없다. 왜냐하면 RAM을 다 사용했기 때문이다.</p><h3 id=thread>Thread<a hidden class=anchor aria-hidden=true href=#thread>#</a></h3><blockquote><p><strong><em>프로세스가 할당 받은 자원을 이용하는 실행단위이자 프로세스 내에 실행되는 여러 흐름의 단위</em></strong></p></blockquote><ul><li><p>프로세스는 최소 한 개 이상의 쓰레드를 가짐, 이를 메인 쓰레드(main thread)라고 한다.</p></li><li><p>쓰레드는 독자적인 스택 메모리를 가진다.</p></li><li><p>프로세스는 쓰레드의 컨테이너이다. 프로세스는 쓰레드의 정보를 담고 있는 것에 불과하다.</p></li><li><p>쓰레드 예시(웹 브라우저의 경우)</p><ul><li>하나의 쓰레드는 이미지와 텍스트를 보여주는 일을 수행</li><li>다른 쓰레드는 네트워크 상의 데이터를 가져오는 일을 수행</li></ul></li></ul><p>🔆 파이썬에서 멀티쓰레드가 존재하니까 여유가 생기면 공부해보자!</p><hr><h1 id=5-메모리-구조>5. 메모리 구조<a hidden class=anchor aria-hidden=true href=#5-메모리-구조>#</a></h1><p><img loading=lazy src=https://user-images.githubusercontent.com/78094972/198869418-d2e97291-7129-4e2d-be51-0363abb4dd2f.png alt=image></p><h2 id=kernel-space>Kernel space<a hidden class=anchor aria-hidden=true href=#kernel-space>#</a></h2><ul><li>우리가 컴퓨터를 실행하는 순간 커널 스페이스에 커널이 올라간다.</li><li>어떤걸 하더라고 커널 스페이스에는 프로세스를 못올린다.</li></ul><h2 id=process의-메모리-상에서-4가지-구조>Process의 메모리 상에서 4가지 구조<a hidden class=anchor aria-hidden=true href=#process의-메모리-상에서-4가지-구조>#</a></h2><ul><li>메모리에 올라간 프로세스는 Stack - Heap - Data - Code 구조를 가진다.</li><li>Stack 방향으로 갈수록 높은 메모리 주소를 가지며, code 방향으로 갈수록 낮은 메모리 주소를 가진다.</li></ul><h2 id=-stack>🔆 Stack<a hidden class=anchor aria-hidden=true href=#-stack>#</a></h2><blockquote><p><strong><em>지역변수, 매개변수, 함수 리턴값</em></strong><br><strong><em>- 위에서 아래로 쌓인다. (높은 메모리 주소 -> 낮은 메모리 주소 방향으로 할당)</em></strong></p></blockquote><ul><li>지역 변수(local variable) 저장</li><li>매개 변수(parameter) 저장</li><li>함수 호출과 함께 할당</li><li>함수 호출이 종료되면 소멸</li><li>재귀 함수처럼 무한정 반복되는 함수 호출시 stack overflow 문제 발생<ul><li>해킹 시에는 일부러 stack overflow를 만들어서 들어간다.</li></ul></li></ul><h2 id=-heap>🔆 Heap<a hidden class=anchor aria-hidden=true href=#-heap>#</a></h2><blockquote><p><strong><em>동적 할당 데이터</em></strong><br><strong><em>stack과 반대방향으로 쌓인다. (낮은 메모리 주소 -> 높은 메모리 주소 방향으로 할당)</em></strong></p></blockquote><ul><li><p>사용자가 직접 관리하는 영역</p><ul><li>C언어에서는 사용자가 직접 입력하고, 지정하여 지정한 것만 사용한다. 그래서 지우는 것도 사용자가 직접 한다.</li><li>하지만 java에서는 java가 heap 할당을 해주기 때문에, garbage collector가 필요하다.</li></ul></li><li><p>사용자에 의해 메모리 할당 및 해제</p></li><li><p>C언어에서 malloc 명령어를 수행했을 때 메모리가 할당되는 곳</p></li><li><p>자바에서 가비지 컬렉션을 할 때, 정리되는 영역</p></li></ul><h2 id=data>Data<a hidden class=anchor aria-hidden=true href=#data>#</a></h2><blockquote><p><strong><em>전역변수, 정적변수</em></strong></p></blockquote><ul><li>전역변수 (global), 정적 변수(static)를 저장</li><li>프로세스 시작과 함께 할당</li><li>프로세스 종료와 함께 소멸</li></ul><h2 id=code>Code<a hidden class=anchor aria-hidden=true href=#code>#</a></h2><blockquote><p><strong><em>코드, 함수, 제어문</em></strong></p></blockquote><ul><li>실행할 프로그램의 소스 코드가 저장되는 곳</li><li>그래서 텍스트(text) 영역이라고도 한다.</li><li>CPU는 코드 영역에 저장된 명령어를 하나씩 가져가서 처리한다.</li></ul><hr><h1 id=6-namespace>6. Namespace<a hidden class=anchor aria-hidden=true href=#6-namespace>#</a></h1><blockquote><p><strong><em>프로세스를 실행할 때 시스템 리소스를 분리해서 실행할 수 있도록 도와주는 기능</em></strong></p></blockquote><ul><li>네임스페이스는 컨테이너 개념과 이어진다.</li></ul><h3 id=namespace의-종료와-역할>namespace의 종료와 역할<a hidden class=anchor aria-hidden=true href=#namespace의-종료와-역할>#</a></h3><table><thead><tr><th>네임스페이스</th><th>의미</th><th>역할</th></tr></thead><tbody><tr><td>pid</td><td>PID: Process ID</td><td>리눅스 커널의 프로세스 ID 분리</td></tr><tr><td>net</td><td>NET: Networking</td><td>네트워크 인터페이스(NET) 관리</td></tr><tr><td>ipc</td><td>IPC: Inter Process Communication</td><td>프로세스 간 통신(IPC) 접근 관리</td></tr><tr><td>mnt</td><td>MNT: Mount</td><td>파일 시스템의 마운트 관리</td></tr><tr><td>uts</td><td>UTX: Unix Timesharing System</td><td>커널과 버전 식별자 분리</td></tr></tbody></table><h2 id=실습>실습<a hidden class=anchor aria-hidden=true href=#실습>#</a></h2><ul><li>EC2 로그인 후, <code>work</code> directory를 생성한다. 그 안에 <code>test</code> directory 생성</li><li><code>ls -al</code> 또는 <code>ll</code> 입력하여 확인하기</li></ul><h3 id=프로그램-생성하기>프로그램 생성하기<a hidden class=anchor aria-hidden=true href=#프로그램-생성하기>#</a></h3><ul><li>vim 으로 아무 파일 생성하기 ex) vi while_loop.py</li></ul><h3 id=프로그램-실행하기>프로그램 실행하기<a hidden class=anchor aria-hidden=true href=#프로그램-실행하기>#</a></h3><ul><li><p><code>python while_loop.py &</code></p><ul><li><code>&</code>의 의미는 백그라운드 실행한다는 의미다. 그러면 다음과 같은 값이 뜬다.</li><li><code>[1] 25514</code></li><li>이는 <strong><em>PID</em></strong> 를 의미한다.</li></ul></li><li><p>다음으로 <code>ps -ef | grep while_loop</code>을 입력하면 다음과 같이 뜬다.</p></li></ul><div class=highlight><div style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">3
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yml data-lang=yml><span style=display:flex><span><span style=color:#6272a4>#UID        PID    PPID   C STIME  TTY                      CMD  </span>
</span></span><span style=display:flex><span>ubuntu     25514   25390 99 10:14 pts/0    00:01:03 python3 while_loop.py
</span></span><span style=display:flex><span>ubuntu     25522   25390  0 10:15 pts/0    00:00:00 grep --color=auto while_loop
</span></span></code></pre></td></tr></table></div></div><h3 id=프로그램을-담고-있는-컨테이너-확인하기>프로그램을 담고 있는 컨테이너 확인하기<a hidden class=anchor aria-hidden=true href=#프로그램을-담고-있는-컨테이너-확인하기>#</a></h3><ul><li>프로세스는 쓰레드를 담고 있는 컨테이너라고 했는데, 위 PID를 담고 있는 컨테이너를 확인해보자.<ul><li><code>ls /proc</code>를 실행하면 여러 목록들이 나오는데 거기서 <code>25514</code>를 확인할 수 있다.</li><li><code>ls /proc/25514</code> 를 입력하면 여러 파일 목록들이 나온다.</li><li><code>/proc/25514</code>는 프로그램이 실행하는 동안 이 프로그램을 닫고 있는 컨테이너를 말한다.</li></ul></li></ul><h3 id=프로그램-종료-시키기>프로그램 종료 시키기<a hidden class=anchor aria-hidden=true href=#프로그램-종료-시키기>#</a></h3><ul><li>만약 실행한 프로그램을 종료시키면 위에 생성된 <code>/proc/25514</code>는 사라진다.</li><li>명령어: <code>kill -9 25514</code></li><li>PID를 입력할 때는 복붙해서 한다.</li></ul><div class=highlight><div style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yml data-lang=yml><span style=display:flex><span>ubuntu     25543   25390  0 10:25 pts/0    00:00:00 grep --color=auto while_loop
</span></span><span style=display:flex><span>[<span style=color:#bd93f9>1</span>]+  Killed                  python3 while_loop.py
</span></span></code></pre></td></tr></table></div></div><p>❗️ <a href=https://losskatsu.github.io/os-kernel/aws-add-user/#aws-%EC%95%84%EB%A7%88%EC%A1%B4-%EB%A6%AC%EB%88%85%EC%8A%A4-%EC%9C%A0%EC%A0%80-%EC%B6%94%EA%B0%80%ED%95%98%EA%B3%A0-password-%EC%A0%91%EC%86%8D-%ED%97%88%EC%9A%A9>root 계정이 아닌 사용자 추가하여 사용하기</a></p><hr><h1 id=reference>Reference<a hidden class=anchor aria-hidden=true href=#reference>#</a></h1><ul><li><a href=https://learningspoons.com/course/detail/django-backend/>러닝스푼즈 - 나노디그리 Python & Django backed course</a>의</li></ul></div><footer class=post-footer><ul class=post-tags><li><a href=http://jeha00.github.io/tags/docker/>docker</a></li></ul><nav class=paginav><a class=prev href=http://jeha00.github.io/post/project/01_why-pr-template/><span class=title>« Prev Page</span><br><span>Project: Pull Request templates를 도입한 이유</span></a>
<a class=next href=http://jeha00.github.io/post/django/drf_study01/><span class=title>Next Page »</span><br><span>Django study: DRF의 직렬화(serialization)와 역직렬화(deserialization)</span></a></nav><div class=share-buttons><a target=_blank rel="noopener noreferrer" aria-label="share Docker study: Docker 학습을 위한 OS background knowledge on twitter" href="https://twitter.com/intent/tweet/?text=Docker%20study%3a%20Docker%20%ed%95%99%ec%8a%b5%ec%9d%84%20%ec%9c%84%ed%95%9c%20OS%20background%20knowledge&url=http%3a%2f%2fjeha00.github.io%2fpost%2fdocker%2f01_os-for-docker%2f&hashtags=docker"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM195.519 424.544c135.939.0 210.268-112.643 210.268-210.268.0-3.218.0-6.437-.153-9.502 14.406-10.421 26.973-23.448 36.935-38.314-13.18 5.824-27.433 9.809-42.452 11.648 15.326-9.196 26.973-23.602 32.49-40.92-14.252 8.429-30.038 14.56-46.896 17.931-13.487-14.406-32.644-23.295-53.946-23.295-40.767.0-73.87 33.104-73.87 73.87.0 5.824.613 11.494 1.992 16.858-61.456-3.065-115.862-32.49-152.337-77.241-6.284 10.881-9.962 23.601-9.962 37.088.0 25.594 13.027 48.276 32.95 61.456-12.107-.307-23.448-3.678-33.41-9.196v.92c0 35.862 25.441 65.594 59.311 72.49-6.13 1.686-12.72 2.606-19.464 2.606-4.751.0-9.348-.46-13.946-1.38 9.349 29.426 36.628 50.728 68.965 51.341-25.287 19.771-57.164 31.571-91.8 31.571-5.977.0-11.801-.306-17.625-1.073 32.337 21.15 71.264 33.41 112.95 33.41z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Docker study: Docker 학습을 위한 OS background knowledge on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&url=http%3a%2f%2fjeha00.github.io%2fpost%2fdocker%2f01_os-for-docker%2f&title=Docker%20study%3a%20Docker%20%ed%95%99%ec%8a%b5%ec%9d%84%20%ec%9c%84%ed%95%9c%20OS%20background%20knowledge&summary=Docker%20study%3a%20Docker%20%ed%95%99%ec%8a%b5%ec%9d%84%20%ec%9c%84%ed%95%9c%20OS%20background%20knowledge&source=http%3a%2f%2fjeha00.github.io%2fpost%2fdocker%2f01_os-for-docker%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Docker study: Docker 학습을 위한 OS background knowledge on reddit" href="https://reddit.com/submit?url=http%3a%2f%2fjeha00.github.io%2fpost%2fdocker%2f01_os-for-docker%2f&title=Docker%20study%3a%20Docker%20%ed%95%99%ec%8a%b5%ec%9d%84%20%ec%9c%84%ed%95%9c%20OS%20background%20knowledge"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Docker study: Docker 학습을 위한 OS background knowledge on facebook" href="https://facebook.com/sharer/sharer.php?u=http%3a%2f%2fjeha00.github.io%2fpost%2fdocker%2f01_os-for-docker%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Docker study: Docker 학습을 위한 OS background knowledge on whatsapp" href="https://api.whatsapp.com/send?text=Docker%20study%3a%20Docker%20%ed%95%99%ec%8a%b5%ec%9d%84%20%ec%9c%84%ed%95%9c%20OS%20background%20knowledge%20-%20http%3a%2f%2fjeha00.github.io%2fpost%2fdocker%2f01_os-for-docker%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Docker study: Docker 학습을 위한 OS background knowledge on telegram" href="https://telegram.me/share/url?text=Docker%20study%3a%20Docker%20%ed%95%99%ec%8a%b5%ec%9d%84%20%ec%9c%84%ed%95%9c%20OS%20background%20knowledge&url=http%3a%2f%2fjeha00.github.io%2fpost%2fdocker%2f01_os-for-docker%2f"><svg viewBox="2 2 28 28"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></div></footer></article></main><footer class=footer><span>&copy; 2022 <a href=http://jeha00.github.io/>Jeha00 DevLog</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerText="copy";function s(){t.innerText="copied!",setTimeout(()=>{t.innerText="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>